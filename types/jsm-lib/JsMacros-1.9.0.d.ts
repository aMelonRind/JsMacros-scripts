
/**
 * The global context  
 * If you're trying to access the context in {@link JsMacros.on},  
 * use the second param of callback
 */
declare const context: EventContainer;
/**
 * Assert and convert event type:
 * ```js
 * JsMacros.assertEvent(event, 'Service')
 * ```
 * If the type doesn't convert, that means the event type doesn't have any properties
 */
declare const event: Events.BaseEvent;
declare const file: Packages.java.io.File;

declare namespace Events {

    interface BaseEvent extends JavaObject {

        getEventName(): string;

    }

    interface Cancellable {

        cancel(): void;

    }

    interface Key extends BaseEvent, Cancellable {
        readonly action: number;
        readonly key: globalThis.Key;
        readonly mods: KeyMods;
    }

    interface LaunchGame extends BaseEvent {
        readonly playerName: string;
    }

    interface MouseScroll extends BaseEvent, Cancellable {
        readonly deltaX: number;
        readonly deltaY: number;
    }

    interface QuitGame extends BaseEvent {}

    interface RecvMessage extends BaseEvent, Cancellable {
        text: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper | null;
        /** @since 1.8.2 */
        signature: JavaArray<number> | null;
        /** @since 1.8.2 */
        messageType: string | null;
    }

    interface RecvPacket extends BaseEvent, Cancellable {
        packet: /* net.minecraft.network.packet.Packet<any> */ any | null;
        readonly type: PacketName;

        /**
         * After modifying the buffer, use {@link PacketByteBufferHelper.toPacket}() to get the modified
         *  packet and replace this packet with the modified one.
         * @return a helper for accessing and modifying the packet's data.
         * @since 1.8.4
         */
        getPacketBuffer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;

    }

    interface ResourcePackLoaded extends BaseEvent {
        readonly isGameStart: boolean;
        readonly loadedPacks: JavaList<string>;
    }

    interface SendMessage extends BaseEvent, Cancellable {
        message: string | null;
    }

    interface SendPacket extends BaseEvent, Cancellable {
        packet: /* net.minecraft.network.packet.Packet<any> */ any | null;
        readonly type: PacketName;

        /**
         * Replaces the packet of this event with a new one of the same type, created from the given
         *  arguments. It's recommended to use {@link getPacketBuffer}() to modify the packet instead.
         * @param args the arguments to pass to the packet's constructor
         * @throws NullPointerException if this.packet is null
         * @since 1.8.4
         */
        replacePacket(...args: JavaVarArgs<any>): void;

        /**
         * After modifying the buffer, use {@link PacketByteBufferHelper.toPacket}() to get the modified
         *  packet and replace this packet with the modified one.
         * @return a helper for accessing and modifying the packet's data.
         * @since 1.8.4
         */
        getPacketBuffer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;

    }

    interface Title extends BaseEvent, Cancellable {
        readonly type: TitleType;
        message: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper | null;
    }

    interface ClickSlot extends BaseEvent, Cancellable {

        /**
         * [https://wiki.vg/Protocol#Click_Window](https://wiki.vg/Protocol#Click_Window)
         */
        readonly mode: number;
        readonly button: ClickSlotButton;
        readonly slot: number;

        /**
         * @return inventory associated with the event
         */
        getInventory(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory;

    }

    interface ContainerUpdate extends BaseEvent {
        readonly inventory: Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory;
        readonly screen: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen;
    }

    interface DropSlot extends BaseEvent, Cancellable {
        readonly slot: number;

        /**
         * whether it's all or a single item being dropped
         */
        readonly all: boolean;

        /**
         * @return inventory associated with the event
         */
        getInventory(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory;

    }

    interface ItemDamage extends BaseEvent {
        readonly item: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
        readonly damage: number;
    }

    interface ItemPickup extends BaseEvent {
        readonly item: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
    }

    interface OpenContainer extends BaseEvent, Cancellable {
        readonly inventory: Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory;
        readonly screen: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen;
    }

    interface SlotUpdate extends BaseEvent {
        readonly type: SlotUpdateType;
        readonly slot: number;
        readonly oldStack: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
        readonly newStack: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

        /**
         * @return inventory associated with the event
         */
        getInventory(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory;

    }

    interface AirChange extends BaseEvent {
        readonly air: number;
    }

    interface ArmorChange extends BaseEvent {
        readonly slot: ArmorSlot;
        readonly item: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
        readonly oldItem: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
    }

    interface AttackBlock extends BaseEvent {
        readonly block: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;
        readonly side: Side;
    }

    interface AttackEntity extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
    }

    interface Damage extends BaseEvent {

        /**
         * @deprecated may not work on servers
         */
        readonly attacker: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;

        /**
         * @deprecated may not work on servers
         */
        readonly source: DamageSource;
        readonly health: number;
        readonly change: number;
    }

    interface Death extends BaseEvent {
        readonly deathPos: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;
        readonly inventory: JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

        /**
         * Respawns the player. Should be used with some delay, one tick should be enough.
         * @since 1.8.4
         */
        respawn(): void;

    }

    interface EXPChange extends BaseEvent {
        readonly progress: number;
        readonly total: number;
        readonly level: number;
        /** @since 1.6.5 */
        readonly prevProgress: number;
        /** @since 1.6.5 */
        readonly prevTotal: number;
        /** @since 1.6.5 */
        readonly prevLevel: number;
    }

    interface FallFlying extends BaseEvent {
        readonly state: boolean;
    }

    interface Heal extends BaseEvent {
        readonly source: HealSource;
        readonly health: number;
        readonly change: number;
    }

    interface HealthChange extends BaseEvent {
        readonly health: number;
        readonly change: number;
    }

    interface HeldItemChange extends BaseEvent {
        readonly offHand: boolean;
        readonly item: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
        readonly oldItem: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
    }

    interface HungerChange extends BaseEvent {
        readonly foodLevel: number;
    }

    interface InteractBlock extends BaseEvent {
        readonly offhand: boolean;
        readonly result: ActionResult;
        readonly block: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;
        readonly side: Side;
    }

    interface InteractEntity extends BaseEvent {
        readonly offhand: boolean;
        readonly result: ActionResult;
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
    }

    interface OpenScreen extends BaseEvent {
        readonly screen: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen;
        readonly screenName: ScreenName;
    }

    interface Riding extends BaseEvent {
        readonly state: boolean;
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
    }

    interface SignEdit extends BaseEvent, Cancellable {
        readonly pos: Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
        closeScreen: boolean;
        signText: JavaList<string> | null;
    }

    interface StatusEffectUpdate extends BaseEvent {
        readonly oldEffect: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper;
        readonly newEffect: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper;
        readonly added: boolean;
        readonly removed: boolean;
    }

    interface BlockUpdate extends BaseEvent {
        readonly block: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;
        readonly updateType: BlockUpdateType;
    }

    interface Bossbar extends BaseEvent {
        readonly bossBar: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.BossBarHelper;
        readonly uuid: string;
        readonly type: BossBarUpdateType;
    }

    interface ChunkLoad extends BaseEvent {
        readonly x: number;
        readonly z: number;
        readonly isFull: boolean;
    }

    interface ChunkUnload extends BaseEvent {
        readonly x: number;
        readonly z: number;
    }

    interface DimensionChange extends BaseEvent {
        readonly dimension: Dimension;
    }

    interface Disconnect extends BaseEvent {
        /** @since 1.6.4 */
        readonly message: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
    }

    interface EntityDamaged extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
        /** @since 1.6.5 */
        readonly health: number;
        readonly damage: number;
    }

    interface EntityHealed extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
        readonly health: number;
        readonly damage: number;
    }

    interface EntityLoad extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
    }

    interface EntityUnload extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
        readonly reason: EntityUnloadReason;
    }

    interface JoinServer extends BaseEvent {
        readonly player: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.ClientPlayerEntityHelper</* net.minecraft.client.network.ClientPlayerEntity */ any>;
        readonly address: string;
    }

    interface PlayerJoin extends BaseEvent {
        readonly UUID: string;
        readonly player: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper;
    }

    interface PlayerLeave extends BaseEvent {
        readonly UUID: string;
        readonly player: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper;
    }

    interface Sound extends BaseEvent, Cancellable {
        readonly sound: SoundId;
        readonly volume: number;
        readonly pitch: number;
        readonly position: Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
    }

    interface Tick extends BaseEvent {}

    interface CommandContext extends BaseEvent {

        getRaw(): Packages.com.mojang.brigadier.context.CommandContext<any>;

        /**
         * @throws CommandSyntaxException
         * @since 1.4.2
         */
        getArg(name: string): any;
        getChild(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandContextHelper;
        getRange(): Packages.com.mojang.brigadier.context.StringRange;
        getInput(): string;

    }

    interface CodeRender extends BaseEvent {
        readonly cursor: Packages.xyz.wagyourtail.jsmacros.client.gui.editor.SelectCursor;
        readonly code: string;
        readonly language: string;
        readonly screen: Packages.xyz.wagyourtail.jsmacros.client.gui.screens.EditorScreen;

        /**
         * you are expected to fill this in with text styling, if not filled, nothing will render
         *  if the code is an empty string, you are still expected to put an empty string as the first line here
         */
        readonly textLines: JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

        /**
         * you are expected to fill this with suggestions for autocomplete created using
         *  {@link createSuggestion}(int, String)
         */
        readonly autoCompleteSuggestions: JavaList<Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AutoCompleteSuggestion>;

        /**
         * you are expected to fill this with a method to create right click actions.  
         *  method should be `(index:number) => Map<string,() => void>`,  
         *  meaning it accepts a character index and returns a map of names to actions.
         */
        rightClickActions: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<number, any, JavaMap<string, Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>>, any>;

        /**
         * @return [Prism4j's
         *  node list](https://github.com/noties/Prism4j/blob/75ac3dae6f8eff5b1b0396df3b806f44ce86c484/prism4j/src/main/java/io/noties/prism4j/Prism4j.java#L54) you don't have to use it but if you're not compiling your own...
         *  peek at the code of {@link TextStyleCompiler} for the default impl for walking the node tree.
         */
        genPrismNodes(): JavaList<Packages.io.noties.prism4j.Prism4j$Node>;

        /**
         * Easy access to the {@link Map} object for use with {@link rightClickActions}
         * @return specifically a {@link LinkedHashMap}
         */
        createMap(): JavaMap<any, any>;

        /**
         * more convenient access to TextBuilder
         * @return new instance for use with {@link textLines}
         */
        createTextBuilder(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder;
        createSuggestion(startIndex: int, suggestion: string): Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AutoCompleteSuggestion;

        /**
         * @param startIndex index that is where the suggestion starts from before the already typed part
         * @param suggestion complete suggestion including the already typed part
         * @param displayText how the text should be displayed in the dropdown, default is suggestion text
         * @return a new suggestion object
         */
        createSuggestion(startIndex: int, suggestion: string, displayText: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AutoCompleteSuggestion;

        /**
         * prefix tree data structure written for you, it's a bit intensive to add things to, especially how I wrote it, but
         *  lookup times are much better at least on larger data sets,  
         *  so create a single copy of this for your static autocompletes and don't be re-creating this every time, store it
         *  in `globalvars`, probably per language
         *
         *  or just don't use it, I'm not forcing you to.
         * @return a new {@link StringHashTrie}
         */
        createPrefixTree(): Packages.xyz.wagyourtail.StringHashTrie;

        /**
         * @return `key -> hex integer` values for theme data points, this can be used with the prism data for
         *  coloring, just have to use {@link TextBuilder.withColor}(int, int, int)
         *  on 1.15 and older versions the integer values with be the default color's index so you can directly pass it
         *  to {@link TextBuilder.withColor}(int)
         */
        getThemeData(): JavaMap<string, JavaArray<number>>;

    }

    interface Custom extends BaseEvent {
        eventName: string;
        joinable: boolean;
        cancelable: boolean;

        joinable(): boolean;
        cancellable(): boolean;

        /**
         * Triggers the event.  
         *  Try not to cause infinite looping by triggering the same {@link EventCustom} from its own listeners.
         * @since 1.2.8
         */
        trigger(): void;

        /**
         * trigger the event listeners, then run `callback` when they finish.
         * @param callback used as a {@link Runnable}, so no args, no return value.
         * @since 1.9.0
         */
        triggerAsync(callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): void;

        /**
         * Put an Integer into the event.
         * @since 1.2.8
         */
        putInt(name: string, i: int): number;

        /**
         * put a String into the event.
         * @since 1.2.8
         */
        putString(name: string, str: string): string;

        /**
         * put a Double into the event.
         * @since 1.2.8
         */
        putDouble(name: string, d: double): number;

        /**
         * put a Boolean into the event.
         * @since 1.2.8
         */
        putBoolean(name: string, b: boolean): boolean;

        /**
         * put anything else into the event.
         * @since 1.2.8
         */
        putObject(name: string, o: any): any;

        /**
         * Returns the type of the defined item in the event as a string.
         * @since 1.2.8
         */
        getType(name: string): 'Int' | 'String' | 'Double' | 'Boolean' | 'Object' | null;

        /**
         * Gets an Integer from the event.
         * @since 1.2.8
         */
        getInt(name: string): number | null;

        /**
         * Gets a String from the event
         * @since 1.2.8
         */
        getString(name: string): string | null;

        /**
         * Gets a Double from the event.
         * @since 1.2.8
         */
        getDouble(name: string): number | null;

        /**
         * Gets a Boolean from the event.
         * @since 1.2.8
         */
        getBoolean(name: string): boolean | null;

        /**
         * Gets an Object from the event.
         * @since 1.2.8
         */
        getObject(name: string): any | null;

        /**
         * @return map backing the event
         * @since 1.6.4
         */
        getUnderlyingMap(): JavaMap<string, any>;

        /**
         * registers event so you can see it in the gui
         * @since 1.3.0
         */
        registerEvent(): void;

    }

    interface ProfileLoad extends BaseEvent {
        readonly profileName: string;
    }

    interface WrappedScript extends BaseEvent {
        readonly arg1: T;
        readonly arg2: U;
        result: R;

        setReturnBoolean(b: boolean): void;
        setReturnInt(i: int): void;
        setReturnDouble(d: double): void;
        setReturnString(s: string): void;
        setReturnObject(o: any): void;

    }

    interface Service extends BaseEvent {
        readonly serviceName: string;

        /**
         * when this service is stopped, this is run...
         */
        stopListener: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any> | null;

        /**
         * Put an Integer into the global variable space.
         * @since 1.6.5
         */
        putInt(name: string, i: int): number;

        /**
         * put a String into the global variable space.
         * @since 1.6.5
         */
        putString(name: string, str: string): string;

        /**
         * put a Double into the global variable space.
         * @since 1.6.5
         */
        putDouble(name: string, d: double): number;

        /**
         * put a Boolean into the global variable space.
         * @since 1.6.5
         */
        putBoolean(name: string, b: boolean): boolean;

        /**
         * put anything else into the global variable space.
         * @since 1.6.5
         */
        putObject(name: string, o: any): any;

        /**
         * Returns the type of the defined item in the global variable space as a string.
         * @since 1.6.5
         */
        getType(name: string): 'Int' | 'String' | 'Double' | 'Boolean' | 'Object' | null;

        /**
         * Gets an Integer from the global variable space.
         * @since 1.6.5
         */
        getInt(name: string): number | null;

        /**
         * Gets an Integer from the global variable space. and then increment it there.
         * @since 1.6.5
         */
        getAndIncrementInt(name: string): number | null;

        /**
         * Gets an integer from the global variable pace. and then decrement it there.
         * @since 1.6.5
         */
        getAndDecrementInt(name: string): number | null;

        /**
         * increment an Integer in the global variable space. then return it.
         * @since 1.6.5
         */
        incrementAndGetInt(name: string): number | null;

        /**
         * decrement an Integer in the global variable space. then return it.
         * @since 1.6.5
         */
        decrementAndGetInt(name: string): number | null;

        /**
         * Gets a String from the global variable space
         * @since 1.6.5
         */
        getString(name: string): string | null;

        /**
         * Gets a Double from the global variable space.
         * @since 1.6.5
         */
        getDouble(name: string): number | null;

        /**
         * Gets a Boolean from the global variable space.
         * @since 1.6.5
         */
        getBoolean(name: string): boolean | null;

        /**
         * toggles a global boolean and returns its new value
         * @since 1.6.5
         */
        toggleBoolean(name: string): boolean | null;

        /**
         * Gets an Object from the global variable space.
         * @since 1.6.5
         */
        getObject(name: string): any | null;

        /**
         * removes a key from the global variable space.
         * @since 1.6.5
         */
        remove(key: string): void;
        getRaw(): JavaMap<string, any>;

    }

}

interface Events {

    Key: Events.Key;
    LaunchGame: Events.LaunchGame;
    MouseScroll: Events.MouseScroll;
    QuitGame: Events.QuitGame;
    RecvMessage: Events.RecvMessage;
    RecvPacket: Events.RecvPacket;
    ResourcePackLoaded: Events.ResourcePackLoaded;
    SendMessage: Events.SendMessage;
    SendPacket: Events.SendPacket;
    Title: Events.Title;
    ClickSlot: Events.ClickSlot;
    ContainerUpdate: Events.ContainerUpdate;
    DropSlot: Events.DropSlot;
    ItemDamage: Events.ItemDamage;
    ItemPickup: Events.ItemPickup;
    OpenContainer: Events.OpenContainer;
    SlotUpdate: Events.SlotUpdate;
    AirChange: Events.AirChange;
    ArmorChange: Events.ArmorChange;
    AttackBlock: Events.AttackBlock;
    AttackEntity: Events.AttackEntity;
    Damage: Events.Damage;
    Death: Events.Death;
    EXPChange: Events.EXPChange;
    FallFlying: Events.FallFlying;
    Heal: Events.Heal;
    HealthChange: Events.HealthChange;
    HeldItemChange: Events.HeldItemChange;
    HungerChange: Events.HungerChange;
    InteractBlock: Events.InteractBlock;
    InteractEntity: Events.InteractEntity;
    OpenScreen: Events.OpenScreen;
    Riding: Events.Riding;
    SignEdit: Events.SignEdit;
    StatusEffectUpdate: Events.StatusEffectUpdate;
    BlockUpdate: Events.BlockUpdate;
    Bossbar: Events.Bossbar;
    ChunkLoad: Events.ChunkLoad;
    ChunkUnload: Events.ChunkUnload;
    DimensionChange: Events.DimensionChange;
    Disconnect: Events.Disconnect;
    EntityDamaged: Events.EntityDamaged;
    EntityHealed: Events.EntityHealed;
    EntityLoad: Events.EntityLoad;
    EntityUnload: Events.EntityUnload;
    JoinServer: Events.JoinServer;
    PlayerJoin: Events.PlayerJoin;
    PlayerLeave: Events.PlayerLeave;
    Sound: Events.Sound;
    Tick: Events.Tick;
    CommandContext: Events.CommandContext;
    CodeRender: Events.CodeRender;
    Custom: Events.Custom;
    ProfileLoad: Events.ProfileLoad;
    WrappedScript: Events.WrappedScript;
    Service: Events.Service;

}

/**
 * Functions for interacting with chat.  
 *
 * @author Wagyourtail
 */
declare namespace Chat {

    /**
     * Log to player chat.
     * @since 1.1.3
     */
    function log(message: any | null): void;

    /**
     * @param await should wait for message to actually be sent to chat to continue.
     * @throws InterruptedException
     */
    function log(message: any | null, await: boolean): void;

    /**
     * Logs the formatted message to the player's chat. The message is formatted using the default
     *  java {@link String.format}(String, Object...) syntax.
     * @param message the message to format and log
     * @param args the arguments used to format the message
     * @throws InterruptedException
     * @since 1.8.4
     */
    function logf(message: string, ...args: JavaVarArgs<any>): void;

    /**
     * Logs the formatted message to the player's chat. The message is formatted using the default
     *  java {@link String.format}(String, Object...) syntax.
     * @param message the message to format and log
     * @param await whether to wait for message to be sent to chat before continuing
     * @param args the arguments used to format the message
     * @throws InterruptedException
     * @since 1.8.4
     */
    function logf(message: string, await: boolean, ...args: JavaVarArgs<any>): void;

    /**
     * Say to server as player.
     * @since 1.0.0
     */
    function say(message: string | null): void;

    /**
     * Say to server as player.
     * @throws InterruptedException
     * @since 1.3.1
     */
    function say(message: string | null, await: boolean): void;

    /**
     * Sends the formatted message to the server. The message is formatted using the default java
     *  {@link String.format}(String, Object...) syntax.
     * @param message the message to format and send to the server
     * @param args the arguments used to format the message
     * @throws InterruptedException
     * @since 1.8.4
     */
    function sayf(message: string, ...args: JavaVarArgs<any>): void;

    /**
     * Sends the formatted message to the server. The message is formatted using the default java
     *  {@link String.format}(String, Object...) syntax.
     * @param message the message to format and send to the server
     * @param await whether to wait for message to be sent to chat before continuing
     * @param args the arguments used to format the message
     * @throws InterruptedException
     * @since 1.8.4
     */
    function sayf(message: string, await: boolean, ...args: JavaVarArgs<any>): void;

    /**
     * open the chat input box with specific text already typed.
     * @param message the message to start the chat screen with
     * @since 1.6.4
     */
    function open(message: string | null): void;

    /**
     * open the chat input box with specific text already typed.  
     *  hint: you can combine with {@link JsMacros.waitForEvent}(String) or
     *  {@link JsMacros.once}(String, MethodWrapper) to wait for the chat screen
     *  to close and/or the to wait for the sent message
     * @param message the message to start the chat screen with
     * @since 1.6.4
     */
    function open(message: string | null, await: boolean): void;

    /**
     * Display a Title to the player.
     * @since 1.2.1
     */
    function title(title: any, subtitle: any, fadeIn: int, remain: int, fadeOut: int): void;
    /** @since 1.8.1 */
    function actionbar(text: any): void;

    /**
     * Display the smaller title that's above the actionbar.
     * @since 1.2.1
     */
    function actionbar(text: any, tinted: boolean): void;

    /**
     * Display a toast.
     * @since 1.2.5
     */
    function toast(title: any, desc: any): void;

    /**
     * Creates a {@link TextHelper} for use where you need one and not a string.
     * @return a new {@link TextHelper}
     * @see TextHelper
     * @since 1.1.3
     */
    function createTextHelperFromString(content: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

    /**
     * @since 1.9.0
     * @return a new {@link TextHelper}
     */
    function createTextHelperFromTranslationKey(key: string, ...content: JavaVarArgs<any>): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
    /** @since 1.5.2 */
    function getLogger(): Packages.org.slf4j.Logger;

    /**
     * returns a log4j logger, for logging to console only.
     * @since 1.5.2
     */
    function getLogger(name: string): Packages.org.slf4j.Logger;

    /**
     * Create a  {@link TextHelper} for use where you need one and not a string.
     * @return a new {@link TextHelper}
     * @see TextHelper
     * @since 1.1.3
     */
    function createTextHelperFromJSON(json: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper | null;

    /**
     * @return a new builder
     * @see TextBuilder
     * @since 1.3.0
     */
    function createTextBuilder(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder;

    /**
     * @param name name of command
     * @see getCommandManager()
     * @since 1.4.2
     * @deprecated
     */
    function createCommandBuilder(name: string): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CommandBuilder;

    /**
     * @see getCommandManager()
     * @since 1.6.5
     * @deprecated
     */
    function unregisterCommand(name: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper;

    /**
     * @see getCommandManager()
     * @since 1.6.5
     * @deprecated
     */
    function reRegisterCommand(node: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper): void;
    /** @since 1.7.0 */
    function getCommandManager(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CommandManager;
    /** @since 1.7.0 */
    function getHistory(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.ChatHistoryManager;

    /**
     * @param text the text to get the width of
     * @return the width of the given text in pixels.
     * @since 1.8.4
     */
    function getTextWidth(text: string | null): number;

    /**
     * @return &#167; -> &amp;
     * @since 1.6.5
     */
    function sectionSymbolToAmpersand(string: string): string;

    /**
     * @return &amp; -> &#167;
     * @since 1.6.5
     */
    function ampersandToSectionSymbol(string: string): string;
    /** @since 1.6.5 */
    function stripFormatting(string: string): string;

}

/**
 * Functions that interact with minecraft that don't fit into their own module.  
 *
 * @author Wagyourtail
 * @since 1.2.9
 */
declare namespace Client {

    /**
     * @return the raw minecraft client class, it may be useful to use [Minecraft Mappings Viewer](https://wagyourtail.xyz/Projects/Minecraft%20Mappings%20Viewer/App) for this.
     * @since 1.0.0 (was in the `jsmacros` library until 1.2.9)
     */
    function getMinecraft(): /* net.minecraft.client.MinecraftClient */ any;

    /**
     * @return a helper for interacting with minecraft's registry.
     * @since 1.8.4
     */
    function getRegistryManager(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.RegistryHelper;

    /**
     * @return a helper to modify and send minecraft packets.
     * @since 1.8.4
     */
    function createPacketByteBuffer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;

    /**
     * Run your task on the main minecraft thread
     * @param runnable task to run
     * @since 1.4.0
     */
    function runOnMainThread(runnable: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): void;

    /**
     * @param watchdogMaxTime max time for the watchdog to wait before killing the script
     * @since 1.6.5
     */
    function runOnMainThread(runnable: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>, watchdogMaxTime: long): void;

    /**
     * @return a helper which gives access to all game options and some other useful features.
     * @since 1.1.7 (was in the `jsmacros` library until 1.2.9)
     */
    function getGameOptions(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper;

    /**
     * @return the current minecraft version as a string.
     * @since 1.1.2 (was in the `jsmacros` library until 1.2.9)
     */
    function mcVersion(): string;

    /**
     * @return the fps debug string from minecraft.
     * @since 1.2.0 (was in the `jsmacros` library until 1.2.9)
     */
    function getFPS(): string;

    /**
     * Join singleplayer world
     * @since 1.6.6
     */
    function loadWorld(folderName: string): void;

    /**
     * @see connect(String, int)
     * @since 1.2.3 (was in the `jsmacros` library until 1.2.9)
     */
    function connect(ip: string): void;

    /**
     * Connect to a server
     * @since 1.2.3 (was in the `jsmacros` library until 1.2.9)
     */
    function connect(ip: string, port: int): void;

    /**
     * @see disconnect(MethodWrapper)
     * @since 1.2.3 (was in the `jsmacros` library until 1.2.9)
     */
    function disconnect(): void;

    /**
     * Disconnect from a server with callback.
     * @param callback calls your method as a {@link Packages.java.util.function.Consumer}<boolean>
     * @since 1.2.3 (was in the `jsmacros` library until 1.2.9)
     *
     *  `callback` defaults to `null`
     */
    function disconnect(callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<boolean, any, any, any> | null): void;

    /**
     * Closes the client (stops the game).  
     *  Waits until the game has stopped, meaning no further code is executed (for obvious reasons).  
     *  Warning: this does not wait on joined threads, so your script may stop at an undefined point.
     * @since 1.6.0
     */
    function shutdown(): never;

    /**
     * @throws InterruptedException
     * @see waitTick(int)
     * @since 1.2.4
     */
    function waitTick(): void;

    /**
     * waits the specified number of client ticks.  
     *  don't use this on an event that the main thread waits on (joins)... that'll cause circular waiting.
     * @throws InterruptedException
     * @since 1.2.6
     */
    function waitTick(i: int): void;

    /**
     * @throws UnknownHostException
     * @throws InterruptedException
     * @since 1.6.5
     */
    function ping(ip: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ServerInfoHelper;

    /**
     * @throws UnknownHostException
     * @since 1.6.5
     */
    function pingAsync(ip: string, callback: MethodWrapper<ServerInfoHelper | null, java.io.IOException | null>): void;
    /** @since 1.6.5 */
    function cancelAllPings(): void;

    /**
     * @return a list of all loaded mods.
     * @since 1.8.4
     */
    function getLoadedMods(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.ModContainerHelper<any>>;

    /**
     * @param modId the mod modId
     * @return `true` if the mod with the given modId is loaded, `false` otherwise.
     * @since 1.8.4
     */
    function isModLoaded(modId: string): boolean;

    /**
     * @param modId the mod modId
     * @return the mod container for the given modId or `null` if the mod is not loaded.
     * @since 1.8.4
     */
    function getMod(modId: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.ModContainerHelper<any> | null;

    /**
     * Makes minecraft believe that the mouse is currently inside the window.  
     *  This will automatically set pause on lost focus to false.
     * @since 1.8.4
     */
    function grabMouse(): void;

    /**
     * @return `true` if the mod is loaded inside a development environment, `false` otherwise.
     * @since 1.8.4
     */
    function isDevEnv(): boolean;

    /**
     * @return the name of the mod loader.
     * @since 1.8.4
     */
    function getModLoader(): string;

    /**
     * @return a list of all loaded blocks as {@link BlockHelper} objects.
     * @since 1.8.4
     */
    function getRegisteredBlocks(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper>;

    /**
     * @return a list of all loaded items as {@link ItemHelper} objects.
     * @since 1.8.4
     */
    function getRegisteredItems(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemHelper>;

    /**
     * Tries to peacefully close the game.
     * @since 1.8.4
     */
    function exitGamePeacefully(): void;

    /**
     * Will close the game forcefully.
     * @since 1.8.4
     */
    function exitGameForcefully(): never;

    /**
     * @param packet the packet to send
     * @see createPacketByteBuffer()
     * @since 1.8.4
     */
    function sendPacket(packet: /* net.minecraft.network.packet.Packet<any> */ any): void;

    /**
     * @param packet the packet to receive
     * @see createPacketByteBuffer()
     * @since 1.8.4
     */
    function receivePacket(packet: /* net.minecraft.network.packet.Packet<net.minecraft.network.listener.ClientPlayPacketListener> */ any): void;

}

/**
 * Functions for displaying stuff in 2 to 3 dimensions
 *
 * @author Wagyourtail
 * @since 1.0.5
 */
declare namespace Hud {

    /**
     * @param dirtBG boolean of whether to use a dirt background or not.
     * @return a new {@link IScreen} Object.
     * @see IScreen
     * @since 1.0.5
     */
    function createScreen(title: string, dirtBG: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.ScriptScreen;

    /**
     * Opens a {@link IScreen} Object.
     * @see IScreen
     * @since 1.0.5
     */
    function openScreen(s: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen | null): void;

    /**
     * @return the currently open Screen as an {@link IScreen}
     * @see IScreen
     * @since 1.2.7
     */
    function getOpenScreen(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen | null;

    /**
     * @param width the width of the canvas
     * @param height the height of the canvas
     * @return a {@link CustomImage} that can be used as a texture for screen backgrounds, rendering
     *  images, etc.
     * @since 1.8.4
     */
    function createTexture(width: int, height: int, name: string | null): Packages.xyz.wagyourtail.jsmacros.client.api.classes.CustomImage;

    /**
     * @param path absolute path to an image file
     * @return a {@link CustomImage} that can be used as a texture for screen backgrounds, rendering
     *  images, etc.
     * @since 1.8.4
     */
    function createTexture(path: string, name: string | null): Packages.xyz.wagyourtail.jsmacros.client.api.classes.CustomImage;

    /**
     * @return an immutable Map of all registered custom textures.
     * @since 1.8.4
     */
    function getRegisteredTextures(): JavaMap<string, Packages.xyz.wagyourtail.jsmacros.client.api.classes.CustomImage>;

    /**
     * @return the current gui scale factor of minecraft.
     * @since 1.8.4
     */
    function getScaleFactor(): number;

    /**
     * @return The name of the currently open screen.
     * @since 1.0.5, renamed from `getOpenScreen` in 1.2.7
     */
    function getOpenScreenName(): ScreenName | null;

    /**
     * @return a boolean denoting if the currently open screen is a container.
     * @since 1.1.2
     */
    function isContainer(): boolean;

    /**
     * @see IDraw2D
     * @since 1.0.5
     */
    function createDraw2D(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D;

    /**
     * @see IDraw2D
     * @since 1.0.5
     *
     *  Registers an {@link IDraw2D} to be rendered.
     * @deprecated since 1.6.5, use {@link Draw2D.register}() instead.
     */
    function registerDraw2D(overlay: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D>): void;

    /**
     * @see IDraw2D
     * @since 1.0.5
     *
     *  Unregisters an {@link IDraw2D} to stop it being rendered.
     * @deprecated since 1.6.5, use {@link Draw2D.unregister}() instead.
     */
    function unregisterDraw2D(overlay: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D>): void;

    /**
     * @return A list of current {@link IDraw2D}.
     * @see IDraw2D
     * @since 1.0.5
     */
    function listDraw2Ds(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D>>;

    /**
     * @see IDraw2D
     * @since 1.0.5
     *
     *  clears the Draw2D render list.
     */
    function clearDraw2Ds(): void;

    /**
     * @return a new {@link Draw3D}.
     * @see Draw3D
     * @since 1.0.6
     */
    function createDraw3D(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D;

    /**
     * @see Draw3D
     * @since 1.0.6
     *
     *  Registers an {@link Draw3D} to be rendered.
     * @deprecated since 1.6.5 use {@link Draw3D.register}() instead.
     */
    function registerDraw3D(draw: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D): void;

    /**
     * @see Draw3D
     * @since 1.0.6
     *
     *  Unregisters an {@link Draw3D} to stop it being rendered.
     * @since 1.6.5 use {@link Draw3D.unregister}() instead.
     * @deprecated
     */
    function unregisterDraw3D(draw: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D): void;

    /**
     * @return A list of current {@link Draw3D}.
     * @see Draw3D
     * @since 1.0.6
     */
    function listDraw3Ds(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D>;

    /**
     * @see Draw3D
     * @since 1.0.6
     *
     *  clears the Draw2D render list.
     */
    function clearDraw3Ds(): void;

    /**
     * @return the current X coordinate of the mouse
     * @since 1.1.3
     */
    function getMouseX(): number;

    /**
     * @return the current Y coordinate of the mouse
     * @since 1.1.3
     */
    function getMouseY(): number;

    /**
     * @return the current window width.
     * @since 1.8.4
     */
    function getWindowWidth(): number;

    /**
     * @return the current window height.
     * @since 1.8.4
     */
    function getWindowHeight(): number;

}

/**
 * @author Etheradon
 * @since 1.8.4
 */
declare namespace JavaUtils {

    /**
     * Creates a java {@link ArrayList}.
     * @return a java ArrayList.
     * @since 1.8.4
     */
    function createArrayList(): Packages.java.util.ArrayList<any>;

    /**
     * Creates a java {@link ArrayList}.
     * @param array the array to add to the list
     * @template T the type of the array
     * @return a java ArrayList from the given array.
     * @since 1.8.4
     */
    function createArrayList<T>(array: T[]): Packages.java.util.ArrayList<T>;

    /**
     * Creates a java {@link HashMap}.
     * @return a java HashMap.
     * @since 1.8.4
     */
    function createHashMap(): Packages.java.util.HashMap<any, any>;

    /**
     * Creates a java {@link HashSet}.
     * @return a java HashSet.
     * @since 1.8.4
     */
    function createHashSet(): Packages.java.util.HashSet<any>;

    /**
     * Returns a {@link SplittableRandom}.
     * @return a SplittableRandom.
     * @since 1.8.4
     */
    function getRandom(): Packages.java.util.SplittableRandom;

    /**
     * Returns {@link SplittableRandom}, initialized with the seed to get identical sequences of
     *  values at all times.
     * @param seed the seed
     * @return a SplittableRandom.
     * @since 1.8.4
     */
    function getRandom(seed: long): Packages.java.util.SplittableRandom;

    /**
     * @param raw the object to wrap
     * @return the correct instance of {@link BaseHelper} for the given object if it exists and
     *  `null` otherwise.
     * @since 1.8.4
     */
    function getHelperFromRaw(raw: any): any | null;

    /**
     * @param array the array to convert
     * @return the String representation of the given array.
     * @since 1.8.4
     */
    function arrayToString(array: any[]): string;

    /**
     * This method will convert any objects hold in the array data to Strings and should be used for
     *  multidimensional arrays.
     * @param array the array to convert
     * @return the String representation of the given array.
     * @since 1.8.4
     */
    function arrayDeepToString(array: any[]): string;

}

/**
 * Functions for getting and modifying key pressed states.  
 *
 * @author Wagyourtail
 */
declare namespace KeyBind {

    /**
     * Dont use this one... get the raw minecraft keycode class.
     * @return the raw minecraft keycode class
     */
    function getKeyCode(keyName: Key): /* net.minecraft.client.util.InputUtil$Key */ any;

    /**
     * @return A {@link Packages.java.util.Map} of all the minecraft keybinds.
     * @since 1.2.2
     */
    function getKeyBindings(): JavaMap<Bind, Key>;

    /**
     * Sets a minecraft keybind to the specified key.
     * @since 1.2.2
     */
    function setKeyBind(bind: Bind, key: Key | null): void;

    /**
     * Set a key-state for a key.
     */
    function key(keyName: Key, keyState: boolean): void;

    /**
     * Calls {@link key}(String, boolean) with keyState set to true.
     * @param keyName the name of the key to press
     * @since 1.8.4
     */
    function pressKey(keyName: Key): void;

    /**
     * Calls {@link key}(String, boolean) with keyState set to false.
     * @param keyName the name of the key to release
     * @since 1.8.4
     */
    function releaseKey(keyName: Key): void;

    /**
     * Set a key-state using the name of the keybind rather than the name of the key.  
     *
     *  This is probably the one you should use.
     * @since 1.2.2
     */
    function keyBind(keyBind: Bind, keyState: boolean): void;

    /**
     * Calls {@link keyBind}(String, boolean) with keyState set to true.
     * @param keyBind the name of the keybinding to press
     * @since 1.8.4
     */
    function pressKeyBind(keyBind: Bind): void;

    /**
     * Calls {@link keyBind}(String, boolean) with keyState set to false.
     * @param keyBind the name of the keybinding to release
     * @since 1.8.4
     */
    function releaseKeyBind(keyBind: Bind): void;

    /**
     * @return a set of currently pressed keys.
     * @since 1.2.6 (turned into set instead of list in 1.6.5)
     */
    function getPressedKeys(): JavaSet<Key>;

}

/**
 * Functions for getting and modifying the player's state.  
 *
 * @author Wagyourtail
 */
declare namespace Player {

    /**
     * @return the Inventory handler
     * @see Inventory
     */
    function openInventory(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory;

    /**
     * @return the player entity wrapper.
     * @see ClientPlayerEntityHelper
     * @since 1.0.3
     */
    function getPlayer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.ClientPlayerEntityHelper</* net.minecraft.client.network.ClientPlayerEntity */ any>;
    /** @since 1.9.0 */
    function getInteractionManager(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.InteractionManagerHelper;

    /**
     * @return the player's current gamemode.
     * @since 1.0.9
     */
    function getGameMode(): Gamemode;

    /**
     * @param gameMode possible values are survival, creative, adventure, spectator (case insensitive)
     * @since 1.8.4
     */
    function setGameMode(gameMode: Gamemode): void;

    /**
     * @return the block/liquid the player is currently looking at.
     * @see BlockDataHelper
     * @since 1.0.5
     */
    function rayTraceBlock(distance: double, fluid: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper | null;

    /**
     * @return the entity the camera is currently looking at. can be affected by {@link InteractionManagerHelper.setTarget}(EntityHelper)
     * @see EntityHelper
     * @deprecated use {@link Player.rayTraceEntity}(int) or {@link InteractionManagerHelper.getTargetedEntity}() instead
     * @since 1.0.5
     */
    function rayTraceEntity(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

    /**
     * @return entity the player entity is currently looking at (if any).
     * @since 1.8.3
     */
    function rayTraceEntity(distance: int): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

    /**
     * Write to a sign screen if a sign screen is currently open.
     * @return of success.
     * @since 1.2.2
     */
    function writeSign(l1: string, l2: string, l3: string, l4: string): boolean;

    /**
     * @param callback calls your method as a {@link Consumer}<{@link TextHelper}>
     * @see takeScreenshot(String, String, MethodWrapper)
     * @since 1.2.6
     */
    function takeScreenshot(folder: string, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any, any, any> | null): void;

    /**
     * Take a screenshot and save to a file.  
     *
     *  `file` is the optional one, typescript doesn't like it not being the last one that's optional
     * @param callback calls your method as a {@link Consumer}<{@link TextHelper}>
     * @since 1.2.6
     */
    function takeScreenshot(folder: string, file: string, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any, any, any> | null): void;

    /**
     * @param folder the folder to save the screenshot to, relative to the macro folder
     * @param width the width of the panorama
     * @param height the height of the panorama
     * @param callback calls your method as a {@link Consumer}<{@link TextHelper}>
     * @since 1.8.4
     */
    function takePanorama(folder: string, width: int, height: int, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any, any, any> | null): void;
    function getStatistics(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatsHelper;

    /**
     * @return the current reach distance of the player.
     * @since 1.8.4
     * @deprecated moved to `Player.getInteractionManager()`
     */
    function getReach(): number;

    /**
     * Creates a new PlayerInput object.
     * @see PlayerInput
     * @since 1.4.0
     */
    function createPlayerInput(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Creates a new PlayerInput object.
     * @see PlayerInput
     * @since 1.4.0
     */
    function createPlayerInput(movementForward: double, movementSideways: double, yaw: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Creates a new PlayerInput object.
     * @see PlayerInput
     * @since 1.4.0
     */
    function createPlayerInput(movementForward: double, yaw: double, jumping: boolean, sprinting: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Creates a new PlayerInput object.
     * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
     * @param movementSideways 1 = left input (A); 0 = no input; -1 = right input (D)
     * @param yaw yaw of the player
     * @param pitch pitch of the player
     * @param jumping jump input
     * @param sneaking sneak input
     * @param sprinting sprint input
     * @see PlayerInput
     * @since 1.4.0
     */
    function createPlayerInput(movementForward: double, movementSideways: double, yaw: double, pitch: double, jumping: boolean, sneaking: boolean, sprinting: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Parses each row of CSV string into a `PlayerInput`.  
     *  The capitalization of the header matters.<br>  
     *  About the columns:  
     *  <ul>  
     *    <li> `movementForward` and `movementSideways` as a number</li>  
     *    <li>`yaw` and `pitch` as an absolute number</li>  
     *    <li>`jumping`, `sneaking` and `sprinting` have to be boolean</li>  
     *  </ul>  
     *
     *  The separation must be a "," it's a csv...(but spaces don't matter)<br>  
     *  Quoted values don't work
     * @param csv CSV string to be parsed
     * @see PlayerInput.PlayerInput(float, float, float, float, boolean, boolean, boolean)
     * @since 1.4.0
     */
    function createPlayerInputsFromCsv(csv: string): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput>;

    /**
     * Parses a JSON string into a `PlayerInput` Object.  
     *  For details see `PlayerInput.fromCsv()`, on what has to be present.<br>  
     *  Capitalization of the keys matters.
     * @param json JSON string to be parsed
     * @return The JSON parsed into a `PlayerInput`
     * @see createPlayerInputsFromCsv(String)
     * @since 1.4.0
     */
    function createPlayerInputsFromJson(json: string): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Creates a new `PlayerInput` object with the current inputs of the player.
     * @see PlayerInput
     * @since 1.4.0
     */
    function getCurrentPlayerInput(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Adds a new `PlayerInput` to `MovementQueue` to be executed
     * @param input the PlayerInput to be executed
     * @see MovementQueue
     * @since 1.4.0
     */
    function addInput(input: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput): void;

    /**
     * Adds multiple new `PlayerInput` to `MovementQueue` to be executed
     * @param inputs the PlayerInputs to be executed
     * @see MovementQueue
     * @since 1.4.0
     */
    function addInputs(inputs: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput[]): void;

    /**
     * Clears all inputs in the `MovementQueue`
     * @see MovementQueue
     * @since 1.4.0
     */
    function clearInputs(): void;
    function setDrawPredictions(val: boolean): void;

    /**
     * Predicts where one tick with a `PlayerInput` as input would lead to.
     * @param input the PlayerInput for the prediction
     * @return the position after the input
     * @see predictInput(PlayerInput, boolean)
     * @since 1.4.0
     */
    function predictInput(input: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

    /**
     * Predicts where one tick with a `PlayerInput` as input would lead to.
     * @param input the PlayerInput for the prediction
     * @param draw whether to visualize the result or not
     * @return the position after the input
     * @since 1.4.0
     */
    function predictInput(input: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput, draw: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

    /**
     * Predicts where each `PlayerInput` executed in a row would lead
     *  without drawing it.
     * @param inputs the PlayerInputs for each tick for the prediction
     * @return the position after each input
     * @see predictInputs(PlayerInput[], boolean)
     * @since 1.4.0
     */
    function predictInputs(inputs: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput[]): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * @since 1.8.0
     * @deprecated use `Player.getInteractionManager().isBreakingBlock()` instead
     */
    function isBreakingBlock(): boolean;

    /**
     * Predicts where each `PlayerInput` executed in a row would lead
     * @param inputs the PlayerInputs for each tick for the prediction
     * @param draw whether to visualize the result or not
     * @return the position after each input
     * @since 1.4.0
     */
    function predictInputs(inputs: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput[], draw: boolean): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * Adds a forward movement with a relative yaw value to the MovementQueue.
     * @param yaw the relative yaw for the player
     * @since 1.4.0
     */
    function moveForward(yaw: double): void;

    /**
     * Adds a backward movement with a relative yaw value to the MovementQueue.
     * @param yaw the relative yaw for the player
     * @since 1.4.0
     */
    function moveBackward(yaw: double): void;

    /**
     * Adds sideways movement with a relative yaw value to the MovementQueue.
     * @param yaw the relative yaw for the player
     * @since 1.4.2
     */
    function moveStrafeLeft(yaw: double): void;

    /**
     * Adds sideways movement with a relative yaw value to the MovementQueue.
     * @param yaw the relative yaw for the player
     * @since 1.4.2
     */
    function moveStrafeRight(yaw: double): void;

}

/**
 * position helper classes
 * @since 1.6.3
 */
declare namespace PositionCommon {

    /**
     * create a new vector object
     * @since 1.6.3
     */
    function createVec(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;
    /** @since 1.8.4 */
    function createLookingVector(entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;
    /** @since 1.8.4 */
    function createLookingVector(yaw: double, pitch: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;
    /** @since 1.6.3 */
    function createVec(x1: double, y1: double, x2: double, y2: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec2D;
    /** @since 1.6.3 */
    function createPos(x: double, y: double, z: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
    /** @since 1.6.3 */
    function createPos(x: double, y: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;

    /**
     * @param x the x position of the block
     * @param y the y position of the block
     * @param z the z position of the block
     * @return a {@link BlockPosHelper} for the given coordinates.
     * @since 1.8.4
     */
    function createBlockPos(x: int, y: int, z: int): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

}

/**
 * @author Etheradon
 * @since 1.8.4
 */
declare namespace Utils {

    /**
     * @param url the url to open
     * @since 1.8.4
     */
    function openUrl(url: string): void;

    /**
     * @param path the path top open, relative the config folder
     * @since 1.8.4
     */
    function openFile(path: string): void;

    /**
     * Copies the text to the clipboard.
     * @param text the text to copy
     * @since 1.8.4
     */
    function copyToClipboard(text: string): void;

    /**
     * @return the text from the clipboard.
     * @since 1.8.4
     */
    function getClipboard(): string;

    /**
     * Tries to guess the name of the sender of a given message. This is not guaranteed to work and
     *  for specific servers it may be better to use regex instead.
     * @param text the text to check
     * @return the name of the sender or `null` if it couldn't be guessed.
     * @since 1.8.4
     */
    function guessName(text: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): string;

    /**
     * Tries to guess the name of the sender of a given message. This is not guaranteed to work and
     *  for specific servers it may be better to use regex instead.
     * @param text the text to check
     * @return the name of the sender or `null` if it couldn't be guessed.
     * @since 1.8.4
     */
    function guessName(text: string): string;

    /**
     * Tries to guess the name, as well as the titles and roles of the sender of the given message.  
     *  This is not guaranteed to work and for specific servers it may be better to use regex
     *  instead.
     * @param text the text to check
     * @return a list of names, titles and roles of the sender or an empty list if it couldn't be
     *  guessed.
     * @since 1.8.4
     */
    function guessNameAndRoles(text: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): JavaList<string>;

    /**
     * Tries to guess the name, as well as the titles and roles of the sender of the given message.  
     *  This is not guaranteed to work and for specific servers it may be better to use regex
     *  instead.
     * @param text the text to check
     * @return a list of names, titles and roles of the sender or an empty list if it couldn't be
     *  guessed.
     * @since 1.8.4
     */
    function guessNameAndRoles(text: string): JavaList<string>;

    /**
     * Hashes the given string with sha-256.
     * @param message the message to hash
     * @return the hashed message.
     * @since 1.8.4
     */
    function hashString(message: string | null): string;

    /**
     * Hashes the given string with sha-256 the selected algorithm.
     * @param message the message to hash
     * @param algorithm sha1 | sha256 | sha384 | sha512 | md2 | md5
     * @return the hashed message.
     * @since 1.8.4
     */
    function hashString(message: string | null, algorithm: string): string | null;

    /**
     * Encodes the given string with Base64.
     * @param message the message to encode
     * @return the encoded message.
     * @since 1.8.4
     */
    function encode(message: string): string;

    /**
     * Decodes the given string with Base64.
     * @param message the message to decode
     * @return the decoded message.
     * @since 1.8.4
     */
    function decode(message: string): string;

}

/**
 * Functions for getting and using world data.  
 *
 * @author Wagyourtail
 */
declare namespace World {

    /**
     * returns whether a world is currently loaded
     * @since 1.3.0
     */
    function isWorldLoaded(): boolean;

    /**
     * @return players within render distance.
     */
    function getLoadedPlayers(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* net.minecraft.entity.player.PlayerEntity */ any>>;

    /**
     * @return players on the tablist.
     */
    function getPlayers(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper>;

    /**
     * @param name the name of the player to get the entry for
     * @return player entry for the given player's name or `null` if not found.
     * @since 1.8.4
     */
    function getPlayerEntry(name: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper | null;

    /**
     * @return The block at that position.
     */
    function getBlock(x: int, y: int, z: int): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper | null;
    function getBlock(pos: Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper | null;
    function getBlock(pos: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper | null;

    /**
     * The x and z position of the chunk can be calculated by the following formula: xChunk =
     *  x >> 4; zChunk = z >> 4;
     * @param x the x coordinate of the chunk, not the absolute position
     * @param z the z coordinate of the chunk, not the absolute position
     * @return ChunkHelper for the chunk coordinates {@link ChunkHelper}.
     * @since 1.8.4
     */
    function getChunk(x: int, z: int): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper;

    /**
     * Usage: <br>  
     *  This will return all blocks that are facing south, don't require a tool to break,  
     *  have a hardness of 10 or less and whose name contains either chest or barrel.  
     *  ```  
     *  World.getWorldScanner()
     *      .withBlockFilter("getHardness").is("<=", 10)
     *      .andStringBlockFilter().contains("chest", "barrel")
     *      .withStringStateFilter().contains("facing=south")
     *      .andStateFilter("isToolRequired").is(false)
     *      .build()
     *  ```
     * @return a builder to create a WorldScanner.
     * @since 1.6.5
     */
    function getWorldScanner(): TypedWorldScannerBuilder.Initial;

    /**
     * @return a scanner for the current world.
     * @since 1.6.5
     */
    function getWorldScanner(blockFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper, any, boolean, any> | null, stateFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper, any, boolean, any> | null): Packages.xyz.wagyourtail.jsmacros.client.api.classes.worldscanner.WorldScanner;
    /** @since 1.6.4 */
    function findBlocksMatching(centerX: int, centerZ: int, id: CanOmitNamespace<BlockId>, chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;
    /** @since 1.6.4 */
    function findBlocksMatching(id: CanOmitNamespace<BlockId>, chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;
    /** @since 1.6.4 */
    function findBlocksMatching(ids: CanOmitNamespace<BlockId>[], chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;
    /** @since 1.6.4 */
    function findBlocksMatching(centerX: int, centerZ: int, ids: CanOmitNamespace<BlockId>[], chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;
    /** @since 1.6.4 */
    function findBlocksMatching(blockFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper, any, boolean, any>, stateFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper, any, boolean, any> | null, chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;
    /** @since 1.6.4 */
    function findBlocksMatching(chunkX: int, chunkZ: int, blockFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper, any, boolean, any>, stateFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper, any, boolean, any> | null, chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * By default, air blocks are ignored and the callback is only called for real blocks.
     * @param pos the center position
     * @param radius the radius to scan
     * @param callback the callback to call for each block
     * @since 1.8.4
     */
    function iterateSphere(pos: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, radius: int, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper, any, any, any>): void;

    /**
     * @param pos the center position
     * @param radius the radius to scan
     * @param ignoreAir whether to ignore air blocks
     * @param callback the callback to call for each block
     * @since 1.8.4
     */
    function iterateSphere(pos: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, radius: int, ignoreAir: boolean, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper, any, any, any>): void;

    /**
     * @param pos1 the first position
     * @param pos2 the second position
     * @param callback the callback to call for each block
     * @since 1.8.4
     */
    function iterateBox(pos1: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper, any, any, any>): void;

    /**
     * @param pos1 the first position
     * @param pos2 the second position
     * @param callback the callback to call for each block
     * @param ignoreAir whether to ignore air blocks
     * @since 1.8.4
     */
    function iterateBox(pos1: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, ignoreAir: boolean, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper, any, any, any>): void;

    /**
     * @return a helper for the scoreboards provided to the client.
     * @since 1.2.9
     */
    function getScoreboards(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ScoreboardsHelper;

    /**
     * @return all entities in the render distance.
     */
    function getEntities(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

    /**
     * @param types the entity types to consider
     * @return all entities in the render distance, that match the specified entity type.
     * @since 1.8.4
     */
    function getEntities<E extends CanOmitNamespace<EntityId>>(...types: E[]): JavaList<EntityTypeFromId<E>>;

    /**
     * @param distance the maximum distance to search for entities
     * @return a list of entities within the specified distance to the player.
     * @since 1.8.4
     */
    function getEntities(distance: double): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

    /**
     * @param distance the maximum distance to search for entities
     * @param types the entity types to consider
     * @return a list of entities within the specified distance to the player, that match the specified entity type.
     * @since 1.8.4
     */
    function getEntities<E extends CanOmitNamespace<EntityId>>(distance: double, ...types: E[]): JavaList<EntityTypeFromId<E>>;

    /**
     * @param filter the entity filter
     * @return a list of entities that match the specified filter.
     * @since 1.8.4
     */
    function getEntities(filter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>, any, any, any>): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

    /**
     * raytrace between two points returning the first block hit.
     * @since 1.6.5
     */
    function rayTraceBlock(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, fluid: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper | null;

    /**
     * raytrace between two points returning the first entity hit.
     * @since 1.8.3
     */
    function rayTraceEntity(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

    /**
     * @return the current dimension.
     * @since 1.1.2
     */
    function getDimension(): Dimension;

    /**
     * @return the current biome.
     * @since 1.1.5
     */
    function getBiome(): string;

    /**
     * ticks processed since world was started.
     * @return the current world time.
     * @since 1.1.5
     */
    function getTime(): number;

    /**
     * icks passed since world was started INCLUDING those skipped when nights were cut short with sleeping.
     * @return the current world time of day.
     * @since 1.1.5
     */
    function getTimeOfDay(): number;

    /**
     * @return `true` if it is daytime, `false` otherwise.
     * @since 1.8.4
     */
    function isDay(): boolean;

    /**
     * @return `true` if it is nighttime, `false` otherwise.
     * @since 1.8.4
     */
    function isNight(): boolean;

    /**
     * @return `true` if it is raining, `false` otherwise.
     * @since 1.8.4
     */
    function isRaining(): boolean;

    /**
     * @return `true` if it is thundering, `false` otherwise.
     * @since 1.8.4
     */
    function isThundering(): boolean;

    /**
     * @return an identifier for the loaded world that is based on the world's name or server ip and
     *  thus most likely unique enough to identify a specific world, or
     *  `"UNKNOWN_NAME"` if no world was found.
     * @since 1.8.4
     */
    function getWorldIdentifier(): string;

    /**
     * @return respawn position.
     * @since 1.2.6
     */
    function getRespawnPos(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

    /**
     * @return world difficulty as an int.
     * @since 1.2.6
     */
    function getDifficulty(): number;

    /**
     * @return moon phase as an int.
     * @since 1.2.6
     */
    function getMoonPhase(): number;

    /**
     * @return sky light as an int.
     * @since 1.1.2
     */
    function getSkyLight(x: int, y: int, z: int): number;

    /**
     * @return block light as an int.
     * @since 1.1.2
     */
    function getBlockLight(x: int, y: int, z: int): number;

    /**
     * plays a sound file using javax's sound stuff.
     * @throws LineUnavailableException
     * @throws IOException
     * @throws UnsupportedAudioFileException
     * @since 1.1.7
     */
    function playSoundFile(file: string, volume: double): Packages.javax.sound.sampled.Clip;

    /**
     * @see World.playSound(String, double, double, double, double, double)
     * @since 1.1.7
     */
    function playSound(id: SoundId): void;

    /**
     * @see World.playSound(String, double, double, double, double, double)
     * @since 1.1.7
     */
    function playSound(id: SoundId, volume: double): void;

    /**
     * @see World.playSound(String, double, double, double, double, double)
     * @since 1.1.7
     */
    function playSound(id: CanOmitNamespace<SoundId>, volume: double, pitch: double): void;

    /**
     * plays a minecraft sound using the internal system.
     * @since 1.1.7
     */
    function playSound(id: CanOmitNamespace<SoundId>, volume: double, pitch: double, x: double, y: double, z: double): void;

    /**
     * @return a map of boss bars by the boss bar's UUID.
     * @since 1.2.1
     */
    function getBossBars(): JavaMap<string, Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.BossBarHelper>;

    /**
     * Check whether a chunk is within the render distance and loaded.
     * @since 1.2.2
     */
    function isChunkLoaded(chunkX: int, chunkZ: int): boolean;

    /**
     * @return the current server address as a string (`server.address/server.ip:port`).
     * @since 1.2.2
     */
    function getCurrentServerAddress(): string | null;

    /**
     * @return biome at specified location, only works if the block/chunk is loaded.
     * @since 1.2.2 [Citation Needed]
     */
    function getBiomeAt(x: int, z: int): string;

    /**
     * @return biome at specified location, only works if the block/chunk is loaded.
     * @since 1.8.4
     */
    function getBiomeAt(x: int, y: int, z: int): string;

    /**
     * @return best attempt to measure and give the server tps with various timings.
     * @since 1.2.7
     */
    function getServerTPS(): string;

    /**
     * @return text helper for the top part of the tab list (above the players)
     * @since 1.3.1
     */
    function getTabListHeader(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper | null;

    /**
     * @return text helper for the bottom part of the tab list (below the players)
     * @since 1.3.1
     */
    function getTabListFooter(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper | null;

    /**
     * Summons the amount of particles at the desired position.
     * @param id the particle id
     * @param x the x position to spawn the particle
     * @param y the y position to spawn the particle
     * @param z the z position to spawn the particle
     * @param count the amount of particles to spawn
     * @since 1.8.4
     */
    function spawnParticle(id: ParticleId, x: double, y: double, z: double, count: int): void;

    /**
     * Summons the amount of particles at the desired position with some variation of delta and the
     *  given speed.
     * @param id the particle id
     * @param x the x position to spawn the particle
     * @param y the y position to spawn the particle
     * @param z the z position to spawn the particle
     * @param deltaX the x variation of the particle
     * @param deltaY the y variation of the particle
     * @param deltaZ the z variation of the particle
     * @param speed the speed of the particle
     * @param count the amount of particles to spawn
     * @param force whether to show the particle if it's more than 32 blocks away
     * @since 1.8.4
     */
    function spawnParticle(id: CanOmitNamespace<ParticleId>, x: double, y: double, z: double, deltaX: double, deltaY: double, deltaZ: double, speed: double, count: int, force: boolean): void;

    /**
     * @return best attempt to measure and give the server tps.
     * @since 1.2.7
     */
    function getServerInstantTPS(): number;

    /**
     * @return best attempt to measure and give the server tps over the previous 1 minute average.
     * @since 1.2.7
     */
    function getServer1MAverageTPS(): number;

    /**
     * @return best attempt to measure and give the server tps over the previous 5 minute average.
     * @since 1.2.7
     */
    function getServer5MAverageTPS(): number;

    /**
     * @return best attempt to measure and give the server tps over the previous 15 minute average.
     * @since 1.2.7
     */
    function getServer15MAverageTPS(): number;

}

/**
 * {@link FunctionalInterface} implementation for wrapping methods to match the language spec.  
 *  <br><br>    
 *  <br><br>  
 *  Javascript:  
 *  language spec requires that only one thread can hold an instance of the language at a time,  
 *  so this implementation uses a non-preemptive priority queue for the threads that call the resulting {@link MethodWrapper}.  
 *  <br><br>  
 *  JEP:  
 *  language spec requires everything to be on the same thread, on the java end, so all calls to {@link MethodWrapper}
 *  call back to JEP's starting thread and wait for the call to complete.  
 *  <br><br>  
 *  Jython:  
 *  no limitations
 *  <br><br>  
 *  LUA:  
 *  no limitations
 * @author Wagyourtail
 * @since 1.2.5, re-named from `consumer` in 1.3.2
 */
declare namespace JavaWrapper {

    /**
     * @return a new {@link MethodWrapper}
     * @since 1.4.0
     */
    function methodToJava<A, B, R>(c: (arg0: A, arg1: B) => R | void): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<A, B, R, any>;

    /**
     * @return a new {@link MethodWrapper}
     * @since 1.4.0
     */
    function methodToJavaAsync<A, B, R>(c: (arg0: A, arg1: B) => R | void): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<A, B, R, any>;

    /**
     * JS/JEP ONLY
     *  allows you to set the position of the thread in the queue. you can use this for return value one's too...
     * @since 1.8.0
     */
    function methodToJavaAsync<A, B, R>(priority: int, c: (arg0: A, arg1: B) => R | void): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<A, B, R, any>;

    /**
     * JS/JEP only, puts current task at end of queue.  
     *  use with caution, don't accidentally cause circular waiting.
     * @throws InterruptedException
     * @since 1.4.0 [citation needed]
     */
    function deferCurrentTask(): void;

    /**
     * JS/JEP only, puts current task at end of queue.  
     *  use with caution, don't accidentally cause circular waiting.
     * @param priorityAdjust the amount to adjust the priority by
     * @throws InterruptedException
     * @since 1.8.0
     */
    function deferCurrentTask(priorityAdjust: int): void;

    /**
     * JS/JEP only, get priority of current task.
     * @throws InterruptedException
     * @since 1.8.0
     */
    function getCurrentPriority(): number;

    /**
     * Close the current context
     * @since 1.2.2
     */
    function stop(): void;

}

/**
 * Better File-System functions.  
 *
 * @author Wagyourtail
 * @since 1.1.8
 */
declare namespace FS {

    /**
     * List files in path.
     * @param path relative to the script's folder.
     * @return An array of file names as string.
     * @since 1.1.8
     */
    function list(path: string): JavaArray<string> | null;

    /**
     * Check if a file exists.
     * @param path relative to the script's folder.
     * @since 1.1.8
     */
    function exists(path: string): boolean;

    /**
     * Check if a file is a directory.
     * @param path relative to the script's folder.
     * @since 1.1.8
     */
    function isDir(path: string): boolean;

    /**
     * @param path the path relative to the script's folder
     * @return `true` if the path leads to a file, `false` otherwise.
     * @since 1.8.4
     */
    function isFile(path: string): boolean;

    /**
     * Get the last part (name) of a file.
     * @param path relative to the script's folder.
     * @return a string of the file name.
     * @since 1.1.8
     */
    function getName(path: string): string;

    /**
     * @param absolutePath the absolute path to the file
     * @return a path relative to the script's folder to the given absolute path.
     * @since 1.8.4
     */
    function toRelativePath(absolutePath: string): string;

    /**
     * Creates a new file in the specified path, relative to the script's folder. This will only
     *  work if the parent directory already exists. See {@link createFile}(String, String, boolean)
     *  to automatically create all parent directories.
     * @param path the path relative to the script's folder
     * @param name the name of the file
     * @return `true` if the file was created successfully, `false` otherwise.
     * @throws IOException if there occurs an error while creating the file.
     * @since 1.8.4
     */
    function createFile(path: string, name: string): boolean;

    /**
     * Creates a new file in the specified path, relative to the script's folder. Optionally parent
     *  directories can be created if they do not exist.
     * @param path the path relative to the script's folder
     * @param name the name of the file
     * @param createDirs whether to create parent directories if they do not exist or not
     * @return `true` if the file was created successfully, `false` otherwise.
     * @throws IOException if there occurs an error while creating the file.
     * @since 1.8.4
     */
    function createFile(path: string, name: string, createDirs: boolean): boolean;

    /**
     * Make a directory.
     * @param path relative to the script's folder.
     * @return a boolean for success.
     * @since 1.1.8
     */
    function makeDir(path: string): boolean;

    /**
     * Move a file.
     * @param from relative to the script's folder.
     * @param to relative to the script's folder.
     * @throws IOException
     * @since 1.1.8
     */
    function move(from: string, to: string): void;

    /**
     * Copy a file.
     * @param from relative to the script's folder.
     * @param to relative to the script's folder.
     * @throws IOException
     * @since 1.1.8
     */
    function copy(from: string, to: string): void;

    /**
     * Delete a file.
     * @param path relative to the script's folder.
     * @return a boolean for success.
     * @since 1.2.9
     */
    function unlink(path: string): boolean;

    /**
     * Combine 2 paths.
     * @param patha path is relative to the script's folder.
     * @return a string of the combined path.
     * @throws IOException
     * @since 1.1.8
     */
    function combine(patha: string, pathb: string): string;

    /**
     * Gets the directory part of a file path, or the parent directory of a folder.
     * @param path relative to the script's folder.
     * @return a string of the combined path.
     * @throws IOException
     * @since 1.1.8
     */
    function getDir(path: string): string;

    /**
     * Open a FileHandler for the file at the specified path.
     * @param path relative to the script's folder.
     * @return a {@link FileHandler} for the file path.
     * @see FileHandler
     * @since 1.1.8
     */
    function open(path: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.FileHandler;

    /**
     * Open a FileHandler for the file at the specified path.
     * @param path relative to the script's folder.
     * @param charset the charset to use for reading/writing the file (default is UTF-8)
     * @return a {@link FileHandler} for the file path.
     * @see FileHandler
     * @since 1.8.4
     */
    function open(path: string, charset: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.FileHandler;

    /**
     * An advanced method to walk a directory tree and get some information about the files, as well
     *  as their paths.
     * @param path the relative path of the directory to walk through
     * @param maxDepth the maximum depth to follow, can cause stack overflow if too high
     * @param followLinks whether to follow symbolic links
     * @param visitor the visitor that is called for each file with the path of the file and its
     *                     attributes
     * @throws IOException
     * @since 1.8.4
     */
    function walkFiles(path: string, maxDepth: int, followLinks: boolean, visitor: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<string, Packages.java.nio.file.attribute.BasicFileAttributes, any, any>): void;

    /**
     * @param path the relative path to get the file object for
     * @return the file object for the specified path.
     * @since 1.8.4
     */
    function toRawFile(path: string): Packages.java.io.File;

    /**
     * @param path the relative path to get the path object for
     * @return the path object for the specified path.
     * @since 1.8.4
     */
    function toRawPath(path: string): Packages.java.nio.file.Path;

    /**
     * @param path the path relative to the script's folder
     * @return the attributes of the file at the specified path.
     * @throws IOException
     * @since 1.8.4
     */
    function getRawAttributes(path: string): Packages.java.nio.file.attribute.BasicFileAttributes;

}

/**
 * "Global" variables for passing to other contexts.  
 *
 * @author Wagyourtail
 * @since 1.0.4
 */
declare namespace GlobalVars {

    /**
     * Put an Integer into the global variable space.
     * @since 1.0.4
     */
    function putInt(name: string, i: int): number;

    /**
     * put a String into the global variable space.
     * @since 1.0.4
     */
    function putString(name: string, str: string): string;

    /**
     * put a Double into the global variable space.
     * @since 1.0.8
     */
    function putDouble(name: string, d: double): number;

    /**
     * put a Boolean into the global variable space.
     * @since 1.1.7
     */
    function putBoolean(name: string, b: boolean): boolean;

    /**
     * put anything else into the global variable space.
     * @since 1.1.7
     */
    function putObject(name: string, o: any): any;

    /**
     * Returns the type of the defined item in the global variable space as a string.
     * @since 1.0.4
     */
    function getType(name: string): string | null;

    /**
     * Gets an Integer from the global variable space.
     * @since 1.0.4
     */
    function getInt(name: string): number | null;

    /**
     * Gets an Integer from the global variable space. and then increment it there.
     * @since 1.6.5
     */
    function getAndIncrementInt(name: string): number | null;

    /**
     * Gets an integer from the global variable space. and then decrement it there.
     * @since 1.6.5
     */
    function getAndDecrementInt(name: string): number | null;

    /**
     * increment an Integer in the global variable space. then return it.
     * @since 1.6.5
     */
    function incrementAndGetInt(name: string): number | null;

    /**
     * decrement an Integer in the global variable space. then return it.
     * @since 1.6.5
     */
    function decrementAndGetInt(name: string): number | null;

    /**
     * Gets a String from the global variable space
     * @since 1.0.4
     */
    function getString(name: string): string | null;

    /**
     * Gets a Double from the global variable space.
     * @since 1.0.8
     */
    function getDouble(name: string): number | null;

    /**
     * Gets a Boolean from the global variable space.
     * @since 1.1.7
     */
    function getBoolean(name: string): boolean | null;

    /**
     * toggles a global boolean and returns its new value
     * @since 1.6.5
     */
    function toggleBoolean(name: string): boolean | null;

    /**
     * Gets an Object from the global variable space.
     * @since 1.1.7
     */
    function getObject(name: string): any;

    /**
     * removes a key from the global variable space.
     * @since 1.2.0
     */
    function remove(key: string): void;
    function getRaw(): JavaMap<string, any>;

}

/**
 * Functions that interact directly with JsMacros or Events.  
 *
 * @author Wagyourtail
 */
declare namespace JsMacros {

    /**
     * @return the JsMacros profile class.
     */
    function getProfile(): Packages.xyz.wagyourtail.jsmacros.core.config.BaseProfile;

    /**
     * @return the JsMacros config management class.
     */
    function getConfig(): Packages.xyz.wagyourtail.jsmacros.core.config.ConfigManager;

    /**
     * services are background scripts designed to run full time and are mainly noticed by their side effects.
     * @return for managing services.
     * @since 1.6.3
     */
    function getServiceManager(): Packages.xyz.wagyourtail.jsmacros.core.service.ServiceManager;

    /**
     * @return list of non-garbage-collected ScriptContext's
     * @since 1.4.0
     */
    function getOpenContexts(): JavaList<Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>>;

    /**
     * @see JsMacros.runScript(String, String, MethodWrapper)
     * @since 1.1.5
     */
    function runScript(file: string): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * @param fakeEvent you probably actually want to pass an instance created by {@link createCustomEvent}(String)
     * @since 1.6.3
     */
    function runScript(file: string, fakeEvent: Events.BaseEvent | null): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * runs a script with a eventCustom to be able to pass args
     * @return container the script is running on.
     * @since 1.6.3 (1.1.5 - 1.6.3 didn't have fakeEvent)
     */
    function runScript(file: string, fakeEvent: Events.BaseEvent | null, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.java.lang.Throwable, any, any, any> | null): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * @see JsMacros.runScript(String, String, MethodWrapper)
     * @since 1.2.4
     */
    function runScript(language: string, script: string): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * Runs a string as a script.
     * @param callback calls your method as a {@link Packages.java.util.function.Consumer}<{@link String}>
     * @return the {@link EventContainer} the script is running on.
     * @since 1.2.4
     */
    function runScript(language: string, script: string, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.java.lang.Throwable, any, any, any> | null): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;
    /** @since 1.6.0 */
    function runScript(language: string, script: string, file: string | null, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.java.lang.Throwable, any, any, any> | null): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;
    /** @since 1.7.0 */
    function runScript(language: string, script: string, file: string | null, event: Events.BaseEvent | null, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.java.lang.Throwable, any, any, any> | null): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;
    /** @since 1.7.0 */
    function wrapScriptRun<T, U, R>(file: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;
    /** @since 1.7.0 */
    function wrapScriptRun<T, U, R>(language: string, script: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;
    /** @since 1.7.0 */
    function wrapScriptRun<T, U, R>(language: string, script: string, file: string | null): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;
    /** @since 1.7.0 */
    function wrapScriptRunAsync<T, U, R>(file: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;
    /** @since 1.7.0 */
    function wrapScriptRunAsync<T, U, R>(language: string, script: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;
    /** @since 1.7.0 */
    function wrapScriptRunAsync<T, U, R>(language: string, script: string, file: string | null): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;

    /**
     * Opens a file with the default system program.
     * @param path relative to the script's folder.
     * @since 1.1.8
     * @deprecated use the Utils library instead.
     */
    function open(path: string): void;

    /**
     * @throws MalformedURLException
     * @since 1.6.0
     * @deprecated use the Utils library instead.
     */
    function openUrl(url: string): void;

    /**
     * Creates a listener for an event, this function can be more efficient that running a script file when used properly.
     * @param callback calls your method as a {@link Packages.java.util.function.BiConsumer}<{@link BaseEvent}, {@link EventContainer}>
     * @see IEventListener
     * @since 1.2.7
     */
    function on<E extends keyof Events>(event: E, callback: MethodWrapper<Events[E], EventContainer>): Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener;

    /**
     * Creates a listener for an event, this function can be more efficient that running a script file when used properly.
     * @param callback calls your method as a {@link Packages.java.util.function.BiConsumer}<{@link BaseEvent}, {@link EventContainer}>
     * @see IEventListener
     * @since 1.9.0
     */
    function on<E extends keyof Events>(event: E, joined: boolean, callback: MethodWrapper<Events[E], EventContainer>): Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener;

    /**
     * Creates a single-run listener for an event, this function can be more efficient that running a script file when used properly.
     * @param callback calls your method as a {@link Packages.java.util.function.BiConsumer}<{@link BaseEvent}, {@link EventContainer}>
     * @return the listener.
     * @see IEventListener
     * @since 1.2.7
     */
    function once<E extends keyof Events>(event: E, callback: MethodWrapper<Events[E], EventContainer>): Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener;

    /**
     * Creates a single-run listener for an event, this function can be more efficient that running a script file when used properly.
     * @param callback calls your method as a {@link Packages.java.util.function.BiConsumer}<{@link BaseEvent}, {@link EventContainer}>
     * @return the listener.
     * @see IEventListener
     * @since 1.9.0
     */
    function once<E extends keyof Events>(event: E, joined: boolean, callback: MethodWrapper<Events[E], EventContainer>): Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener;

    /**
     * @see JsMacros.off(String, IEventListener)
     * @since 1.2.3
     */
    function off(listener: Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener): boolean;

    /**
     * Removes a {@link IEventListener} from an event.
     * @see IEventListener
     * @since 1.2.3
     */
    function off<E extends keyof Events>(event: E, listener: IEventListener): boolean;

    /**
     * Will also disable all listeners for the given event, including JsMacros own event listeners.
     * @param event the event to remove all listeners from
     * @since 1.8.4
     */
    function disableAllListeners(event: keyof Events): void;

    /**
     * Will also disable all listeners, including JsMacros own event listeners.
     * @since 1.8.4
     */
    function disableAllListeners(): void;

    /**
     * Will only disable user created event listeners for the given event. This includes listeners
     *  created from {@link on}(String, MethodWrapper), {@link once}(String, MethodWrapper),  
     *  {@link waitForEvent}(String), {@link waitForEvent}(String, MethodWrapper) and
     *  {@link waitForEvent}(String, MethodWrapper, MethodWrapper).
     * @param event the event to remove all listeners from
     * @since 1.8.4
     */
    function disableScriptListeners(event: keyof Events): void;

    /**
     * Will only disable user created event listeners.  This includes listeners created from
     *  {@link on}(String, MethodWrapper), {@link once}(String, MethodWrapper),  
     *  {@link waitForEvent}(String), {@link waitForEvent}(String, MethodWrapper) and
     *  {@link waitForEvent}(String, MethodWrapper, MethodWrapper).
     * @since 1.8.4
     */
    function disableScriptListeners(): void;

    /**
     * @param event event to wait for
     * @return a event and a new context if the event you're waiting for was joined, to leave it early.
     * @throws InterruptedException
     * @since 1.5.0
     */
    function waitForEvent<E extends keyof Events>(event: E): FJsMacros$EventAndContext<Events[E]>;

    /**
     * @param event event to wait for
     * @return a event and a new context if the event you're waiting for was joined, to leave it early.
     * @throws InterruptedException
     * @since 1.9.0
     */
    function waitForEvent<E extends keyof Events>(event: E, join: boolean): FJsMacros$EventAndContext<Events[E]>;

    /**
     * @throws InterruptedException
     * @since 1.5.0 [citation needed]
     */
    function waitForEvent<E extends keyof Events>(event: E, filter: MethodWrapper<Events[E], undefined, boolean>): FJsMacros$EventAndContext<Events[E]>;

    /**
     * @throws InterruptedException
     * @since 1.9.0
     */
    function waitForEvent<E extends keyof Events>(event: E, join: boolean, filter: MethodWrapper<Events[E], undefined, boolean>): FJsMacros$EventAndContext<Events[E]>;

    /**
     * waits for an event. if this thread is bound to an event already, this will release current lock.
     * @param event event to wait for
     * @param filter filter the event until it has the proper values or whatever.
     * @param runBeforeWaiting runs as a {@link Runnable}, run before waiting, this is a thread-safety thing to prevent "interrupts" from going in between this and things like deferCurrentTask
     * @return a event and a new context if the event you're waiting for was joined, to leave it early.
     * @throws InterruptedException
     * @since 1.5.0
     */
    function waitForEvent<E extends keyof Events>(event: E, filter: MethodWrapper<Events[E], undefined, boolean>, runBeforeWaiting: MethodWrapper<JavaObject, JavaObject, JavaObject>): FJsMacros$EventAndContext<Events[E]>;

    /**
     * waits for an event. if this thread is bound to an event already, this will release current lock.
     * @param event event to wait for
     * @param filter filter the event until it has the proper values or whatever.
     * @param runBeforeWaiting runs as a {@link Runnable}, run before waiting, this is a thread-safety thing to prevent "interrupts" from going in between this and things like deferCurrentTask
     * @return a event and a new context if the event you're waiting for was joined, to leave it early.
     * @throws InterruptedException
     * @since 1.9.0
     */
    function waitForEvent<E extends keyof Events>(event: E, join: boolean, filter: MethodWrapper<Events[E], undefined, boolean>, runBeforeWaiting: MethodWrapper<JavaObject, JavaObject, JavaObject>): FJsMacros$EventAndContext<Events[E]>;

    /**
     * @return a list of script-added listeners.
     * @since 1.2.3
     */
    function listeners(event: keyof Events): JavaList<Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener>;

    /**
     * create a custom event object that can trigger a event. It's recommended to use
     *  {@link EventCustom.registerEvent}() to set up the event to be visible in the GUI.
     * @param eventName name of the event. please don't use an existing one... your scripts might not like that.
     * @see BaseEventRegistry.addEvent(String)
     * @since 1.2.8
     */
    function createCustomEvent(eventName: string): Packages.xyz.wagyourtail.jsmacros.core.event.impl.EventCustom;

    /**
     * asserts if `event` is the correct type of event<br>  
     *  and convert `event` type to target type in ts<br>  
     *  example:  
     *  ```  
     *  JsMacros.assertEvent(event, 'Service')
     *  ```
     * @param event the event to assert
     * @param type string of the event type
     * @since 1.9.0
     */
    function assertEvent<E extends keyof Events>(event: Events.BaseEvent, type: E): asserts event is Events[E];

}

/**
 * Functions for getting and using raw java classes, methods and functions.  
 *
 * @author Wagyourtail
 * @since 1.2.3
 */
declare namespace Reflection {

    /**
     * @param name name of class like `path.to.class`
     * @return resolved class
     * @throws ClassNotFoundException
     * @see Reflection.getClass(String, String)
     * @since 1.2.3
     */
    function getClass<C extends string>(name: C): GetJava.Type$Reflection<C>;
    function getClass<C extends JavaTypeList | keyof GetJava.Primitives>(name: C): GetJava.Type$Reflection<C>;

    /**
     * Use this to specify a class with intermediary and yarn names of classes for cleaner code. also has support for
     *  java primitives by using their name in lower case.
     * @param name first try
     * @param name2 second try
     * @return a {@link Packages.java.lang.Class} reference.
     * @throws ClassNotFoundException
     * @since 1.2.3
     */
    function getClass<C extends string>(name: C, name2: string): GetJava.Type$Reflection<C>;
    function getClass<C extends JavaTypeList | keyof GetJava.Primitives>(name: C, name2: JavaTypeList | keyof GetJava.Primitives): GetJava.Type$Reflection<C>;

    /**
     * @throws NoSuchMethodException
     * @throws SecurityException
     * @see Reflection.getDeclaredMethod(Class, String, String, Class...)
     * @since 1.2.3
     */
    function getDeclaredMethod(c: JavaClassArg<any>, name: string, ...parameterTypes: JavaVarArgs<JavaClassArg<any>>): Packages.java.lang.reflect.Method;

    /**
     * Use this to specify a method with intermediary and yarn names of classes for cleaner code.
     * @return a {@link Packages.java.lang.reflect.Method} reference.
     * @throws NoSuchMethodException
     * @throws SecurityException
     * @since 1.2.3
     */
    function getDeclaredMethod(c: JavaClassArg<any>, name: string, name2: string, ...parameterTypes: JavaVarArgs<JavaClassArg<any>>): Packages.java.lang.reflect.Method;

    /**
     * @throws NoSuchMethodException
     * @since 1.6.0
     */
    function getMethod(c: JavaClassArg<any>, name: string, name2: string, ...parameterTypes: JavaVarArgs<JavaClassArg<any>>): Packages.java.lang.reflect.Method;

    /**
     * @throws NoSuchMethodException
     * @since 1.6.0
     */
    function getMethod(c: JavaClassArg<any>, name: string, ...parameterTypes: JavaVarArgs<JavaClassArg<any>>): Packages.java.lang.reflect.Method;

    /**
     * @throws NoSuchFieldException
     * @throws SecurityException
     * @see Reflection.getDeclaredField(Class, String, String)
     * @since 1.2.3
     */
    function getDeclaredField(c: JavaClassArg<any>, name: string): Packages.java.lang.reflect.Field;

    /**
     * Use this to specify a field with intermediary and yarn names of classes for cleaner code.
     * @return a {@link Packages.java.lang.reflect.Field} reference.
     * @throws NoSuchFieldException
     * @throws SecurityException
     * @since 1.2.3
     */
    function getDeclaredField(c: JavaClassArg<any>, name: string, name2: string): Packages.java.lang.reflect.Field;

    /**
     * @throws NoSuchFieldException
     * @since 1.6.0
     */
    function getField(c: JavaClassArg<any>, name: string): Packages.java.lang.reflect.Field;

    /**
     * @throws NoSuchFieldException
     * @since 1.6.0
     */
    function getField(c: JavaClassArg<any>, name: string, name2: string): Packages.java.lang.reflect.Field;

    /**
     * Invoke a method on an object with auto type coercion for numbers.
     * @param m method
     * @param c object (can be `null` for statics)
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     * @since 1.2.3
     */
    function invokeMethod(m: Packages.java.lang.reflect.Method, c: any, ...objects: JavaVarArgs<any>): any;

    /**
     * Attempts to create a new instance of a class. You probably don't have to use this one and can just call `
     *  new` on a {@link Packages.java.lang.Class} unless you're in LUA, but then you also have the (kinda poorly
     *  documented, can someone find a better docs link for me)
     *  [LuaJava Library](http://luaj.sourceforge.net/api/3.2/org/luaj/vm2/lib/jse/LuajavaLib.html).
     * @since 1.2.7
     */
    function newInstance<T>(c: JavaClassArg<T>, ...objects: JavaVarArgs<any>): T;

    /**
     * proxy for extending java classes in the guest language with proper threading support.
     * @since 1.6.0
     */
    function createClassProxyBuilder<T>(clazz: JavaClassArg<T>, ...interfaces: JavaVarArgs<JavaClassArg<any>>): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ProxyBuilder<T>;

    /**
     * @throws NotFoundException
     * @throws CannotCompileException
     * @since 1.6.5
     */
    function createClassBuilder<T>(cName: string, clazz: JavaClassArg<T>, ...interfaces: JavaVarArgs<JavaClassArg<any>>): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder<T>;

    /**
     * @throws ClassNotFoundException
     * @since 1.6.5
     */
    function getClassFromClassBuilderResult(cName: string): JavaClass<any>;
    function createLibraryBuilder(name: string, perExec: boolean, ...acceptedLangs: JavaVarArgs<string>): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.LibraryBuilder;

    /**
     * A library class always has a {@link Library} annotation containing the name of the library,  
     *  which may differ from the actual class name. A library class must also extend
     *  {@link BaseLibrary} in some way, either directly or through
     *  {@link PerExecLibrary},  
     *  {@link PerExecLanguageLibrary}
     *  or {@link PerLanguageLibrary}.
     * @param className the fully qualified name of the class, including the package
     * @param javaCode the source code of the library
     * @since 1.8.4
     */
    function createLibrary(className: string, javaCode: string): void;

    /**
     * A Java Development Kit (JDK) must be installed (and potentially used to start Minecraft) in
     *  order to compile whole classes.  
     *
     *  Compiled classes can't be accessed from any guest language, but must be either stored through
     *  {@link GlobalVars.putObject}(String, Object) or retrieved from this library. Unlike normal
     *  hot swapping, already created instances of the class will not be updated. Thus, it's
     *  important to know which version of the class you're using when instantiating it.
     * @param className the fully qualified name of the class, including the package
     * @param code the java code to compile
     * @return the compiled class.
     * @since 1.8.4
     */
    function compileJavaClass(className: string, code: string): JavaClass<any>;

    /**
     * @param className the fully qualified name of the class, including the package
     * @return the latest compiled class or `null` if it doesn't exist.
     * @since 1.8.4
     */
    function getCompiledJavaClass(className: string): JavaClass<any>;

    /**
     * @param className the fully qualified name of the class, including the package
     * @return all compiled versions of the class, in order of compilation.
     * @since 1.8.4
     */
    function getAllCompiledJavaClassVersions(className: string): JavaList<JavaClass<any>>;

    /**
     * See [jOOR Github](https://github.com/jOOQ/jOOR) for more information.
     * @param obj the object to wrap
     * @return a wrapper for the passed object to do help with java reflection.
     * @since 1.8.4
     */
    function getReflect(obj: any): Packages.org.joor.Reflect;

    /**
     * Loads a jar file to be accessible with this library.
     * @param file relative to the script's folder.
     * @return success value
     * @throws IOException
     * @since 1.2.6
     */
    function loadJarFile(file: string): boolean;

    /**
     * @return the previous mapping helper generated with {@link loadMappingHelper}(String)
     * @since 1.3.1
     */
    function loadCurrentMappingHelper(): Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings | null;

    /**
     * @param o class you want the name of
     * @return the fully qualified class name (with "."'s not "/"'s)
     * @since 1.3.1
     */
    function getClassName(o: any): string;

    /**
     * @param urlorfile a url or file path the the yarn mappings `-v2.jar` file, or `.tiny` file. for example `https://maven.fabricmc.net/net/fabricmc/yarn/1.16.5%2Bbuild.3/yarn-1.16.5%2Bbuild.3-v2.jar`, if same url/path as previous this will load from cache.
     * @return the associated mapping helper.
     * @since 1.3.1
     */
    function loadMappingHelper(urlorfile: string): Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings;
    /** @since 1.6.5 */
    function wrapInstace<T>(instance: T): Packages.xyz.wagyourtail.jsmacros.core.classes.WrappedClassInstance<T>;

    /**
     * @throws ClassNotFoundException
     * @since 1.6.5
     */
    function getWrappedClass(className: string): Packages.xyz.wagyourtail.jsmacros.core.classes.WrappedClassInstance<any>;

}

/**
 * Functions for getting and using raw java classes, methods and functions.  
 *
 * @author Wagyourtail
 * @since 1.1.8
 */
declare namespace Request {

    /**
     * create a HTTPRequest handler to the specified URL
     * @return Request Wrapper
     * @throws IOException
     * @see HTTPRequest
     * @since 1.1.8
     */
    function create(url: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest;

    /**
     * @throws IOException
     * @see Request.get(String, Map)
     * @since 1.1.8
     */
    function get(url: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;

    /**
     * send a GET request to the specified URL.
     * @return Response Data
     * @throws IOException
     * @see HTTPRequest.Response
     * @since 1.1.8
     */
    function get(url: string, headers: JavaMap<string, string> | null): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;

    /**
     * @throws IOException
     * @see Request.post(String, String, Map)
     * @since 1.1.8
     */
    function post(url: string, data: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;

    /**
     * send a POST request to the specified URL.
     * @return Response Data
     * @throws IOException
     * @since 1.1.8
     */
    function post(url: string, data: string, headers: JavaMap<string, string> | null): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;

    /**
     * Create a Websocket handler.
     * @throws IOException
     * @see Websocket
     * @since 1.2.7
     */
    function createWS(url: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.Websocket;

    /**
     * Create a Websocket handler.
     * @throws IOException
     * @since 1.1.9
     * @deprecated 1.2.7
     */
    function createWS2(url: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.Websocket;

}

/**
 * Functions for getting and using raw java classes, methods and functions.  
 *
 * @author Wagyourtail
 */
declare namespace Time {

    /**
     * @return current time in MS.
     */
    function time(): number;

    /**
     * Sleeps the current thread for the specified time in MS.
     * @throws InterruptedException
     */
    function sleep(millis: long): void;

}

declare namespace Packages {

    namespace com {

        namespace google {

            namespace common.collect {

                abstract class Multimap<K, V> extends java.lang.Interface {
                    static readonly class: JavaClass<Multimap<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Multimap<K, V> {

                    size(): number;
                    isEmpty(): boolean;
                    containsKey(arg0: any): boolean;
                    containsValue(arg0: any): boolean;
                    containsEntry(arg0: any, arg1: any): boolean;
                    put(arg0: K, arg1: V): boolean;
                    remove(arg0: any, arg1: any): boolean;
                    putAll(arg0: K, arg1: java.lang.Iterable<V>): boolean;
                    putAll(arg0: Multimap<K, V>): boolean;
                    replaceValues(arg0: K, arg1: java.lang.Iterable<V>): JavaCollection<V>;
                    removeAll(arg0: any): JavaCollection<V>;
                    clear(): void;
                    get(arg0: K): JavaCollection<V>;
                    keySet(): JavaSet<K>;
                    keys(): Multiset<K>;
                    values(): JavaCollection<V>;
                    entries(): JavaCollection<java.util.Map$Entry<K, V>>;
                    forEach(arg0: MethodWrapper<K, V>): void;
                    asMap(): JavaMap<K, JavaCollection<V>>;

                }

                abstract class ForwardingObject extends java.lang.Object {
                    static readonly class: JavaClass<ForwardingObject>;
                    /** @deprecated */ static prototype: undefined;
                }

                interface ForwardingMultimap<K, V> extends Multimap<K, V> {}
                abstract class ForwardingMultimap<K, V> extends ForwardingObject {
                    static readonly class: JavaClass<ForwardingMultimap<any, any>>;
                    /** @deprecated */ static prototype: undefined;

                    asMap(): JavaMap<K, JavaCollection<V>>;
                    clear(): void;
                    containsEntry(arg0: any, arg1: any): boolean;
                    containsKey(arg0: any): boolean;
                    containsValue(arg0: any): boolean;
                    entries(): JavaCollection<java.util.Map$Entry<K, V>>;
                    get(arg0: K): JavaCollection<V>;
                    isEmpty(): boolean;
                    keys(): Multiset<K>;
                    keySet(): JavaSet<K>;
                    put(arg0: K, arg1: V): boolean;
                    putAll(arg0: K, arg1: java.lang.Iterable<V>): boolean;
                    putAll(arg0: Multimap<K, V>): boolean;
                    remove(arg0: any, arg1: any): boolean;
                    removeAll(arg0: any): JavaCollection<V>;
                    replaceValues(arg0: K, arg1: java.lang.Iterable<V>): JavaCollection<V>;
                    size(): number;
                    values(): JavaCollection<V>;

                }

                abstract class Multiset<E> extends java.lang.Interface {
                    static readonly class: JavaClass<Multiset<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Multiset<E> extends JavaCollection<E> {

                    size(): number;
                    count(arg0: any): number;
                    add(arg0: E, arg1: int): number;
                    add(arg0: E): boolean;
                    remove(arg0: any, arg1: int): number;
                    remove(arg0: any): boolean;
                    setCount(arg0: E, arg1: int): number;
                    setCount(arg0: E, arg1: int, arg2: int): boolean;
                    elementSet(): JavaSet<E>;
                    entrySet(): JavaSet<Multiset$Entry<E>>;
                    forEachEntry(arg0: java.util.function.ObjIntConsumer<E>): void;
                    iterator(): java.util.Iterator<E>;
                    contains(arg0: any): boolean;
                    containsAll(arg0: JavaCollection<any>): boolean;
                    removeAll(arg0: JavaCollection<any>): boolean;
                    retainAll(arg0: JavaCollection<any>): boolean;
                    forEach(arg0: MethodWrapper<E>): void;
                    spliterator(): java.util.Spliterator<E>;

                }

                abstract class Multiset$Entry<E> extends java.lang.Interface {
                    static readonly class: JavaClass<Multiset$Entry<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Multiset$Entry<E> {

                    getElement(): E;
                    getCount(): number;

                }

                export {
                    Multimap,
                    ForwardingObject,
                    ForwardingMultimap,
                    Multiset,
                    Multiset$Entry
                }

            }

            namespace gson {

                class JsonObject extends JsonElement {
                    static readonly class: JavaClass<JsonObject>;
                    /** @deprecated */ static prototype: undefined;

                    constructor ();

                    deepCopy(): JsonObject;
                    add(arg0: string, arg1: JsonElement): void;
                    remove(arg0: string): JsonElement;
                    addProperty(arg0: string, arg1: string): void;
                    addProperty(arg0: string, arg1: number): void;
                    addProperty(arg0: string, arg1: boolean): void;
                    addProperty(arg0: string, arg1: char): void;
                    entrySet(): JavaSet<java.util.Map$Entry<string, JsonElement>>;
                    keySet(): JavaSet<string>;
                    size(): number;
                    isEmpty(): boolean;
                    has(arg0: string): boolean;
                    get(arg0: string): JsonElement;
                    getAsJsonPrimitive(arg0: string): JsonPrimitive;
                    getAsJsonPrimitive(): JsonPrimitive;
                    getAsJsonArray(arg0: string): JsonArray;
                    getAsJsonArray(): JsonArray;
                    getAsJsonObject(arg0: string): JsonObject;
                    getAsJsonObject(): JsonObject;
                    asMap(): JavaMap<string, JsonElement>;

                }

                interface JsonArray extends java.lang.Iterable<JsonElement> {}
                class JsonArray extends JsonElement {
                    static readonly class: JavaClass<JsonArray>;
                    /** @deprecated */ static prototype: undefined;

                    constructor ();
                    constructor (arg0: int);

                    deepCopy(): JsonArray;
                    add(arg0: boolean): void;
                    add(arg0: char): void;
                    add(arg0: number): void;
                    add(arg0: string): void;
                    add(arg0: JsonElement): void;
                    addAll(arg0: JsonArray): void;
                    set(arg0: int, arg1: JsonElement): JsonElement;
                    remove(arg0: JsonElement): boolean;
                    remove(arg0: int): JsonElement;
                    contains(arg0: JsonElement): boolean;
                    size(): number;
                    isEmpty(): boolean;
                    iterator(): java.util.Iterator<JsonElement>;
                    get(arg0: int): JsonElement;
                    getAsNumber(): number;
                    getAsString(): string;
                    getAsDouble(): number;
                    getAsBigDecimal(): java.math.BigDecimal;
                    getAsBigInteger(): java.math.BigInteger;
                    getAsFloat(): number;
                    getAsLong(): number;
                    getAsInt(): number;
                    getAsByte(): number;
                    /** @deprecated */
                    getAsCharacter(): number;
                    getAsShort(): number;
                    getAsBoolean(): boolean;
                    asList(): JavaList<JsonElement>;

                }

                class JsonPrimitive extends JsonElement {
                    static readonly class: JavaClass<JsonPrimitive>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: boolean);
                    constructor (arg0: number);
                    constructor (arg0: string);
                    constructor (arg0: char);

                    deepCopy(): JsonPrimitive;
                    isBoolean(): boolean;
                    getAsBoolean(): boolean;
                    isNumber(): boolean;
                    getAsNumber(): number;
                    isString(): boolean;
                    getAsString(): string;
                    getAsDouble(): number;
                    getAsBigDecimal(): java.math.BigDecimal;
                    getAsBigInteger(): java.math.BigInteger;
                    getAsFloat(): number;
                    getAsLong(): number;
                    getAsShort(): number;
                    getAsInt(): number;
                    getAsByte(): number;
                    /** @deprecated */
                    getAsCharacter(): number;

                }

                class JsonElement extends java.lang.Object {
                    static readonly class: JavaClass<JsonElement>;
                    /** @deprecated */ static prototype: undefined;

                    /** @deprecated */
                    constructor ();

                    deepCopy(): JsonElement;
                    isJsonArray(): boolean;
                    isJsonObject(): boolean;
                    isJsonPrimitive(): boolean;
                    isJsonNull(): boolean;
                    getAsJsonObject(): JsonObject;
                    getAsJsonArray(): JsonArray;
                    getAsJsonPrimitive(): JsonPrimitive;
                    getAsJsonNull(): JsonNull;
                    getAsBoolean(): boolean;
                    getAsNumber(): number;
                    getAsString(): string;
                    getAsDouble(): number;
                    getAsFloat(): number;
                    getAsLong(): number;
                    getAsInt(): number;
                    getAsByte(): number;
                    /** @deprecated */
                    getAsCharacter(): number;
                    getAsBigDecimal(): java.math.BigDecimal;
                    getAsBigInteger(): java.math.BigInteger;
                    getAsShort(): number;

                }

                class JsonNull extends JsonElement {
                    static readonly class: JavaClass<JsonNull>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly INSTANCE: JsonNull;

                    /** @deprecated */
                    constructor ();

                    deepCopy(): JsonNull;

                }

                export { JsonObject, JsonArray, JsonPrimitive, JsonElement, JsonNull }

            }

        }

        namespace mojang {

            namespace authlib {

                class GameProfile extends java.lang.Object {
                    static readonly class: JavaClass<GameProfile>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: java.util.UUID, arg1: string);

                    getId(): java.util.UUID;
                    getName(): string;
                    getProperties(): com.mojang.authlib.properties.PropertyMap;

                }

                export { GameProfile }

            }
            namespace authlib {

                namespace properties {

                    class PropertyMap extends com.google.common.collect.ForwardingMultimap<java.lang.String, Property> {
                        static readonly class: JavaClass<PropertyMap>;
                        /** @deprecated */ static prototype: undefined;

                        constructor ();

                    }

                    class Property extends java.lang.Record {
                        static readonly class: JavaClass<Property>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (arg0: string, arg1: string);
                        constructor (arg0: string, arg1: string, arg2: string | null);

                        hasSignature(): boolean;
                        /** @deprecated */
                        isSignatureValid(arg0: java.security.PublicKey): boolean;
                        name(): string;
                        value(): string;
                        signature(): string | null;

                    }

                    export { PropertyMap, Property }

                }

            }

            namespace brigadier {

                abstract class ImmutableStringReader extends java.lang.Interface {
                    static readonly class: JavaClass<ImmutableStringReader>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ImmutableStringReader {

                    getString(): string;
                    getRemainingLength(): number;
                    getTotalLength(): number;
                    getCursor(): number;
                    getRead(): string;
                    getRemaining(): string;
                    canRead(arg0: int): boolean;
                    canRead(): boolean;
                    peek(): number;
                    peek(arg0: int): number;

                }

                abstract class Command<S> extends java.lang.Interface {
                    static readonly class: JavaClass<Command<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly SINGLE_SUCCESS: number;
                }
                interface Command<S> {

                    run(arg0: com.mojang.brigadier.context.CommandContext<S>): number;

                }

                abstract class RedirectModifier<S> extends java.lang.Interface {
                    static readonly class: JavaClass<RedirectModifier<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface RedirectModifier<S> {

                    apply(arg0: com.mojang.brigadier.context.CommandContext<S>): JavaCollection<S>;

                }

                interface StringReader extends ImmutableStringReader {}
                class StringReader extends java.lang.Object {
                    static readonly class: JavaClass<StringReader>;
                    /** @deprecated */ static prototype: undefined;

                    static isAllowedNumber(arg0: char): boolean;
                    static isQuotedStringStart(arg0: char): boolean;
                    static isAllowedInUnquotedString(arg0: char): boolean;

                    constructor (arg0: StringReader);
                    constructor (arg0: string);

                    getString(): string;
                    setCursor(arg0: int): void;
                    getRemainingLength(): number;
                    getTotalLength(): number;
                    getCursor(): number;
                    getRead(): string;
                    getRemaining(): string;
                    canRead(arg0: int): boolean;
                    canRead(): boolean;
                    peek(): number;
                    peek(arg0: int): number;
                    read(): number;
                    skip(): void;
                    skipWhitespace(): void;
                    readInt(): number;
                    readLong(): number;
                    readDouble(): number;
                    readFloat(): number;
                    readUnquotedString(): string;
                    readQuotedString(): string;
                    readStringUntil(arg0: char): string;
                    readString(): string;
                    readBoolean(): boolean;
                    expect(arg0: char): void;

                }

                abstract class AmbiguityConsumer<S> extends java.lang.Interface {
                    static readonly class: JavaClass<AmbiguityConsumer<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface AmbiguityConsumer<S> {

                    ambiguous(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: com.mojang.brigadier.tree.CommandNode<S>, arg2: com.mojang.brigadier.tree.CommandNode<S>, arg3: JavaCollection<string>): void;

                }

                abstract class Message extends java.lang.Interface {
                    static readonly class: JavaClass<Message>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Message {

                    getString(): string;

                }

                class CommandDispatcher<S> extends java.lang.Object {
                    static readonly class: JavaClass<CommandDispatcher<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly ARGUMENT_SEPARATOR: string;
                    static readonly ARGUMENT_SEPARATOR_CHAR: number;

                    constructor <S>(arg0: com.mojang.brigadier.tree.RootCommandNode<S>);
                    constructor <S>();

                    register(arg0: com.mojang.brigadier.builder.LiteralArgumentBuilder<S>): com.mojang.brigadier.tree.LiteralCommandNode<S>;
                    setConsumer(arg0: ResultConsumer<S>): void;
                    execute(arg0: string, arg1: S): number;
                    execute(arg0: StringReader, arg1: S): number;
                    execute(arg0: ParseResults<S>): number;
                    parse(arg0: string, arg1: S): ParseResults<S>;
                    parse(arg0: StringReader, arg1: S): ParseResults<S>;
                    getAllUsage(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: S, arg2: boolean): JavaArray<string>;
                    getSmartUsage(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: S): JavaMap<com.mojang.brigadier.tree.CommandNode<S>, string>;
                    getCompletionSuggestions(arg0: ParseResults<S>): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                    getCompletionSuggestions(arg0: ParseResults<S>, arg1: int): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                    getRoot(): com.mojang.brigadier.tree.RootCommandNode<S>;
                    getPath(arg0: com.mojang.brigadier.tree.CommandNode<S>): JavaCollection<string>;
                    findNode(arg0: JavaCollection<string>): com.mojang.brigadier.tree.CommandNode<S>;
                    findAmbiguities(arg0: AmbiguityConsumer<S>): void;

                }

                abstract class SingleRedirectModifier<S> extends java.lang.Interface {
                    static readonly class: JavaClass<SingleRedirectModifier<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface SingleRedirectModifier<S> {

                    apply(arg0: com.mojang.brigadier.context.CommandContext<S>): S;

                }

                abstract class ResultConsumer<S> extends java.lang.Interface {
                    static readonly class: JavaClass<ResultConsumer<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ResultConsumer<S> {

                    onCommandComplete(arg0: com.mojang.brigadier.context.CommandContext<S>, arg1: boolean, arg2: int): void;

                }

                class ParseResults<S> extends java.lang.Object {
                    static readonly class: JavaClass<ParseResults<any>>;
                    /** @deprecated */ static prototype: undefined;

                    constructor <S>(arg0: com.mojang.brigadier.context.CommandContextBuilder<S>, arg1: ImmutableStringReader, arg2: JavaMap<com.mojang.brigadier.tree.CommandNode<S>, com.mojang.brigadier.exceptions.CommandSyntaxException>);
                    constructor <S>(arg0: com.mojang.brigadier.context.CommandContextBuilder<S>);

                    getContext(): com.mojang.brigadier.context.CommandContextBuilder<S>;
                    getReader(): ImmutableStringReader;
                    getExceptions(): JavaMap<com.mojang.brigadier.tree.CommandNode<S>, com.mojang.brigadier.exceptions.CommandSyntaxException>;

                }

                export {
                    ImmutableStringReader,
                    Command,
                    RedirectModifier,
                    StringReader,
                    AmbiguityConsumer,
                    Message,
                    CommandDispatcher,
                    SingleRedirectModifier,
                    ResultConsumer,
                    ParseResults
                }

            }
            namespace brigadier {

                namespace builder {

                    class ArgumentBuilder<S, T extends ArgumentBuilder<S, T>> extends java.lang.Object {
                        static readonly class: JavaClass<ArgumentBuilder<any, any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <S, T extends ArgumentBuilder<S, T>>();

                        then(arg0: ArgumentBuilder<S, any>): T;
                        then(arg0: com.mojang.brigadier.tree.CommandNode<S>): T;
                        getArguments(): JavaCollection<com.mojang.brigadier.tree.CommandNode<S>>;
                        executes(arg0: com.mojang.brigadier.Command<S>): T;
                        getCommand(): com.mojang.brigadier.Command<S>;
                        requires(arg0: MethodWrapper<S, any, boolean>): T;
                        getRequirement(): MethodWrapper<S, any, boolean>;
                        redirect(arg0: com.mojang.brigadier.tree.CommandNode<S>): T;
                        redirect(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: com.mojang.brigadier.SingleRedirectModifier<S>): T;
                        fork(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: com.mojang.brigadier.RedirectModifier<S>): T;
                        forward(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: com.mojang.brigadier.RedirectModifier<S>, arg2: boolean): T;
                        getRedirect(): com.mojang.brigadier.tree.CommandNode<S>;
                        getRedirectModifier(): com.mojang.brigadier.RedirectModifier<S>;
                        isFork(): boolean;
                        build(): com.mojang.brigadier.tree.CommandNode<S>;

                    }

                    abstract class LiteralArgumentBuilder<S> extends ArgumentBuilder<S, LiteralArgumentBuilder<S>> {
                        static readonly class: JavaClass<LiteralArgumentBuilder<any>>;
                        /** @deprecated */ static prototype: undefined;

                        static literal<S>(arg0: string): LiteralArgumentBuilder<S>;

                        getLiteral(): string;
                        build(): com.mojang.brigadier.tree.LiteralCommandNode<S>;

                    }

                    export { ArgumentBuilder, LiteralArgumentBuilder }

                }

                namespace context {

                    class CommandContext<S> extends java.lang.Object {
                        static readonly class: JavaClass<CommandContext<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <S>(arg0: S, arg1: string, arg2: JavaMap<string, ParsedArgument<S, any>>, arg3: com.mojang.brigadier.Command<S>, arg4: com.mojang.brigadier.tree.CommandNode<S>, arg5: JavaList<ParsedCommandNode<S>>, arg6: StringRange, arg7: CommandContext<S>, arg8: com.mojang.brigadier.RedirectModifier<S>, arg9: boolean);

                        copyFor(arg0: S): CommandContext<S>;
                        getChild(): CommandContext<S>;
                        getLastChild(): CommandContext<S>;
                        getCommand(): com.mojang.brigadier.Command<S>;
                        getSource(): S;
                        getArgument<V>(arg0: string, arg1: JavaClassArg<V>): V;
                        getRedirectModifier(): com.mojang.brigadier.RedirectModifier<S>;
                        getRange(): StringRange;
                        getInput(): string;
                        getRootNode(): com.mojang.brigadier.tree.CommandNode<S>;
                        getNodes(): JavaList<ParsedCommandNode<S>>;
                        hasNodes(): boolean;
                        isForked(): boolean;

                    }

                    class StringRange extends java.lang.Object {
                        static readonly class: JavaClass<StringRange>;
                        /** @deprecated */ static prototype: undefined;

                        static at(arg0: int): StringRange;
                        static between(arg0: int, arg1: int): StringRange;
                        static encompassing(arg0: StringRange, arg1: StringRange): StringRange;

                        constructor (arg0: int, arg1: int);

                        getStart(): number;
                        getEnd(): number;
                        get(arg0: com.mojang.brigadier.ImmutableStringReader): string;
                        get(arg0: string): string;
                        isEmpty(): boolean;
                        getLength(): number;

                    }

                    class ParsedArgument<S, T> extends java.lang.Object {
                        static readonly class: JavaClass<ParsedArgument<any, any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <S, T>(arg0: int, arg1: int, arg2: T);

                        getRange(): StringRange;
                        getResult(): T;

                    }

                    class ParsedCommandNode<S> extends java.lang.Object {
                        static readonly class: JavaClass<ParsedCommandNode<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <S>(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: StringRange);

                        getNode(): com.mojang.brigadier.tree.CommandNode<S>;
                        getRange(): StringRange;

                    }

                    class CommandContextBuilder<S> extends java.lang.Object {
                        static readonly class: JavaClass<CommandContextBuilder<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <S>(arg0: com.mojang.brigadier.CommandDispatcher<S>, arg1: S, arg2: com.mojang.brigadier.tree.CommandNode<S>, arg3: int);

                        withSource(arg0: S): CommandContextBuilder<S>;
                        getSource(): S;
                        getRootNode(): com.mojang.brigadier.tree.CommandNode<S>;
                        withArgument(arg0: string, arg1: ParsedArgument<S, any>): CommandContextBuilder<S>;
                        getArguments(): JavaMap<string, ParsedArgument<S, any>>;
                        withCommand(arg0: com.mojang.brigadier.Command<S>): CommandContextBuilder<S>;
                        withNode(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: StringRange): CommandContextBuilder<S>;
                        copy(): CommandContextBuilder<S>;
                        withChild(arg0: CommandContextBuilder<S>): CommandContextBuilder<S>;
                        getChild(): CommandContextBuilder<S>;
                        getLastChild(): CommandContextBuilder<S>;
                        getCommand(): com.mojang.brigadier.Command<S>;
                        getNodes(): JavaList<ParsedCommandNode<S>>;
                        build(arg0: string): CommandContext<S>;
                        getDispatcher(): com.mojang.brigadier.CommandDispatcher<S>;
                        getRange(): StringRange;
                        findSuggestionContext(arg0: int): SuggestionContext<S>;

                    }

                    class SuggestionContext<S> extends java.lang.Object {
                        static readonly class: JavaClass<SuggestionContext<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <S>(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: int);

                        readonly parent: com.mojang.brigadier.tree.CommandNode<S>;
                        readonly startPos: number;
                    }

                    export {
                        CommandContext,
                        StringRange,
                        ParsedArgument,
                        ParsedCommandNode,
                        CommandContextBuilder,
                        SuggestionContext
                    }

                }

                namespace exceptions {

                    class CommandSyntaxException extends java.lang.Exception {
                        static readonly class: JavaClass<CommandSyntaxException>;
                        /** @deprecated */ static prototype: undefined;

                        static readonly CONTEXT_AMOUNT: number;
                        static ENABLE_COMMAND_STACK_TRACES: boolean;
                        static BUILT_IN_EXCEPTIONS: BuiltInExceptionProvider;

                        constructor (arg0: CommandExceptionType, arg1: com.mojang.brigadier.Message);
                        constructor (arg0: CommandExceptionType, arg1: com.mojang.brigadier.Message, arg2: string, arg3: int);

                        getMessage(): string;
                        getRawMessage(): com.mojang.brigadier.Message;
                        getContext(): string;
                        getType(): CommandExceptionType;
                        getInput(): string;
                        getCursor(): number;

                    }

                    abstract class BuiltInExceptionProvider extends java.lang.Interface {
                        static readonly class: JavaClass<BuiltInExceptionProvider>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface BuiltInExceptionProvider {

                        doubleTooLow(): Dynamic2CommandExceptionType;
                        doubleTooHigh(): Dynamic2CommandExceptionType;
                        floatTooLow(): Dynamic2CommandExceptionType;
                        floatTooHigh(): Dynamic2CommandExceptionType;
                        integerTooLow(): Dynamic2CommandExceptionType;
                        integerTooHigh(): Dynamic2CommandExceptionType;
                        longTooLow(): Dynamic2CommandExceptionType;
                        longTooHigh(): Dynamic2CommandExceptionType;
                        literalIncorrect(): DynamicCommandExceptionType;
                        readerExpectedStartOfQuote(): SimpleCommandExceptionType;
                        readerExpectedEndOfQuote(): SimpleCommandExceptionType;
                        readerInvalidEscape(): DynamicCommandExceptionType;
                        readerInvalidBool(): DynamicCommandExceptionType;
                        readerInvalidInt(): DynamicCommandExceptionType;
                        readerExpectedInt(): SimpleCommandExceptionType;
                        readerInvalidLong(): DynamicCommandExceptionType;
                        readerExpectedLong(): SimpleCommandExceptionType;
                        readerInvalidDouble(): DynamicCommandExceptionType;
                        readerExpectedDouble(): SimpleCommandExceptionType;
                        readerInvalidFloat(): DynamicCommandExceptionType;
                        readerExpectedFloat(): SimpleCommandExceptionType;
                        readerExpectedBool(): SimpleCommandExceptionType;
                        readerExpectedSymbol(): DynamicCommandExceptionType;
                        dispatcherUnknownCommand(): SimpleCommandExceptionType;
                        dispatcherUnknownArgument(): SimpleCommandExceptionType;
                        dispatcherExpectedArgumentSeparator(): SimpleCommandExceptionType;
                        dispatcherParseException(): DynamicCommandExceptionType;

                    }

                    abstract class CommandExceptionType extends java.lang.Interface {
                        static readonly class: JavaClass<CommandExceptionType>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface CommandExceptionType {}

                    interface Dynamic2CommandExceptionType extends CommandExceptionType {}
                    class Dynamic2CommandExceptionType extends java.lang.Object {
                        static readonly class: JavaClass<Dynamic2CommandExceptionType>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (arg0: Dynamic2CommandExceptionType$Function);

                        create(arg0: any, arg1: any): CommandSyntaxException;
                        createWithContext(arg0: com.mojang.brigadier.ImmutableStringReader, arg1: any, arg2: any): CommandSyntaxException;

                    }

                    interface DynamicCommandExceptionType extends CommandExceptionType {}
                    class DynamicCommandExceptionType extends java.lang.Object {
                        static readonly class: JavaClass<DynamicCommandExceptionType>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (arg0: MethodWrapper<any, any, com.mojang.brigadier.Message>);

                        create(arg0: any): CommandSyntaxException;
                        createWithContext(arg0: com.mojang.brigadier.ImmutableStringReader, arg1: any): CommandSyntaxException;

                    }

                    interface SimpleCommandExceptionType extends CommandExceptionType {}
                    class SimpleCommandExceptionType extends java.lang.Object {
                        static readonly class: JavaClass<SimpleCommandExceptionType>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (arg0: com.mojang.brigadier.Message);

                        create(): CommandSyntaxException;
                        createWithContext(arg0: com.mojang.brigadier.ImmutableStringReader): CommandSyntaxException;

                    }

                    abstract class Dynamic2CommandExceptionType$Function extends java.lang.Interface {
                        static readonly class: JavaClass<Dynamic2CommandExceptionType$Function>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface Dynamic2CommandExceptionType$Function {

                        apply(arg0: any, arg1: any): com.mojang.brigadier.Message;

                    }

                    export {
                        CommandSyntaxException,
                        BuiltInExceptionProvider,
                        CommandExceptionType,
                        Dynamic2CommandExceptionType,
                        DynamicCommandExceptionType,
                        SimpleCommandExceptionType,
                        Dynamic2CommandExceptionType$Function
                    }

                }

                namespace suggestion {

                    class SuggestionsBuilder extends java.lang.Object {
                        static readonly class: JavaClass<SuggestionsBuilder>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (arg0: string, arg1: string, arg2: int);
                        constructor (arg0: string, arg1: int);

                        getInput(): string;
                        getStart(): number;
                        getRemaining(): string;
                        getRemainingLowerCase(): string;
                        build(): Suggestions;
                        buildFuture(): java.util.concurrent.CompletableFuture<Suggestions>;
                        suggest(arg0: string): SuggestionsBuilder;
                        suggest(arg0: string, arg1: com.mojang.brigadier.Message): SuggestionsBuilder;
                        suggest(arg0: int): SuggestionsBuilder;
                        suggest(arg0: int, arg1: com.mojang.brigadier.Message): SuggestionsBuilder;
                        add(arg0: SuggestionsBuilder): SuggestionsBuilder;
                        createOffset(arg0: int): SuggestionsBuilder;
                        restart(): SuggestionsBuilder;

                    }

                    class Suggestions extends java.lang.Object {
                        static readonly class: JavaClass<Suggestions>;
                        /** @deprecated */ static prototype: undefined;

                        static empty(): java.util.concurrent.CompletableFuture<Suggestions>;
                        static merge(arg0: string, arg1: JavaCollection<Suggestions>): Suggestions;
                        static create(arg0: string, arg1: JavaCollection<Suggestion>): Suggestions;

                        constructor (arg0: com.mojang.brigadier.context.StringRange, arg1: JavaList<Suggestion>);

                        getRange(): com.mojang.brigadier.context.StringRange;
                        getList(): JavaList<Suggestion>;
                        isEmpty(): boolean;

                    }

                    interface Suggestion extends java.lang.Comparable<Suggestion> {}
                    class Suggestion extends java.lang.Object {
                        static readonly class: JavaClass<Suggestion>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (arg0: com.mojang.brigadier.context.StringRange, arg1: string);
                        constructor (arg0: com.mojang.brigadier.context.StringRange, arg1: string, arg2: com.mojang.brigadier.Message);

                        getRange(): com.mojang.brigadier.context.StringRange;
                        getText(): string;
                        getTooltip(): com.mojang.brigadier.Message;
                        apply(arg0: string): string;
                        compareTo(arg0: Suggestion): number;
                        compareToIgnoreCase(arg0: Suggestion): number;
                        expand(arg0: string, arg1: com.mojang.brigadier.context.StringRange): Suggestion;

                    }

                    export { SuggestionsBuilder, Suggestions, Suggestion }

                }

                namespace tree {

                    interface CommandNode<S> extends java.lang.Comparable<CommandNode<S>> {}
                    abstract class CommandNode<S> extends java.lang.Object {
                        static readonly class: JavaClass<CommandNode<any>>;
                        /** @deprecated */ static prototype: undefined;

                        getCommand(): com.mojang.brigadier.Command<S>;
                        getChildren(): JavaCollection<CommandNode<S>>;
                        getChild(arg0: string): CommandNode<S>;
                        getRedirect(): CommandNode<S>;
                        getRedirectModifier(): com.mojang.brigadier.RedirectModifier<S>;
                        canUse(arg0: S): boolean;
                        addChild(arg0: CommandNode<S>): void;
                        findAmbiguities(arg0: com.mojang.brigadier.AmbiguityConsumer<S>): void;
                        getRequirement(): MethodWrapper<S, any, boolean>;
                        getName(): string;
                        getUsageText(): string;
                        parse(arg0: com.mojang.brigadier.StringReader, arg1: com.mojang.brigadier.context.CommandContextBuilder<S>): void;
                        listSuggestions(arg0: com.mojang.brigadier.context.CommandContext<S>, arg1: com.mojang.brigadier.suggestion.SuggestionsBuilder): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                        createBuilder(): com.mojang.brigadier.builder.ArgumentBuilder<S, any>;
                        getRelevantNodes(arg0: com.mojang.brigadier.StringReader): JavaCollection<CommandNode<S>>;
                        compareTo(arg0: CommandNode<S>): number;
                        isFork(): boolean;
                        getExamples(): JavaCollection<string>;

                    }

                    class LiteralCommandNode<S> extends CommandNode<S> {
                        static readonly class: JavaClass<LiteralCommandNode<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <S>(arg0: string, arg1: com.mojang.brigadier.Command<S>, arg2: MethodWrapper<S, any, boolean>, arg3: CommandNode<S>, arg4: com.mojang.brigadier.RedirectModifier<S>, arg5: boolean);

                        getLiteral(): string;
                        getName(): string;
                        parse(arg0: com.mojang.brigadier.StringReader, arg1: com.mojang.brigadier.context.CommandContextBuilder<S>): void;
                        listSuggestions(arg0: com.mojang.brigadier.context.CommandContext<S>, arg1: com.mojang.brigadier.suggestion.SuggestionsBuilder): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                        isValidInput(arg0: string): boolean;
                        getUsageText(): string;
                        createBuilder(): com.mojang.brigadier.builder.LiteralArgumentBuilder<S>;
                        getExamples(): JavaCollection<string>;

                    }

                    class RootCommandNode<S> extends CommandNode<S> {
                        static readonly class: JavaClass<RootCommandNode<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <S>();

                        getName(): string;
                        getUsageText(): string;
                        parse(arg0: com.mojang.brigadier.StringReader, arg1: com.mojang.brigadier.context.CommandContextBuilder<S>): void;
                        listSuggestions(arg0: com.mojang.brigadier.context.CommandContext<S>, arg1: com.mojang.brigadier.suggestion.SuggestionsBuilder): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                        isValidInput(arg0: string): boolean;
                        createBuilder(): com.mojang.brigadier.builder.ArgumentBuilder<S, any>;
                        getExamples(): JavaCollection<string>;

                    }

                    export { CommandNode, LiteralCommandNode, RootCommandNode }

                }

            }

        }

        namespace neovisionaries.ws.client {

            class WebSocketFrame extends java.lang.Object {
                static readonly class: JavaClass<WebSocketFrame>;
                /** @deprecated */ static prototype: undefined;

                static createContinuationFrame(): WebSocketFrame;
                static createContinuationFrame(arg0: byte[]): WebSocketFrame;
                static createContinuationFrame(arg0: string): WebSocketFrame;
                static createTextFrame(arg0: string): WebSocketFrame;
                static createBinaryFrame(arg0: byte[]): WebSocketFrame;
                static createCloseFrame(): WebSocketFrame;
                static createCloseFrame(arg0: int): WebSocketFrame;
                static createCloseFrame(arg0: int, arg1: string): WebSocketFrame;
                static createPingFrame(): WebSocketFrame;
                static createPingFrame(arg0: byte[]): WebSocketFrame;
                static createPingFrame(arg0: string): WebSocketFrame;
                static createPongFrame(): WebSocketFrame;
                static createPongFrame(arg0: byte[]): WebSocketFrame;
                static createPongFrame(arg0: string): WebSocketFrame;

                constructor ();

                getFin(): boolean;
                setFin(arg0: boolean): WebSocketFrame;
                getRsv1(): boolean;
                setRsv1(arg0: boolean): WebSocketFrame;
                getRsv2(): boolean;
                setRsv2(arg0: boolean): WebSocketFrame;
                getRsv3(): boolean;
                setRsv3(arg0: boolean): WebSocketFrame;
                getOpcode(): number;
                setOpcode(arg0: int): WebSocketFrame;
                isContinuationFrame(): boolean;
                isTextFrame(): boolean;
                isBinaryFrame(): boolean;
                isCloseFrame(): boolean;
                isPingFrame(): boolean;
                isPongFrame(): boolean;
                isDataFrame(): boolean;
                isControlFrame(): boolean;
                hasPayload(): boolean;
                getPayloadLength(): number;
                getPayload(): JavaArray<number>;
                getPayloadText(): string;
                setPayload(arg0: byte[]): WebSocketFrame;
                setPayload(arg0: string): WebSocketFrame;
                setCloseFramePayload(arg0: int, arg1: string): WebSocketFrame;
                getCloseCode(): number;
                getCloseReason(): string;

            }

            class WebSocketException extends java.lang.Exception {
                static readonly class: JavaClass<WebSocketException>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: WebSocketError);
                constructor (arg0: WebSocketError, arg1: string);
                constructor (arg0: WebSocketError, arg1: java.lang.Throwable);
                constructor (arg0: WebSocketError, arg1: string, arg2: java.lang.Throwable);

                getError(): WebSocketError;

            }

            abstract class WebSocket extends java.lang.Object {
                static readonly class: JavaClass<WebSocket>;
                /** @deprecated */ static prototype: undefined;

                recreate(): WebSocket;
                recreate(arg0: int): WebSocket;
                getState(): WebSocketState;
                isOpen(): boolean;
                addProtocol(arg0: string): WebSocket;
                removeProtocol(arg0: string): WebSocket;
                clearProtocols(): WebSocket;
                addExtension(arg0: WebSocketExtension): WebSocket;
                addExtension(arg0: string): WebSocket;
                removeExtension(arg0: WebSocketExtension): WebSocket;
                removeExtensions(arg0: string): WebSocket;
                clearExtensions(): WebSocket;
                addHeader(arg0: string, arg1: string): WebSocket;
                removeHeaders(arg0: string): WebSocket;
                clearHeaders(): WebSocket;
                setUserInfo(arg0: string): WebSocket;
                setUserInfo(arg0: string, arg1: string): WebSocket;
                clearUserInfo(): WebSocket;
                isExtended(): boolean;
                setExtended(arg0: boolean): WebSocket;
                isAutoFlush(): boolean;
                setAutoFlush(arg0: boolean): WebSocket;
                isMissingCloseFrameAllowed(): boolean;
                setMissingCloseFrameAllowed(arg0: boolean): WebSocket;
                isDirectTextMessage(): boolean;
                setDirectTextMessage(arg0: boolean): WebSocket;
                flush(): WebSocket;
                getFrameQueueSize(): number;
                setFrameQueueSize(arg0: int): WebSocket;
                getMaxPayloadSize(): number;
                setMaxPayloadSize(arg0: int): WebSocket;
                getPingInterval(): number;
                setPingInterval(arg0: long): WebSocket;
                getPongInterval(): number;
                setPongInterval(arg0: long): WebSocket;
                getPingPayloadGenerator(): PayloadGenerator;
                setPingPayloadGenerator(arg0: PayloadGenerator): WebSocket;
                getPongPayloadGenerator(): PayloadGenerator;
                setPongPayloadGenerator(arg0: PayloadGenerator): WebSocket;
                getPingSenderName(): string;
                setPingSenderName(arg0: string): WebSocket;
                getPongSenderName(): string;
                setPongSenderName(arg0: string): WebSocket;
                addListener(arg0: WebSocketListener): WebSocket;
                addListeners(arg0: JavaList<WebSocketListener>): WebSocket;
                removeListener(arg0: WebSocketListener): WebSocket;
                removeListeners(arg0: JavaList<WebSocketListener>): WebSocket;
                clearListeners(): WebSocket;
                getSocket(): java.net.Socket;
                getConnectedSocket(): java.net.Socket;
                getURI(): java.net.URI;
                connect(): WebSocket;
                connect(arg0: java.util.concurrent.ExecutorService): java.util.concurrent.Future<WebSocket>;
                connectable(): java.util.concurrent.Callable<WebSocket>;
                connectAsynchronously(): WebSocket;
                disconnect(): WebSocket;
                disconnect(arg0: int): WebSocket;
                disconnect(arg0: string): WebSocket;
                disconnect(arg0: int, arg1: string): WebSocket;
                disconnect(arg0: int, arg1: string, arg2: long): WebSocket;
                getAgreedExtensions(): JavaList<WebSocketExtension>;
                getAgreedProtocol(): string;
                sendFrame(arg0: WebSocketFrame): WebSocket;
                sendContinuation(): WebSocket;
                sendContinuation(arg0: boolean): WebSocket;
                sendContinuation(arg0: string): WebSocket;
                sendContinuation(arg0: string, arg1: boolean): WebSocket;
                sendContinuation(arg0: byte[]): WebSocket;
                sendContinuation(arg0: byte[], arg1: boolean): WebSocket;
                sendText(arg0: string): WebSocket;
                sendText(arg0: string, arg1: boolean): WebSocket;
                sendBinary(arg0: byte[]): WebSocket;
                sendBinary(arg0: byte[], arg1: boolean): WebSocket;
                sendClose(): WebSocket;
                sendClose(arg0: int): WebSocket;
                sendClose(arg0: int, arg1: string): WebSocket;
                sendPing(): WebSocket;
                sendPing(arg0: byte[]): WebSocket;
                sendPing(arg0: string): WebSocket;
                sendPong(): WebSocket;
                sendPong(arg0: byte[]): WebSocket;
                sendPong(arg0: string): WebSocket;

            }

            abstract class PayloadGenerator extends java.lang.Interface {
                static readonly class: JavaClass<PayloadGenerator>;
                /** @deprecated */ static prototype: undefined;
            }
            interface PayloadGenerator {

                generate(): JavaArray<number>;

            }

            abstract class WebSocketError extends java.lang.Enum<WebSocketError> {
                static readonly class: JavaClass<WebSocketError>;
                /** @deprecated */ static prototype: undefined;

                static readonly NOT_IN_CREATED_STATE: WebSocketError;
                static readonly SOCKET_INPUT_STREAM_FAILURE: WebSocketError;
                static readonly SOCKET_OUTPUT_STREAM_FAILURE: WebSocketError;
                static readonly OPENING_HAHDSHAKE_REQUEST_FAILURE: WebSocketError;
                static readonly OPENING_HANDSHAKE_RESPONSE_FAILURE: WebSocketError;
                static readonly STATUS_LINE_EMPTY: WebSocketError;
                static readonly STATUS_LINE_BAD_FORMAT: WebSocketError;
                static readonly NOT_SWITCHING_PROTOCOLS: WebSocketError;
                static readonly HTTP_HEADER_FAILURE: WebSocketError;
                static readonly NO_UPGRADE_HEADER: WebSocketError;
                static readonly NO_WEBSOCKET_IN_UPGRADE_HEADER: WebSocketError;
                static readonly NO_CONNECTION_HEADER: WebSocketError;
                static readonly NO_UPGRADE_IN_CONNECTION_HEADER: WebSocketError;
                static readonly NO_SEC_WEBSOCKET_ACCEPT_HEADER: WebSocketError;
                static readonly UNEXPECTED_SEC_WEBSOCKET_ACCEPT_HEADER: WebSocketError;
                static readonly EXTENSION_PARSE_ERROR: WebSocketError;
                static readonly UNSUPPORTED_EXTENSION: WebSocketError;
                static readonly EXTENSIONS_CONFLICT: WebSocketError;
                static readonly UNSUPPORTED_PROTOCOL: WebSocketError;
                static readonly INSUFFICENT_DATA: WebSocketError;
                static readonly INVALID_PAYLOAD_LENGTH: WebSocketError;
                static readonly TOO_LONG_PAYLOAD: WebSocketError;
                static readonly INSUFFICIENT_MEMORY_FOR_PAYLOAD: WebSocketError;
                static readonly INTERRUPTED_IN_READING: WebSocketError;
                static readonly IO_ERROR_IN_READING: WebSocketError;
                static readonly IO_ERROR_IN_WRITING: WebSocketError;
                static readonly FLUSH_ERROR: WebSocketError;
                static readonly NON_ZERO_RESERVED_BITS: WebSocketError;
                static readonly UNEXPECTED_RESERVED_BIT: WebSocketError;
                static readonly FRAME_MASKED: WebSocketError;
                static readonly UNKNOWN_OPCODE: WebSocketError;
                static readonly FRAGMENTED_CONTROL_FRAME: WebSocketError;
                static readonly UNEXPECTED_CONTINUATION_FRAME: WebSocketError;
                static readonly CONTINUATION_NOT_CLOSED: WebSocketError;
                static readonly TOO_LONG_CONTROL_FRAME_PAYLOAD: WebSocketError;
                static readonly MESSAGE_CONSTRUCTION_ERROR: WebSocketError;
                static readonly TEXT_MESSAGE_CONSTRUCTION_ERROR: WebSocketError;
                static readonly UNEXPECTED_ERROR_IN_READING_THREAD: WebSocketError;
                static readonly UNEXPECTED_ERROR_IN_WRITING_THREAD: WebSocketError;
                static readonly PERMESSAGE_DEFLATE_UNSUPPORTED_PARAMETER: WebSocketError;
                static readonly PERMESSAGE_DEFLATE_INVALID_MAX_WINDOW_BITS: WebSocketError;
                static readonly COMPRESSION_ERROR: WebSocketError;
                static readonly DECOMPRESSION_ERROR: WebSocketError;
                static readonly SOCKET_CONNECT_ERROR: WebSocketError;
                static readonly PROXY_HANDSHAKE_ERROR: WebSocketError;
                static readonly SOCKET_OVERLAY_ERROR: WebSocketError;
                static readonly SSL_HANDSHAKE_ERROR: WebSocketError;
                static readonly NO_MORE_FRAME: WebSocketError;
                static readonly HOSTNAME_UNVERIFIED: WebSocketError;

                static values(): JavaArray<WebSocketError>;
                static valueOf(arg0: string): WebSocketError;

            }

            abstract class WebSocketState extends java.lang.Enum<WebSocketState> {
                static readonly class: JavaClass<WebSocketState>;
                /** @deprecated */ static prototype: undefined;

                static readonly CREATED: WebSocketState;
                static readonly CONNECTING: WebSocketState;
                static readonly OPEN: WebSocketState;
                static readonly CLOSING: WebSocketState;
                static readonly CLOSED: WebSocketState;

                static values(): JavaArray<WebSocketState>;
                static valueOf(arg0: string): WebSocketState;

            }

            abstract class WebSocketListener extends java.lang.Interface {
                static readonly class: JavaClass<WebSocketListener>;
                /** @deprecated */ static prototype: undefined;
            }
            interface WebSocketListener {

                onStateChanged(arg0: WebSocket, arg1: WebSocketState): void;
                onConnected(arg0: WebSocket, arg1: JavaMap<string, JavaList<string>>): void;
                onConnectError(arg0: WebSocket, arg1: WebSocketException): void;
                onDisconnected(arg0: WebSocket, arg1: WebSocketFrame, arg2: WebSocketFrame, arg3: boolean): void;
                onFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onContinuationFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onTextFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onBinaryFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onCloseFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onPingFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onPongFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onTextMessage(arg0: WebSocket, arg1: string): void;
                onTextMessage(arg0: WebSocket, arg1: byte[]): void;
                onBinaryMessage(arg0: WebSocket, arg1: byte[]): void;
                onSendingFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onFrameSent(arg0: WebSocket, arg1: WebSocketFrame): void;
                onFrameUnsent(arg0: WebSocket, arg1: WebSocketFrame): void;
                onThreadCreated(arg0: WebSocket, arg1: ThreadType, arg2: java.lang.Thread): void;
                onThreadStarted(arg0: WebSocket, arg1: ThreadType, arg2: java.lang.Thread): void;
                onThreadStopping(arg0: WebSocket, arg1: ThreadType, arg2: java.lang.Thread): void;
                onError(arg0: WebSocket, arg1: WebSocketException): void;
                onFrameError(arg0: WebSocket, arg1: WebSocketException, arg2: WebSocketFrame): void;
                onMessageError(arg0: WebSocket, arg1: WebSocketException, arg2: JavaList<WebSocketFrame>): void;
                onMessageDecompressionError(arg0: WebSocket, arg1: WebSocketException, arg2: byte[]): void;
                onTextMessageError(arg0: WebSocket, arg1: WebSocketException, arg2: byte[]): void;
                onSendError(arg0: WebSocket, arg1: WebSocketException, arg2: WebSocketFrame): void;
                onUnexpectedError(arg0: WebSocket, arg1: WebSocketException): void;
                handleCallbackError(arg0: WebSocket, arg1: java.lang.Throwable): void;
                onSendingHandshake(arg0: WebSocket, arg1: string, arg2: JavaList<string[]>): void;

            }

            class WebSocketExtension extends java.lang.Object {
                static readonly class: JavaClass<WebSocketExtension>;
                /** @deprecated */ static prototype: undefined;

                static readonly PERMESSAGE_DEFLATE: string;

                static parse(arg0: string): WebSocketExtension;

                constructor (arg0: string);
                constructor (arg0: WebSocketExtension);

                getName(): string;
                getParameters(): JavaMap<string, string>;
                containsParameter(arg0: string): boolean;
                getParameter(arg0: string): string;
                setParameter(arg0: string, arg1: string): WebSocketExtension;

            }

            abstract class ThreadType extends java.lang.Enum<ThreadType> {
                static readonly class: JavaClass<ThreadType>;
                /** @deprecated */ static prototype: undefined;

                static readonly READING_THREAD: ThreadType;
                static readonly WRITING_THREAD: ThreadType;
                static readonly CONNECT_THREAD: ThreadType;
                static readonly FINISH_THREAD: ThreadType;

                static values(): JavaArray<ThreadType>;
                static valueOf(arg0: string): ThreadType;

            }

            export {
                WebSocketFrame,
                WebSocketException,
                WebSocket,
                PayloadGenerator,
                WebSocketError,
                WebSocketState,
                WebSocketListener,
                WebSocketExtension,
                ThreadType
            }

        }

    }

    namespace io.noties.prism4j {

        abstract class Prism4j$Node extends java.lang.Interface {
            static readonly class: JavaClass<Prism4j$Node>;
            /** @deprecated */ static prototype: undefined;
        }
        interface Prism4j$Node {

            textLength(): number;
            isSyntax(): boolean;

        }

        export { Prism4j$Node }

    }

    namespace it.unimi.dsi.fastutil {

        abstract class BidirectionalIterator<K> extends java.lang.Interface {
            static readonly class: JavaClass<BidirectionalIterator<any>>;
            /** @deprecated */ static prototype: undefined;
        }
        interface BidirectionalIterator<K> extends java.util.Iterator<K> {

            previous(): K;
            hasPrevious(): boolean;

        }

        export { BidirectionalIterator }

    }
    namespace it.unimi.dsi.fastutil {

        namespace ints {

            abstract class IntList extends java.lang.Interface {
                static readonly class: JavaClass<IntList>;
                /** @deprecated */ static prototype: undefined;

                static of(): IntList;
                static of(arg0: int): IntList;
                static of(arg0: int, arg1: int): IntList;
                static of(arg0: int, arg1: int, arg2: int): IntList;
                static of(...arg0: JavaVarArgs<int>): IntList;

            }
            interface IntList extends JavaList<java.lang.Integer>, IntCollection, java.lang.Comparable<JavaList<java.lang.Integer>> {

                iterator(): IntListIterator;
                spliterator(): IntSpliterator;
                listIterator(): IntListIterator;
                listIterator(arg0: int): IntListIterator;
                subList(arg0: int, arg1: int): IntList;
                size(arg0: int): void;
                size(): number;
                getElements(arg0: int, arg1: int[], arg2: int, arg3: int): void;
                removeElements(arg0: int, arg1: int): void;
                addElements(arg0: int, arg1: int[]): void;
                addElements(arg0: int, arg1: int[], arg2: int, arg3: int): void;
                setElements(arg0: int[]): void;
                setElements(arg0: int, arg1: int[]): void;
                setElements(arg0: int, arg1: int[], arg2: int, arg3: int): void;
                add(arg0: int): boolean;
                add(arg0: int, arg1: int): void;
                /** @deprecated */
                add(arg0: int, arg1: int): void;
                addAll(arg0: int, arg1: IntCollection): boolean;
                addAll(arg0: JavaCollection<E>): boolean;
                addAll(arg0: int, arg1: JavaCollection<E>): boolean;
                addAll(arg0: IntCollection): boolean;
                set(arg0: int, arg1: int): number;
                replaceAll(arg0: java.util.function.IntUnaryOperator): void;
                replaceAll(arg0: IntUnaryOperator): void;
                /** @deprecated */
                replaceAll(arg0: java.util.function.UnaryOperator<int>): void;
                getInt(arg0: int): number;
                indexOf(arg0: int): number;
                lastIndexOf(arg0: int): number;
                /** @deprecated */
                contains(arg0: any): boolean;
                contains(arg0: int): boolean;
                /** @deprecated */
                get(arg0: int): number;
                /** @deprecated */
                indexOf(arg0: any): number;
                /** @deprecated */
                lastIndexOf(arg0: any): number;
                /** @deprecated */
                add(arg0: int): boolean;
                removeInt(arg0: int): number;
                /** @deprecated */
                remove(arg0: any): boolean;
                /** @deprecated */
                remove(arg0: int): number;
                /** @deprecated */
                set(arg0: int, arg1: int): number;
                addAll(arg0: int, arg1: IntList): boolean;
                addAll(arg0: IntList): boolean;
                /** @deprecated */
                sort(arg0: MethodWrapper<int, int, int>): void;
                sort(arg0: IntComparator): void;
                /** @deprecated */
                unstableSort(arg0: MethodWrapper<int, int, int>): void;
                unstableSort(arg0: IntComparator): void;

            }

            abstract class IntListIterator extends java.lang.Interface {
                static readonly class: JavaClass<IntListIterator>;
                /** @deprecated */ static prototype: undefined;
            }
            interface IntListIterator extends java.util.ListIterator<java.lang.Integer>, IntBidirectionalIterator {

                set(arg0: int): void;
                add(arg0: int): void;
                remove(): void;
                /** @deprecated */
                set(arg0: int): void;
                /** @deprecated */
                add(arg0: int): void;
                /** @deprecated */
                next(): number;
                /** @deprecated */
                previous(): number;

            }

            abstract class IntUnaryOperator extends java.lang.Interface {
                static readonly class: JavaClass<IntUnaryOperator>;
                /** @deprecated */ static prototype: undefined;

                static identity(): IntUnaryOperator;
                static negation(): IntUnaryOperator;

            }
            interface IntUnaryOperator extends java.util.function.UnaryOperator<java.lang.Integer>, java.util.function.IntUnaryOperator {

                apply(arg0: int): number;
                /** @deprecated */
                applyAsInt(arg0: int): number;
                /** @deprecated */
                apply(arg0: int): number;

            }

            abstract class IntCollection extends java.lang.Interface {
                static readonly class: JavaClass<IntCollection>;
                /** @deprecated */ static prototype: undefined;
            }
            interface IntCollection extends JavaCollection<java.lang.Integer>, IntIterable {

                iterator(): IntIterator;
                intIterator(): IntIterator;
                spliterator(): IntSpliterator;
                intSpliterator(): IntSpliterator;
                add(arg0: int): boolean;
                contains(arg0: int): boolean;
                rem(arg0: int): boolean;
                /** @deprecated */
                add(arg0: int): boolean;
                /** @deprecated */
                contains(arg0: any): boolean;
                /** @deprecated */
                remove(arg0: any): boolean;
                toIntArray(): JavaArray<number>;
                /** @deprecated */
                toIntArray(arg0: int[]): JavaArray<number>;
                toArray(arg0: int[]): JavaArray<number>;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;
                toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
                addAll(arg0: IntCollection): boolean;
                addAll(arg0: JavaCollection<E>): boolean;
                containsAll(arg0: IntCollection): boolean;
                containsAll(arg0: JavaCollection<any>): boolean;
                removeAll(arg0: IntCollection): boolean;
                removeAll(arg0: JavaCollection<any>): boolean;
                /** @deprecated */
                removeIf(arg0: MethodWrapper<int, any, boolean>): boolean;
                removeIf(arg0: java.util.function.IntPredicate): boolean;
                removeIf(arg0: IntPredicate): boolean;
                retainAll(arg0: IntCollection): boolean;
                retainAll(arg0: JavaCollection<any>): boolean;
                /** @deprecated */
                stream(): java.util.stream.Stream<number>;
                intStream(): java.util.stream.IntStream;
                /** @deprecated */
                parallelStream(): java.util.stream.Stream<number>;
                intParallelStream(): java.util.stream.IntStream;

            }

            abstract class IntIterable extends java.lang.Interface {
                static readonly class: JavaClass<IntIterable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface IntIterable extends java.lang.Iterable<java.lang.Integer> {

                iterator(): IntIterator;
                intIterator(): IntIterator;
                spliterator(): IntSpliterator;
                intSpliterator(): IntSpliterator;
                forEach(arg0: java.util.function.IntConsumer): void;
                forEach(arg0: IntConsumer): void;
                /** @deprecated */
                forEach(arg0: MethodWrapper<int>): void;

            }

            abstract class IntSpliterator extends java.lang.Interface {
                static readonly class: JavaClass<IntSpliterator>;
                /** @deprecated */ static prototype: undefined;
            }
            interface IntSpliterator extends java.util.Spliterator$OfInt {

                /** @deprecated */
                tryAdvance(arg0: MethodWrapper<int>): boolean;
                tryAdvance(arg0: IntConsumer): boolean;
                tryAdvance(arg0: java.util.function.IntConsumer): boolean;
                /** @deprecated */
                forEachRemaining(arg0: MethodWrapper<int>): void;
                forEachRemaining(arg0: IntConsumer): void;
                forEachRemaining(arg0: java.util.function.IntConsumer): void;
                skip(arg0: long): number;
                trySplit(): IntSpliterator;
                getComparator(): IntComparator;

            }

            abstract class IntComparator extends java.lang.Interface {
                static readonly class: JavaClass<IntComparator>;
                /** @deprecated */ static prototype: undefined;
            }
            interface IntComparator extends java.util.Comparator<java.lang.Integer> {

                compare(arg0: int, arg1: int): number;
                reversed(): IntComparator;
                /** @deprecated */
                compare(arg0: int, arg1: int): number;
                thenComparing(arg0: IntComparator): IntComparator;
                thenComparing(arg0: MethodWrapper<int, int, int>): MethodWrapper<number, number, int>;
                thenComparing<U>(arg0: MethodWrapper<T, any, U>, arg1: MethodWrapper<U, U, int>): MethodWrapper<T, T, int>;
                thenComparing<U extends java.lang.Comparable<U>>(arg0: MethodWrapper<T, any, U>): MethodWrapper<T, T, int>;

            }

            abstract class IntConsumer extends java.lang.Interface {
                static readonly class: JavaClass<IntConsumer>;
                /** @deprecated */ static prototype: undefined;
            }
            interface IntConsumer extends java.util.function.Consumer<java.lang.Integer>, java.util.function.IntConsumer {

                /** @deprecated */
                accept(arg0: int): void;
                accept(arg0: int): void;
                andThen(arg0: java.util.function.IntConsumer): IntConsumer;
                andThen(arg0: IntConsumer): IntConsumer;
                /** @deprecated */
                andThen(arg0: MethodWrapper<int>): MethodWrapper<number>;

            }

            abstract class IntBidirectionalIterator extends java.lang.Interface {
                static readonly class: JavaClass<IntBidirectionalIterator>;
                /** @deprecated */ static prototype: undefined;
            }
            interface IntBidirectionalIterator extends IntIterator, it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator<java.lang.Integer> {

                previousInt(): number;
                /** @deprecated */
                previous(): number;
                back(arg0: int): number;
                skip(arg0: int): number;

            }

            abstract class IntIterator extends java.lang.Interface {
                static readonly class: JavaClass<IntIterator>;
                /** @deprecated */ static prototype: undefined;
            }
            interface IntIterator extends java.util.PrimitiveIterator$OfInt {

                nextInt(): number;
                /** @deprecated */
                next(): number;
                forEachRemaining(arg0: IntConsumer): void;
                /** @deprecated */
                forEachRemaining(arg0: MethodWrapper<int>): void;
                forEachRemaining(arg0: java.util.function.IntConsumer): void;
                skip(arg0: int): number;

            }

            abstract class IntPredicate extends java.lang.Interface {
                static readonly class: JavaClass<IntPredicate>;
                /** @deprecated */ static prototype: undefined;
            }
            interface IntPredicate extends java.util.function.Predicate<java.lang.Integer>, java.util.function.IntPredicate {

                /** @deprecated */
                test(arg0: int): boolean;
                test(arg0: int): boolean;
                and(arg0: java.util.function.IntPredicate): IntPredicate;
                and(arg0: IntPredicate): IntPredicate;
                /** @deprecated */
                and(arg0: MethodWrapper<int, any, boolean>): MethodWrapper<number, any, boolean>;
                negate(): IntPredicate;
                or(arg0: java.util.function.IntPredicate): IntPredicate;
                or(arg0: IntPredicate): IntPredicate;
                /** @deprecated */
                or(arg0: MethodWrapper<int, any, boolean>): MethodWrapper<number, any, boolean>;

            }

            export {
                IntList,
                IntListIterator,
                IntUnaryOperator,
                IntCollection,
                IntIterable,
                IntSpliterator,
                IntComparator,
                IntConsumer,
                IntBidirectionalIterator,
                IntIterator,
                IntPredicate
            }

        }

        namespace objects {

            abstract class ObjectIterator<K> extends java.lang.Interface {
                static readonly class: JavaClass<ObjectIterator<any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface ObjectIterator<K> extends java.util.Iterator<K> {

                skip(arg0: int): number;

            }

            abstract class ObjectBidirectionalIterator<K> extends java.lang.Interface {
                static readonly class: JavaClass<ObjectBidirectionalIterator<any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface ObjectBidirectionalIterator<K> extends ObjectIterator<K>, it.unimi.dsi.fastutil.BidirectionalIterator<K> {

                back(arg0: int): number;
                skip(arg0: int): number;

            }

            export { ObjectIterator, ObjectBidirectionalIterator }

        }

    }

    namespace java {

        namespace awt {

            abstract class Image extends java.lang.Object {
                static readonly class: JavaClass<Image>;
                /** @deprecated */ static prototype: undefined;

                static readonly UndefinedProperty: any;
                static readonly SCALE_DEFAULT: number;
                static readonly SCALE_FAST: number;
                static readonly SCALE_SMOOTH: number;
                static readonly SCALE_REPLICATE: number;
                static readonly SCALE_AREA_AVERAGING: number;

                getWidth(arg0: java.awt.image.ImageObserver): number;
                getHeight(arg0: java.awt.image.ImageObserver): number;
                getSource(): java.awt.image.ImageProducer;
                getGraphics(): Graphics;
                getProperty(arg0: string, arg1: java.awt.image.ImageObserver): any;
                getScaledInstance(arg0: int, arg1: int, arg2: int): Image;
                flush(): void;
                getCapabilities(arg0: GraphicsConfiguration): ImageCapabilities;
                setAccelerationPriority(arg0: float): void;
                getAccelerationPriority(): number;

            }

            interface Rectangle extends java.io.Serializable, Shape {}
            class Rectangle extends java.awt.geom.Rectangle2D {
                static readonly class: JavaClass<Rectangle>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Rectangle);
                constructor (arg0: int, arg1: int, arg2: int, arg3: int);
                constructor (arg0: int, arg1: int);
                constructor (arg0: Point, arg1: Dimension);
                constructor (arg0: Point);
                constructor (arg0: Dimension);

                x: number;
                y: number;
                width: number;
                height: number;

                getX(): number;
                getY(): number;
                getWidth(): number;
                getHeight(): number;
                getBounds(): Rectangle;
                getBounds2D(): java.awt.geom.Rectangle2D;
                setBounds(arg0: Rectangle): void;
                setBounds(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setRect(arg0: double, arg1: double, arg2: double, arg3: double): void;
                setRect(arg0: java.awt.geom.Rectangle2D): void;
                /** @deprecated */
                reshape(arg0: int, arg1: int, arg2: int, arg3: int): void;
                getLocation(): Point;
                setLocation(arg0: Point): void;
                setLocation(arg0: int, arg1: int): void;
                /** @deprecated */
                move(arg0: int, arg1: int): void;
                translate(arg0: int, arg1: int): void;
                getSize(): Dimension;
                setSize(arg0: Dimension): void;
                setSize(arg0: int, arg1: int): void;
                /** @deprecated */
                resize(arg0: int, arg1: int): void;
                contains(arg0: Point): boolean;
                contains(arg0: int, arg1: int): boolean;
                contains(arg0: Rectangle): boolean;
                contains(arg0: int, arg1: int, arg2: int, arg3: int): boolean;
                contains(arg0: double, arg1: double): boolean;
                contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                contains(arg0: java.awt.geom.Point2D): boolean;
                contains(arg0: java.awt.geom.Rectangle2D): boolean;
                /** @deprecated */
                inside(arg0: int, arg1: int): boolean;
                intersects(arg0: Rectangle): boolean;
                intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                intersects(arg0: java.awt.geom.Rectangle2D): boolean;
                intersection(arg0: Rectangle): Rectangle;
                union(arg0: Rectangle): Rectangle;
                add(arg0: int, arg1: int): void;
                add(arg0: Point): void;
                add(arg0: Rectangle): void;
                add(arg0: double, arg1: double): void;
                add(arg0: java.awt.geom.Point2D): void;
                add(arg0: java.awt.geom.Rectangle2D): void;
                grow(arg0: int, arg1: int): void;
                isEmpty(): boolean;
                outcode(arg0: double, arg1: double): number;
                outcode(arg0: java.awt.geom.Point2D): number;
                createIntersection(arg0: java.awt.geom.Rectangle2D): java.awt.geom.Rectangle2D;
                createUnion(arg0: java.awt.geom.Rectangle2D): java.awt.geom.Rectangle2D;

            }

            abstract class Shape extends java.lang.Interface {
                static readonly class: JavaClass<Shape>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Shape {

                getBounds(): Rectangle;
                getBounds2D(): java.awt.geom.Rectangle2D;
                contains(arg0: double, arg1: double): boolean;
                contains(arg0: java.awt.geom.Point2D): boolean;
                intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                intersects(arg0: java.awt.geom.Rectangle2D): boolean;
                contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                contains(arg0: java.awt.geom.Rectangle2D): boolean;
                getPathIterator(arg0: java.awt.geom.AffineTransform): java.awt.geom.PathIterator;
                getPathIterator(arg0: java.awt.geom.AffineTransform, arg1: double): java.awt.geom.PathIterator;

            }

            abstract class GraphicsConfiguration extends java.lang.Object {
                static readonly class: JavaClass<GraphicsConfiguration>;
                /** @deprecated */ static prototype: undefined;

                getDevice(): GraphicsDevice;
                createCompatibleImage(arg0: int, arg1: int): java.awt.image.BufferedImage;
                createCompatibleImage(arg0: int, arg1: int, arg2: int): java.awt.image.BufferedImage;
                createCompatibleVolatileImage(arg0: int, arg1: int): java.awt.image.VolatileImage;
                createCompatibleVolatileImage(arg0: int, arg1: int, arg2: int): java.awt.image.VolatileImage;
                createCompatibleVolatileImage(arg0: int, arg1: int, arg2: ImageCapabilities): java.awt.image.VolatileImage;
                createCompatibleVolatileImage(arg0: int, arg1: int, arg2: ImageCapabilities, arg3: int): java.awt.image.VolatileImage;
                getColorModel(): java.awt.image.ColorModel;
                getColorModel(arg0: int): java.awt.image.ColorModel;
                getDefaultTransform(): java.awt.geom.AffineTransform;
                getNormalizingTransform(): java.awt.geom.AffineTransform;
                getBounds(): Rectangle;
                getBufferCapabilities(): BufferCapabilities;
                getImageCapabilities(): ImageCapabilities;
                isTranslucencyCapable(): boolean;

            }

            interface ImageCapabilities extends java.lang.Cloneable {}
            class ImageCapabilities extends java.lang.Object {
                static readonly class: JavaClass<ImageCapabilities>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: boolean);

                isAccelerated(): boolean;
                isTrueVolatile(): boolean;
                clone(): any;

            }

            interface Dimension extends java.io.Serializable {}
            class Dimension extends java.awt.geom.Dimension2D {
                static readonly class: JavaClass<Dimension>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Dimension);
                constructor (arg0: int, arg1: int);

                width: number;
                height: number;

                getWidth(): number;
                getHeight(): number;
                setSize(arg0: double, arg1: double): void;
                setSize(arg0: java.awt.geom.Dimension2D): void;
                getSize(): Dimension;
                setSize(arg0: Dimension): void;
                setSize(arg0: int, arg1: int): void;

            }

            abstract class Transparency extends java.lang.Interface {
                static readonly class: JavaClass<Transparency>;
                /** @deprecated */ static prototype: undefined;

                static readonly OPAQUE: number;
                static readonly BITMASK: number;
                static readonly TRANSLUCENT: number;
            }
            interface Transparency {

                getTransparency(): number;

            }

            interface Point extends java.io.Serializable {}
            class Point extends java.awt.geom.Point2D {
                static readonly class: JavaClass<Point>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Point);
                constructor (arg0: int, arg1: int);

                x: number;
                y: number;

                getX(): number;
                getY(): number;
                getLocation(): Point;
                setLocation(arg0: Point): void;
                setLocation(arg0: int, arg1: int): void;
                setLocation(arg0: double, arg1: double): void;
                setLocation(arg0: java.awt.geom.Point2D): void;
                move(arg0: int, arg1: int): void;
                translate(arg0: int, arg1: int): void;

            }

            abstract class Graphics extends java.lang.Object {
                static readonly class: JavaClass<Graphics>;
                /** @deprecated */ static prototype: undefined;

                create(): Graphics;
                create(arg0: int, arg1: int, arg2: int, arg3: int): Graphics;
                translate(arg0: int, arg1: int): void;
                getColor(): Color;
                setColor(arg0: Color): void;
                setPaintMode(): void;
                setXORMode(arg0: Color): void;
                getFont(): Font;
                setFont(arg0: Font): void;
                getFontMetrics(): FontMetrics;
                getFontMetrics(arg0: Font): FontMetrics;
                getClipBounds(): Rectangle;
                clipRect(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setClip(arg0: int, arg1: int, arg2: int, arg3: int): void;
                getClip(): Shape;
                setClip(arg0: Shape): void;
                copyArea(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                drawLine(arg0: int, arg1: int, arg2: int, arg3: int): void;
                fillRect(arg0: int, arg1: int, arg2: int, arg3: int): void;
                drawRect(arg0: int, arg1: int, arg2: int, arg3: int): void;
                clearRect(arg0: int, arg1: int, arg2: int, arg3: int): void;
                drawRoundRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                fillRoundRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                draw3DRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void;
                fill3DRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void;
                drawOval(arg0: int, arg1: int, arg2: int, arg3: int): void;
                fillOval(arg0: int, arg1: int, arg2: int, arg3: int): void;
                drawArc(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                fillArc(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                drawPolyline(arg0: int[], arg1: int[], arg2: int): void;
                drawPolygon(arg0: int[], arg1: int[], arg2: int): void;
                drawPolygon(arg0: Polygon): void;
                fillPolygon(arg0: int[], arg1: int[], arg2: int): void;
                fillPolygon(arg0: Polygon): void;
                drawString(arg0: string, arg1: int, arg2: int): void;
                drawString(arg0: java.text.AttributedCharacterIterator, arg1: int, arg2: int): void;
                drawChars(arg0: char[], arg1: int, arg2: int, arg3: int, arg4: int): void;
                drawBytes(arg0: byte[], arg1: int, arg2: int, arg3: int, arg4: int): void;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: Color, arg4: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: Color, arg6: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: Color, arg10: java.awt.image.ImageObserver): boolean;
                dispose(): void;
                /** @deprecated */
                finalize(): void;
                /** @deprecated */
                getClipRect(): Rectangle;
                hitClip(arg0: int, arg1: int, arg2: int, arg3: int): boolean;
                getClipBounds(arg0: Rectangle): Rectangle;

            }

            abstract class Graphics2D extends Graphics {
                static readonly class: JavaClass<Graphics2D>;
                /** @deprecated */ static prototype: undefined;

                draw3DRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void;
                fill3DRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void;
                draw(arg0: Shape): void;
                drawImage(arg0: Image, arg1: java.awt.geom.AffineTransform, arg2: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: java.awt.image.BufferedImage, arg1: java.awt.image.BufferedImageOp, arg2: int, arg3: int): void;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: Color, arg4: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: Color, arg6: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: Color, arg10: java.awt.image.ImageObserver): boolean;
                drawRenderedImage(arg0: java.awt.image.RenderedImage, arg1: java.awt.geom.AffineTransform): void;
                drawRenderableImage(arg0: java.awt.image.renderable.RenderableImage, arg1: java.awt.geom.AffineTransform): void;
                drawString(arg0: string, arg1: int, arg2: int): void;
                drawString(arg0: string, arg1: float, arg2: float): void;
                drawString(arg0: java.text.AttributedCharacterIterator, arg1: int, arg2: int): void;
                drawString(arg0: java.text.AttributedCharacterIterator, arg1: float, arg2: float): void;
                drawGlyphVector(arg0: java.awt.font.GlyphVector, arg1: float, arg2: float): void;
                fill(arg0: Shape): void;
                hit(arg0: Rectangle, arg1: Shape, arg2: boolean): boolean;
                getDeviceConfiguration(): GraphicsConfiguration;
                setComposite(arg0: Composite): void;
                setPaint(arg0: Paint): void;
                setStroke(arg0: Stroke): void;
                setRenderingHint(arg0: RenderingHints$Key, arg1: any): void;
                getRenderingHint(arg0: RenderingHints$Key): any;
                setRenderingHints(arg0: JavaMap<any, any>): void;
                addRenderingHints(arg0: JavaMap<any, any>): void;
                getRenderingHints(): RenderingHints;
                translate(arg0: int, arg1: int): void;
                translate(arg0: double, arg1: double): void;
                rotate(arg0: double): void;
                rotate(arg0: double, arg1: double, arg2: double): void;
                scale(arg0: double, arg1: double): void;
                shear(arg0: double, arg1: double): void;
                transform(arg0: java.awt.geom.AffineTransform): void;
                setTransform(arg0: java.awt.geom.AffineTransform): void;
                getTransform(): java.awt.geom.AffineTransform;
                getPaint(): Paint;
                getComposite(): Composite;
                setBackground(arg0: Color): void;
                getBackground(): Color;
                getStroke(): Stroke;
                clip(arg0: Shape): void;
                getFontRenderContext(): java.awt.font.FontRenderContext;

            }

            interface Color extends Paint, java.io.Serializable {}
            class Color extends java.lang.Object {
                static readonly class: JavaClass<Color>;
                /** @deprecated */ static prototype: undefined;

                static readonly white: Color;
                static readonly WHITE: Color;
                static readonly lightGray: Color;
                static readonly LIGHT_GRAY: Color;
                static readonly gray: Color;
                static readonly GRAY: Color;
                static readonly darkGray: Color;
                static readonly DARK_GRAY: Color;
                static readonly black: Color;
                static readonly BLACK: Color;
                static readonly red: Color;
                static readonly RED: Color;
                static readonly pink: Color;
                static readonly PINK: Color;
                static readonly orange: Color;
                static readonly ORANGE: Color;
                static readonly yellow: Color;
                static readonly YELLOW: Color;
                static readonly green: Color;
                static readonly GREEN: Color;
                static readonly magenta: Color;
                static readonly MAGENTA: Color;
                static readonly cyan: Color;
                static readonly CYAN: Color;
                static readonly blue: Color;
                static readonly BLUE: Color;

                static decode(arg0: string): Color;
                static getColor(arg0: string): Color;
                static getColor(arg0: string, arg1: Color): Color;
                static getColor(arg0: string, arg1: int): Color;
                static HSBtoRGB(arg0: float, arg1: float, arg2: float): number;
                static RGBtoHSB(arg0: int, arg1: int, arg2: int, arg3: float[]): JavaArray<number>;
                static getHSBColor(arg0: float, arg1: float, arg2: float): Color;

                constructor (arg0: int, arg1: int, arg2: int);
                constructor (arg0: int, arg1: int, arg2: int, arg3: int);
                constructor (arg0: int);
                constructor (arg0: int, arg1: boolean);
                constructor (arg0: float, arg1: float, arg2: float);
                constructor (arg0: float, arg1: float, arg2: float, arg3: float);
                constructor (arg0: java.awt.color.ColorSpace, arg1: float[], arg2: float);

                getRed(): number;
                getGreen(): number;
                getBlue(): number;
                getAlpha(): number;
                getRGB(): number;
                brighter(): Color;
                darker(): Color;
                getRGBComponents(arg0: float[]): JavaArray<number>;
                getRGBColorComponents(arg0: float[]): JavaArray<number>;
                getComponents(arg0: float[]): JavaArray<number>;
                getColorComponents(arg0: float[]): JavaArray<number>;
                getComponents(arg0: java.awt.color.ColorSpace, arg1: float[]): JavaArray<number>;
                getColorComponents(arg0: java.awt.color.ColorSpace, arg1: float[]): JavaArray<number>;
                getColorSpace(): java.awt.color.ColorSpace;
                createContext(arg0: java.awt.image.ColorModel, arg1: Rectangle, arg2: java.awt.geom.Rectangle2D, arg3: java.awt.geom.AffineTransform, arg4: RenderingHints): PaintContext;
                getTransparency(): number;

            }

            abstract class Paint extends java.lang.Interface {
                static readonly class: JavaClass<Paint>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Paint extends Transparency {

                createContext(arg0: java.awt.image.ColorModel, arg1: Rectangle, arg2: java.awt.geom.Rectangle2D, arg3: java.awt.geom.AffineTransform, arg4: RenderingHints): PaintContext;

            }

            interface BufferCapabilities extends java.lang.Cloneable {}
            class BufferCapabilities extends java.lang.Object {
                static readonly class: JavaClass<BufferCapabilities>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: ImageCapabilities, arg1: ImageCapabilities, arg2: BufferCapabilities$FlipContents);

                getFrontBufferCapabilities(): ImageCapabilities;
                getBackBufferCapabilities(): ImageCapabilities;
                isPageFlipping(): boolean;
                getFlipContents(): BufferCapabilities$FlipContents;
                isFullScreenRequired(): boolean;
                isMultiBufferAvailable(): boolean;
                clone(): any;

            }

            abstract class GraphicsDevice extends java.lang.Object {
                static readonly class: JavaClass<GraphicsDevice>;
                /** @deprecated */ static prototype: undefined;

                static readonly TYPE_RASTER_SCREEN: number;
                static readonly TYPE_PRINTER: number;
                static readonly TYPE_IMAGE_BUFFER: number;

                getType(): number;
                getIDstring(): string;
                getConfigurations(): JavaArray<GraphicsConfiguration>;
                getDefaultConfiguration(): GraphicsConfiguration;
                getBestConfiguration(arg0: GraphicsConfigTemplate): GraphicsConfiguration;
                isFullScreenSupported(): boolean;
                setFullScreenWindow(arg0: Window): void;
                getFullScreenWindow(): Window;
                isDisplayChangeSupported(): boolean;
                setDisplayMode(arg0: DisplayMode): void;
                getDisplayMode(): DisplayMode;
                getDisplayModes(): JavaArray<DisplayMode>;
                getAvailableAcceleratedMemory(): number;
                isWindowTranslucencySupported(arg0: GraphicsDevice$WindowTranslucency): boolean;

            }

            interface Font extends java.io.Serializable {}
            class Font extends java.lang.Object {
                static readonly class: JavaClass<Font>;
                /** @deprecated */ static prototype: undefined;

                static readonly DIALOG: string;
                static readonly DIALOG_INPUT: string;
                static readonly SANS_SERIF: string;
                static readonly SERIF: string;
                static readonly MONOSPACED: string;
                static readonly PLAIN: number;
                static readonly BOLD: number;
                static readonly ITALIC: number;
                static readonly ROMAN_BASELINE: number;
                static readonly CENTER_BASELINE: number;
                static readonly HANGING_BASELINE: number;
                static readonly TRUETYPE_FONT: number;
                static readonly TYPE1_FONT: number;
                static readonly LAYOUT_LEFT_TO_RIGHT: number;
                static readonly LAYOUT_RIGHT_TO_LEFT: number;
                static readonly LAYOUT_NO_START_CONTEXT: number;
                static readonly LAYOUT_NO_LIMIT_CONTEXT: number;

                static textRequiresLayout(arg0: char[], arg1: int, arg2: int): boolean;
                static getFont(arg0: JavaMap<java.text.AttributedCharacterIterator$Attribute, any>): Font;
                static createFonts(arg0: java.io.InputStream): JavaArray<Font>;
                static createFonts(arg0: java.io.File): JavaArray<Font>;
                static createFont(arg0: int, arg1: java.io.InputStream): Font;
                static createFont(arg0: int, arg1: java.io.File): Font;
                static getFont(arg0: string): Font;
                static decode(arg0: string): Font;
                static getFont(arg0: string, arg1: Font): Font;

                constructor (arg0: string, arg1: int, arg2: int);
                constructor (arg0: JavaMap<java.text.AttributedCharacterIterator$Attribute, any>);

                getTransform(): java.awt.geom.AffineTransform;
                getFamily(): string;
                getFamily(arg0: java.util.Locale): string;
                getPSName(): string;
                getName(): string;
                getFontName(): string;
                getFontName(arg0: java.util.Locale): string;
                getStyle(): number;
                getSize(): number;
                getSize2D(): number;
                isPlain(): boolean;
                isBold(): boolean;
                isItalic(): boolean;
                isTransformed(): boolean;
                hasLayoutAttributes(): boolean;
                getNumGlyphs(): number;
                getMissingGlyphCode(): number;
                getBaselineFor(arg0: char): number;
                getAttributes(): JavaMap<java.awt.font.TextAttribute, any>;
                getAvailableAttributes(): JavaArray<java.text.AttributedCharacterIterator$Attribute>;
                deriveFont(arg0: int, arg1: float): Font;
                deriveFont(arg0: int, arg1: java.awt.geom.AffineTransform): Font;
                deriveFont(arg0: float): Font;
                deriveFont(arg0: java.awt.geom.AffineTransform): Font;
                deriveFont(arg0: int): Font;
                deriveFont(arg0: JavaMap<java.text.AttributedCharacterIterator$Attribute, any>): Font;
                canDisplay(arg0: char): boolean;
                canDisplay(arg0: int): boolean;
                canDisplayUpTo(arg0: string): number;
                canDisplayUpTo(arg0: char[], arg1: int, arg2: int): number;
                canDisplayUpTo(arg0: java.text.CharacterIterator, arg1: int, arg2: int): number;
                getItalicAngle(): number;
                hasUniformLineMetrics(): boolean;
                getLineMetrics(arg0: string, arg1: java.awt.font.FontRenderContext): java.awt.font.LineMetrics;
                getLineMetrics(arg0: string, arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.font.LineMetrics;
                getLineMetrics(arg0: char[], arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.font.LineMetrics;
                getLineMetrics(arg0: java.text.CharacterIterator, arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.font.LineMetrics;
                getStringBounds(arg0: string, arg1: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: string, arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: char[], arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: java.text.CharacterIterator, arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                getMaxCharBounds(arg0: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                createGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: string): java.awt.font.GlyphVector;
                createGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: char[]): java.awt.font.GlyphVector;
                createGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: java.text.CharacterIterator): java.awt.font.GlyphVector;
                createGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: int[]): java.awt.font.GlyphVector;
                layoutGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: char[], arg2: int, arg3: int, arg4: int): java.awt.font.GlyphVector;

            }

            interface RenderingHints extends JavaMap<java.lang.Object, java.lang.Object>, java.lang.Cloneable {}
            class RenderingHints extends java.lang.Object {
                static readonly class: JavaClass<RenderingHints>;
                /** @deprecated */ static prototype: undefined;

                static readonly KEY_ANTIALIASING: RenderingHints$Key;
                static readonly VALUE_ANTIALIAS_ON: any;
                static readonly VALUE_ANTIALIAS_OFF: any;
                static readonly VALUE_ANTIALIAS_DEFAULT: any;
                static readonly KEY_RENDERING: RenderingHints$Key;
                static readonly VALUE_RENDER_SPEED: any;
                static readonly VALUE_RENDER_QUALITY: any;
                static readonly VALUE_RENDER_DEFAULT: any;
                static readonly KEY_DITHERING: RenderingHints$Key;
                static readonly VALUE_DITHER_DISABLE: any;
                static readonly VALUE_DITHER_ENABLE: any;
                static readonly VALUE_DITHER_DEFAULT: any;
                static readonly KEY_TEXT_ANTIALIASING: RenderingHints$Key;
                static readonly VALUE_TEXT_ANTIALIAS_ON: any;
                static readonly VALUE_TEXT_ANTIALIAS_OFF: any;
                static readonly VALUE_TEXT_ANTIALIAS_DEFAULT: any;
                static readonly VALUE_TEXT_ANTIALIAS_GASP: any;
                static readonly VALUE_TEXT_ANTIALIAS_LCD_HRGB: any;
                static readonly VALUE_TEXT_ANTIALIAS_LCD_HBGR: any;
                static readonly VALUE_TEXT_ANTIALIAS_LCD_VRGB: any;
                static readonly VALUE_TEXT_ANTIALIAS_LCD_VBGR: any;
                static readonly KEY_TEXT_LCD_CONTRAST: RenderingHints$Key;
                static readonly KEY_FRACTIONALMETRICS: RenderingHints$Key;
                static readonly VALUE_FRACTIONALMETRICS_OFF: any;
                static readonly VALUE_FRACTIONALMETRICS_ON: any;
                static readonly VALUE_FRACTIONALMETRICS_DEFAULT: any;
                static readonly KEY_INTERPOLATION: RenderingHints$Key;
                static readonly VALUE_INTERPOLATION_NEAREST_NEIGHBOR: any;
                static readonly VALUE_INTERPOLATION_BILINEAR: any;
                static readonly VALUE_INTERPOLATION_BICUBIC: any;
                static readonly KEY_ALPHA_INTERPOLATION: RenderingHints$Key;
                static readonly VALUE_ALPHA_INTERPOLATION_SPEED: any;
                static readonly VALUE_ALPHA_INTERPOLATION_QUALITY: any;
                static readonly VALUE_ALPHA_INTERPOLATION_DEFAULT: any;
                static readonly KEY_COLOR_RENDERING: RenderingHints$Key;
                static readonly VALUE_COLOR_RENDER_SPEED: any;
                static readonly VALUE_COLOR_RENDER_QUALITY: any;
                static readonly VALUE_COLOR_RENDER_DEFAULT: any;
                static readonly KEY_STROKE_CONTROL: RenderingHints$Key;
                static readonly VALUE_STROKE_DEFAULT: any;
                static readonly VALUE_STROKE_NORMALIZE: any;
                static readonly VALUE_STROKE_PURE: any;
                static readonly KEY_RESOLUTION_VARIANT: RenderingHints$Key;
                static readonly VALUE_RESOLUTION_VARIANT_DEFAULT: any;
                static readonly VALUE_RESOLUTION_VARIANT_BASE: any;
                static readonly VALUE_RESOLUTION_VARIANT_SIZE_FIT: any;
                static readonly VALUE_RESOLUTION_VARIANT_DPI_FIT: any;

                constructor (arg0: JavaMap<RenderingHints$Key, any>);
                constructor (arg0: RenderingHints$Key, arg1: any);

                size(): number;
                isEmpty(): boolean;
                containsKey(arg0: any): boolean;
                containsValue(arg0: any): boolean;
                get(arg0: any): any;
                put(arg0: any, arg1: any): any;
                add(arg0: RenderingHints): void;
                clear(): void;
                remove(arg0: any): any;
                remove(arg0: any, arg1: any): boolean;
                putAll(arg0: JavaMap<any, any>): void;
                keySet(): JavaSet<any>;
                values(): JavaCollection<any>;
                entrySet(): JavaSet<java.util.Map$Entry<any, any>>;
                clone(): any;

            }

            interface FontMetrics extends java.io.Serializable {}
            abstract class FontMetrics extends java.lang.Object {
                static readonly class: JavaClass<FontMetrics>;
                /** @deprecated */ static prototype: undefined;

                getFont(): Font;
                getFontRenderContext(): java.awt.font.FontRenderContext;
                getLeading(): number;
                getAscent(): number;
                getDescent(): number;
                getHeight(): number;
                getMaxAscent(): number;
                getMaxDescent(): number;
                /** @deprecated */
                getMaxDecent(): number;
                getMaxAdvance(): number;
                charWidth(arg0: int): number;
                charWidth(arg0: char): number;
                stringWidth(arg0: string): number;
                charsWidth(arg0: char[], arg1: int, arg2: int): number;
                bytesWidth(arg0: byte[], arg1: int, arg2: int): number;
                getWidths(): JavaArray<number>;
                hasUniformLineMetrics(): boolean;
                getLineMetrics(arg0: string, arg1: Graphics): java.awt.font.LineMetrics;
                getLineMetrics(arg0: string, arg1: int, arg2: int, arg3: Graphics): java.awt.font.LineMetrics;
                getLineMetrics(arg0: char[], arg1: int, arg2: int, arg3: Graphics): java.awt.font.LineMetrics;
                getLineMetrics(arg0: java.text.CharacterIterator, arg1: int, arg2: int, arg3: Graphics): java.awt.font.LineMetrics;
                getStringBounds(arg0: string, arg1: Graphics): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: string, arg1: int, arg2: int, arg3: Graphics): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: char[], arg1: int, arg2: int, arg3: Graphics): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: java.text.CharacterIterator, arg1: int, arg2: int, arg3: Graphics): java.awt.geom.Rectangle2D;
                getMaxCharBounds(arg0: Graphics): java.awt.geom.Rectangle2D;

            }

            abstract class Composite extends java.lang.Interface {
                static readonly class: JavaClass<Composite>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Composite {

                createContext(arg0: java.awt.image.ColorModel, arg1: java.awt.image.ColorModel, arg2: RenderingHints): CompositeContext;

            }

            abstract class Stroke extends java.lang.Interface {
                static readonly class: JavaClass<Stroke>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Stroke {

                createStrokedShape(arg0: Shape): Shape;

            }

            interface Polygon extends java.io.Serializable, Shape {}
            class Polygon extends java.lang.Object {
                static readonly class: JavaClass<Polygon>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: int[], arg1: int[], arg2: int);

                npoints: number;
                xpoints: JavaArray<number>;
                ypoints: JavaArray<number>;

                reset(): void;
                invalidate(): void;
                translate(arg0: int, arg1: int): void;
                addPoint(arg0: int, arg1: int): void;
                getBounds(): Rectangle;
                /** @deprecated */
                getBoundingBox(): Rectangle;
                contains(arg0: Point): boolean;
                contains(arg0: int, arg1: int): boolean;
                /** @deprecated */
                inside(arg0: int, arg1: int): boolean;
                getBounds2D(): java.awt.geom.Rectangle2D;
                contains(arg0: double, arg1: double): boolean;
                contains(arg0: java.awt.geom.Point2D): boolean;
                intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                intersects(arg0: java.awt.geom.Rectangle2D): boolean;
                contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                contains(arg0: java.awt.geom.Rectangle2D): boolean;
                getPathIterator(arg0: java.awt.geom.AffineTransform): java.awt.geom.PathIterator;
                getPathIterator(arg0: java.awt.geom.AffineTransform, arg1: double): java.awt.geom.PathIterator;

            }

            abstract class RenderingHints$Key extends java.lang.Object {
                static readonly class: JavaClass<RenderingHints$Key>;
                /** @deprecated */ static prototype: undefined;

                isCompatibleValue(arg0: any): boolean;

            }

            interface GraphicsConfigTemplate extends java.io.Serializable {}
            class GraphicsConfigTemplate extends java.lang.Object {
                static readonly class: JavaClass<GraphicsConfigTemplate>;
                /** @deprecated */ static prototype: undefined;

                static readonly REQUIRED: number;
                static readonly PREFERRED: number;
                static readonly UNNECESSARY: number;

                constructor ();

                getBestConfiguration(arg0: GraphicsConfiguration[]): GraphicsConfiguration;
                isGraphicsConfigSupported(arg0: GraphicsConfiguration): boolean;

            }

            interface Window extends javax.accessibility.Accessible {}
            class Window extends Container {
                static readonly class: JavaClass<Window>;
                /** @deprecated */ static prototype: undefined;

                static getWindows(): JavaArray<Window>;
                static getOwnerlessWindows(): JavaArray<Window>;

                constructor (arg0: Frame);
                constructor (arg0: Window);
                constructor (arg0: Window, arg1: GraphicsConfiguration);

                getIconImages(): JavaList<Image>;
                setIconImages(arg0: JavaList<Image>): void;
                setIconImage(arg0: Image): void;
                addNotify(): void;
                removeNotify(): void;
                pack(): void;
                setMinimumSize(arg0: Dimension): void;
                setSize(arg0: Dimension): void;
                setSize(arg0: int, arg1: int): void;
                setLocation(arg0: int, arg1: int): void;
                setLocation(arg0: Point): void;
                /** @deprecated */
                reshape(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setVisible(arg0: boolean): void;
                /** @deprecated */
                show(): void;
                /** @deprecated */
                show(arg0: boolean): void;
                /** @deprecated */
                hide(): void;
                dispose(): void;
                toFront(): void;
                toBack(): void;
                getToolkit(): Toolkit;
                getWarningString(): string;
                getLocale(): java.util.Locale;
                getInputContext(): java.awt.im.InputContext;
                setCursor(arg0: Cursor): void;
                getOwner(): Window;
                getOwnedWindows(): JavaArray<Window>;
                setModalExclusionType(arg0: Dialog$ModalExclusionType): void;
                getModalExclusionType(): Dialog$ModalExclusionType;
                addWindowListener(arg0: java.awt.event.WindowListener): void;
                addWindowStateListener(arg0: java.awt.event.WindowStateListener): void;
                addWindowFocusListener(arg0: java.awt.event.WindowFocusListener): void;
                removeWindowListener(arg0: java.awt.event.WindowListener): void;
                removeWindowStateListener(arg0: java.awt.event.WindowStateListener): void;
                removeWindowFocusListener(arg0: java.awt.event.WindowFocusListener): void;
                getWindowListeners(): JavaArray<java.awt.event.WindowListener>;
                getWindowFocusListeners(): JavaArray<java.awt.event.WindowFocusListener>;
                getWindowStateListeners(): JavaArray<java.awt.event.WindowStateListener>;
                getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;
                setAlwaysOnTop(arg0: boolean): void;
                isAlwaysOnTopSupported(): boolean;
                isAlwaysOnTop(): boolean;
                getFocusOwner(): Component;
                getMostRecentFocusOwner(): Component;
                isActive(): boolean;
                isFocused(): boolean;
                getFocusTraversalKeys(arg0: int): JavaSet<AWTKeyStroke>;
                setFocusCycleRoot(arg0: boolean): void;
                isFocusCycleRoot(): boolean;
                isFocusCycleRoot(arg0: Container): boolean;
                getFocusCycleRootAncestor(): Container;
                isFocusableWindow(): boolean;
                getFocusableWindowState(): boolean;
                setFocusableWindowState(arg0: boolean): void;
                setAutoRequestFocus(arg0: boolean): void;
                isAutoRequestFocus(): boolean;
                addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                addPropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                isValidateRoot(): boolean;
                /** @deprecated */
                postEvent(arg0: Event): boolean;
                isShowing(): boolean;
                /** @deprecated */
                applyResourceBundle(arg0: java.util.ResourceBundle): void;
                /** @deprecated */
                applyResourceBundle(arg0: string): void;
                setType(arg0: Window$Type): void;
                getType(): Window$Type;
                getAccessibleContext(): javax.accessibility.AccessibleContext;
                setLocationRelativeTo(arg0: Component): void;
                createBufferStrategy(arg0: int): void;
                createBufferStrategy(arg0: int, arg1: BufferCapabilities): void;
                getBufferStrategy(): java.awt.image.BufferStrategy;
                setLocationByPlatform(arg0: boolean): void;
                isLocationByPlatform(): boolean;
                setBounds(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setBounds(arg0: Rectangle): void;
                getOpacity(): number;
                setOpacity(arg0: float): void;
                getShape(): Shape;
                setShape(arg0: Shape): void;
                getBackground(): Color;
                setBackground(arg0: Color): void;
                isOpaque(): boolean;
                paint(arg0: Graphics): void;

            }

            abstract class GraphicsDevice$WindowTranslucency extends java.lang.Enum<GraphicsDevice$WindowTranslucency> {
                static readonly class: JavaClass<GraphicsDevice$WindowTranslucency>;
                /** @deprecated */ static prototype: undefined;

                static readonly PERPIXEL_TRANSPARENT: GraphicsDevice$WindowTranslucency;
                static readonly TRANSLUCENT: GraphicsDevice$WindowTranslucency;
                static readonly PERPIXEL_TRANSLUCENT: GraphicsDevice$WindowTranslucency;

                static values(): JavaArray<GraphicsDevice$WindowTranslucency>;
                static valueOf(arg0: string): GraphicsDevice$WindowTranslucency;

            }

            abstract class CompositeContext extends java.lang.Interface {
                static readonly class: JavaClass<CompositeContext>;
                /** @deprecated */ static prototype: undefined;
            }
            interface CompositeContext {

                dispose(): void;
                compose(arg0: java.awt.image.Raster, arg1: java.awt.image.Raster, arg2: java.awt.image.WritableRaster): void;

            }

            class DisplayMode extends java.lang.Object {
                static readonly class: JavaClass<DisplayMode>;
                /** @deprecated */ static prototype: undefined;

                static readonly BIT_DEPTH_MULTI: number;
                static readonly REFRESH_RATE_UNKNOWN: number;

                constructor (arg0: int, arg1: int, arg2: int, arg3: int);

                getHeight(): number;
                getWidth(): number;
                getBitDepth(): number;
                getRefreshRate(): number;
                equals(arg0: DisplayMode): boolean;
                equals(arg0: any): boolean;

            }

            abstract class BufferCapabilities$FlipContents extends AttributeValue {
                static readonly class: JavaClass<BufferCapabilities$FlipContents>;
                /** @deprecated */ static prototype: undefined;

                static readonly UNDEFINED: BufferCapabilities$FlipContents;
                static readonly BACKGROUND: BufferCapabilities$FlipContents;
                static readonly PRIOR: BufferCapabilities$FlipContents;
                static readonly COPIED: BufferCapabilities$FlipContents;
            }

            abstract class PaintContext extends java.lang.Interface {
                static readonly class: JavaClass<PaintContext>;
                /** @deprecated */ static prototype: undefined;
            }
            interface PaintContext {

                dispose(): void;
                getColorModel(): java.awt.image.ColorModel;
                getRaster(arg0: int, arg1: int, arg2: int, arg3: int): java.awt.image.Raster;

            }

            abstract class Dialog$ModalExclusionType extends java.lang.Enum<Dialog$ModalExclusionType> {
                static readonly class: JavaClass<Dialog$ModalExclusionType>;
                /** @deprecated */ static prototype: undefined;

                static readonly NO_EXCLUDE: Dialog$ModalExclusionType;
                static readonly APPLICATION_EXCLUDE: Dialog$ModalExclusionType;
                static readonly TOOLKIT_EXCLUDE: Dialog$ModalExclusionType;

                static values(): JavaArray<Dialog$ModalExclusionType>;
                static valueOf(arg0: string): Dialog$ModalExclusionType;

            }

            abstract class AttributeValue extends java.lang.Object {
                static readonly class: JavaClass<AttributeValue>;
                /** @deprecated */ static prototype: undefined;
            }

            class Container extends Component {
                static readonly class: JavaClass<Container>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

                getComponentCount(): number;
                /** @deprecated */
                countComponents(): number;
                getComponent(arg0: int): Component;
                getComponents(): JavaArray<Component>;
                getInsets(): Insets;
                /** @deprecated */
                insets(): Insets;
                add(arg0: Component): Component;
                add(arg0: string, arg1: Component): Component;
                add(arg0: Component, arg1: int): Component;
                add(arg0: PopupMenu): void;
                setComponentZOrder(arg0: Component, arg1: int): void;
                getComponentZOrder(arg0: Component): number;
                add(arg0: Component, arg1: any): void;
                add(arg0: Component, arg1: any, arg2: int): void;
                remove(arg0: int): void;
                remove(arg0: Component): void;
                remove(arg0: MenuComponent): void;
                removeAll(): void;
                getLayout(): LayoutManager;
                setLayout(arg0: LayoutManager): void;
                doLayout(): void;
                /** @deprecated */
                layout(): void;
                isValidateRoot(): boolean;
                invalidate(): void;
                validate(): void;
                setFont(arg0: Font): void;
                getPreferredSize(): Dimension;
                /** @deprecated */
                preferredSize(): Dimension;
                getMinimumSize(): Dimension;
                /** @deprecated */
                minimumSize(): Dimension;
                getMaximumSize(): Dimension;
                getAlignmentX(): number;
                getAlignmentY(): number;
                paint(arg0: Graphics): void;
                update(arg0: Graphics): void;
                print(arg0: Graphics): void;
                paintComponents(arg0: Graphics): void;
                printComponents(arg0: Graphics): void;
                addContainerListener(arg0: java.awt.event.ContainerListener): void;
                removeContainerListener(arg0: java.awt.event.ContainerListener): void;
                getContainerListeners(): JavaArray<java.awt.event.ContainerListener>;
                getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;
                /** @deprecated */
                deliverEvent(arg0: Event): void;
                getComponentAt(arg0: int, arg1: int): Component;
                /** @deprecated */
                locate(arg0: int, arg1: int): Component;
                getComponentAt(arg0: Point): Component;
                getMousePosition(arg0: boolean): Point;
                getMousePosition(): Point;
                findComponentAt(arg0: int, arg1: int): Component;
                findComponentAt(arg0: Point): Component;
                addNotify(): void;
                removeNotify(): void;
                isAncestorOf(arg0: Component): boolean;
                list(arg0: java.io.PrintStream, arg1: int): void;
                list(arg0: java.io.PrintWriter, arg1: int): void;
                list(): void;
                list(arg0: java.io.PrintStream): void;
                list(arg0: java.io.PrintWriter): void;
                setFocusTraversalKeys(arg0: int, arg1: JavaSet<AWTKeyStroke>): void;
                getFocusTraversalKeys(arg0: int): JavaSet<AWTKeyStroke>;
                areFocusTraversalKeysSet(arg0: int): boolean;
                isFocusCycleRoot(arg0: Container): boolean;
                setFocusTraversalPolicy(arg0: FocusTraversalPolicy): void;
                getFocusTraversalPolicy(): FocusTraversalPolicy;
                isFocusTraversalPolicySet(): boolean;
                setFocusCycleRoot(arg0: boolean): void;
                isFocusCycleRoot(): boolean;
                setFocusTraversalPolicyProvider(arg0: boolean): void;
                isFocusTraversalPolicyProvider(): boolean;
                transferFocusDownCycle(): void;
                applyComponentOrientation(arg0: ComponentOrientation): void;
                addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                addPropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;

            }

            abstract class MenuContainer extends java.lang.Interface {
                static readonly class: JavaClass<MenuContainer>;
                /** @deprecated */ static prototype: undefined;
            }
            interface MenuContainer {

                getFont(): Font;
                remove(arg0: MenuComponent): void;
                /** @deprecated */
                postEvent(arg0: Event): boolean;

            }

            class AWTEvent extends java.util.EventObject {
                static readonly class: JavaClass<AWTEvent>;
                /** @deprecated */ static prototype: undefined;

                static readonly COMPONENT_EVENT_MASK: number;
                static readonly CONTAINER_EVENT_MASK: number;
                static readonly FOCUS_EVENT_MASK: number;
                static readonly KEY_EVENT_MASK: number;
                static readonly MOUSE_EVENT_MASK: number;
                static readonly MOUSE_MOTION_EVENT_MASK: number;
                static readonly WINDOW_EVENT_MASK: number;
                static readonly ACTION_EVENT_MASK: number;
                static readonly ADJUSTMENT_EVENT_MASK: number;
                static readonly ITEM_EVENT_MASK: number;
                static readonly TEXT_EVENT_MASK: number;
                static readonly INPUT_METHOD_EVENT_MASK: number;
                static readonly PAINT_EVENT_MASK: number;
                static readonly INVOCATION_EVENT_MASK: number;
                static readonly HIERARCHY_EVENT_MASK: number;
                static readonly HIERARCHY_BOUNDS_EVENT_MASK: number;
                static readonly MOUSE_WHEEL_EVENT_MASK: number;
                static readonly WINDOW_STATE_EVENT_MASK: number;
                static readonly WINDOW_FOCUS_EVENT_MASK: number;
                static readonly RESERVED_ID_MAX: number;

                /** @deprecated */
                constructor (arg0: Event);
                constructor (arg0: any, arg1: int);

                setSource(arg0: any): void;
                getID(): number;
                paramString(): string;

            }

            abstract class Toolkit extends java.lang.Object {
                static readonly class: JavaClass<Toolkit>;
                /** @deprecated */ static prototype: undefined;

                static getDefaultToolkit(): Toolkit;
                static getProperty(arg0: string, arg1: string): string;

                setDynamicLayout(arg0: boolean): void;
                isDynamicLayoutActive(): boolean;
                getScreenSize(): Dimension;
                getScreenResolution(): number;
                getScreenInsets(arg0: GraphicsConfiguration): Insets;
                getColorModel(): java.awt.image.ColorModel;
                /** @deprecated */
                getFontList(): JavaArray<string>;
                /** @deprecated */
                getFontMetrics(arg0: Font): FontMetrics;
                sync(): void;
                getImage(arg0: string): Image;
                getImage(arg0: java.net.URL): Image;
                createImage(arg0: string): Image;
                createImage(arg0: java.net.URL): Image;
                prepareImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): boolean;
                checkImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): number;
                createImage(arg0: java.awt.image.ImageProducer): Image;
                createImage(arg0: byte[]): Image;
                createImage(arg0: byte[], arg1: int, arg2: int): Image;
                getPrintJob(arg0: Frame, arg1: string, arg2: java.util.Properties): PrintJob;
                getPrintJob(arg0: Frame, arg1: string, arg2: JobAttributes, arg3: PageAttributes): PrintJob;
                beep(): void;
                getSystemClipboard(): java.awt.datatransfer.Clipboard;
                getSystemSelection(): java.awt.datatransfer.Clipboard;
                /** @deprecated */
                getMenuShortcutKeyMask(): number;
                getMenuShortcutKeyMaskEx(): number;
                getLockingKeyState(arg0: int): boolean;
                setLockingKeyState(arg0: int, arg1: boolean): void;
                createCustomCursor(arg0: Image, arg1: Point, arg2: string): Cursor;
                getBestCursorSize(arg0: int, arg1: int): Dimension;
                getMaximumCursorColors(): number;
                isFrameStateSupported(arg0: int): boolean;
                getSystemEventQueue(): EventQueue;
                createDragGestureRecognizer<T extends java.awt.dnd.DragGestureRecognizer>(arg0: JavaClassArg<T>, arg1: java.awt.dnd.DragSource, arg2: Component, arg3: int, arg4: java.awt.dnd.DragGestureListener): T;
                getDesktopProperty(arg0: string): any;
                addPropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                removePropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                getPropertyChangeListeners(): JavaArray<java.beans.PropertyChangeListener>;
                getPropertyChangeListeners(arg0: string): JavaArray<java.beans.PropertyChangeListener>;
                isAlwaysOnTopSupported(): boolean;
                isModalityTypeSupported(arg0: Dialog$ModalityType): boolean;
                isModalExclusionTypeSupported(arg0: Dialog$ModalExclusionType): boolean;
                addAWTEventListener(arg0: java.awt.event.AWTEventListener, arg1: long): void;
                removeAWTEventListener(arg0: java.awt.event.AWTEventListener): void;
                getAWTEventListeners(): JavaArray<java.awt.event.AWTEventListener>;
                getAWTEventListeners(arg0: long): JavaArray<java.awt.event.AWTEventListener>;
                mapInputMethodHighlight(arg0: java.awt.im.InputMethodHighlight): JavaMap<java.awt.font.TextAttribute, any>;
                areExtraMouseButtonsEnabled(): boolean;

            }

            /** @deprecated */
            interface Event extends java.io.Serializable {}
            class Event extends java.lang.Object {
                static readonly class: JavaClass<Event>;
                /** @deprecated */ static prototype: undefined;

                static readonly SHIFT_MASK: number;
                static readonly CTRL_MASK: number;
                static readonly META_MASK: number;
                static readonly ALT_MASK: number;
                static readonly HOME: number;
                static readonly END: number;
                static readonly PGUP: number;
                static readonly PGDN: number;
                static readonly UP: number;
                static readonly DOWN: number;
                static readonly LEFT: number;
                static readonly RIGHT: number;
                static readonly F1: number;
                static readonly F2: number;
                static readonly F3: number;
                static readonly F4: number;
                static readonly F5: number;
                static readonly F6: number;
                static readonly F7: number;
                static readonly F8: number;
                static readonly F9: number;
                static readonly F10: number;
                static readonly F11: number;
                static readonly F12: number;
                static readonly PRINT_SCREEN: number;
                static readonly SCROLL_LOCK: number;
                static readonly CAPS_LOCK: number;
                static readonly NUM_LOCK: number;
                static readonly PAUSE: number;
                static readonly INSERT: number;
                static readonly ENTER: number;
                static readonly BACK_SPACE: number;
                static readonly TAB: number;
                static readonly ESCAPE: number;
                static readonly DELETE: number;
                static readonly WINDOW_DESTROY: number;
                static readonly WINDOW_EXPOSE: number;
                static readonly WINDOW_ICONIFY: number;
                static readonly WINDOW_DEICONIFY: number;
                static readonly WINDOW_MOVED: number;
                static readonly KEY_PRESS: number;
                static readonly KEY_RELEASE: number;
                static readonly KEY_ACTION: number;
                static readonly KEY_ACTION_RELEASE: number;
                static readonly MOUSE_DOWN: number;
                static readonly MOUSE_UP: number;
                static readonly MOUSE_MOVE: number;
                static readonly MOUSE_ENTER: number;
                static readonly MOUSE_EXIT: number;
                static readonly MOUSE_DRAG: number;
                static readonly SCROLL_LINE_UP: number;
                static readonly SCROLL_LINE_DOWN: number;
                static readonly SCROLL_PAGE_UP: number;
                static readonly SCROLL_PAGE_DOWN: number;
                static readonly SCROLL_ABSOLUTE: number;
                static readonly SCROLL_BEGIN: number;
                static readonly SCROLL_END: number;
                static readonly LIST_SELECT: number;
                static readonly LIST_DESELECT: number;
                static readonly ACTION_EVENT: number;
                static readonly LOAD_FILE: number;
                static readonly SAVE_FILE: number;
                static readonly GOT_FOCUS: number;
                static readonly LOST_FOCUS: number;

                constructor (arg0: any, arg1: long, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: any);
                constructor (arg0: any, arg1: long, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int);
                constructor (arg0: any, arg1: int, arg2: any);

                target: any;
                when: number;
                id: number;
                x: number;
                y: number;
                key: number;
                modifiers: number;
                clickCount: number;
                arg: any;
                evt: Event;

                translate(arg0: int, arg1: int): void;
                shiftDown(): boolean;
                controlDown(): boolean;
                metaDown(): boolean;

            }

            interface Frame extends MenuContainer {}
            class Frame extends Window {
                static readonly class: JavaClass<Frame>;
                /** @deprecated */ static prototype: undefined;

                /** @deprecated */
                static readonly DEFAULT_CURSOR: number;
                /** @deprecated */
                static readonly CROSSHAIR_CURSOR: number;
                /** @deprecated */
                static readonly TEXT_CURSOR: number;
                /** @deprecated */
                static readonly WAIT_CURSOR: number;
                /** @deprecated */
                static readonly SW_RESIZE_CURSOR: number;
                /** @deprecated */
                static readonly SE_RESIZE_CURSOR: number;
                /** @deprecated */
                static readonly NW_RESIZE_CURSOR: number;
                /** @deprecated */
                static readonly NE_RESIZE_CURSOR: number;
                /** @deprecated */
                static readonly N_RESIZE_CURSOR: number;
                /** @deprecated */
                static readonly S_RESIZE_CURSOR: number;
                /** @deprecated */
                static readonly W_RESIZE_CURSOR: number;
                /** @deprecated */
                static readonly E_RESIZE_CURSOR: number;
                /** @deprecated */
                static readonly HAND_CURSOR: number;
                /** @deprecated */
                static readonly MOVE_CURSOR: number;
                static readonly NORMAL: number;
                static readonly ICONIFIED: number;
                static readonly MAXIMIZED_HORIZ: number;
                static readonly MAXIMIZED_VERT: number;
                static readonly MAXIMIZED_BOTH: number;

                static getFrames(): JavaArray<Frame>;

                constructor ();
                constructor (arg0: GraphicsConfiguration);
                constructor (arg0: string);
                constructor (arg0: string, arg1: GraphicsConfiguration);

                addNotify(): void;
                getTitle(): string;
                setTitle(arg0: string): void;
                getIconImage(): Image;
                setIconImage(arg0: Image): void;
                getMenuBar(): MenuBar;
                setMenuBar(arg0: MenuBar): void;
                isResizable(): boolean;
                setResizable(arg0: boolean): void;
                setState(arg0: int): void;
                setExtendedState(arg0: int): void;
                getState(): number;
                getExtendedState(): number;
                setMaximizedBounds(arg0: Rectangle): void;
                getMaximizedBounds(): Rectangle;
                setUndecorated(arg0: boolean): void;
                isUndecorated(): boolean;
                setOpacity(arg0: float): void;
                setShape(arg0: Shape): void;
                setBackground(arg0: Color): void;
                remove(arg0: MenuComponent): void;
                remove(arg0: int): void;
                remove(arg0: Component): void;
                removeNotify(): void;
                /** @deprecated */
                setCursor(arg0: int): void;
                setCursor(arg0: Cursor): void;
                /** @deprecated */
                getCursorType(): number;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            abstract class Window$Type extends java.lang.Enum<Window$Type> {
                static readonly class: JavaClass<Window$Type>;
                /** @deprecated */ static prototype: undefined;

                static readonly NORMAL: Window$Type;
                static readonly UTILITY: Window$Type;
                static readonly POPUP: Window$Type;

                static values(): JavaArray<Window$Type>;
                static valueOf(arg0: string): Window$Type;

            }

            interface AWTKeyStroke extends java.io.Serializable {}
            abstract class AWTKeyStroke extends java.lang.Object {
                static readonly class: JavaClass<AWTKeyStroke>;
                /** @deprecated */ static prototype: undefined;

                static getAWTKeyStroke(arg0: char): AWTKeyStroke;
                static getAWTKeyStroke(arg0: char, arg1: int): AWTKeyStroke;
                static getAWTKeyStroke(arg0: int, arg1: int, arg2: boolean): AWTKeyStroke;
                static getAWTKeyStroke(arg0: int, arg1: int): AWTKeyStroke;
                static getAWTKeyStrokeForEvent(arg0: java.awt.event.KeyEvent): AWTKeyStroke;
                static getAWTKeyStroke(arg0: string): AWTKeyStroke;

                getKeyChar(): number;
                getKeyCode(): number;
                getModifiers(): number;
                isOnKeyRelease(): boolean;
                getKeyEventType(): number;

            }

            interface Component extends java.awt.image.ImageObserver, java.io.Serializable, MenuContainer {}
            abstract class Component extends java.lang.Object {
                static readonly class: JavaClass<Component>;
                /** @deprecated */ static prototype: undefined;

                static readonly TOP_ALIGNMENT: number;
                static readonly CENTER_ALIGNMENT: number;
                static readonly BOTTOM_ALIGNMENT: number;
                static readonly LEFT_ALIGNMENT: number;
                static readonly RIGHT_ALIGNMENT: number;

                getName(): string;
                setName(arg0: string): void;
                getParent(): Container;
                setDropTarget(arg0: java.awt.dnd.DropTarget): void;
                getDropTarget(): java.awt.dnd.DropTarget;
                getGraphicsConfiguration(): GraphicsConfiguration;
                getTreeLock(): any;
                getToolkit(): Toolkit;
                isValid(): boolean;
                isDisplayable(): boolean;
                isVisible(): boolean;
                getMousePosition(): Point;
                isShowing(): boolean;
                isEnabled(): boolean;
                setEnabled(arg0: boolean): void;
                /** @deprecated */
                enable(): void;
                /** @deprecated */
                enable(arg0: boolean): void;
                /** @deprecated */
                disable(): void;
                isDoubleBuffered(): boolean;
                enableInputMethods(arg0: boolean): void;
                setVisible(arg0: boolean): void;
                /** @deprecated */
                show(): void;
                /** @deprecated */
                show(arg0: boolean): void;
                /** @deprecated */
                hide(): void;
                getForeground(): Color;
                setForeground(arg0: Color): void;
                isForegroundSet(): boolean;
                getBackground(): Color;
                setBackground(arg0: Color): void;
                isBackgroundSet(): boolean;
                getFont(): Font;
                setFont(arg0: Font): void;
                isFontSet(): boolean;
                getLocale(): java.util.Locale;
                setLocale(arg0: java.util.Locale): void;
                getColorModel(): java.awt.image.ColorModel;
                getLocation(): Point;
                getLocationOnScreen(): Point;
                /** @deprecated */
                location(): Point;
                setLocation(arg0: int, arg1: int): void;
                /** @deprecated */
                move(arg0: int, arg1: int): void;
                setLocation(arg0: Point): void;
                getSize(): Dimension;
                /** @deprecated */
                size(): Dimension;
                setSize(arg0: int, arg1: int): void;
                /** @deprecated */
                resize(arg0: int, arg1: int): void;
                setSize(arg0: Dimension): void;
                /** @deprecated */
                resize(arg0: Dimension): void;
                getBounds(): Rectangle;
                /** @deprecated */
                bounds(): Rectangle;
                setBounds(arg0: int, arg1: int, arg2: int, arg3: int): void;
                /** @deprecated */
                reshape(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setBounds(arg0: Rectangle): void;
                getX(): number;
                getY(): number;
                getWidth(): number;
                getHeight(): number;
                getBounds(arg0: Rectangle): Rectangle;
                getSize(arg0: Dimension): Dimension;
                getLocation(arg0: Point): Point;
                isOpaque(): boolean;
                isLightweight(): boolean;
                setPreferredSize(arg0: Dimension): void;
                isPreferredSizeSet(): boolean;
                getPreferredSize(): Dimension;
                /** @deprecated */
                preferredSize(): Dimension;
                setMinimumSize(arg0: Dimension): void;
                isMinimumSizeSet(): boolean;
                getMinimumSize(): Dimension;
                /** @deprecated */
                minimumSize(): Dimension;
                setMaximumSize(arg0: Dimension): void;
                isMaximumSizeSet(): boolean;
                getMaximumSize(): Dimension;
                getAlignmentX(): number;
                getAlignmentY(): number;
                getBaseline(arg0: int, arg1: int): number;
                getBaselineResizeBehavior(): Component$BaselineResizeBehavior;
                doLayout(): void;
                /** @deprecated */
                layout(): void;
                validate(): void;
                invalidate(): void;
                revalidate(): void;
                getGraphics(): Graphics;
                getFontMetrics(arg0: Font): FontMetrics;
                setCursor(arg0: Cursor): void;
                getCursor(): Cursor;
                isCursorSet(): boolean;
                paint(arg0: Graphics): void;
                update(arg0: Graphics): void;
                paintAll(arg0: Graphics): void;
                repaint(): void;
                repaint(arg0: long): void;
                repaint(arg0: int, arg1: int, arg2: int, arg3: int): void;
                repaint(arg0: long, arg1: int, arg2: int, arg3: int, arg4: int): void;
                print(arg0: Graphics): void;
                printAll(arg0: Graphics): void;
                imageUpdate(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): boolean;
                createImage(arg0: java.awt.image.ImageProducer): Image;
                createImage(arg0: int, arg1: int): Image;
                createVolatileImage(arg0: int, arg1: int): java.awt.image.VolatileImage;
                createVolatileImage(arg0: int, arg1: int, arg2: ImageCapabilities): java.awt.image.VolatileImage;
                prepareImage(arg0: Image, arg1: java.awt.image.ImageObserver): boolean;
                prepareImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): boolean;
                checkImage(arg0: Image, arg1: java.awt.image.ImageObserver): number;
                checkImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): number;
                setIgnoreRepaint(arg0: boolean): void;
                getIgnoreRepaint(): boolean;
                contains(arg0: int, arg1: int): boolean;
                /** @deprecated */
                inside(arg0: int, arg1: int): boolean;
                contains(arg0: Point): boolean;
                getComponentAt(arg0: int, arg1: int): Component;
                /** @deprecated */
                locate(arg0: int, arg1: int): Component;
                getComponentAt(arg0: Point): Component;
                /** @deprecated */
                deliverEvent(arg0: Event): void;
                dispatchEvent(arg0: AWTEvent): void;
                /** @deprecated */
                postEvent(arg0: Event): boolean;
                addComponentListener(arg0: java.awt.event.ComponentListener): void;
                removeComponentListener(arg0: java.awt.event.ComponentListener): void;
                getComponentListeners(): JavaArray<java.awt.event.ComponentListener>;
                addFocusListener(arg0: java.awt.event.FocusListener): void;
                removeFocusListener(arg0: java.awt.event.FocusListener): void;
                getFocusListeners(): JavaArray<java.awt.event.FocusListener>;
                addHierarchyListener(arg0: java.awt.event.HierarchyListener): void;
                removeHierarchyListener(arg0: java.awt.event.HierarchyListener): void;
                getHierarchyListeners(): JavaArray<java.awt.event.HierarchyListener>;
                addHierarchyBoundsListener(arg0: java.awt.event.HierarchyBoundsListener): void;
                removeHierarchyBoundsListener(arg0: java.awt.event.HierarchyBoundsListener): void;
                getHierarchyBoundsListeners(): JavaArray<java.awt.event.HierarchyBoundsListener>;
                addKeyListener(arg0: java.awt.event.KeyListener): void;
                removeKeyListener(arg0: java.awt.event.KeyListener): void;
                getKeyListeners(): JavaArray<java.awt.event.KeyListener>;
                addMouseListener(arg0: java.awt.event.MouseListener): void;
                removeMouseListener(arg0: java.awt.event.MouseListener): void;
                getMouseListeners(): JavaArray<java.awt.event.MouseListener>;
                addMouseMotionListener(arg0: java.awt.event.MouseMotionListener): void;
                removeMouseMotionListener(arg0: java.awt.event.MouseMotionListener): void;
                getMouseMotionListeners(): JavaArray<java.awt.event.MouseMotionListener>;
                addMouseWheelListener(arg0: java.awt.event.MouseWheelListener): void;
                removeMouseWheelListener(arg0: java.awt.event.MouseWheelListener): void;
                getMouseWheelListeners(): JavaArray<java.awt.event.MouseWheelListener>;
                addInputMethodListener(arg0: java.awt.event.InputMethodListener): void;
                removeInputMethodListener(arg0: java.awt.event.InputMethodListener): void;
                getInputMethodListeners(): JavaArray<java.awt.event.InputMethodListener>;
                getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;
                getInputMethodRequests(): java.awt.im.InputMethodRequests;
                getInputContext(): java.awt.im.InputContext;
                /** @deprecated */
                handleEvent(arg0: Event): boolean;
                /** @deprecated */
                mouseDown(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseDrag(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseUp(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseMove(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseEnter(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseExit(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                keyDown(arg0: Event, arg1: int): boolean;
                /** @deprecated */
                keyUp(arg0: Event, arg1: int): boolean;
                /** @deprecated */
                action(arg0: Event, arg1: any): boolean;
                addNotify(): void;
                removeNotify(): void;
                /** @deprecated */
                gotFocus(arg0: Event, arg1: any): boolean;
                /** @deprecated */
                lostFocus(arg0: Event, arg1: any): boolean;
                /** @deprecated */
                isFocusTraversable(): boolean;
                isFocusable(): boolean;
                setFocusable(arg0: boolean): void;
                setFocusTraversalKeys(arg0: int, arg1: JavaSet<AWTKeyStroke>): void;
                getFocusTraversalKeys(arg0: int): JavaSet<AWTKeyStroke>;
                areFocusTraversalKeysSet(arg0: int): boolean;
                setFocusTraversalKeysEnabled(arg0: boolean): void;
                getFocusTraversalKeysEnabled(): boolean;
                requestFocus(): void;
                requestFocus(arg0: java.awt.event.FocusEvent$Cause): void;
                requestFocusInWindow(): boolean;
                requestFocusInWindow(arg0: java.awt.event.FocusEvent$Cause): boolean;
                getFocusCycleRootAncestor(): Container;
                isFocusCycleRoot(arg0: Container): boolean;
                transferFocus(): void;
                /** @deprecated */
                nextFocus(): void;
                transferFocusBackward(): void;
                transferFocusUpCycle(): void;
                hasFocus(): boolean;
                isFocusOwner(): boolean;
                add(arg0: PopupMenu): void;
                remove(arg0: MenuComponent): void;
                list(): void;
                list(arg0: java.io.PrintStream): void;
                list(arg0: java.io.PrintStream, arg1: int): void;
                list(arg0: java.io.PrintWriter): void;
                list(arg0: java.io.PrintWriter, arg1: int): void;
                addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                removePropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                getPropertyChangeListeners(): JavaArray<java.beans.PropertyChangeListener>;
                addPropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                removePropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                getPropertyChangeListeners(arg0: string): JavaArray<java.beans.PropertyChangeListener>;
                firePropertyChange(arg0: string, arg1: byte, arg2: byte): void;
                firePropertyChange(arg0: string, arg1: char, arg2: char): void;
                firePropertyChange(arg0: string, arg1: short, arg2: short): void;
                firePropertyChange(arg0: string, arg1: long, arg2: long): void;
                firePropertyChange(arg0: string, arg1: float, arg2: float): void;
                firePropertyChange(arg0: string, arg1: double, arg2: double): void;
                setComponentOrientation(arg0: ComponentOrientation): void;
                getComponentOrientation(): ComponentOrientation;
                applyComponentOrientation(arg0: ComponentOrientation): void;
                getAccessibleContext(): javax.accessibility.AccessibleContext;
                setMixingCutoutShape(arg0: Shape): void;

            }

            interface Cursor extends java.io.Serializable {}
            class Cursor extends java.lang.Object {
                static readonly class: JavaClass<Cursor>;
                /** @deprecated */ static prototype: undefined;

                static readonly DEFAULT_CURSOR: number;
                static readonly CROSSHAIR_CURSOR: number;
                static readonly TEXT_CURSOR: number;
                static readonly WAIT_CURSOR: number;
                static readonly SW_RESIZE_CURSOR: number;
                static readonly SE_RESIZE_CURSOR: number;
                static readonly NW_RESIZE_CURSOR: number;
                static readonly NE_RESIZE_CURSOR: number;
                static readonly N_RESIZE_CURSOR: number;
                static readonly S_RESIZE_CURSOR: number;
                static readonly W_RESIZE_CURSOR: number;
                static readonly E_RESIZE_CURSOR: number;
                static readonly HAND_CURSOR: number;
                static readonly MOVE_CURSOR: number;
                static readonly CUSTOM_CURSOR: number;

                static getPredefinedCursor(arg0: int): Cursor;
                static getSystemCustomCursor(arg0: string): Cursor;
                static getDefaultCursor(): Cursor;

                constructor (arg0: int);

                getType(): number;
                getName(): string;

            }

            interface ComponentOrientation extends java.io.Serializable {}
            abstract class ComponentOrientation extends java.lang.Object {
                static readonly class: JavaClass<ComponentOrientation>;
                /** @deprecated */ static prototype: undefined;

                static readonly LEFT_TO_RIGHT: ComponentOrientation;
                static readonly RIGHT_TO_LEFT: ComponentOrientation;
                static readonly UNKNOWN: ComponentOrientation;

                static getOrientation(arg0: java.util.Locale): ComponentOrientation;
                /** @deprecated */
                static getOrientation(arg0: java.util.ResourceBundle): ComponentOrientation;

                isHorizontal(): boolean;
                isLeftToRight(): boolean;

            }

            interface Insets extends java.lang.Cloneable, java.io.Serializable {}
            class Insets extends java.lang.Object {
                static readonly class: JavaClass<Insets>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: int, arg1: int, arg2: int, arg3: int);

                top: number;
                left: number;
                bottom: number;
                right: number;

                set(arg0: int, arg1: int, arg2: int, arg3: int): void;
                clone(): any;

            }

            class PopupMenu extends Menu {
                static readonly class: JavaClass<PopupMenu>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: string);

                getParent(): MenuContainer;
                addNotify(): void;
                show(arg0: Component, arg1: int, arg2: int): void;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            abstract class LayoutManager extends java.lang.Interface {
                static readonly class: JavaClass<LayoutManager>;
                /** @deprecated */ static prototype: undefined;
            }
            interface LayoutManager {

                addLayoutComponent(arg0: string, arg1: Component): void;
                removeLayoutComponent(arg0: Component): void;
                preferredLayoutSize(arg0: Container): Dimension;
                minimumLayoutSize(arg0: Container): Dimension;
                layoutContainer(arg0: Container): void;

            }

            abstract class Component$BaselineResizeBehavior extends java.lang.Enum<Component$BaselineResizeBehavior> {
                static readonly class: JavaClass<Component$BaselineResizeBehavior>;
                /** @deprecated */ static prototype: undefined;

                static readonly CONSTANT_ASCENT: Component$BaselineResizeBehavior;
                static readonly CONSTANT_DESCENT: Component$BaselineResizeBehavior;
                static readonly CENTER_OFFSET: Component$BaselineResizeBehavior;
                static readonly OTHER: Component$BaselineResizeBehavior;

                static values(): JavaArray<Component$BaselineResizeBehavior>;
                static valueOf(arg0: string): Component$BaselineResizeBehavior;

            }

            interface MenuComponent extends java.io.Serializable {}
            class MenuComponent extends java.lang.Object {
                static readonly class: JavaClass<MenuComponent>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

                getName(): string;
                setName(arg0: string): void;
                getParent(): MenuContainer;
                getFont(): Font;
                setFont(arg0: Font): void;
                removeNotify(): void;
                /** @deprecated */
                postEvent(arg0: Event): boolean;
                dispatchEvent(arg0: AWTEvent): void;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            abstract class Dialog$ModalityType extends java.lang.Enum<Dialog$ModalityType> {
                static readonly class: JavaClass<Dialog$ModalityType>;
                /** @deprecated */ static prototype: undefined;

                static readonly MODELESS: Dialog$ModalityType;
                static readonly DOCUMENT_MODAL: Dialog$ModalityType;
                static readonly APPLICATION_MODAL: Dialog$ModalityType;
                static readonly TOOLKIT_MODAL: Dialog$ModalityType;

                static values(): JavaArray<Dialog$ModalityType>;
                static valueOf(arg0: string): Dialog$ModalityType;

            }

            interface PageAttributes extends java.lang.Cloneable {}
            class PageAttributes extends java.lang.Object {
                static readonly class: JavaClass<PageAttributes>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: PageAttributes);
                constructor (arg0: PageAttributes$ColorType, arg1: PageAttributes$MediaType, arg2: PageAttributes$OrientationRequestedType, arg3: PageAttributes$OriginType, arg4: PageAttributes$PrintQualityType, arg5: int[]);

                clone(): any;
                set(arg0: PageAttributes): void;
                getColor(): PageAttributes$ColorType;
                setColor(arg0: PageAttributes$ColorType): void;
                getMedia(): PageAttributes$MediaType;
                setMedia(arg0: PageAttributes$MediaType): void;
                setMediaToDefault(): void;
                getOrientationRequested(): PageAttributes$OrientationRequestedType;
                setOrientationRequested(arg0: PageAttributes$OrientationRequestedType): void;
                setOrientationRequested(arg0: int): void;
                setOrientationRequestedToDefault(): void;
                getOrigin(): PageAttributes$OriginType;
                setOrigin(arg0: PageAttributes$OriginType): void;
                getPrintQuality(): PageAttributes$PrintQualityType;
                setPrintQuality(arg0: PageAttributes$PrintQualityType): void;
                setPrintQuality(arg0: int): void;
                setPrintQualityToDefault(): void;
                getPrinterResolution(): JavaArray<number>;
                setPrinterResolution(arg0: int[]): void;
                setPrinterResolution(arg0: int): void;
                setPrinterResolutionToDefault(): void;

            }

            interface MenuBar extends javax.accessibility.Accessible, MenuContainer {}
            class MenuBar extends MenuComponent {
                static readonly class: JavaClass<MenuBar>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

                addNotify(): void;
                removeNotify(): void;
                getHelpMenu(): Menu;
                setHelpMenu(arg0: Menu): void;
                add(arg0: Menu): Menu;
                remove(arg0: int): void;
                remove(arg0: MenuComponent): void;
                getMenuCount(): number;
                /** @deprecated */
                countMenus(): number;
                getMenu(arg0: int): Menu;
                shortcuts(): java.util.Enumeration<MenuShortcut>;
                getShortcutMenuItem(arg0: MenuShortcut): MenuItem;
                deleteShortcut(arg0: MenuShortcut): void;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            class EventQueue extends java.lang.Object {
                static readonly class: JavaClass<EventQueue>;
                /** @deprecated */ static prototype: undefined;

                static getMostRecentEventTime(): number;
                static getCurrentEvent(): AWTEvent;
                static isDispatchThread(): boolean;
                static invokeLater(arg0: MethodWrapper): void;
                static invokeAndWait(arg0: MethodWrapper): void;

                constructor ();

                postEvent(arg0: AWTEvent): void;
                getNextEvent(): AWTEvent;
                peekEvent(): AWTEvent;
                peekEvent(arg0: int): AWTEvent;
                push(arg0: EventQueue): void;
                createSecondaryLoop(): SecondaryLoop;

            }

            abstract class PrintJob extends java.lang.Object {
                static readonly class: JavaClass<PrintJob>;
                /** @deprecated */ static prototype: undefined;

                getGraphics(): Graphics;
                getPageDimension(): Dimension;
                getPageResolution(): number;
                lastPageFirst(): boolean;
                end(): void;
                /** @deprecated */
                finalize(): void;

            }

            abstract class FocusTraversalPolicy extends java.lang.Object {
                static readonly class: JavaClass<FocusTraversalPolicy>;
                /** @deprecated */ static prototype: undefined;

                getComponentAfter(arg0: Container, arg1: Component): Component;
                getComponentBefore(arg0: Container, arg1: Component): Component;
                getFirstComponent(arg0: Container): Component;
                getLastComponent(arg0: Container): Component;
                getDefaultComponent(arg0: Container): Component;
                getInitialComponent(arg0: Window): Component;

            }

            interface JobAttributes extends java.lang.Cloneable {}
            class JobAttributes extends java.lang.Object {
                static readonly class: JavaClass<JobAttributes>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: JobAttributes);
                constructor (arg0: int, arg1: JobAttributes$DefaultSelectionType, arg2: JobAttributes$DestinationType, arg3: JobAttributes$DialogType, arg4: string, arg5: int, arg6: int, arg7: JobAttributes$MultipleDocumentHandlingType, arg8: int[][], arg9: string, arg10: JobAttributes$SidesType);

                clone(): any;
                set(arg0: JobAttributes): void;
                getCopies(): number;
                setCopies(arg0: int): void;
                setCopiesToDefault(): void;
                getDefaultSelection(): JobAttributes$DefaultSelectionType;
                setDefaultSelection(arg0: JobAttributes$DefaultSelectionType): void;
                getDestination(): JobAttributes$DestinationType;
                setDestination(arg0: JobAttributes$DestinationType): void;
                getDialog(): JobAttributes$DialogType;
                setDialog(arg0: JobAttributes$DialogType): void;
                getFileName(): string;
                setFileName(arg0: string): void;
                getFromPage(): number;
                setFromPage(arg0: int): void;
                getMaxPage(): number;
                setMaxPage(arg0: int): void;
                getMinPage(): number;
                setMinPage(arg0: int): void;
                getMultipleDocumentHandling(): JobAttributes$MultipleDocumentHandlingType;
                setMultipleDocumentHandling(arg0: JobAttributes$MultipleDocumentHandlingType): void;
                setMultipleDocumentHandlingToDefault(): void;
                getPageRanges(): JavaArray<JavaArray<number>>;
                setPageRanges(arg0: int[][]): void;
                getPrinter(): string;
                setPrinter(arg0: string): void;
                getSides(): JobAttributes$SidesType;
                setSides(arg0: JobAttributes$SidesType): void;
                setSidesToDefault(): void;
                getToPage(): number;
                setToPage(arg0: int): void;

            }

            abstract class JobAttributes$DialogType extends AttributeValue {
                static readonly class: JavaClass<JobAttributes$DialogType>;
                /** @deprecated */ static prototype: undefined;

                static readonly COMMON: JobAttributes$DialogType;
                static readonly NATIVE: JobAttributes$DialogType;
                static readonly NONE: JobAttributes$DialogType;
            }

            abstract class PageAttributes$MediaType extends AttributeValue {
                static readonly class: JavaClass<PageAttributes$MediaType>;
                /** @deprecated */ static prototype: undefined;

                static readonly ISO_4A0: PageAttributes$MediaType;
                static readonly ISO_2A0: PageAttributes$MediaType;
                static readonly ISO_A0: PageAttributes$MediaType;
                static readonly ISO_A1: PageAttributes$MediaType;
                static readonly ISO_A2: PageAttributes$MediaType;
                static readonly ISO_A3: PageAttributes$MediaType;
                static readonly ISO_A4: PageAttributes$MediaType;
                static readonly ISO_A5: PageAttributes$MediaType;
                static readonly ISO_A6: PageAttributes$MediaType;
                static readonly ISO_A7: PageAttributes$MediaType;
                static readonly ISO_A8: PageAttributes$MediaType;
                static readonly ISO_A9: PageAttributes$MediaType;
                static readonly ISO_A10: PageAttributes$MediaType;
                static readonly ISO_B0: PageAttributes$MediaType;
                static readonly ISO_B1: PageAttributes$MediaType;
                static readonly ISO_B2: PageAttributes$MediaType;
                static readonly ISO_B3: PageAttributes$MediaType;
                static readonly ISO_B4: PageAttributes$MediaType;
                static readonly ISO_B5: PageAttributes$MediaType;
                static readonly ISO_B6: PageAttributes$MediaType;
                static readonly ISO_B7: PageAttributes$MediaType;
                static readonly ISO_B8: PageAttributes$MediaType;
                static readonly ISO_B9: PageAttributes$MediaType;
                static readonly ISO_B10: PageAttributes$MediaType;
                static readonly JIS_B0: PageAttributes$MediaType;
                static readonly JIS_B1: PageAttributes$MediaType;
                static readonly JIS_B2: PageAttributes$MediaType;
                static readonly JIS_B3: PageAttributes$MediaType;
                static readonly JIS_B4: PageAttributes$MediaType;
                static readonly JIS_B5: PageAttributes$MediaType;
                static readonly JIS_B6: PageAttributes$MediaType;
                static readonly JIS_B7: PageAttributes$MediaType;
                static readonly JIS_B8: PageAttributes$MediaType;
                static readonly JIS_B9: PageAttributes$MediaType;
                static readonly JIS_B10: PageAttributes$MediaType;
                static readonly ISO_C0: PageAttributes$MediaType;
                static readonly ISO_C1: PageAttributes$MediaType;
                static readonly ISO_C2: PageAttributes$MediaType;
                static readonly ISO_C3: PageAttributes$MediaType;
                static readonly ISO_C4: PageAttributes$MediaType;
                static readonly ISO_C5: PageAttributes$MediaType;
                static readonly ISO_C6: PageAttributes$MediaType;
                static readonly ISO_C7: PageAttributes$MediaType;
                static readonly ISO_C8: PageAttributes$MediaType;
                static readonly ISO_C9: PageAttributes$MediaType;
                static readonly ISO_C10: PageAttributes$MediaType;
                static readonly ISO_DESIGNATED_LONG: PageAttributes$MediaType;
                static readonly EXECUTIVE: PageAttributes$MediaType;
                static readonly FOLIO: PageAttributes$MediaType;
                static readonly INVOICE: PageAttributes$MediaType;
                static readonly LEDGER: PageAttributes$MediaType;
                static readonly NA_LETTER: PageAttributes$MediaType;
                static readonly NA_LEGAL: PageAttributes$MediaType;
                static readonly QUARTO: PageAttributes$MediaType;
                static readonly A: PageAttributes$MediaType;
                static readonly B: PageAttributes$MediaType;
                static readonly C: PageAttributes$MediaType;
                static readonly D: PageAttributes$MediaType;
                static readonly E: PageAttributes$MediaType;
                static readonly NA_10X15_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_10X14_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_10X13_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_9X12_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_9X11_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_7X9_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_6X9_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_NUMBER_9_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_NUMBER_10_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_NUMBER_11_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_NUMBER_12_ENVELOPE: PageAttributes$MediaType;
                static readonly NA_NUMBER_14_ENVELOPE: PageAttributes$MediaType;
                static readonly INVITE_ENVELOPE: PageAttributes$MediaType;
                static readonly ITALY_ENVELOPE: PageAttributes$MediaType;
                static readonly MONARCH_ENVELOPE: PageAttributes$MediaType;
                static readonly PERSONAL_ENVELOPE: PageAttributes$MediaType;
                static readonly A0: PageAttributes$MediaType;
                static readonly A1: PageAttributes$MediaType;
                static readonly A2: PageAttributes$MediaType;
                static readonly A3: PageAttributes$MediaType;
                static readonly A4: PageAttributes$MediaType;
                static readonly A5: PageAttributes$MediaType;
                static readonly A6: PageAttributes$MediaType;
                static readonly A7: PageAttributes$MediaType;
                static readonly A8: PageAttributes$MediaType;
                static readonly A9: PageAttributes$MediaType;
                static readonly A10: PageAttributes$MediaType;
                static readonly B0: PageAttributes$MediaType;
                static readonly B1: PageAttributes$MediaType;
                static readonly B2: PageAttributes$MediaType;
                static readonly B3: PageAttributes$MediaType;
                static readonly B4: PageAttributes$MediaType;
                static readonly ISO_B4_ENVELOPE: PageAttributes$MediaType;
                static readonly B5: PageAttributes$MediaType;
                static readonly ISO_B5_ENVELOPE: PageAttributes$MediaType;
                static readonly B6: PageAttributes$MediaType;
                static readonly B7: PageAttributes$MediaType;
                static readonly B8: PageAttributes$MediaType;
                static readonly B9: PageAttributes$MediaType;
                static readonly B10: PageAttributes$MediaType;
                static readonly C0: PageAttributes$MediaType;
                static readonly ISO_C0_ENVELOPE: PageAttributes$MediaType;
                static readonly C1: PageAttributes$MediaType;
                static readonly ISO_C1_ENVELOPE: PageAttributes$MediaType;
                static readonly C2: PageAttributes$MediaType;
                static readonly ISO_C2_ENVELOPE: PageAttributes$MediaType;
                static readonly C3: PageAttributes$MediaType;
                static readonly ISO_C3_ENVELOPE: PageAttributes$MediaType;
                static readonly C4: PageAttributes$MediaType;
                static readonly ISO_C4_ENVELOPE: PageAttributes$MediaType;
                static readonly C5: PageAttributes$MediaType;
                static readonly ISO_C5_ENVELOPE: PageAttributes$MediaType;
                static readonly C6: PageAttributes$MediaType;
                static readonly ISO_C6_ENVELOPE: PageAttributes$MediaType;
                static readonly C7: PageAttributes$MediaType;
                static readonly ISO_C7_ENVELOPE: PageAttributes$MediaType;
                static readonly C8: PageAttributes$MediaType;
                static readonly ISO_C8_ENVELOPE: PageAttributes$MediaType;
                static readonly C9: PageAttributes$MediaType;
                static readonly ISO_C9_ENVELOPE: PageAttributes$MediaType;
                static readonly C10: PageAttributes$MediaType;
                static readonly ISO_C10_ENVELOPE: PageAttributes$MediaType;
                static readonly ISO_DESIGNATED_LONG_ENVELOPE: PageAttributes$MediaType;
                static readonly STATEMENT: PageAttributes$MediaType;
                static readonly TABLOID: PageAttributes$MediaType;
                static readonly LETTER: PageAttributes$MediaType;
                static readonly NOTE: PageAttributes$MediaType;
                static readonly LEGAL: PageAttributes$MediaType;
                static readonly ENV_10X15: PageAttributes$MediaType;
                static readonly ENV_10X14: PageAttributes$MediaType;
                static readonly ENV_10X13: PageAttributes$MediaType;
                static readonly ENV_9X12: PageAttributes$MediaType;
                static readonly ENV_9X11: PageAttributes$MediaType;
                static readonly ENV_7X9: PageAttributes$MediaType;
                static readonly ENV_6X9: PageAttributes$MediaType;
                static readonly ENV_9: PageAttributes$MediaType;
                static readonly ENV_10: PageAttributes$MediaType;
                static readonly ENV_11: PageAttributes$MediaType;
                static readonly ENV_12: PageAttributes$MediaType;
                static readonly ENV_14: PageAttributes$MediaType;
                static readonly ENV_INVITE: PageAttributes$MediaType;
                static readonly ENV_ITALY: PageAttributes$MediaType;
                static readonly ENV_MONARCH: PageAttributes$MediaType;
                static readonly ENV_PERSONAL: PageAttributes$MediaType;
                static readonly INVITE: PageAttributes$MediaType;
                static readonly ITALY: PageAttributes$MediaType;
                static readonly MONARCH: PageAttributes$MediaType;
                static readonly PERSONAL: PageAttributes$MediaType;
            }

            abstract class JobAttributes$DefaultSelectionType extends AttributeValue {
                static readonly class: JavaClass<JobAttributes$DefaultSelectionType>;
                /** @deprecated */ static prototype: undefined;

                static readonly ALL: JobAttributes$DefaultSelectionType;
                static readonly RANGE: JobAttributes$DefaultSelectionType;
                static readonly SELECTION: JobAttributes$DefaultSelectionType;
            }

            abstract class JobAttributes$SidesType extends AttributeValue {
                static readonly class: JavaClass<JobAttributes$SidesType>;
                /** @deprecated */ static prototype: undefined;

                static readonly ONE_SIDED: JobAttributes$SidesType;
                static readonly TWO_SIDED_LONG_EDGE: JobAttributes$SidesType;
                static readonly TWO_SIDED_SHORT_EDGE: JobAttributes$SidesType;
            }

            abstract class PageAttributes$OrientationRequestedType extends AttributeValue {
                static readonly class: JavaClass<PageAttributes$OrientationRequestedType>;
                /** @deprecated */ static prototype: undefined;

                static readonly PORTRAIT: PageAttributes$OrientationRequestedType;
                static readonly LANDSCAPE: PageAttributes$OrientationRequestedType;
            }

            abstract class SecondaryLoop extends java.lang.Interface {
                static readonly class: JavaClass<SecondaryLoop>;
                /** @deprecated */ static prototype: undefined;
            }
            interface SecondaryLoop {

                enter(): boolean;
                exit(): boolean;

            }

            interface MenuShortcut extends java.io.Serializable {}
            class MenuShortcut extends java.lang.Object {
                static readonly class: JavaClass<MenuShortcut>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: int);
                constructor (arg0: int, arg1: boolean);

                getKey(): number;
                usesShiftModifier(): boolean;
                equals(arg0: MenuShortcut): boolean;
                equals(arg0: any): boolean;

            }

            abstract class PageAttributes$ColorType extends AttributeValue {
                static readonly class: JavaClass<PageAttributes$ColorType>;
                /** @deprecated */ static prototype: undefined;

                static readonly COLOR: PageAttributes$ColorType;
                static readonly MONOCHROME: PageAttributes$ColorType;
            }

            interface Menu extends javax.accessibility.Accessible, MenuContainer {}
            class Menu extends MenuItem {
                static readonly class: JavaClass<Menu>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: string);
                constructor (arg0: string, arg1: boolean);

                addNotify(): void;
                removeNotify(): void;
                isTearOff(): boolean;
                getItemCount(): number;
                /** @deprecated */
                countItems(): number;
                getItem(arg0: int): MenuItem;
                add(arg0: MenuItem): MenuItem;
                add(arg0: string): void;
                insert(arg0: MenuItem, arg1: int): void;
                insert(arg0: string, arg1: int): void;
                addSeparator(): void;
                insertSeparator(arg0: int): void;
                remove(arg0: int): void;
                remove(arg0: MenuComponent): void;
                removeAll(): void;
                paramString(): string;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            interface MenuItem extends javax.accessibility.Accessible {}
            class MenuItem extends MenuComponent {
                static readonly class: JavaClass<MenuItem>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: string);
                constructor (arg0: string, arg1: MenuShortcut);

                addNotify(): void;
                getLabel(): string;
                setLabel(arg0: string): void;
                isEnabled(): boolean;
                setEnabled(arg0: boolean): void;
                /** @deprecated */
                enable(): void;
                /** @deprecated */
                enable(arg0: boolean): void;
                /** @deprecated */
                disable(): void;
                getShortcut(): MenuShortcut;
                setShortcut(arg0: MenuShortcut): void;
                deleteShortcut(): void;
                setActionCommand(arg0: string): void;
                getActionCommand(): string;
                addActionListener(arg0: java.awt.event.ActionListener): void;
                removeActionListener(arg0: java.awt.event.ActionListener): void;
                getActionListeners(): JavaArray<java.awt.event.ActionListener>;
                getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;
                paramString(): string;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            abstract class JobAttributes$DestinationType extends AttributeValue {
                static readonly class: JavaClass<JobAttributes$DestinationType>;
                /** @deprecated */ static prototype: undefined;

                static readonly FILE: JobAttributes$DestinationType;
                static readonly PRINTER: JobAttributes$DestinationType;
            }

            abstract class PageAttributes$PrintQualityType extends AttributeValue {
                static readonly class: JavaClass<PageAttributes$PrintQualityType>;
                /** @deprecated */ static prototype: undefined;

                static readonly HIGH: PageAttributes$PrintQualityType;
                static readonly NORMAL: PageAttributes$PrintQualityType;
                static readonly DRAFT: PageAttributes$PrintQualityType;
            }

            abstract class JobAttributes$MultipleDocumentHandlingType extends AttributeValue {
                static readonly class: JavaClass<JobAttributes$MultipleDocumentHandlingType>;
                /** @deprecated */ static prototype: undefined;

                static readonly SEPARATE_DOCUMENTS_COLLATED_COPIES: JobAttributes$MultipleDocumentHandlingType;
                static readonly SEPARATE_DOCUMENTS_UNCOLLATED_COPIES: JobAttributes$MultipleDocumentHandlingType;
            }

            abstract class PageAttributes$OriginType extends AttributeValue {
                static readonly class: JavaClass<PageAttributes$OriginType>;
                /** @deprecated */ static prototype: undefined;

                static readonly PHYSICAL: PageAttributes$OriginType;
                static readonly PRINTABLE: PageAttributes$OriginType;
            }

            export {
                Image,
                Rectangle,
                Shape,
                GraphicsConfiguration,
                ImageCapabilities,
                Dimension,
                Transparency,
                Point,
                Graphics,
                Graphics2D,
                Color,
                Paint,
                BufferCapabilities,
                GraphicsDevice,
                Font,
                RenderingHints,
                FontMetrics,
                Composite,
                Stroke,
                Polygon,
                RenderingHints$Key,
                GraphicsConfigTemplate,
                Window,
                GraphicsDevice$WindowTranslucency,
                CompositeContext,
                DisplayMode,
                BufferCapabilities$FlipContents,
                PaintContext,
                Dialog$ModalExclusionType,
                AttributeValue,
                Container,
                MenuContainer,
                AWTEvent,
                Toolkit,
                Event,
                Frame,
                Window$Type,
                AWTKeyStroke,
                Component,
                Cursor,
                ComponentOrientation,
                Insets,
                PopupMenu,
                LayoutManager,
                Component$BaselineResizeBehavior,
                MenuComponent,
                Dialog$ModalityType,
                PageAttributes,
                MenuBar,
                EventQueue,
                PrintJob,
                FocusTraversalPolicy,
                JobAttributes,
                JobAttributes$DialogType,
                PageAttributes$MediaType,
                JobAttributes$DefaultSelectionType,
                JobAttributes$SidesType,
                PageAttributes$OrientationRequestedType,
                SecondaryLoop,
                MenuShortcut,
                PageAttributes$ColorType,
                Menu,
                MenuItem,
                JobAttributes$DestinationType,
                PageAttributes$PrintQualityType,
                JobAttributes$MultipleDocumentHandlingType,
                PageAttributes$OriginType
            }

        }
        namespace awt {

            namespace color {

                interface ColorSpace extends java.io.Serializable {}
                abstract class ColorSpace extends java.lang.Object {
                    static readonly class: JavaClass<ColorSpace>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly TYPE_XYZ: number;
                    static readonly TYPE_Lab: number;
                    static readonly TYPE_Luv: number;
                    static readonly TYPE_YCbCr: number;
                    static readonly TYPE_Yxy: number;
                    static readonly TYPE_RGB: number;
                    static readonly TYPE_GRAY: number;
                    static readonly TYPE_HSV: number;
                    static readonly TYPE_HLS: number;
                    static readonly TYPE_CMYK: number;
                    static readonly TYPE_CMY: number;
                    static readonly TYPE_2CLR: number;
                    static readonly TYPE_3CLR: number;
                    static readonly TYPE_4CLR: number;
                    static readonly TYPE_5CLR: number;
                    static readonly TYPE_6CLR: number;
                    static readonly TYPE_7CLR: number;
                    static readonly TYPE_8CLR: number;
                    static readonly TYPE_9CLR: number;
                    static readonly TYPE_ACLR: number;
                    static readonly TYPE_BCLR: number;
                    static readonly TYPE_CCLR: number;
                    static readonly TYPE_DCLR: number;
                    static readonly TYPE_ECLR: number;
                    static readonly TYPE_FCLR: number;
                    static readonly CS_sRGB: number;
                    static readonly CS_LINEAR_RGB: number;
                    static readonly CS_CIEXYZ: number;
                    static readonly CS_PYCC: number;
                    static readonly CS_GRAY: number;

                    static getInstance(arg0: int): ColorSpace;

                    isCS_sRGB(): boolean;
                    toRGB(arg0: float[]): JavaArray<number>;
                    fromRGB(arg0: float[]): JavaArray<number>;
                    toCIEXYZ(arg0: float[]): JavaArray<number>;
                    fromCIEXYZ(arg0: float[]): JavaArray<number>;
                    getType(): number;
                    getNumComponents(): number;
                    getName(arg0: int): string;
                    getMinValue(arg0: int): number;
                    getMaxValue(arg0: int): number;

                }

                export { ColorSpace }

            }

            namespace datatransfer {

                class Clipboard extends java.lang.Object {
                    static readonly class: JavaClass<Clipboard>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: string);

                    getName(): string;
                    setContents(arg0: Transferable, arg1: ClipboardOwner): void;
                    getContents(arg0: any): Transferable;
                    getAvailableDataFlavors(): JavaArray<DataFlavor>;
                    isDataFlavorAvailable(arg0: DataFlavor): boolean;
                    getData(arg0: DataFlavor): any;
                    addFlavorListener(arg0: FlavorListener): void;
                    removeFlavorListener(arg0: FlavorListener): void;
                    getFlavorListeners(): JavaArray<FlavorListener>;

                }

                interface DataFlavor extends java.lang.Cloneable, java.io.Externalizable {}
                class DataFlavor extends java.lang.Object {
                    static readonly class: JavaClass<DataFlavor>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly stringFlavor: DataFlavor;
                    static readonly imageFlavor: DataFlavor;
                    /** @deprecated */
                    static readonly plainTextFlavor: DataFlavor;
                    static readonly javaSerializedObjectMimeType: string;
                    static readonly javaFileListFlavor: DataFlavor;
                    static readonly javaJVMLocalObjectMimeType: string;
                    static readonly javaRemoteObjectMimeType: string;
                    static readonly selectionHtmlFlavor: DataFlavor;
                    static readonly fragmentHtmlFlavor: DataFlavor;
                    static readonly allHtmlFlavor: DataFlavor;

                    static getTextPlainUnicodeFlavor(): DataFlavor;
                    static selectBestTextFlavor(arg0: DataFlavor[]): DataFlavor;

                    constructor ();
                    constructor (arg0: JavaClassArg<any>, arg1: string);
                    constructor (arg0: string, arg1: string);
                    constructor (arg0: string, arg1: string, arg2: java.lang.ClassLoader);
                    constructor (arg0: string);

                    getReaderForText(arg0: Transferable): java.io.Reader;
                    getMimeType(): string;
                    getRepresentationClass(): JavaClass<any>;
                    getHumanPresentableName(): string;
                    getPrimaryType(): string;
                    getSubType(): string;
                    getParameter(arg0: string): string;
                    setHumanPresentableName(arg0: string): void;
                    equals(arg0: DataFlavor): boolean;
                    /** @deprecated */
                    equals(arg0: string): boolean;
                    equals(arg0: any): boolean;
                    match(arg0: DataFlavor): boolean;
                    isMimeTypeEqual(arg0: string): boolean;
                    isMimeTypeEqual(arg0: DataFlavor): boolean;
                    isMimeTypeSerializedObject(): boolean;
                    getDefaultRepresentationClass(): JavaClass<any>;
                    getDefaultRepresentationClassAsString(): string;
                    isRepresentationClassInputStream(): boolean;
                    isRepresentationClassReader(): boolean;
                    isRepresentationClassCharBuffer(): boolean;
                    isRepresentationClassByteBuffer(): boolean;
                    isRepresentationClassSerializable(): boolean;
                    isRepresentationClassRemote(): boolean;
                    isFlavorSerializedObjectType(): boolean;
                    isFlavorRemoteObjectType(): boolean;
                    isFlavorJavaFileListType(): boolean;
                    isFlavorTextType(): boolean;
                    writeExternal(arg0: java.io.ObjectOutput): void;
                    readExternal(arg0: java.io.ObjectInput): void;
                    clone(): any;

                }

                abstract class Transferable extends java.lang.Interface {
                    static readonly class: JavaClass<Transferable>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Transferable {

                    getTransferDataFlavors(): JavaArray<DataFlavor>;
                    isDataFlavorSupported(arg0: DataFlavor): boolean;
                    getTransferData(arg0: DataFlavor): any;

                }

                abstract class FlavorMap extends java.lang.Interface {
                    static readonly class: JavaClass<FlavorMap>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface FlavorMap {

                    getNativesForFlavors(arg0: DataFlavor[]): JavaMap<DataFlavor, string>;
                    getFlavorsForNatives(arg0: string[]): JavaMap<string, DataFlavor>;

                }

                abstract class ClipboardOwner extends java.lang.Interface {
                    static readonly class: JavaClass<ClipboardOwner>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ClipboardOwner {

                    lostOwnership(arg0: Clipboard, arg1: Transferable): void;

                }

                abstract class FlavorListener extends java.lang.Interface {
                    static readonly class: JavaClass<FlavorListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface FlavorListener extends java.util.EventListener {

                    flavorsChanged(arg0: FlavorEvent): void;

                }

                class FlavorEvent extends java.util.EventObject {
                    static readonly class: JavaClass<FlavorEvent>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: Clipboard);

                }

                export {
                    Clipboard,
                    DataFlavor,
                    Transferable,
                    FlavorMap,
                    ClipboardOwner,
                    FlavorListener,
                    FlavorEvent
                }

            }

            namespace dnd {

                interface DragGestureRecognizer extends java.io.Serializable {}
                abstract class DragGestureRecognizer extends java.lang.Object {
                    static readonly class: JavaClass<DragGestureRecognizer>;
                    /** @deprecated */ static prototype: undefined;

                    getDragSource(): DragSource;
                    getComponent(): java.awt.Component;
                    setComponent(arg0: java.awt.Component): void;
                    getSourceActions(): number;
                    setSourceActions(arg0: int): void;
                    getTriggerEvent(): java.awt.event.InputEvent;
                    resetRecognizer(): void;
                    addDragGestureListener(arg0: DragGestureListener): void;
                    removeDragGestureListener(arg0: DragGestureListener): void;

                }

                interface DragSource extends java.io.Serializable {}
                class DragSource extends java.lang.Object {
                    static readonly class: JavaClass<DragSource>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly DefaultCopyDrop: java.awt.Cursor;
                    static readonly DefaultMoveDrop: java.awt.Cursor;
                    static readonly DefaultLinkDrop: java.awt.Cursor;
                    static readonly DefaultCopyNoDrop: java.awt.Cursor;
                    static readonly DefaultMoveNoDrop: java.awt.Cursor;
                    static readonly DefaultLinkNoDrop: java.awt.Cursor;

                    static getDefaultDragSource(): DragSource;
                    static isDragImageSupported(): boolean;
                    static getDragThreshold(): number;

                    constructor ();

                    startDrag(arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.Image, arg3: java.awt.Point, arg4: java.awt.datatransfer.Transferable, arg5: DragSourceListener, arg6: java.awt.datatransfer.FlavorMap): void;
                    startDrag(arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.datatransfer.Transferable, arg3: DragSourceListener, arg4: java.awt.datatransfer.FlavorMap): void;
                    startDrag(arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.Image, arg3: java.awt.Point, arg4: java.awt.datatransfer.Transferable, arg5: DragSourceListener): void;
                    startDrag(arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.datatransfer.Transferable, arg3: DragSourceListener): void;
                    getFlavorMap(): java.awt.datatransfer.FlavorMap;
                    createDragGestureRecognizer<T extends DragGestureRecognizer>(arg0: JavaClassArg<T>, arg1: java.awt.Component, arg2: int, arg3: DragGestureListener): T;
                    createDefaultDragGestureRecognizer(arg0: java.awt.Component, arg1: int, arg2: DragGestureListener): DragGestureRecognizer;
                    addDragSourceListener(arg0: DragSourceListener): void;
                    removeDragSourceListener(arg0: DragSourceListener): void;
                    getDragSourceListeners(): JavaArray<DragSourceListener>;
                    addDragSourceMotionListener(arg0: DragSourceMotionListener): void;
                    removeDragSourceMotionListener(arg0: DragSourceMotionListener): void;
                    getDragSourceMotionListeners(): JavaArray<DragSourceMotionListener>;
                    getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;

                }

                interface DropTarget extends DropTargetListener, java.io.Serializable {}
                class DropTarget extends java.lang.Object {
                    static readonly class: JavaClass<DropTarget>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: java.awt.Component, arg1: int, arg2: DropTargetListener, arg3: boolean, arg4: java.awt.datatransfer.FlavorMap);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: DropTargetListener, arg3: boolean);
                    constructor ();
                    constructor (arg0: java.awt.Component, arg1: DropTargetListener);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: DropTargetListener);

                    setComponent(arg0: java.awt.Component): void;
                    getComponent(): java.awt.Component;
                    setDefaultActions(arg0: int): void;
                    getDefaultActions(): number;
                    setActive(arg0: boolean): void;
                    isActive(): boolean;
                    addDropTargetListener(arg0: DropTargetListener): void;
                    removeDropTargetListener(arg0: DropTargetListener): void;
                    dragEnter(arg0: DropTargetDragEvent): void;
                    dragOver(arg0: DropTargetDragEvent): void;
                    dropActionChanged(arg0: DropTargetDragEvent): void;
                    dragExit(arg0: DropTargetEvent): void;
                    drop(arg0: DropTargetDropEvent): void;
                    getFlavorMap(): java.awt.datatransfer.FlavorMap;
                    setFlavorMap(arg0: java.awt.datatransfer.FlavorMap): void;
                    addNotify(): void;
                    removeNotify(): void;
                    getDropTargetContext(): DropTargetContext;

                }

                abstract class DragGestureListener extends java.lang.Interface {
                    static readonly class: JavaClass<DragGestureListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DragGestureListener extends java.util.EventListener {

                    dragGestureRecognized(arg0: DragGestureEvent): void;

                }

                class DropTargetEvent extends java.util.EventObject {
                    static readonly class: JavaClass<DropTargetEvent>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: DropTargetContext);

                    getDropTargetContext(): DropTargetContext;

                }

                interface DropTargetContext extends java.io.Serializable {}
                abstract class DropTargetContext extends java.lang.Object {
                    static readonly class: JavaClass<DropTargetContext>;
                    /** @deprecated */ static prototype: undefined;

                    getDropTarget(): DropTarget;
                    getComponent(): java.awt.Component;
                    dropComplete(arg0: boolean): void;

                }

                abstract class DragSourceMotionListener extends java.lang.Interface {
                    static readonly class: JavaClass<DragSourceMotionListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DragSourceMotionListener extends java.util.EventListener {

                    dragMouseMoved(arg0: DragSourceDragEvent): void;

                }

                class DropTargetDropEvent extends DropTargetEvent {
                    static readonly class: JavaClass<DropTargetDropEvent>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: DropTargetContext, arg1: java.awt.Point, arg2: int, arg3: int);
                    constructor (arg0: DropTargetContext, arg1: java.awt.Point, arg2: int, arg3: int, arg4: boolean);

                    getLocation(): java.awt.Point;
                    getCurrentDataFlavors(): JavaArray<java.awt.datatransfer.DataFlavor>;
                    getCurrentDataFlavorsAsList(): JavaList<java.awt.datatransfer.DataFlavor>;
                    isDataFlavorSupported(arg0: java.awt.datatransfer.DataFlavor): boolean;
                    getSourceActions(): number;
                    getDropAction(): number;
                    getTransferable(): java.awt.datatransfer.Transferable;
                    acceptDrop(arg0: int): void;
                    rejectDrop(): void;
                    dropComplete(arg0: boolean): void;
                    isLocalTransfer(): boolean;

                }

                abstract class DropTargetListener extends java.lang.Interface {
                    static readonly class: JavaClass<DropTargetListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DropTargetListener extends java.util.EventListener {

                    dragEnter(arg0: DropTargetDragEvent): void;
                    dragOver(arg0: DropTargetDragEvent): void;
                    dropActionChanged(arg0: DropTargetDragEvent): void;
                    dragExit(arg0: DropTargetEvent): void;
                    drop(arg0: DropTargetDropEvent): void;

                }

                class DragGestureEvent extends java.util.EventObject {
                    static readonly class: JavaClass<DragGestureEvent>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: DragGestureRecognizer, arg1: int, arg2: java.awt.Point, arg3: JavaList<java.awt.event.InputEvent>);

                    getSourceAsDragGestureRecognizer(): DragGestureRecognizer;
                    getComponent(): java.awt.Component;
                    getDragSource(): DragSource;
                    getDragOrigin(): java.awt.Point;
                    iterator(): java.util.Iterator<java.awt.event.InputEvent>;
                    toArray(): JavaArray<any>;
                    toArray(arg0: any[]): JavaArray<any>;
                    getDragAction(): number;
                    getTriggerEvent(): java.awt.event.InputEvent;
                    startDrag(arg0: java.awt.Cursor, arg1: java.awt.datatransfer.Transferable): void;
                    startDrag(arg0: java.awt.Cursor, arg1: java.awt.datatransfer.Transferable, arg2: DragSourceListener): void;
                    startDrag(arg0: java.awt.Cursor, arg1: java.awt.Image, arg2: java.awt.Point, arg3: java.awt.datatransfer.Transferable, arg4: DragSourceListener): void;

                }

                abstract class DragSourceListener extends java.lang.Interface {
                    static readonly class: JavaClass<DragSourceListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DragSourceListener extends java.util.EventListener {

                    dragEnter(arg0: DragSourceDragEvent): void;
                    dragOver(arg0: DragSourceDragEvent): void;
                    dropActionChanged(arg0: DragSourceDragEvent): void;
                    dragExit(arg0: DragSourceEvent): void;
                    dragDropEnd(arg0: DragSourceDropEvent): void;

                }

                class DropTargetDragEvent extends DropTargetEvent {
                    static readonly class: JavaClass<DropTargetDragEvent>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: DropTargetContext, arg1: java.awt.Point, arg2: int, arg3: int);

                    getLocation(): java.awt.Point;
                    getCurrentDataFlavors(): JavaArray<java.awt.datatransfer.DataFlavor>;
                    getCurrentDataFlavorsAsList(): JavaList<java.awt.datatransfer.DataFlavor>;
                    isDataFlavorSupported(arg0: java.awt.datatransfer.DataFlavor): boolean;
                    getSourceActions(): number;
                    getDropAction(): number;
                    getTransferable(): java.awt.datatransfer.Transferable;
                    acceptDrag(arg0: int): void;
                    rejectDrag(): void;

                }

                class DragSourceDropEvent extends DragSourceEvent {
                    static readonly class: JavaClass<DragSourceDropEvent>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: DragSourceContext, arg1: int, arg2: boolean);
                    constructor (arg0: DragSourceContext, arg1: int, arg2: boolean, arg3: int, arg4: int);
                    constructor (arg0: DragSourceContext);

                    getDropSuccess(): boolean;
                    getDropAction(): number;

                }

                class DragSourceDragEvent extends DragSourceEvent {
                    static readonly class: JavaClass<DragSourceDragEvent>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: DragSourceContext, arg1: int, arg2: int, arg3: int);
                    constructor (arg0: DragSourceContext, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int);

                    getTargetActions(): number;
                    getGestureModifiers(): number;
                    getGestureModifiersEx(): number;
                    getUserAction(): number;
                    getDropAction(): number;

                }

                class DragSourceEvent extends java.util.EventObject {
                    static readonly class: JavaClass<DragSourceEvent>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: DragSourceContext);
                    constructor (arg0: DragSourceContext, arg1: int, arg2: int);

                    getDragSourceContext(): DragSourceContext;
                    getLocation(): java.awt.Point;
                    getX(): number;
                    getY(): number;

                }

                interface DragSourceContext extends DragSourceListener, java.io.Serializable, DragSourceMotionListener {}
                class DragSourceContext extends java.lang.Object {
                    static readonly class: JavaClass<DragSourceContext>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.Image, arg3: java.awt.Point, arg4: java.awt.datatransfer.Transferable, arg5: DragSourceListener);

                    getDragSource(): DragSource;
                    getComponent(): java.awt.Component;
                    getTrigger(): DragGestureEvent;
                    getSourceActions(): number;
                    setCursor(arg0: java.awt.Cursor): void;
                    getCursor(): java.awt.Cursor;
                    addDragSourceListener(arg0: DragSourceListener): void;
                    removeDragSourceListener(arg0: DragSourceListener): void;
                    transferablesFlavorsChanged(): void;
                    dragEnter(arg0: DragSourceDragEvent): void;
                    dragOver(arg0: DragSourceDragEvent): void;
                    dragExit(arg0: DragSourceEvent): void;
                    dropActionChanged(arg0: DragSourceDragEvent): void;
                    dragDropEnd(arg0: DragSourceDropEvent): void;
                    dragMouseMoved(arg0: DragSourceDragEvent): void;
                    getTransferable(): java.awt.datatransfer.Transferable;

                }

                export {
                    DragGestureRecognizer,
                    DragSource,
                    DropTarget,
                    DragGestureListener,
                    DropTargetEvent,
                    DropTargetContext,
                    DragSourceMotionListener,
                    DropTargetDropEvent,
                    DropTargetListener,
                    DragGestureEvent,
                    DragSourceListener,
                    DropTargetDragEvent,
                    DragSourceDropEvent,
                    DragSourceDragEvent,
                    DragSourceEvent,
                    DragSourceContext
                }

            }

            namespace event {

                abstract class WindowListener extends java.lang.Interface {
                    static readonly class: JavaClass<WindowListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WindowListener extends java.util.EventListener {

                    windowOpened(arg0: WindowEvent): void;
                    windowClosing(arg0: WindowEvent): void;
                    windowClosed(arg0: WindowEvent): void;
                    windowIconified(arg0: WindowEvent): void;
                    windowDeiconified(arg0: WindowEvent): void;
                    windowActivated(arg0: WindowEvent): void;
                    windowDeactivated(arg0: WindowEvent): void;

                }

                abstract class WindowStateListener extends java.lang.Interface {
                    static readonly class: JavaClass<WindowStateListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WindowStateListener extends java.util.EventListener {

                    windowStateChanged(arg0: WindowEvent): void;

                }

                abstract class WindowFocusListener extends java.lang.Interface {
                    static readonly class: JavaClass<WindowFocusListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WindowFocusListener extends java.util.EventListener {

                    windowGainedFocus(arg0: WindowEvent): void;
                    windowLostFocus(arg0: WindowEvent): void;

                }

                class WindowEvent extends ComponentEvent {
                    static readonly class: JavaClass<WindowEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly WINDOW_FIRST: number;
                    static readonly WINDOW_OPENED: number;
                    static readonly WINDOW_CLOSING: number;
                    static readonly WINDOW_CLOSED: number;
                    static readonly WINDOW_ICONIFIED: number;
                    static readonly WINDOW_DEICONIFIED: number;
                    static readonly WINDOW_ACTIVATED: number;
                    static readonly WINDOW_DEACTIVATED: number;
                    static readonly WINDOW_GAINED_FOCUS: number;
                    static readonly WINDOW_LOST_FOCUS: number;
                    static readonly WINDOW_STATE_CHANGED: number;
                    static readonly WINDOW_LAST: number;

                    constructor (arg0: java.awt.Window, arg1: int, arg2: java.awt.Window, arg3: int, arg4: int);
                    constructor (arg0: java.awt.Window, arg1: int, arg2: java.awt.Window);
                    constructor (arg0: java.awt.Window, arg1: int, arg2: int, arg3: int);
                    constructor (arg0: java.awt.Window, arg1: int);

                    getWindow(): java.awt.Window;
                    getOppositeWindow(): java.awt.Window;
                    getOldState(): number;
                    getNewState(): number;
                    paramString(): string;

                }

                class ComponentEvent extends java.awt.AWTEvent {
                    static readonly class: JavaClass<ComponentEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly COMPONENT_FIRST: number;
                    static readonly COMPONENT_LAST: number;
                    static readonly COMPONENT_MOVED: number;
                    static readonly COMPONENT_RESIZED: number;
                    static readonly COMPONENT_SHOWN: number;
                    static readonly COMPONENT_HIDDEN: number;

                    constructor (arg0: java.awt.Component, arg1: int);

                    getComponent(): java.awt.Component;
                    paramString(): string;

                }

                class KeyEvent extends InputEvent {
                    static readonly class: JavaClass<KeyEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly KEY_FIRST: number;
                    static readonly KEY_LAST: number;
                    static readonly KEY_TYPED: number;
                    static readonly KEY_PRESSED: number;
                    static readonly KEY_RELEASED: number;
                    static readonly VK_ENTER: number;
                    static readonly VK_BACK_SPACE: number;
                    static readonly VK_TAB: number;
                    static readonly VK_CANCEL: number;
                    static readonly VK_CLEAR: number;
                    static readonly VK_SHIFT: number;
                    static readonly VK_CONTROL: number;
                    static readonly VK_ALT: number;
                    static readonly VK_PAUSE: number;
                    static readonly VK_CAPS_LOCK: number;
                    static readonly VK_ESCAPE: number;
                    static readonly VK_SPACE: number;
                    static readonly VK_PAGE_UP: number;
                    static readonly VK_PAGE_DOWN: number;
                    static readonly VK_END: number;
                    static readonly VK_HOME: number;
                    static readonly VK_LEFT: number;
                    static readonly VK_UP: number;
                    static readonly VK_RIGHT: number;
                    static readonly VK_DOWN: number;
                    static readonly VK_COMMA: number;
                    static readonly VK_MINUS: number;
                    static readonly VK_PERIOD: number;
                    static readonly VK_SLASH: number;
                    static readonly VK_0: number;
                    static readonly VK_1: number;
                    static readonly VK_2: number;
                    static readonly VK_3: number;
                    static readonly VK_4: number;
                    static readonly VK_5: number;
                    static readonly VK_6: number;
                    static readonly VK_7: number;
                    static readonly VK_8: number;
                    static readonly VK_9: number;
                    static readonly VK_SEMICOLON: number;
                    static readonly VK_EQUALS: number;
                    static readonly VK_A: number;
                    static readonly VK_B: number;
                    static readonly VK_C: number;
                    static readonly VK_D: number;
                    static readonly VK_E: number;
                    static readonly VK_F: number;
                    static readonly VK_G: number;
                    static readonly VK_H: number;
                    static readonly VK_I: number;
                    static readonly VK_J: number;
                    static readonly VK_K: number;
                    static readonly VK_L: number;
                    static readonly VK_M: number;
                    static readonly VK_N: number;
                    static readonly VK_O: number;
                    static readonly VK_P: number;
                    static readonly VK_Q: number;
                    static readonly VK_R: number;
                    static readonly VK_S: number;
                    static readonly VK_T: number;
                    static readonly VK_U: number;
                    static readonly VK_V: number;
                    static readonly VK_W: number;
                    static readonly VK_X: number;
                    static readonly VK_Y: number;
                    static readonly VK_Z: number;
                    static readonly VK_OPEN_BRACKET: number;
                    static readonly VK_BACK_SLASH: number;
                    static readonly VK_CLOSE_BRACKET: number;
                    static readonly VK_NUMPAD0: number;
                    static readonly VK_NUMPAD1: number;
                    static readonly VK_NUMPAD2: number;
                    static readonly VK_NUMPAD3: number;
                    static readonly VK_NUMPAD4: number;
                    static readonly VK_NUMPAD5: number;
                    static readonly VK_NUMPAD6: number;
                    static readonly VK_NUMPAD7: number;
                    static readonly VK_NUMPAD8: number;
                    static readonly VK_NUMPAD9: number;
                    static readonly VK_MULTIPLY: number;
                    static readonly VK_ADD: number;
                    static readonly VK_SEPARATER: number;
                    static readonly VK_SEPARATOR: number;
                    static readonly VK_SUBTRACT: number;
                    static readonly VK_DECIMAL: number;
                    static readonly VK_DIVIDE: number;
                    static readonly VK_DELETE: number;
                    static readonly VK_NUM_LOCK: number;
                    static readonly VK_SCROLL_LOCK: number;
                    static readonly VK_F1: number;
                    static readonly VK_F2: number;
                    static readonly VK_F3: number;
                    static readonly VK_F4: number;
                    static readonly VK_F5: number;
                    static readonly VK_F6: number;
                    static readonly VK_F7: number;
                    static readonly VK_F8: number;
                    static readonly VK_F9: number;
                    static readonly VK_F10: number;
                    static readonly VK_F11: number;
                    static readonly VK_F12: number;
                    static readonly VK_F13: number;
                    static readonly VK_F14: number;
                    static readonly VK_F15: number;
                    static readonly VK_F16: number;
                    static readonly VK_F17: number;
                    static readonly VK_F18: number;
                    static readonly VK_F19: number;
                    static readonly VK_F20: number;
                    static readonly VK_F21: number;
                    static readonly VK_F22: number;
                    static readonly VK_F23: number;
                    static readonly VK_F24: number;
                    static readonly VK_PRINTSCREEN: number;
                    static readonly VK_INSERT: number;
                    static readonly VK_HELP: number;
                    static readonly VK_META: number;
                    static readonly VK_BACK_QUOTE: number;
                    static readonly VK_QUOTE: number;
                    static readonly VK_KP_UP: number;
                    static readonly VK_KP_DOWN: number;
                    static readonly VK_KP_LEFT: number;
                    static readonly VK_KP_RIGHT: number;
                    static readonly VK_DEAD_GRAVE: number;
                    static readonly VK_DEAD_ACUTE: number;
                    static readonly VK_DEAD_CIRCUMFLEX: number;
                    static readonly VK_DEAD_TILDE: number;
                    static readonly VK_DEAD_MACRON: number;
                    static readonly VK_DEAD_BREVE: number;
                    static readonly VK_DEAD_ABOVEDOT: number;
                    static readonly VK_DEAD_DIAERESIS: number;
                    static readonly VK_DEAD_ABOVERING: number;
                    static readonly VK_DEAD_DOUBLEACUTE: number;
                    static readonly VK_DEAD_CARON: number;
                    static readonly VK_DEAD_CEDILLA: number;
                    static readonly VK_DEAD_OGONEK: number;
                    static readonly VK_DEAD_IOTA: number;
                    static readonly VK_DEAD_VOICED_SOUND: number;
                    static readonly VK_DEAD_SEMIVOICED_SOUND: number;
                    static readonly VK_AMPERSAND: number;
                    static readonly VK_ASTERISK: number;
                    static readonly VK_QUOTEDBL: number;
                    static readonly VK_LESS: number;
                    static readonly VK_GREATER: number;
                    static readonly VK_BRACELEFT: number;
                    static readonly VK_BRACERIGHT: number;
                    static readonly VK_AT: number;
                    static readonly VK_COLON: number;
                    static readonly VK_CIRCUMFLEX: number;
                    static readonly VK_DOLLAR: number;
                    static readonly VK_EURO_SIGN: number;
                    static readonly VK_EXCLAMATION_MARK: number;
                    static readonly VK_INVERTED_EXCLAMATION_MARK: number;
                    static readonly VK_LEFT_PARENTHESIS: number;
                    static readonly VK_NUMBER_SIGN: number;
                    static readonly VK_PLUS: number;
                    static readonly VK_RIGHT_PARENTHESIS: number;
                    static readonly VK_UNDERSCORE: number;
                    static readonly VK_WINDOWS: number;
                    static readonly VK_CONTEXT_MENU: number;
                    static readonly VK_FINAL: number;
                    static readonly VK_CONVERT: number;
                    static readonly VK_NONCONVERT: number;
                    static readonly VK_ACCEPT: number;
                    static readonly VK_MODECHANGE: number;
                    static readonly VK_KANA: number;
                    static readonly VK_KANJI: number;
                    static readonly VK_ALPHANUMERIC: number;
                    static readonly VK_KATAKANA: number;
                    static readonly VK_HIRAGANA: number;
                    static readonly VK_FULL_WIDTH: number;
                    static readonly VK_HALF_WIDTH: number;
                    static readonly VK_ROMAN_CHARACTERS: number;
                    static readonly VK_ALL_CANDIDATES: number;
                    static readonly VK_PREVIOUS_CANDIDATE: number;
                    static readonly VK_CODE_INPUT: number;
                    static readonly VK_JAPANESE_KATAKANA: number;
                    static readonly VK_JAPANESE_HIRAGANA: number;
                    static readonly VK_JAPANESE_ROMAN: number;
                    static readonly VK_KANA_LOCK: number;
                    static readonly VK_INPUT_METHOD_ON_OFF: number;
                    static readonly VK_CUT: number;
                    static readonly VK_COPY: number;
                    static readonly VK_PASTE: number;
                    static readonly VK_UNDO: number;
                    static readonly VK_AGAIN: number;
                    static readonly VK_FIND: number;
                    static readonly VK_PROPS: number;
                    static readonly VK_STOP: number;
                    static readonly VK_COMPOSE: number;
                    static readonly VK_ALT_GRAPH: number;
                    static readonly VK_BEGIN: number;
                    static readonly VK_UNDEFINED: number;
                    static readonly CHAR_UNDEFINED: number;
                    static readonly KEY_LOCATION_UNKNOWN: number;
                    static readonly KEY_LOCATION_STANDARD: number;
                    static readonly KEY_LOCATION_LEFT: number;
                    static readonly KEY_LOCATION_RIGHT: number;
                    static readonly KEY_LOCATION_NUMPAD: number;

                    static getKeyText(arg0: int): string;
                    /** @deprecated */
                    static getKeyModifiersText(arg0: int): string;
                    static getExtendedKeyCodeForChar(arg0: int): number;

                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: char, arg6: int);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: char);
                    /** @deprecated */
                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int);

                    getKeyCode(): number;
                    setKeyCode(arg0: int): void;
                    getKeyChar(): number;
                    setKeyChar(arg0: char): void;
                    /** @deprecated */
                    setModifiers(arg0: int): void;
                    getKeyLocation(): number;
                    isActionKey(): boolean;
                    paramString(): string;
                    getExtendedKeyCode(): number;

                }

                abstract class InputMethodListener extends java.lang.Interface {
                    static readonly class: JavaClass<InputMethodListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface InputMethodListener extends java.util.EventListener {

                    inputMethodTextChanged(arg0: InputMethodEvent): void;
                    caretPositionChanged(arg0: InputMethodEvent): void;

                }

                abstract class AWTEventListener extends java.lang.Interface {
                    static readonly class: JavaClass<AWTEventListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface AWTEventListener extends java.util.EventListener {

                    eventDispatched(arg0: java.awt.AWTEvent): void;

                }

                abstract class InputEvent extends ComponentEvent {
                    static readonly class: JavaClass<InputEvent>;
                    /** @deprecated */ static prototype: undefined;

                    /** @deprecated */
                    static readonly SHIFT_MASK: number;
                    /** @deprecated */
                    static readonly CTRL_MASK: number;
                    /** @deprecated */
                    static readonly META_MASK: number;
                    /** @deprecated */
                    static readonly ALT_MASK: number;
                    /** @deprecated */
                    static readonly ALT_GRAPH_MASK: number;
                    /** @deprecated */
                    static readonly BUTTON1_MASK: number;
                    /** @deprecated */
                    static readonly BUTTON2_MASK: number;
                    /** @deprecated */
                    static readonly BUTTON3_MASK: number;
                    static readonly SHIFT_DOWN_MASK: number;
                    static readonly CTRL_DOWN_MASK: number;
                    static readonly META_DOWN_MASK: number;
                    static readonly ALT_DOWN_MASK: number;
                    static readonly BUTTON1_DOWN_MASK: number;
                    static readonly BUTTON2_DOWN_MASK: number;
                    static readonly BUTTON3_DOWN_MASK: number;
                    static readonly ALT_GRAPH_DOWN_MASK: number;

                    static getMaskForButton(arg0: int): number;
                    static getModifiersExText(arg0: int): string;

                    isShiftDown(): boolean;
                    isControlDown(): boolean;
                    isMetaDown(): boolean;
                    isAltDown(): boolean;
                    isAltGraphDown(): boolean;
                    getWhen(): number;
                    /** @deprecated */
                    getModifiers(): number;
                    getModifiersEx(): number;
                    consume(): void;
                    isConsumed(): boolean;

                }

                abstract class MouseWheelListener extends java.lang.Interface {
                    static readonly class: JavaClass<MouseWheelListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface MouseWheelListener extends java.util.EventListener {

                    mouseWheelMoved(arg0: MouseWheelEvent): void;

                }

                abstract class MouseMotionListener extends java.lang.Interface {
                    static readonly class: JavaClass<MouseMotionListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface MouseMotionListener extends java.util.EventListener {

                    mouseDragged(arg0: MouseEvent): void;
                    mouseMoved(arg0: MouseEvent): void;

                }

                abstract class FocusEvent$Cause extends java.lang.Enum<FocusEvent$Cause> {
                    static readonly class: JavaClass<FocusEvent$Cause>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly UNKNOWN: FocusEvent$Cause;
                    static readonly MOUSE_EVENT: FocusEvent$Cause;
                    static readonly TRAVERSAL: FocusEvent$Cause;
                    static readonly TRAVERSAL_UP: FocusEvent$Cause;
                    static readonly TRAVERSAL_DOWN: FocusEvent$Cause;
                    static readonly TRAVERSAL_FORWARD: FocusEvent$Cause;
                    static readonly TRAVERSAL_BACKWARD: FocusEvent$Cause;
                    static readonly ROLLBACK: FocusEvent$Cause;
                    static readonly UNEXPECTED: FocusEvent$Cause;
                    static readonly ACTIVATION: FocusEvent$Cause;
                    static readonly CLEAR_GLOBAL_FOCUS_OWNER: FocusEvent$Cause;

                    static values(): JavaArray<FocusEvent$Cause>;
                    static valueOf(arg0: string): FocusEvent$Cause;

                }

                abstract class HierarchyListener extends java.lang.Interface {
                    static readonly class: JavaClass<HierarchyListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface HierarchyListener extends java.util.EventListener {

                    hierarchyChanged(arg0: HierarchyEvent): void;

                }

                abstract class HierarchyBoundsListener extends java.lang.Interface {
                    static readonly class: JavaClass<HierarchyBoundsListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface HierarchyBoundsListener extends java.util.EventListener {

                    ancestorMoved(arg0: HierarchyEvent): void;
                    ancestorResized(arg0: HierarchyEvent): void;

                }

                abstract class MouseListener extends java.lang.Interface {
                    static readonly class: JavaClass<MouseListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface MouseListener extends java.util.EventListener {

                    mouseClicked(arg0: MouseEvent): void;
                    mousePressed(arg0: MouseEvent): void;
                    mouseReleased(arg0: MouseEvent): void;
                    mouseEntered(arg0: MouseEvent): void;
                    mouseExited(arg0: MouseEvent): void;

                }

                abstract class FocusListener extends java.lang.Interface {
                    static readonly class: JavaClass<FocusListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface FocusListener extends java.util.EventListener {

                    focusGained(arg0: FocusEvent): void;
                    focusLost(arg0: FocusEvent): void;

                }

                abstract class KeyListener extends java.lang.Interface {
                    static readonly class: JavaClass<KeyListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface KeyListener extends java.util.EventListener {

                    keyTyped(arg0: KeyEvent): void;
                    keyPressed(arg0: KeyEvent): void;
                    keyReleased(arg0: KeyEvent): void;

                }

                abstract class ContainerListener extends java.lang.Interface {
                    static readonly class: JavaClass<ContainerListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ContainerListener extends java.util.EventListener {

                    componentAdded(arg0: ContainerEvent): void;
                    componentRemoved(arg0: ContainerEvent): void;

                }

                abstract class ComponentListener extends java.lang.Interface {
                    static readonly class: JavaClass<ComponentListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ComponentListener extends java.util.EventListener {

                    componentResized(arg0: ComponentEvent): void;
                    componentMoved(arg0: ComponentEvent): void;
                    componentShown(arg0: ComponentEvent): void;
                    componentHidden(arg0: ComponentEvent): void;

                }

                class MouseEvent extends InputEvent {
                    static readonly class: JavaClass<MouseEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly MOUSE_FIRST: number;
                    static readonly MOUSE_LAST: number;
                    static readonly MOUSE_CLICKED: number;
                    static readonly MOUSE_PRESSED: number;
                    static readonly MOUSE_RELEASED: number;
                    static readonly MOUSE_MOVED: number;
                    static readonly MOUSE_ENTERED: number;
                    static readonly MOUSE_EXITED: number;
                    static readonly MOUSE_DRAGGED: number;
                    static readonly MOUSE_WHEEL: number;
                    static readonly NOBUTTON: number;
                    static readonly BUTTON1: number;
                    static readonly BUTTON2: number;
                    static readonly BUTTON3: number;

                    static getMouseModifiersText(arg0: int): string;

                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: boolean, arg8: int);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: boolean);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: boolean, arg10: int);

                    getLocationOnScreen(): java.awt.Point;
                    getXOnScreen(): number;
                    getYOnScreen(): number;
                    getModifiersEx(): number;
                    getX(): number;
                    getY(): number;
                    getPoint(): java.awt.Point;
                    translatePoint(arg0: int, arg1: int): void;
                    getClickCount(): number;
                    getButton(): number;
                    isPopupTrigger(): boolean;
                    paramString(): string;

                }

                class HierarchyEvent extends java.awt.AWTEvent {
                    static readonly class: JavaClass<HierarchyEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly HIERARCHY_FIRST: number;
                    static readonly HIERARCHY_CHANGED: number;
                    static readonly ANCESTOR_MOVED: number;
                    static readonly ANCESTOR_RESIZED: number;
                    static readonly HIERARCHY_LAST: number;
                    static readonly PARENT_CHANGED: number;
                    static readonly DISPLAYABILITY_CHANGED: number;
                    static readonly SHOWING_CHANGED: number;

                    constructor (arg0: java.awt.Component, arg1: int, arg2: java.awt.Component, arg3: java.awt.Container);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: java.awt.Component, arg3: java.awt.Container, arg4: long);

                    getComponent(): java.awt.Component;
                    getChanged(): java.awt.Component;
                    getChangedParent(): java.awt.Container;
                    getChangeFlags(): number;
                    paramString(): string;

                }

                class ContainerEvent extends ComponentEvent {
                    static readonly class: JavaClass<ContainerEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly CONTAINER_FIRST: number;
                    static readonly CONTAINER_LAST: number;
                    static readonly COMPONENT_ADDED: number;
                    static readonly COMPONENT_REMOVED: number;

                    constructor (arg0: java.awt.Component, arg1: int, arg2: java.awt.Component);

                    getContainer(): java.awt.Container;
                    getChild(): java.awt.Component;
                    paramString(): string;

                }

                class InputMethodEvent extends java.awt.AWTEvent {
                    static readonly class: JavaClass<InputMethodEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly INPUT_METHOD_FIRST: number;
                    static readonly INPUT_METHOD_TEXT_CHANGED: number;
                    static readonly CARET_POSITION_CHANGED: number;
                    static readonly INPUT_METHOD_LAST: number;

                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: java.text.AttributedCharacterIterator, arg4: int, arg5: java.awt.font.TextHitInfo, arg6: java.awt.font.TextHitInfo);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: java.text.AttributedCharacterIterator, arg3: int, arg4: java.awt.font.TextHitInfo, arg5: java.awt.font.TextHitInfo);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: java.awt.font.TextHitInfo, arg3: java.awt.font.TextHitInfo);

                    getText(): java.text.AttributedCharacterIterator;
                    getCommittedCharacterCount(): number;
                    getCaret(): java.awt.font.TextHitInfo;
                    getVisiblePosition(): java.awt.font.TextHitInfo;
                    consume(): void;
                    isConsumed(): boolean;
                    getWhen(): number;
                    paramString(): string;

                }

                class FocusEvent extends ComponentEvent {
                    static readonly class: JavaClass<FocusEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly FOCUS_FIRST: number;
                    static readonly FOCUS_LAST: number;
                    static readonly FOCUS_GAINED: number;
                    static readonly FOCUS_LOST: number;

                    constructor (arg0: java.awt.Component, arg1: int, arg2: boolean, arg3: java.awt.Component);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: boolean, arg3: java.awt.Component, arg4: FocusEvent$Cause);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: boolean);
                    constructor (arg0: java.awt.Component, arg1: int);

                    isTemporary(): boolean;
                    getOppositeComponent(): java.awt.Component;
                    paramString(): string;
                    getCause(): FocusEvent$Cause;

                }

                class MouseWheelEvent extends MouseEvent {
                    static readonly class: JavaClass<MouseWheelEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly WHEEL_UNIT_SCROLL: number;
                    static readonly WHEEL_BLOCK_SCROLL: number;

                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: boolean, arg8: int, arg9: int, arg10: int);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: boolean, arg10: int, arg11: int, arg12: int);
                    constructor (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: boolean, arg10: int, arg11: int, arg12: int, arg13: double);

                    getScrollType(): number;
                    getScrollAmount(): number;
                    getWheelRotation(): number;
                    getPreciseWheelRotation(): number;
                    getUnitsToScroll(): number;
                    paramString(): string;

                }

                abstract class ActionListener extends java.lang.Interface {
                    static readonly class: JavaClass<ActionListener>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ActionListener extends java.util.EventListener {

                    actionPerformed(arg0: ActionEvent): void;

                }

                class ActionEvent extends java.awt.AWTEvent {
                    static readonly class: JavaClass<ActionEvent>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly SHIFT_MASK: number;
                    static readonly CTRL_MASK: number;
                    static readonly META_MASK: number;
                    static readonly ALT_MASK: number;
                    static readonly ACTION_FIRST: number;
                    static readonly ACTION_LAST: number;
                    static readonly ACTION_PERFORMED: number;

                    constructor (arg0: any, arg1: int, arg2: string);
                    constructor (arg0: any, arg1: int, arg2: string, arg3: int);
                    constructor (arg0: any, arg1: int, arg2: string, arg3: long, arg4: int);

                    getActionCommand(): string;
                    getWhen(): number;
                    getModifiers(): number;
                    paramString(): string;

                }

                export {
                    WindowListener,
                    WindowStateListener,
                    WindowFocusListener,
                    WindowEvent,
                    ComponentEvent,
                    KeyEvent,
                    InputMethodListener,
                    AWTEventListener,
                    InputEvent,
                    MouseWheelListener,
                    MouseMotionListener,
                    FocusEvent$Cause,
                    HierarchyListener,
                    HierarchyBoundsListener,
                    MouseListener,
                    FocusListener,
                    KeyListener,
                    ContainerListener,
                    ComponentListener,
                    MouseEvent,
                    HierarchyEvent,
                    ContainerEvent,
                    InputMethodEvent,
                    FocusEvent,
                    MouseWheelEvent,
                    ActionListener,
                    ActionEvent
                }

            }

            namespace font {

                interface GlyphVector extends java.lang.Cloneable {}
                abstract class GlyphVector extends java.lang.Object {
                    static readonly class: JavaClass<GlyphVector>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly FLAG_HAS_TRANSFORMS: number;
                    static readonly FLAG_HAS_POSITION_ADJUSTMENTS: number;
                    static readonly FLAG_RUN_RTL: number;
                    static readonly FLAG_COMPLEX_GLYPHS: number;
                    static readonly FLAG_MASK: number;

                    getFont(): java.awt.Font;
                    getFontRenderContext(): FontRenderContext;
                    performDefaultLayout(): void;
                    getNumGlyphs(): number;
                    getGlyphCode(arg0: int): number;
                    getGlyphCodes(arg0: int, arg1: int, arg2: int[]): JavaArray<number>;
                    getGlyphCharIndex(arg0: int): number;
                    getGlyphCharIndices(arg0: int, arg1: int, arg2: int[]): JavaArray<number>;
                    getLogicalBounds(): java.awt.geom.Rectangle2D;
                    getVisualBounds(): java.awt.geom.Rectangle2D;
                    getPixelBounds(arg0: FontRenderContext, arg1: float, arg2: float): java.awt.Rectangle;
                    getOutline(): java.awt.Shape;
                    getOutline(arg0: float, arg1: float): java.awt.Shape;
                    getGlyphOutline(arg0: int): java.awt.Shape;
                    getGlyphOutline(arg0: int, arg1: float, arg2: float): java.awt.Shape;
                    getGlyphPosition(arg0: int): java.awt.geom.Point2D;
                    setGlyphPosition(arg0: int, arg1: java.awt.geom.Point2D): void;
                    getGlyphTransform(arg0: int): java.awt.geom.AffineTransform;
                    setGlyphTransform(arg0: int, arg1: java.awt.geom.AffineTransform): void;
                    getLayoutFlags(): number;
                    getGlyphPositions(arg0: int, arg1: int, arg2: float[]): JavaArray<number>;
                    getGlyphLogicalBounds(arg0: int): java.awt.Shape;
                    getGlyphVisualBounds(arg0: int): java.awt.Shape;
                    getGlyphPixelBounds(arg0: int, arg1: FontRenderContext, arg2: float, arg3: float): java.awt.Rectangle;
                    getGlyphMetrics(arg0: int): GlyphMetrics;
                    getGlyphJustificationInfo(arg0: int): GlyphJustificationInfo;
                    equals(arg0: GlyphVector): boolean;
                    equals(arg0: any): boolean;

                }

                class FontRenderContext extends java.lang.Object {
                    static readonly class: JavaClass<FontRenderContext>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: java.awt.geom.AffineTransform, arg1: boolean, arg2: boolean);
                    constructor (arg0: java.awt.geom.AffineTransform, arg1: any, arg2: any);

                    isTransformed(): boolean;
                    getTransformType(): number;
                    getTransform(): java.awt.geom.AffineTransform;
                    isAntiAliased(): boolean;
                    usesFractionalMetrics(): boolean;
                    getAntiAliasingHint(): any;
                    getFractionalMetricsHint(): any;
                    equals(arg0: FontRenderContext): boolean;
                    equals(arg0: any): boolean;

                }

                class GlyphMetrics extends java.lang.Object {
                    static readonly class: JavaClass<GlyphMetrics>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly STANDARD: number;
                    static readonly LIGATURE: number;
                    static readonly COMBINING: number;
                    static readonly COMPONENT: number;
                    static readonly WHITESPACE: number;

                    constructor (arg0: float, arg1: java.awt.geom.Rectangle2D, arg2: byte);
                    constructor (arg0: boolean, arg1: float, arg2: float, arg3: java.awt.geom.Rectangle2D, arg4: byte);

                    getAdvance(): number;
                    getAdvanceX(): number;
                    getAdvanceY(): number;
                    getBounds2D(): java.awt.geom.Rectangle2D;
                    getLSB(): number;
                    getRSB(): number;
                    getType(): number;
                    isStandard(): boolean;
                    isLigature(): boolean;
                    isCombining(): boolean;
                    isComponent(): boolean;
                    isWhitespace(): boolean;

                }

                class GlyphJustificationInfo extends java.lang.Object {
                    static readonly class: JavaClass<GlyphJustificationInfo>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly PRIORITY_KASHIDA: number;
                    static readonly PRIORITY_WHITESPACE: number;
                    static readonly PRIORITY_INTERCHAR: number;
                    static readonly PRIORITY_NONE: number;

                    constructor (arg0: float, arg1: boolean, arg2: int, arg3: float, arg4: float, arg5: boolean, arg6: int, arg7: float, arg8: float);

                    readonly weight: number;
                    readonly growPriority: number;
                    readonly growAbsorb: boolean;
                    readonly growLeftLimit: number;
                    readonly growRightLimit: number;
                    readonly shrinkPriority: number;
                    readonly shrinkAbsorb: boolean;
                    readonly shrinkLeftLimit: number;
                    readonly shrinkRightLimit: number;
                }

                abstract class TextAttribute extends java.text.AttributedCharacterIterator$Attribute {
                    static readonly class: JavaClass<TextAttribute>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly FAMILY: TextAttribute;
                    static readonly WEIGHT: TextAttribute;
                    static readonly WEIGHT_EXTRA_LIGHT: number;
                    static readonly WEIGHT_LIGHT: number;
                    static readonly WEIGHT_DEMILIGHT: number;
                    static readonly WEIGHT_REGULAR: number;
                    static readonly WEIGHT_SEMIBOLD: number;
                    static readonly WEIGHT_MEDIUM: number;
                    static readonly WEIGHT_DEMIBOLD: number;
                    static readonly WEIGHT_BOLD: number;
                    static readonly WEIGHT_HEAVY: number;
                    static readonly WEIGHT_EXTRABOLD: number;
                    static readonly WEIGHT_ULTRABOLD: number;
                    static readonly WIDTH: TextAttribute;
                    static readonly WIDTH_CONDENSED: number;
                    static readonly WIDTH_SEMI_CONDENSED: number;
                    static readonly WIDTH_REGULAR: number;
                    static readonly WIDTH_SEMI_EXTENDED: number;
                    static readonly WIDTH_EXTENDED: number;
                    static readonly POSTURE: TextAttribute;
                    static readonly POSTURE_REGULAR: number;
                    static readonly POSTURE_OBLIQUE: number;
                    static readonly SIZE: TextAttribute;
                    static readonly TRANSFORM: TextAttribute;
                    static readonly SUPERSCRIPT: TextAttribute;
                    static readonly SUPERSCRIPT_SUPER: number;
                    static readonly SUPERSCRIPT_SUB: number;
                    static readonly FONT: TextAttribute;
                    static readonly CHAR_REPLACEMENT: TextAttribute;
                    static readonly FOREGROUND: TextAttribute;
                    static readonly BACKGROUND: TextAttribute;
                    static readonly UNDERLINE: TextAttribute;
                    static readonly UNDERLINE_ON: number;
                    static readonly STRIKETHROUGH: TextAttribute;
                    static readonly STRIKETHROUGH_ON: boolean;
                    static readonly RUN_DIRECTION: TextAttribute;
                    static readonly RUN_DIRECTION_LTR: boolean;
                    static readonly RUN_DIRECTION_RTL: boolean;
                    static readonly BIDI_EMBEDDING: TextAttribute;
                    static readonly JUSTIFICATION: TextAttribute;
                    static readonly JUSTIFICATION_FULL: number;
                    static readonly JUSTIFICATION_NONE: number;
                    static readonly INPUT_METHOD_HIGHLIGHT: TextAttribute;
                    static readonly INPUT_METHOD_UNDERLINE: TextAttribute;
                    static readonly UNDERLINE_LOW_ONE_PIXEL: number;
                    static readonly UNDERLINE_LOW_TWO_PIXEL: number;
                    static readonly UNDERLINE_LOW_DOTTED: number;
                    static readonly UNDERLINE_LOW_GRAY: number;
                    static readonly UNDERLINE_LOW_DASHED: number;
                    static readonly SWAP_COLORS: TextAttribute;
                    static readonly SWAP_COLORS_ON: boolean;
                    static readonly NUMERIC_SHAPING: TextAttribute;
                    static readonly KERNING: TextAttribute;
                    static readonly KERNING_ON: number;
                    static readonly LIGATURES: TextAttribute;
                    static readonly LIGATURES_ON: number;
                    static readonly TRACKING: TextAttribute;
                    static readonly TRACKING_TIGHT: number;
                    static readonly TRACKING_LOOSE: number;
                }

                abstract class LineMetrics extends java.lang.Object {
                    static readonly class: JavaClass<LineMetrics>;
                    /** @deprecated */ static prototype: undefined;

                    getNumChars(): number;
                    getAscent(): number;
                    getDescent(): number;
                    getLeading(): number;
                    getHeight(): number;
                    getBaselineIndex(): number;
                    getBaselineOffsets(): JavaArray<number>;
                    getStrikethroughOffset(): number;
                    getStrikethroughThickness(): number;
                    getUnderlineOffset(): number;
                    getUnderlineThickness(): number;

                }

                abstract class TextHitInfo extends java.lang.Object {
                    static readonly class: JavaClass<TextHitInfo>;
                    /** @deprecated */ static prototype: undefined;

                    static leading(arg0: int): TextHitInfo;
                    static trailing(arg0: int): TextHitInfo;
                    static beforeOffset(arg0: int): TextHitInfo;
                    static afterOffset(arg0: int): TextHitInfo;

                    getCharIndex(): number;
                    isLeadingEdge(): boolean;
                    getInsertionIndex(): number;
                    equals(arg0: TextHitInfo): boolean;
                    equals(arg0: any): boolean;
                    getOtherHit(): TextHitInfo;
                    getOffsetHit(arg0: int): TextHitInfo;

                }

                export {
                    GlyphVector,
                    FontRenderContext,
                    GlyphMetrics,
                    GlyphJustificationInfo,
                    TextAttribute,
                    LineMetrics,
                    TextHitInfo
                }

            }

            namespace geom {

                abstract class Rectangle2D extends RectangularShape {
                    static readonly class: JavaClass<Rectangle2D>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly OUT_LEFT: number;
                    static readonly OUT_TOP: number;
                    static readonly OUT_RIGHT: number;
                    static readonly OUT_BOTTOM: number;

                    static intersect(arg0: Rectangle2D, arg1: Rectangle2D, arg2: Rectangle2D): void;
                    static union(arg0: Rectangle2D, arg1: Rectangle2D, arg2: Rectangle2D): void;

                    setRect(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setRect(arg0: Rectangle2D): void;
                    intersectsLine(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersectsLine(arg0: Line2D): boolean;
                    outcode(arg0: double, arg1: double): number;
                    outcode(arg0: Point2D): number;
                    setFrame(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setFrame(arg0: Point2D, arg1: Dimension2D): void;
                    setFrame(arg0: Rectangle2D): void;
                    getBounds2D(): Rectangle2D;
                    contains(arg0: double, arg1: double): boolean;
                    contains(arg0: Point2D): boolean;
                    contains(arg0: Rectangle2D): boolean;
                    intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersects(arg0: Rectangle2D): boolean;
                    contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    createIntersection(arg0: Rectangle2D): Rectangle2D;
                    createUnion(arg0: Rectangle2D): Rectangle2D;
                    add(arg0: double, arg1: double): void;
                    add(arg0: Point2D): void;
                    add(arg0: Rectangle2D): void;
                    getPathIterator(arg0: AffineTransform): PathIterator;
                    getPathIterator(arg0: AffineTransform, arg1: double): PathIterator;

                }

                interface RectangularShape extends java.lang.Cloneable, java.awt.Shape {}
                abstract class RectangularShape extends java.lang.Object {
                    static readonly class: JavaClass<RectangularShape>;
                    /** @deprecated */ static prototype: undefined;

                    getX(): number;
                    getY(): number;
                    getWidth(): number;
                    getHeight(): number;
                    getMinX(): number;
                    getMinY(): number;
                    getMaxX(): number;
                    getMaxY(): number;
                    getCenterX(): number;
                    getCenterY(): number;
                    getFrame(): Rectangle2D;
                    isEmpty(): boolean;
                    setFrame(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setFrame(arg0: Point2D, arg1: Dimension2D): void;
                    setFrame(arg0: Rectangle2D): void;
                    setFrameFromDiagonal(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setFrameFromDiagonal(arg0: Point2D, arg1: Point2D): void;
                    setFrameFromCenter(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setFrameFromCenter(arg0: Point2D, arg1: Point2D): void;
                    contains(arg0: Point2D): boolean;
                    contains(arg0: double, arg1: double): boolean;
                    contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersects(arg0: Rectangle2D): boolean;
                    intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    contains(arg0: Rectangle2D): boolean;
                    getBounds(): java.awt.Rectangle;
                    getPathIterator(arg0: AffineTransform, arg1: double): PathIterator;
                    getPathIterator(arg0: AffineTransform): PathIterator;
                    clone(): any;

                }

                interface Point2D extends java.lang.Cloneable {}
                abstract class Point2D extends java.lang.Object {
                    static readonly class: JavaClass<Point2D>;
                    /** @deprecated */ static prototype: undefined;

                    static distanceSq(arg0: double, arg1: double, arg2: double, arg3: double): number;
                    static distance(arg0: double, arg1: double, arg2: double, arg3: double): number;

                    getX(): number;
                    getY(): number;
                    setLocation(arg0: double, arg1: double): void;
                    setLocation(arg0: Point2D): void;
                    distanceSq(arg0: double, arg1: double): number;
                    distanceSq(arg0: Point2D): number;
                    distance(arg0: double, arg1: double): number;
                    distance(arg0: Point2D): number;
                    clone(): any;

                }

                interface AffineTransform extends java.lang.Cloneable, java.io.Serializable {}
                class AffineTransform extends java.lang.Object {
                    static readonly class: JavaClass<AffineTransform>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly TYPE_IDENTITY: number;
                    static readonly TYPE_TRANSLATION: number;
                    static readonly TYPE_UNIFORM_SCALE: number;
                    static readonly TYPE_GENERAL_SCALE: number;
                    static readonly TYPE_MASK_SCALE: number;
                    static readonly TYPE_FLIP: number;
                    static readonly TYPE_QUADRANT_ROTATION: number;
                    static readonly TYPE_GENERAL_ROTATION: number;
                    static readonly TYPE_MASK_ROTATION: number;
                    static readonly TYPE_GENERAL_TRANSFORM: number;

                    static getTranslateInstance(arg0: double, arg1: double): AffineTransform;
                    static getRotateInstance(arg0: double): AffineTransform;
                    static getRotateInstance(arg0: double, arg1: double, arg2: double): AffineTransform;
                    static getRotateInstance(arg0: double, arg1: double): AffineTransform;
                    static getRotateInstance(arg0: double, arg1: double, arg2: double, arg3: double): AffineTransform;
                    static getQuadrantRotateInstance(arg0: int): AffineTransform;
                    static getQuadrantRotateInstance(arg0: int, arg1: double, arg2: double): AffineTransform;
                    static getScaleInstance(arg0: double, arg1: double): AffineTransform;
                    static getShearInstance(arg0: double, arg1: double): AffineTransform;

                    constructor ();
                    constructor (arg0: AffineTransform);
                    constructor (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float);
                    constructor (arg0: float[]);
                    constructor (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double);
                    constructor (arg0: double[]);

                    getType(): number;
                    getDeterminant(): number;
                    getMatrix(arg0: double[]): void;
                    getScaleX(): number;
                    getScaleY(): number;
                    getShearX(): number;
                    getShearY(): number;
                    getTranslateX(): number;
                    getTranslateY(): number;
                    translate(arg0: double, arg1: double): void;
                    rotate(arg0: double): void;
                    rotate(arg0: double, arg1: double, arg2: double): void;
                    rotate(arg0: double, arg1: double): void;
                    rotate(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    quadrantRotate(arg0: int): void;
                    quadrantRotate(arg0: int, arg1: double, arg2: double): void;
                    scale(arg0: double, arg1: double): void;
                    shear(arg0: double, arg1: double): void;
                    setToIdentity(): void;
                    setToTranslation(arg0: double, arg1: double): void;
                    setToRotation(arg0: double): void;
                    setToRotation(arg0: double, arg1: double, arg2: double): void;
                    setToRotation(arg0: double, arg1: double): void;
                    setToRotation(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setToQuadrantRotation(arg0: int): void;
                    setToQuadrantRotation(arg0: int, arg1: double, arg2: double): void;
                    setToScale(arg0: double, arg1: double): void;
                    setToShear(arg0: double, arg1: double): void;
                    setTransform(arg0: AffineTransform): void;
                    setTransform(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): void;
                    concatenate(arg0: AffineTransform): void;
                    preConcatenate(arg0: AffineTransform): void;
                    createInverse(): AffineTransform;
                    invert(): void;
                    transform(arg0: Point2D, arg1: Point2D): Point2D;
                    transform(arg0: Point2D[], arg1: int, arg2: Point2D[], arg3: int, arg4: int): void;
                    transform(arg0: float[], arg1: int, arg2: float[], arg3: int, arg4: int): void;
                    transform(arg0: double[], arg1: int, arg2: double[], arg3: int, arg4: int): void;
                    transform(arg0: float[], arg1: int, arg2: double[], arg3: int, arg4: int): void;
                    transform(arg0: double[], arg1: int, arg2: float[], arg3: int, arg4: int): void;
                    inverseTransform(arg0: Point2D, arg1: Point2D): Point2D;
                    inverseTransform(arg0: double[], arg1: int, arg2: double[], arg3: int, arg4: int): void;
                    deltaTransform(arg0: Point2D, arg1: Point2D): Point2D;
                    deltaTransform(arg0: double[], arg1: int, arg2: double[], arg3: int, arg4: int): void;
                    createTransformedShape(arg0: java.awt.Shape): java.awt.Shape;
                    isIdentity(): boolean;
                    clone(): any;

                }

                interface Line2D extends java.lang.Cloneable, java.awt.Shape {}
                abstract class Line2D extends java.lang.Object {
                    static readonly class: JavaClass<Line2D>;
                    /** @deprecated */ static prototype: undefined;

                    static relativeCCW(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                    static linesIntersect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): boolean;
                    static ptSegDistSq(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                    static ptSegDist(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                    static ptLineDistSq(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                    static ptLineDist(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;

                    getX1(): number;
                    getY1(): number;
                    getP1(): Point2D;
                    getX2(): number;
                    getY2(): number;
                    getP2(): Point2D;
                    setLine(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setLine(arg0: Point2D, arg1: Point2D): void;
                    setLine(arg0: Line2D): void;
                    relativeCCW(arg0: double, arg1: double): number;
                    relativeCCW(arg0: Point2D): number;
                    intersectsLine(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersectsLine(arg0: Line2D): boolean;
                    ptSegDistSq(arg0: double, arg1: double): number;
                    ptSegDistSq(arg0: Point2D): number;
                    ptSegDist(arg0: double, arg1: double): number;
                    ptSegDist(arg0: Point2D): number;
                    ptLineDistSq(arg0: double, arg1: double): number;
                    ptLineDistSq(arg0: Point2D): number;
                    ptLineDist(arg0: double, arg1: double): number;
                    ptLineDist(arg0: Point2D): number;
                    contains(arg0: double, arg1: double): boolean;
                    contains(arg0: Point2D): boolean;
                    intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersects(arg0: Rectangle2D): boolean;
                    contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    contains(arg0: Rectangle2D): boolean;
                    getBounds(): java.awt.Rectangle;
                    getPathIterator(arg0: AffineTransform): PathIterator;
                    getPathIterator(arg0: AffineTransform, arg1: double): PathIterator;
                    clone(): any;

                }

                abstract class PathIterator extends java.lang.Interface {
                    static readonly class: JavaClass<PathIterator>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly WIND_EVEN_ODD: number;
                    static readonly WIND_NON_ZERO: number;
                    static readonly SEG_MOVETO: number;
                    static readonly SEG_LINETO: number;
                    static readonly SEG_QUADTO: number;
                    static readonly SEG_CUBICTO: number;
                    static readonly SEG_CLOSE: number;
                }
                interface PathIterator {

                    getWindingRule(): number;
                    isDone(): boolean;
                    next(): void;
                    currentSegment(arg0: float[]): number;
                    currentSegment(arg0: double[]): number;

                }

                interface Dimension2D extends java.lang.Cloneable {}
                abstract class Dimension2D extends java.lang.Object {
                    static readonly class: JavaClass<Dimension2D>;
                    /** @deprecated */ static prototype: undefined;

                    getWidth(): number;
                    getHeight(): number;
                    setSize(arg0: double, arg1: double): void;
                    setSize(arg0: Dimension2D): void;
                    clone(): any;

                }

                export {
                    Rectangle2D,
                    RectangularShape,
                    Point2D,
                    AffineTransform,
                    Line2D,
                    PathIterator,
                    Dimension2D
                }

            }

            namespace im {

                abstract class InputContext extends java.lang.Object {
                    static readonly class: JavaClass<InputContext>;
                    /** @deprecated */ static prototype: undefined;

                    static getInstance(): InputContext;

                    selectInputMethod(arg0: java.util.Locale): boolean;
                    getLocale(): java.util.Locale;
                    setCharacterSubsets(arg0: java.lang.Character$Subset[]): void;
                    setCompositionEnabled(arg0: boolean): void;
                    isCompositionEnabled(): boolean;
                    reconvert(): void;
                    dispatchEvent(arg0: java.awt.AWTEvent): void;
                    removeNotify(arg0: java.awt.Component): void;
                    endComposition(): void;
                    dispose(): void;
                    getInputMethodControlObject(): any;

                }

                abstract class InputMethodRequests extends java.lang.Interface {
                    static readonly class: JavaClass<InputMethodRequests>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface InputMethodRequests {

                    getTextLocation(arg0: java.awt.font.TextHitInfo): java.awt.Rectangle;
                    getLocationOffset(arg0: int, arg1: int): java.awt.font.TextHitInfo;
                    getInsertPositionOffset(): number;
                    getCommittedText(arg0: int, arg1: int, arg2: java.text.AttributedCharacterIterator$Attribute[]): java.text.AttributedCharacterIterator;
                    getCommittedTextLength(): number;
                    cancelLatestCommittedText(arg0: java.text.AttributedCharacterIterator$Attribute[]): java.text.AttributedCharacterIterator;
                    getSelectedText(arg0: java.text.AttributedCharacterIterator$Attribute[]): java.text.AttributedCharacterIterator;

                }

                class InputMethodHighlight extends java.lang.Object {
                    static readonly class: JavaClass<InputMethodHighlight>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly RAW_TEXT: number;
                    static readonly CONVERTED_TEXT: number;
                    static readonly UNSELECTED_RAW_TEXT_HIGHLIGHT: InputMethodHighlight;
                    static readonly SELECTED_RAW_TEXT_HIGHLIGHT: InputMethodHighlight;
                    static readonly UNSELECTED_CONVERTED_TEXT_HIGHLIGHT: InputMethodHighlight;
                    static readonly SELECTED_CONVERTED_TEXT_HIGHLIGHT: InputMethodHighlight;

                    constructor (arg0: boolean, arg1: int);
                    constructor (arg0: boolean, arg1: int, arg2: int);
                    constructor (arg0: boolean, arg1: int, arg2: int, arg3: JavaMap<java.awt.font.TextAttribute, any>);

                    isSelected(): boolean;
                    getState(): number;
                    getVariation(): number;
                    getStyle(): JavaMap<java.awt.font.TextAttribute, any>;

                }

                export { InputContext, InputMethodRequests, InputMethodHighlight }

            }

            namespace image {

                abstract class ImageProducer extends java.lang.Interface {
                    static readonly class: JavaClass<ImageProducer>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ImageProducer {

                    addConsumer(arg0: ImageConsumer): void;
                    isConsumer(arg0: ImageConsumer): boolean;
                    removeConsumer(arg0: ImageConsumer): void;
                    startProduction(arg0: ImageConsumer): void;
                    requestTopDownLeftRightResend(arg0: ImageConsumer): void;

                }

                abstract class ImageObserver extends java.lang.Interface {
                    static readonly class: JavaClass<ImageObserver>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly WIDTH: number;
                    static readonly HEIGHT: number;
                    static readonly PROPERTIES: number;
                    static readonly SOMEBITS: number;
                    static readonly FRAMEBITS: number;
                    static readonly ALLBITS: number;
                    static readonly ERROR: number;
                    static readonly ABORT: number;
                }
                interface ImageObserver {

                    imageUpdate(arg0: java.awt.Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): boolean;

                }

                interface BufferedImage extends java.awt.Transparency, WritableRenderedImage {}
                class BufferedImage extends java.awt.Image {
                    static readonly class: JavaClass<BufferedImage>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly TYPE_CUSTOM: number;
                    static readonly TYPE_INT_RGB: number;
                    static readonly TYPE_INT_ARGB: number;
                    static readonly TYPE_INT_ARGB_PRE: number;
                    static readonly TYPE_INT_BGR: number;
                    static readonly TYPE_3BYTE_BGR: number;
                    static readonly TYPE_4BYTE_ABGR: number;
                    static readonly TYPE_4BYTE_ABGR_PRE: number;
                    static readonly TYPE_USHORT_565_RGB: number;
                    static readonly TYPE_USHORT_555_RGB: number;
                    static readonly TYPE_BYTE_GRAY: number;
                    static readonly TYPE_USHORT_GRAY: number;
                    static readonly TYPE_BYTE_BINARY: number;
                    static readonly TYPE_BYTE_INDEXED: number;

                    constructor (arg0: int, arg1: int, arg2: int);
                    constructor (arg0: int, arg1: int, arg2: int, arg3: IndexColorModel);
                    constructor (arg0: ColorModel, arg1: WritableRaster, arg2: boolean, arg3: java.util.Hashtable<any, any>);

                    getType(): number;
                    getColorModel(): ColorModel;
                    getRaster(): WritableRaster;
                    getAlphaRaster(): WritableRaster;
                    getRGB(arg0: int, arg1: int): number;
                    getRGB(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: int, arg6: int): JavaArray<number>;
                    setRGB(arg0: int, arg1: int, arg2: int): void;
                    setRGB(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: int, arg6: int): void;
                    getWidth(): number;
                    getHeight(): number;
                    getWidth(arg0: ImageObserver): number;
                    getHeight(arg0: ImageObserver): number;
                    getSource(): ImageProducer;
                    getProperty(arg0: string, arg1: ImageObserver): any;
                    getProperty(arg0: string): any;
                    getGraphics(): java.awt.Graphics;
                    createGraphics(): java.awt.Graphics2D;
                    getSubimage(arg0: int, arg1: int, arg2: int, arg3: int): BufferedImage;
                    isAlphaPremultiplied(): boolean;
                    coerceData(arg0: boolean): void;
                    getSources(): java.util.Vector<RenderedImage>;
                    getPropertyNames(): JavaArray<string>;
                    getMinX(): number;
                    getMinY(): number;
                    getSampleModel(): SampleModel;
                    getNumXTiles(): number;
                    getNumYTiles(): number;
                    getMinTileX(): number;
                    getMinTileY(): number;
                    getTileWidth(): number;
                    getTileHeight(): number;
                    getTileGridXOffset(): number;
                    getTileGridYOffset(): number;
                    getTile(arg0: int, arg1: int): Raster;
                    getData(): Raster;
                    getData(arg0: java.awt.Rectangle): Raster;
                    copyData(arg0: WritableRaster): WritableRaster;
                    setData(arg0: Raster): void;
                    addTileObserver(arg0: TileObserver): void;
                    removeTileObserver(arg0: TileObserver): void;
                    isTileWritable(arg0: int, arg1: int): boolean;
                    getWritableTileIndices(): JavaArray<java.awt.Point>;
                    hasTileWriters(): boolean;
                    getWritableTile(arg0: int, arg1: int): WritableRaster;
                    releaseWritableTile(arg0: int, arg1: int): void;
                    getTransparency(): number;

                }

                abstract class WritableRaster extends Raster {
                    static readonly class: JavaClass<WritableRaster>;
                    /** @deprecated */ static prototype: undefined;

                    getWritableParent(): WritableRaster;
                    createWritableTranslatedChild(arg0: int, arg1: int): WritableRaster;
                    createWritableChild(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int[]): WritableRaster;
                    setDataElements(arg0: int, arg1: int, arg2: any): void;
                    setDataElements(arg0: int, arg1: int, arg2: Raster): void;
                    setDataElements(arg0: int, arg1: int, arg2: int, arg3: int, arg4: any): void;
                    setRect(arg0: Raster): void;
                    setRect(arg0: int, arg1: int, arg2: Raster): void;
                    setPixel(arg0: int, arg1: int, arg2: int[]): void;
                    setPixel(arg0: int, arg1: int, arg2: float[]): void;
                    setPixel(arg0: int, arg1: int, arg2: double[]): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[]): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: float[]): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: double[]): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: int): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: float): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: double): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[]): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: float[]): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: double[]): void;

                }

                abstract class ImageConsumer extends java.lang.Interface {
                    static readonly class: JavaClass<ImageConsumer>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly RANDOMPIXELORDER: number;
                    static readonly TOPDOWNLEFTRIGHT: number;
                    static readonly COMPLETESCANLINES: number;
                    static readonly SINGLEPASS: number;
                    static readonly SINGLEFRAME: number;
                    static readonly IMAGEERROR: number;
                    static readonly SINGLEFRAMEDONE: number;
                    static readonly STATICIMAGEDONE: number;
                    static readonly IMAGEABORTED: number;
                }
                interface ImageConsumer {

                    setDimensions(arg0: int, arg1: int): void;
                    setProperties(arg0: java.util.Hashtable<any, any>): void;
                    setColorModel(arg0: ColorModel): void;
                    setHints(arg0: int): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: ColorModel, arg5: byte[], arg6: int, arg7: int): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: ColorModel, arg5: int[], arg6: int, arg7: int): void;
                    imageComplete(arg0: int): void;

                }

                abstract class RenderedImage extends java.lang.Interface {
                    static readonly class: JavaClass<RenderedImage>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface RenderedImage {

                    getSources(): java.util.Vector<RenderedImage>;
                    getProperty(arg0: string): any;
                    getPropertyNames(): JavaArray<string>;
                    getColorModel(): ColorModel;
                    getSampleModel(): SampleModel;
                    getWidth(): number;
                    getHeight(): number;
                    getMinX(): number;
                    getMinY(): number;
                    getNumXTiles(): number;
                    getNumYTiles(): number;
                    getMinTileX(): number;
                    getMinTileY(): number;
                    getTileWidth(): number;
                    getTileHeight(): number;
                    getTileGridXOffset(): number;
                    getTileGridYOffset(): number;
                    getTile(arg0: int, arg1: int): Raster;
                    getData(): Raster;
                    getData(arg0: java.awt.Rectangle): Raster;
                    copyData(arg0: WritableRaster): WritableRaster;

                }

                class SampleModel extends java.lang.Object {
                    static readonly class: JavaClass<SampleModel>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: int, arg1: int, arg2: int, arg3: int);

                    getWidth(): number;
                    getHeight(): number;
                    getNumBands(): number;
                    getNumDataElements(): number;
                    getDataType(): number;
                    getTransferType(): number;
                    getPixel(arg0: int, arg1: int, arg2: int[], arg3: DataBuffer): JavaArray<number>;
                    getDataElements(arg0: int, arg1: int, arg2: any, arg3: DataBuffer): any;
                    getDataElements(arg0: int, arg1: int, arg2: int, arg3: int, arg4: any, arg5: DataBuffer): any;
                    setDataElements(arg0: int, arg1: int, arg2: any, arg3: DataBuffer): void;
                    setDataElements(arg0: int, arg1: int, arg2: int, arg3: int, arg4: any, arg5: DataBuffer): void;
                    getPixel(arg0: int, arg1: int, arg2: float[], arg3: DataBuffer): JavaArray<number>;
                    getPixel(arg0: int, arg1: int, arg2: double[], arg3: DataBuffer): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: DataBuffer): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: float[], arg5: DataBuffer): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: double[], arg5: DataBuffer): JavaArray<number>;
                    getSample(arg0: int, arg1: int, arg2: int, arg3: DataBuffer): number;
                    getSampleFloat(arg0: int, arg1: int, arg2: int, arg3: DataBuffer): number;
                    getSampleDouble(arg0: int, arg1: int, arg2: int, arg3: DataBuffer): number;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[], arg6: DataBuffer): JavaArray<number>;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: float[], arg6: DataBuffer): JavaArray<number>;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: double[], arg6: DataBuffer): JavaArray<number>;
                    setPixel(arg0: int, arg1: int, arg2: int[], arg3: DataBuffer): void;
                    setPixel(arg0: int, arg1: int, arg2: float[], arg3: DataBuffer): void;
                    setPixel(arg0: int, arg1: int, arg2: double[], arg3: DataBuffer): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: DataBuffer): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: float[], arg5: DataBuffer): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: double[], arg5: DataBuffer): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: int, arg4: DataBuffer): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: float, arg4: DataBuffer): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: double, arg4: DataBuffer): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[], arg6: DataBuffer): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: float[], arg6: DataBuffer): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: double[], arg6: DataBuffer): void;
                    createCompatibleSampleModel(arg0: int, arg1: int): SampleModel;
                    createSubsetSampleModel(arg0: int[]): SampleModel;
                    createDataBuffer(): DataBuffer;
                    getSampleSize(): JavaArray<number>;
                    getSampleSize(arg0: int): number;

                }

                abstract class WritableRenderedImage extends java.lang.Interface {
                    static readonly class: JavaClass<WritableRenderedImage>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WritableRenderedImage extends RenderedImage {

                    addTileObserver(arg0: TileObserver): void;
                    removeTileObserver(arg0: TileObserver): void;
                    getWritableTile(arg0: int, arg1: int): WritableRaster;
                    releaseWritableTile(arg0: int, arg1: int): void;
                    isTileWritable(arg0: int, arg1: int): boolean;
                    getWritableTileIndices(): JavaArray<java.awt.Point>;
                    hasTileWriters(): boolean;
                    setData(arg0: Raster): void;

                }

                abstract class Raster extends java.lang.Object {
                    static readonly class: JavaClass<Raster>;
                    /** @deprecated */ static prototype: undefined;

                    static createInterleavedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: java.awt.Point): WritableRaster;
                    static createInterleavedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[], arg6: java.awt.Point): WritableRaster;
                    static createBandedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: java.awt.Point): WritableRaster;
                    static createBandedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: int[], arg6: java.awt.Point): WritableRaster;
                    static createPackedRaster(arg0: int, arg1: int, arg2: int, arg3: int[], arg4: java.awt.Point): WritableRaster;
                    static createPackedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: java.awt.Point): WritableRaster;
                    static createInterleavedRaster(arg0: DataBuffer, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[], arg6: java.awt.Point): WritableRaster;
                    static createBandedRaster(arg0: DataBuffer, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: int[], arg6: java.awt.Point): WritableRaster;
                    static createPackedRaster(arg0: DataBuffer, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: java.awt.Point): WritableRaster;
                    static createPackedRaster(arg0: DataBuffer, arg1: int, arg2: int, arg3: int, arg4: java.awt.Point): WritableRaster;
                    static createRaster(arg0: SampleModel, arg1: DataBuffer, arg2: java.awt.Point): Raster;
                    static createWritableRaster(arg0: SampleModel, arg1: java.awt.Point): WritableRaster;
                    static createWritableRaster(arg0: SampleModel, arg1: DataBuffer, arg2: java.awt.Point): WritableRaster;

                    getParent(): Raster;
                    getSampleModelTranslateX(): number;
                    getSampleModelTranslateY(): number;
                    createCompatibleWritableRaster(): WritableRaster;
                    createCompatibleWritableRaster(arg0: int, arg1: int): WritableRaster;
                    createCompatibleWritableRaster(arg0: java.awt.Rectangle): WritableRaster;
                    createCompatibleWritableRaster(arg0: int, arg1: int, arg2: int, arg3: int): WritableRaster;
                    createTranslatedChild(arg0: int, arg1: int): Raster;
                    createChild(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int[]): Raster;
                    getBounds(): java.awt.Rectangle;
                    getMinX(): number;
                    getMinY(): number;
                    getWidth(): number;
                    getHeight(): number;
                    getNumBands(): number;
                    getNumDataElements(): number;
                    getTransferType(): number;
                    getDataBuffer(): DataBuffer;
                    getSampleModel(): SampleModel;
                    getDataElements(arg0: int, arg1: int, arg2: any): any;
                    getDataElements(arg0: int, arg1: int, arg2: int, arg3: int, arg4: any): any;
                    getPixel(arg0: int, arg1: int, arg2: int[]): JavaArray<number>;
                    getPixel(arg0: int, arg1: int, arg2: float[]): JavaArray<number>;
                    getPixel(arg0: int, arg1: int, arg2: double[]): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[]): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: float[]): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: double[]): JavaArray<number>;
                    getSample(arg0: int, arg1: int, arg2: int): number;
                    getSampleFloat(arg0: int, arg1: int, arg2: int): number;
                    getSampleDouble(arg0: int, arg1: int, arg2: int): number;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[]): JavaArray<number>;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: float[]): JavaArray<number>;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: double[]): JavaArray<number>;

                }

                interface ColorModel extends java.awt.Transparency {}
                class ColorModel extends java.lang.Object {
                    static readonly class: JavaClass<ColorModel>;
                    /** @deprecated */ static prototype: undefined;

                    static getRGBdefault(): ColorModel;

                    constructor (arg0: int);

                    hasAlpha(): boolean;
                    isAlphaPremultiplied(): boolean;
                    getTransferType(): number;
                    getPixelSize(): number;
                    getComponentSize(arg0: int): number;
                    getComponentSize(): JavaArray<number>;
                    getTransparency(): number;
                    getNumComponents(): number;
                    getNumColorComponents(): number;
                    getRed(arg0: int): number;
                    getGreen(arg0: int): number;
                    getBlue(arg0: int): number;
                    getAlpha(arg0: int): number;
                    getRGB(arg0: int): number;
                    getRed(arg0: any): number;
                    getGreen(arg0: any): number;
                    getBlue(arg0: any): number;
                    getAlpha(arg0: any): number;
                    getRGB(arg0: any): number;
                    getDataElements(arg0: int, arg1: any): any;
                    getComponents(arg0: int, arg1: int[], arg2: int): JavaArray<number>;
                    getComponents(arg0: any, arg1: int[], arg2: int): JavaArray<number>;
                    getUnnormalizedComponents(arg0: float[], arg1: int, arg2: int[], arg3: int): JavaArray<number>;
                    getNormalizedComponents(arg0: int[], arg1: int, arg2: float[], arg3: int): JavaArray<number>;
                    getDataElement(arg0: int[], arg1: int): number;
                    getDataElements(arg0: int[], arg1: int, arg2: any): any;
                    getDataElement(arg0: float[], arg1: int): number;
                    getDataElements(arg0: float[], arg1: int, arg2: any): any;
                    getNormalizedComponents(arg0: any, arg1: float[], arg2: int): JavaArray<number>;
                    getColorSpace(): java.awt.color.ColorSpace;
                    coerceData(arg0: WritableRaster, arg1: boolean): ColorModel;
                    isCompatibleRaster(arg0: Raster): boolean;
                    createCompatibleWritableRaster(arg0: int, arg1: int): WritableRaster;
                    createCompatibleSampleModel(arg0: int, arg1: int): SampleModel;
                    isCompatibleSampleModel(arg0: SampleModel): boolean;
                    /** @deprecated */
                    finalize(): void;
                    getAlphaRaster(arg0: WritableRaster): WritableRaster;

                }

                class IndexColorModel extends ColorModel {
                    static readonly class: JavaClass<IndexColorModel>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (arg0: int, arg1: int, arg2: byte[], arg3: byte[], arg4: byte[]);
                    constructor (arg0: int, arg1: int, arg2: byte[], arg3: byte[], arg4: byte[], arg5: int);
                    constructor (arg0: int, arg1: int, arg2: byte[], arg3: byte[], arg4: byte[], arg5: byte[]);
                    constructor (arg0: int, arg1: int, arg2: byte[], arg3: int, arg4: boolean);
                    constructor (arg0: int, arg1: int, arg2: byte[], arg3: int, arg4: boolean, arg5: int);
                    constructor (arg0: int, arg1: int, arg2: int[], arg3: int, arg4: boolean, arg5: int, arg6: int);
                    constructor (arg0: int, arg1: int, arg2: int[], arg3: int, arg4: int, arg5: java.math.BigInteger);

                    getTransparency(): number;
                    getComponentSize(): JavaArray<number>;
                    getComponentSize(arg0: int): number;
                    getMapSize(): number;
                    getTransparentPixel(): number;
                    getReds(arg0: byte[]): void;
                    getGreens(arg0: byte[]): void;
                    getBlues(arg0: byte[]): void;
                    getAlphas(arg0: byte[]): void;
                    getRGBs(arg0: int[]): void;
                    getRed(arg0: int): number;
                    getRed(arg0: any): number;
                    getGreen(arg0: int): number;
                    getGreen(arg0: any): number;
                    getBlue(arg0: int): number;
                    getBlue(arg0: any): number;
                    getAlpha(arg0: int): number;
                    getAlpha(arg0: any): number;
                    getRGB(arg0: int): number;
                    getRGB(arg0: any): number;
                    getDataElements(arg0: int, arg1: any): any;
                    getDataElements(arg0: float[], arg1: int, arg2: any): any;
                    getComponents(arg0: int, arg1: int[], arg2: int): JavaArray<number>;
                    getComponents(arg0: any, arg1: int[], arg2: int): JavaArray<number>;
                    getDataElement(arg0: int[], arg1: int): number;
                    getDataElement(arg0: float[], arg1: int): number;
                    getDataElements(arg0: int[], arg1: int, arg2: any): any;
                    createCompatibleWritableRaster(arg0: int, arg1: int): WritableRaster;
                    isCompatibleRaster(arg0: Raster): boolean;
                    createCompatibleSampleModel(arg0: int, arg1: int): SampleModel;
                    isCompatibleSampleModel(arg0: SampleModel): boolean;
                    convertToIntDiscrete(arg0: Raster, arg1: boolean): BufferedImage;
                    isValid(arg0: int): boolean;
                    isValid(): boolean;
                    getValidPixels(): java.math.BigInteger;
                    /** @deprecated */
                    finalize(): void;

                }

                abstract class TileObserver extends java.lang.Interface {
                    static readonly class: JavaClass<TileObserver>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TileObserver {

                    tileUpdate(arg0: WritableRenderedImage, arg1: int, arg2: int, arg3: boolean): void;

                }

                abstract class DataBuffer extends java.lang.Object {
                    static readonly class: JavaClass<DataBuffer>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly TYPE_BYTE: number;
                    static readonly TYPE_USHORT: number;
                    static readonly TYPE_SHORT: number;
                    static readonly TYPE_INT: number;
                    static readonly TYPE_FLOAT: number;
                    static readonly TYPE_DOUBLE: number;
                    static readonly TYPE_UNDEFINED: number;

                    static getDataTypeSize(arg0: int): number;

                    getDataType(): number;
                    getSize(): number;
                    getOffset(): number;
                    getOffsets(): JavaArray<number>;
                    getNumBanks(): number;
                    getElem(arg0: int): number;
                    getElem(arg0: int, arg1: int): number;
                    setElem(arg0: int, arg1: int): void;
                    setElem(arg0: int, arg1: int, arg2: int): void;
                    getElemFloat(arg0: int): number;
                    getElemFloat(arg0: int, arg1: int): number;
                    setElemFloat(arg0: int, arg1: float): void;
                    setElemFloat(arg0: int, arg1: int, arg2: float): void;
                    getElemDouble(arg0: int): number;
                    getElemDouble(arg0: int, arg1: int): number;
                    setElemDouble(arg0: int, arg1: double): void;
                    setElemDouble(arg0: int, arg1: int, arg2: double): void;

                }

                interface VolatileImage extends java.awt.Transparency {}
                abstract class VolatileImage extends java.awt.Image {
                    static readonly class: JavaClass<VolatileImage>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly IMAGE_OK: number;
                    static readonly IMAGE_RESTORED: number;
                    static readonly IMAGE_INCOMPATIBLE: number;

                    getSnapshot(): BufferedImage;
                    getWidth(): number;
                    getWidth(arg0: ImageObserver): number;
                    getHeight(): number;
                    getHeight(arg0: ImageObserver): number;
                    getSource(): ImageProducer;
                    getGraphics(): java.awt.Graphics;
                    createGraphics(): java.awt.Graphics2D;
                    validate(arg0: java.awt.GraphicsConfiguration): number;
                    contentsLost(): boolean;
                    getCapabilities(): java.awt.ImageCapabilities;
                    getCapabilities(arg0: java.awt.GraphicsConfiguration): java.awt.ImageCapabilities;
                    getTransparency(): number;

                }

                abstract class BufferedImageOp extends java.lang.Interface {
                    static readonly class: JavaClass<BufferedImageOp>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface BufferedImageOp {

                    filter(arg0: BufferedImage, arg1: BufferedImage): BufferedImage;
                    getBounds2D(arg0: BufferedImage): java.awt.geom.Rectangle2D;
                    createCompatibleDestImage(arg0: BufferedImage, arg1: ColorModel): BufferedImage;
                    getPoint2D(arg0: java.awt.geom.Point2D, arg1: java.awt.geom.Point2D): java.awt.geom.Point2D;
                    getRenderingHints(): java.awt.RenderingHints;

                }

                abstract class BufferStrategy extends java.lang.Object {
                    static readonly class: JavaClass<BufferStrategy>;
                    /** @deprecated */ static prototype: undefined;

                    getCapabilities(): java.awt.BufferCapabilities;
                    getDrawGraphics(): java.awt.Graphics;
                    contentsLost(): boolean;
                    contentsRestored(): boolean;
                    show(): void;
                    dispose(): void;

                }

                export {
                    ImageProducer,
                    ImageObserver,
                    BufferedImage,
                    WritableRaster,
                    ImageConsumer,
                    RenderedImage,
                    SampleModel,
                    WritableRenderedImage,
                    Raster,
                    ColorModel,
                    IndexColorModel,
                    TileObserver,
                    DataBuffer,
                    VolatileImage,
                    BufferedImageOp,
                    BufferStrategy
                }

            }
            namespace image {

                namespace renderable {

                    abstract class RenderableImage extends java.lang.Interface {
                        static readonly class: JavaClass<RenderableImage>;
                        /** @deprecated */ static prototype: undefined;

                        static readonly HINTS_OBSERVED: string;
                    }
                    interface RenderableImage {

                        getSources(): java.util.Vector<RenderableImage>;
                        getProperty(arg0: string): any;
                        getPropertyNames(): JavaArray<string>;
                        isDynamic(): boolean;
                        getWidth(): number;
                        getHeight(): number;
                        getMinX(): number;
                        getMinY(): number;
                        createScaledRendering(arg0: int, arg1: int, arg2: java.awt.RenderingHints): java.awt.image.RenderedImage;
                        createDefaultRendering(): java.awt.image.RenderedImage;
                        createRendering(arg0: RenderContext): java.awt.image.RenderedImage;

                    }

                    interface RenderContext extends java.lang.Cloneable {}
                    class RenderContext extends java.lang.Object {
                        static readonly class: JavaClass<RenderContext>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (arg0: java.awt.geom.AffineTransform, arg1: java.awt.Shape, arg2: java.awt.RenderingHints);
                        constructor (arg0: java.awt.geom.AffineTransform);
                        constructor (arg0: java.awt.geom.AffineTransform, arg1: java.awt.RenderingHints);
                        constructor (arg0: java.awt.geom.AffineTransform, arg1: java.awt.Shape);

                        getRenderingHints(): java.awt.RenderingHints;
                        setRenderingHints(arg0: java.awt.RenderingHints): void;
                        setTransform(arg0: java.awt.geom.AffineTransform): void;
                        preConcatenateTransform(arg0: java.awt.geom.AffineTransform): void;
                        /** @deprecated */
                        preConcetenateTransform(arg0: java.awt.geom.AffineTransform): void;
                        concatenateTransform(arg0: java.awt.geom.AffineTransform): void;
                        /** @deprecated */
                        concetenateTransform(arg0: java.awt.geom.AffineTransform): void;
                        getTransform(): java.awt.geom.AffineTransform;
                        setAreaOfInterest(arg0: java.awt.Shape): void;
                        getAreaOfInterest(): java.awt.Shape;
                        clone(): any;

                    }

                    export { RenderableImage, RenderContext }

                }

            }

        }

        namespace beans {

            abstract class PropertyChangeListener extends java.lang.Interface {
                static readonly class: JavaClass<PropertyChangeListener>;
                /** @deprecated */ static prototype: undefined;
            }
            interface PropertyChangeListener extends java.util.EventListener {

                propertyChange(arg0: PropertyChangeEvent): void;

            }

            class PropertyChangeEvent extends java.util.EventObject {
                static readonly class: JavaClass<PropertyChangeEvent>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: any, arg1: string, arg2: any, arg3: any);

                getPropertyName(): string;
                getNewValue(): any;
                getOldValue(): any;
                setPropagationId(arg0: any): void;
                getPropagationId(): any;

            }

            export { PropertyChangeListener, PropertyChangeEvent }

        }

        namespace io {

            interface OutputStream extends Closeable, Flushable {}
            class OutputStream extends java.lang.Object {
                static readonly class: JavaClass<OutputStream>;
                /** @deprecated */ static prototype: undefined;

                static nullOutputStream(): OutputStream;

                constructor ();

                write(arg0: int): void;
                write(arg0: byte[]): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                flush(): void;
                close(): void;

            }

            interface InputStream extends Closeable {}
            class InputStream extends java.lang.Object {
                static readonly class: JavaClass<InputStream>;
                /** @deprecated */ static prototype: undefined;

                static nullInputStream(): InputStream;

                constructor ();

                read(): number;
                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                readAllBytes(): JavaArray<number>;
                readNBytes(arg0: int): JavaArray<number>;
                readNBytes(arg0: byte[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                skipNBytes(arg0: long): void;
                available(): number;
                close(): void;
                mark(arg0: int): void;
                reset(): void;
                markSupported(): boolean;
                transferTo(arg0: OutputStream): number;

            }

            abstract class Closeable extends java.lang.Interface {
                static readonly class: JavaClass<Closeable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Closeable extends java.lang.AutoCloseable {

                close(): void;

            }

            abstract class Flushable extends java.lang.Interface {
                static readonly class: JavaClass<Flushable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Flushable {

                flush(): void;

            }

            abstract class ObjectOutput extends java.lang.Interface {
                static readonly class: JavaClass<ObjectOutput>;
                /** @deprecated */ static prototype: undefined;
            }
            interface ObjectOutput extends java.lang.AutoCloseable, DataOutput {

                writeObject(arg0: any): void;
                write(arg0: int): void;
                write(arg0: byte[]): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                flush(): void;
                close(): void;

            }

            class BufferedInputStream extends FilterInputStream {
                static readonly class: JavaClass<BufferedInputStream>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: InputStream);
                constructor (arg0: InputStream, arg1: int);

                read(): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                read(arg0: byte[]): number;
                skip(arg0: long): number;
                available(): number;
                mark(arg0: int): void;
                reset(): void;
                markSupported(): boolean;
                close(): void;

            }

            abstract class Externalizable extends java.lang.Interface {
                static readonly class: JavaClass<Externalizable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Externalizable extends Serializable {

                writeExternal(arg0: ObjectOutput): void;
                readExternal(arg0: ObjectInput): void;

            }

            abstract class ObjectInput extends java.lang.Interface {
                static readonly class: JavaClass<ObjectInput>;
                /** @deprecated */ static prototype: undefined;
            }
            interface ObjectInput extends DataInput, java.lang.AutoCloseable {

                readObject(): any;
                read(): number;
                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                available(): number;
                close(): void;

            }

            abstract class DataInput extends java.lang.Interface {
                static readonly class: JavaClass<DataInput>;
                /** @deprecated */ static prototype: undefined;
            }
            interface DataInput {

                readFully(arg0: byte[]): void;
                readFully(arg0: byte[], arg1: int, arg2: int): void;
                skipBytes(arg0: int): number;
                readBoolean(): boolean;
                readByte(): number;
                readUnsignedByte(): number;
                readShort(): number;
                readUnsignedShort(): number;
                readChar(): number;
                readInt(): number;
                readLong(): number;
                readFloat(): number;
                readDouble(): number;
                readLine(): string;
                readUTF(): string;

            }

            abstract class DataOutput extends java.lang.Interface {
                static readonly class: JavaClass<DataOutput>;
                /** @deprecated */ static prototype: undefined;
            }
            interface DataOutput {

                write(arg0: int): void;
                write(arg0: byte[]): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                writeBoolean(arg0: boolean): void;
                writeByte(arg0: int): void;
                writeShort(arg0: int): void;
                writeChar(arg0: int): void;
                writeInt(arg0: int): void;
                writeLong(arg0: long): void;
                writeFloat(arg0: float): void;
                writeDouble(arg0: double): void;
                writeBytes(arg0: string): void;
                writeChars(arg0: string): void;
                writeUTF(arg0: string): void;

            }

            abstract class FilterInputStream extends InputStream {
                static readonly class: JavaClass<FilterInputStream>;
                /** @deprecated */ static prototype: undefined;

                read(): number;
                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                available(): number;
                close(): void;
                mark(arg0: int): void;
                reset(): void;
                markSupported(): boolean;

            }

            class PrintWriter extends Writer {
                static readonly class: JavaClass<PrintWriter>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: Writer);
                constructor (arg0: Writer, arg1: boolean);
                constructor (arg0: OutputStream);
                constructor (arg0: OutputStream, arg1: boolean);
                constructor (arg0: OutputStream, arg1: boolean, arg2: java.nio.charset.Charset);
                constructor (arg0: string);
                constructor (arg0: string, arg1: string);
                constructor (arg0: string, arg1: java.nio.charset.Charset);
                constructor (arg0: File);
                constructor (arg0: File, arg1: string);
                constructor (arg0: File, arg1: java.nio.charset.Charset);

                flush(): void;
                close(): void;
                checkError(): boolean;
                write(arg0: int): void;
                write(arg0: char[], arg1: int, arg2: int): void;
                write(arg0: char[]): void;
                write(arg0: string, arg1: int, arg2: int): void;
                write(arg0: string): void;
                print(arg0: boolean): void;
                print(arg0: char): void;
                print(arg0: int): void;
                print(arg0: long): void;
                print(arg0: float): void;
                print(arg0: double): void;
                print(arg0: char[]): void;
                print(arg0: string): void;
                print(arg0: any): void;
                println(): void;
                println(arg0: boolean): void;
                println(arg0: char): void;
                println(arg0: int): void;
                println(arg0: long): void;
                println(arg0: float): void;
                println(arg0: double): void;
                println(arg0: char[]): void;
                println(arg0: string): void;
                println(arg0: any): void;
                printf(arg0: string, ...arg1: JavaVarArgs<any>): PrintWriter;
                printf(arg0: java.util.Locale, arg1: string, ...arg2: JavaVarArgs<any>): PrintWriter;
                format(arg0: string, ...arg1: JavaVarArgs<any>): PrintWriter;
                format(arg0: java.util.Locale, arg1: string, ...arg2: JavaVarArgs<any>): PrintWriter;
                append(arg0: java.lang.CharSequence): PrintWriter;
                append(arg0: java.lang.CharSequence, arg1: int, arg2: int): PrintWriter;
                append(arg0: char): PrintWriter;

            }

            interface PrintStream extends java.lang.Appendable, Closeable {}
            class PrintStream extends FilterOutputStream {
                static readonly class: JavaClass<PrintStream>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: OutputStream);
                constructor (arg0: OutputStream, arg1: boolean);
                constructor (arg0: OutputStream, arg1: boolean, arg2: string);
                constructor (arg0: OutputStream, arg1: boolean, arg2: java.nio.charset.Charset);
                constructor (arg0: string);
                constructor (arg0: string, arg1: string);
                constructor (arg0: string, arg1: java.nio.charset.Charset);
                constructor (arg0: File);
                constructor (arg0: File, arg1: string);
                constructor (arg0: File, arg1: java.nio.charset.Charset);

                flush(): void;
                close(): void;
                checkError(): boolean;
                write(arg0: int): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                write(arg0: byte[]): void;
                writeBytes(arg0: byte[]): void;
                print(arg0: boolean): void;
                print(arg0: char): void;
                print(arg0: int): void;
                print(arg0: long): void;
                print(arg0: float): void;
                print(arg0: double): void;
                print(arg0: char[]): void;
                print(arg0: string): void;
                print(arg0: any): void;
                println(): void;
                println(arg0: boolean): void;
                println(arg0: char): void;
                println(arg0: int): void;
                println(arg0: long): void;
                println(arg0: float): void;
                println(arg0: double): void;
                println(arg0: char[]): void;
                println(arg0: string): void;
                println(arg0: any): void;
                printf(arg0: string, ...arg1: JavaVarArgs<any>): PrintStream;
                printf(arg0: java.util.Locale, arg1: string, ...arg2: JavaVarArgs<any>): PrintStream;
                format(arg0: string, ...arg1: JavaVarArgs<any>): PrintStream;
                format(arg0: java.util.Locale, arg1: string, ...arg2: JavaVarArgs<any>): PrintStream;
                append(arg0: java.lang.CharSequence): PrintStream;
                append(arg0: java.lang.CharSequence, arg1: int, arg2: int): PrintStream;
                append(arg0: char): PrintStream;

            }

            interface Reader extends java.lang.Readable, Closeable {}
            abstract class Reader extends java.lang.Object {
                static readonly class: JavaClass<Reader>;
                /** @deprecated */ static prototype: undefined;

                static nullReader(): Reader;

                read(arg0: java.nio.CharBuffer): number;
                read(): number;
                read(arg0: char[]): number;
                read(arg0: char[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                ready(): boolean;
                markSupported(): boolean;
                mark(arg0: int): void;
                reset(): void;
                close(): void;
                transferTo(arg0: Writer): number;

            }

            interface Writer extends java.lang.Appendable, Closeable, Flushable {}
            abstract class Writer extends java.lang.Object {
                static readonly class: JavaClass<Writer>;
                /** @deprecated */ static prototype: undefined;

                static nullWriter(): Writer;

                write(arg0: int): void;
                write(arg0: char[]): void;
                write(arg0: char[], arg1: int, arg2: int): void;
                write(arg0: string): void;
                write(arg0: string, arg1: int, arg2: int): void;
                append(arg0: java.lang.CharSequence): Writer;
                append(arg0: java.lang.CharSequence, arg1: int, arg2: int): Writer;
                append(arg0: char): Writer;
                flush(): void;
                close(): void;

            }

            class FilterOutputStream extends OutputStream {
                static readonly class: JavaClass<FilterOutputStream>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: OutputStream);

                write(arg0: int): void;
                write(arg0: byte[]): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                flush(): void;
                close(): void;

            }

            interface DataOutputStream extends DataOutput {}
            class DataOutputStream extends FilterOutputStream {
                static readonly class: JavaClass<DataOutputStream>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: OutputStream);

                write(arg0: int): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                write(arg0: byte[]): void;
                flush(): void;
                writeBoolean(arg0: boolean): void;
                writeByte(arg0: int): void;
                writeShort(arg0: int): void;
                writeChar(arg0: int): void;
                writeInt(arg0: int): void;
                writeLong(arg0: long): void;
                writeFloat(arg0: float): void;
                writeDouble(arg0: double): void;
                writeBytes(arg0: string): void;
                writeChars(arg0: string): void;
                writeUTF(arg0: string): void;
                size(): number;

            }

            interface DataInputStream extends DataInput {}
            class DataInputStream extends FilterInputStream {
                static readonly class: JavaClass<DataInputStream>;
                /** @deprecated */ static prototype: undefined;

                static readUTF(arg0: DataInput): string;

                constructor (arg0: InputStream);

                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                read(): number;
                readFully(arg0: byte[]): void;
                readFully(arg0: byte[], arg1: int, arg2: int): void;
                skipBytes(arg0: int): number;
                readBoolean(): boolean;
                readByte(): number;
                readUnsignedByte(): number;
                readShort(): number;
                readUnsignedShort(): number;
                readChar(): number;
                readInt(): number;
                readLong(): number;
                readFloat(): number;
                readDouble(): number;
                /** @deprecated */
                readLine(): string;
                readUTF(): string;

            }

            export {
                OutputStream,
                InputStream,
                Closeable,
                Flushable,
                ObjectOutput,
                BufferedInputStream,
                Externalizable,
                ObjectInput,
                DataInput,
                DataOutput,
                FilterInputStream,
                PrintWriter,
                PrintStream,
                Reader,
                Writer,
                FilterOutputStream,
                DataOutputStream,
                DataInputStream
            }

        }

        namespace lang {

            interface Boolean extends java.lang.constant.Constable, Comparable<Boolean>, java.io.Serializable {}
            class Boolean extends java.lang.Object {
                static readonly class: JavaClass<Boolean>;
                /** @deprecated */ static prototype: undefined;

                static readonly TRUE: boolean;
                static readonly FALSE: boolean;
                static readonly TYPE: JavaClass<boolean>;

                static parseBoolean(arg0: string): boolean;
                static valueOf(arg0: boolean): boolean;
                static valueOf(arg0: string): boolean;
                static toString(arg0: boolean): string;
                static hashCode(arg0: boolean): number;
                static getBoolean(arg0: string): boolean;
                static compare(arg0: boolean, arg1: boolean): number;
                static logicalAnd(arg0: boolean, arg1: boolean): boolean;
                static logicalOr(arg0: boolean, arg1: boolean): boolean;
                static logicalXor(arg0: boolean, arg1: boolean): boolean;

                /** @deprecated */
                constructor (arg0: boolean);
                /** @deprecated */
                constructor (arg0: string);

                booleanValue(): boolean;
                compareTo(arg0: boolean): number;
                describeConstable(): java.util.Optional<java.lang.constant.DynamicConstantDesc<boolean>>;

            }

            abstract class Appendable extends java.lang.Interface {
                static readonly class: JavaClass<Appendable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Appendable {

                append(arg0: CharSequence): Appendable;
                append(arg0: CharSequence, arg1: int, arg2: int): Appendable;
                append(arg0: char): Appendable;

            }

            abstract class CharSequence extends java.lang.Interface {
                static readonly class: JavaClass<CharSequence>;
                /** @deprecated */ static prototype: undefined;

                static compare(arg0: CharSequence, arg1: CharSequence): number;

            }
            interface CharSequence {

                length(): number;
                charAt(arg0: int): number;
                isEmpty(): boolean;
                subSequence(arg0: int, arg1: int): CharSequence;
                chars(): java.util.stream.IntStream;
                codePoints(): java.util.stream.IntStream;

            }

            interface String extends CharSequence, java.lang.constant.Constable, Comparable<String>, java.io.Serializable, java.lang.constant.ConstantDesc {}
            class String extends java.lang.Object {
                static readonly class: JavaClass<String>;
                /** @deprecated */ static prototype: undefined;

                static readonly CASE_INSENSITIVE_ORDER: MethodWrapper<string, string, int>;

                static join(arg0: CharSequence, ...arg1: JavaVarArgs<CharSequence>): string;
                static join(arg0: CharSequence, arg1: Iterable<CharSequence>): string;
                static format(arg0: string, ...arg1: JavaVarArgs<any>): string;
                static format(arg0: java.util.Locale, arg1: string, ...arg2: JavaVarArgs<any>): string;
                static valueOf(arg0: any): string;
                static valueOf(arg0: char[]): string;
                static valueOf(arg0: char[], arg1: int, arg2: int): string;
                static copyValueOf(arg0: char[], arg1: int, arg2: int): string;
                static copyValueOf(arg0: char[]): string;
                static valueOf(arg0: boolean): string;
                static valueOf(arg0: char): string;
                static valueOf(arg0: int): string;
                static valueOf(arg0: long): string;
                static valueOf(arg0: float): string;
                static valueOf(arg0: double): string;

                constructor ();
                constructor (arg0: string);
                constructor (arg0: char[]);
                constructor (arg0: char[], arg1: int, arg2: int);
                constructor (arg0: int[], arg1: int, arg2: int);
                /** @deprecated */
                constructor (arg0: byte[], arg1: int, arg2: int, arg3: int);
                /** @deprecated */
                constructor (arg0: byte[], arg1: int);
                constructor (arg0: byte[], arg1: int, arg2: int, arg3: string);
                constructor (arg0: byte[], arg1: int, arg2: int, arg3: java.nio.charset.Charset);
                constructor (arg0: byte[], arg1: string);
                constructor (arg0: byte[], arg1: java.nio.charset.Charset);
                constructor (arg0: byte[], arg1: int, arg2: int);
                constructor (arg0: byte[]);
                constructor (arg0: StringBuffer);
                constructor (arg0: StringBuilder);

                length(): number;
                isEmpty(): boolean;
                charAt(arg0: int): number;
                codePointAt(arg0: int): number;
                codePointBefore(arg0: int): number;
                codePointCount(arg0: int, arg1: int): number;
                offsetByCodePoints(arg0: int, arg1: int): number;
                getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void;
                /** @deprecated */
                getBytes(arg0: int, arg1: int, arg2: byte[], arg3: int): void;
                getBytes(arg0: string): JavaArray<number>;
                getBytes(arg0: java.nio.charset.Charset): JavaArray<number>;
                getBytes(): JavaArray<number>;
                contentEquals(arg0: StringBuffer): boolean;
                contentEquals(arg0: CharSequence): boolean;
                equalsIgnoreCase(arg0: string): boolean;
                compareTo(arg0: string): number;
                compareToIgnoreCase(arg0: string): number;
                regionMatches(arg0: int, arg1: string, arg2: int, arg3: int): boolean;
                regionMatches(arg0: boolean, arg1: int, arg2: string, arg3: int, arg4: int): boolean;
                startsWith(arg0: string, arg1: int): boolean;
                startsWith(arg0: string): boolean;
                endsWith(arg0: string): boolean;
                indexOf(arg0: int): number;
                indexOf(arg0: int, arg1: int): number;
                lastIndexOf(arg0: int): number;
                lastIndexOf(arg0: int, arg1: int): number;
                indexOf(arg0: string): number;
                indexOf(arg0: string, arg1: int): number;
                lastIndexOf(arg0: string): number;
                lastIndexOf(arg0: string, arg1: int): number;
                substring(arg0: int): string;
                substring(arg0: int, arg1: int): string;
                subSequence(arg0: int, arg1: int): CharSequence;
                concat(arg0: string): string;
                replace(arg0: char, arg1: char): string;
                matches(arg0: string): boolean;
                contains(arg0: CharSequence): boolean;
                replaceFirst(arg0: string, arg1: string): string;
                replaceAll(arg0: string, arg1: string): string;
                replace(arg0: CharSequence, arg1: CharSequence): string;
                split(arg0: string, arg1: int): JavaArray<string>;
                split(arg0: string): JavaArray<string>;
                toLowerCase(arg0: java.util.Locale): string;
                toLowerCase(): string;
                toUpperCase(arg0: java.util.Locale): string;
                toUpperCase(): string;
                trim(): string;
                strip(): string;
                stripLeading(): string;
                stripTrailing(): string;
                isBlank(): boolean;
                lines(): java.util.stream.Stream<string>;
                indent(arg0: int): string;
                stripIndent(): string;
                translateEscapes(): string;
                transform<R>(arg0: MethodWrapper<string, any, R>): R;
                chars(): java.util.stream.IntStream;
                codePoints(): java.util.stream.IntStream;
                toCharArray(): JavaArray<number>;
                formatted(...arg0: JavaVarArgs<any>): string;
                intern(): string;
                repeat(arg0: int): string;
                describeConstable(): java.util.Optional<string>;
                resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): string;

            }

            class Exception extends Throwable {
                static readonly class: JavaClass<Exception>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: string);
                constructor (arg0: string, arg1: Throwable);
                constructor (arg0: Throwable);

            }

            abstract class AutoCloseable extends java.lang.Interface {
                static readonly class: JavaClass<AutoCloseable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface AutoCloseable {

                close(): void;

            }

            abstract class Readable extends java.lang.Interface {
                static readonly class: JavaClass<Readable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Readable {

                read(arg0: java.nio.CharBuffer): number;

            }

            interface Integer extends java.lang.constant.Constable, Comparable<Integer>, java.lang.constant.ConstantDesc {}
            class Integer extends Number {
                static readonly class: JavaClass<Integer>;
                /** @deprecated */ static prototype: undefined;

                static readonly MIN_VALUE: number;
                static readonly MAX_VALUE: number;
                static readonly TYPE: JavaClass<number>;
                static readonly SIZE: number;
                static readonly BYTES: number;

                static toString(arg0: int, arg1: int): string;
                static toUnsignedString(arg0: int, arg1: int): string;
                static toHexString(arg0: int): string;
                static toOctalString(arg0: int): string;
                static toBinaryString(arg0: int): string;
                static toString(arg0: int): string;
                static toUnsignedString(arg0: int): string;
                static parseInt(arg0: string, arg1: int): number;
                static parseInt(arg0: CharSequence, arg1: int, arg2: int, arg3: int): number;
                static parseInt(arg0: string): number;
                static parseUnsignedInt(arg0: string, arg1: int): number;
                static parseUnsignedInt(arg0: CharSequence, arg1: int, arg2: int, arg3: int): number;
                static parseUnsignedInt(arg0: string): number;
                static valueOf(arg0: string, arg1: int): number;
                static valueOf(arg0: string): number;
                static valueOf(arg0: int): number;
                static hashCode(arg0: int): number;
                static getInteger(arg0: string): number;
                static getInteger(arg0: string, arg1: int): number;
                static getInteger(arg0: string, arg1: int): number;
                static decode(arg0: string): number;
                static compare(arg0: int, arg1: int): number;
                static compareUnsigned(arg0: int, arg1: int): number;
                static toUnsignedLong(arg0: int): number;
                static divideUnsigned(arg0: int, arg1: int): number;
                static remainderUnsigned(arg0: int, arg1: int): number;
                static highestOneBit(arg0: int): number;
                static lowestOneBit(arg0: int): number;
                static numberOfLeadingZeros(arg0: int): number;
                static numberOfTrailingZeros(arg0: int): number;
                static bitCount(arg0: int): number;
                static rotateLeft(arg0: int, arg1: int): number;
                static rotateRight(arg0: int, arg1: int): number;
                static reverse(arg0: int): number;
                static signum(arg0: int): number;
                static reverseBytes(arg0: int): number;
                static sum(arg0: int, arg1: int): number;
                static max(arg0: int, arg1: int): number;
                static min(arg0: int, arg1: int): number;

                /** @deprecated */
                constructor (arg0: int);
                /** @deprecated */
                constructor (arg0: string);

                byteValue(): number;
                shortValue(): number;
                intValue(): number;
                longValue(): number;
                floatValue(): number;
                doubleValue(): number;
                compareTo(arg0: int): number;
                describeConstable(): java.util.Optional<number>;
                resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): number;

            }

            abstract class Comparable<T> extends java.lang.Interface {
                static readonly class: JavaClass<Comparable<any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Comparable<T> {

                compareTo(arg0: T): number;

            }

            interface Double extends java.lang.constant.Constable, Comparable<Double>, java.lang.constant.ConstantDesc {}
            class Double extends Number {
                static readonly class: JavaClass<Double>;
                /** @deprecated */ static prototype: undefined;

                static readonly POSITIVE_INFINITY: number;
                static readonly NEGATIVE_INFINITY: number;
                static readonly NaN: number;
                static readonly MAX_VALUE: number;
                static readonly MIN_NORMAL: number;
                static readonly MIN_VALUE: number;
                static readonly MAX_EXPONENT: number;
                static readonly MIN_EXPONENT: number;
                static readonly SIZE: number;
                static readonly BYTES: number;
                static readonly TYPE: JavaClass<number>;

                static toString(arg0: double): string;
                static toHexString(arg0: double): string;
                static valueOf(arg0: string): number;
                static valueOf(arg0: double): number;
                static parseDouble(arg0: string): number;
                static isNaN(arg0: double): boolean;
                static isInfinite(arg0: double): boolean;
                static isFinite(arg0: double): boolean;
                static hashCode(arg0: double): number;
                static doubleToLongBits(arg0: double): number;
                static doubleToRawLongBits(arg0: double): number;
                static longBitsToDouble(arg0: long): number;
                static compare(arg0: double, arg1: double): number;
                static sum(arg0: double, arg1: double): number;
                static max(arg0: double, arg1: double): number;
                static min(arg0: double, arg1: double): number;

                /** @deprecated */
                constructor (arg0: double);
                /** @deprecated */
                constructor (arg0: string);

                isNaN(): boolean;
                isInfinite(): boolean;
                byteValue(): number;
                shortValue(): number;
                intValue(): number;
                longValue(): number;
                floatValue(): number;
                doubleValue(): number;
                compareTo(arg0: double): number;
                describeConstable(): java.util.Optional<number>;
                resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): number;

            }

            interface Enum<E extends Enum<E>> extends java.lang.constant.Constable, Comparable<E>, java.io.Serializable {}
            abstract class Enum<E extends Enum<E>> extends java.lang.Object {
                static readonly class: JavaClass<Enum<any>>;
                /** @deprecated */ static prototype: undefined;

                static valueOf<T extends Enum<T>>(arg0: JavaClassArg<T>, arg1: string): T;

                name(): string;
                ordinal(): number;
                compareTo(arg0: E): number;
                getDeclaringClass(): JavaClass<E>;
                describeConstable(): java.util.Optional<Enum$EnumDesc<E>>;

            }

            abstract class Enum$EnumDesc<E extends Enum<E>> extends java.lang.constant.DynamicConstantDesc<E> {
                static readonly class: JavaClass<Enum$EnumDesc<any>>;
                /** @deprecated */ static prototype: undefined;

                static of<E extends Enum<E>>(arg0: java.lang.constant.ClassDesc, arg1: string): Enum$EnumDesc<E>;

                resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): E;

            }

            interface StringBuilder extends Comparable<StringBuilder>, CharSequence, java.io.Serializable {}
            class StringBuilder extends AbstractStringBuilder {
                static readonly class: JavaClass<StringBuilder>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: int);
                constructor (arg0: string);
                constructor (arg0: CharSequence);

                compareTo(arg0: StringBuilder): number;
                append(arg0: any): StringBuilder;
                append(arg0: string): StringBuilder;
                append(arg0: StringBuffer): StringBuilder;
                append(arg0: CharSequence): StringBuilder;
                append(arg0: CharSequence, arg1: int, arg2: int): StringBuilder;
                append(arg0: char[]): StringBuilder;
                append(arg0: char[], arg1: int, arg2: int): StringBuilder;
                append(arg0: boolean): StringBuilder;
                append(arg0: char): StringBuilder;
                append(arg0: int): StringBuilder;
                append(arg0: long): StringBuilder;
                append(arg0: float): StringBuilder;
                append(arg0: double): StringBuilder;
                appendCodePoint(arg0: int): StringBuilder;
                delete(arg0: int, arg1: int): StringBuilder;
                deleteCharAt(arg0: int): StringBuilder;
                replace(arg0: int, arg1: int, arg2: string): StringBuilder;
                insert(arg0: int, arg1: char[], arg2: int, arg3: int): StringBuilder;
                insert(arg0: int, arg1: any): StringBuilder;
                insert(arg0: int, arg1: string): StringBuilder;
                insert(arg0: int, arg1: char[]): StringBuilder;
                insert(arg0: int, arg1: CharSequence): StringBuilder;
                insert(arg0: int, arg1: CharSequence, arg2: int, arg3: int): StringBuilder;
                insert(arg0: int, arg1: boolean): StringBuilder;
                insert(arg0: int, arg1: char): StringBuilder;
                insert(arg0: int, arg1: int): StringBuilder;
                insert(arg0: int, arg1: long): StringBuilder;
                insert(arg0: int, arg1: float): StringBuilder;
                insert(arg0: int, arg1: double): StringBuilder;
                indexOf(arg0: string): number;
                indexOf(arg0: string, arg1: int): number;
                lastIndexOf(arg0: string): number;
                lastIndexOf(arg0: string, arg1: int): number;
                reverse(): StringBuilder;

            }

            interface StringBuffer extends CharSequence, java.io.Serializable, Comparable<StringBuffer> {}
            class StringBuffer extends AbstractStringBuilder {
                static readonly class: JavaClass<StringBuffer>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: int);
                constructor (arg0: string);
                constructor (arg0: CharSequence);

                compareTo(arg0: StringBuffer): number;
                length(): number;
                capacity(): number;
                ensureCapacity(arg0: int): void;
                trimToSize(): void;
                setLength(arg0: int): void;
                charAt(arg0: int): number;
                codePointAt(arg0: int): number;
                codePointBefore(arg0: int): number;
                codePointCount(arg0: int, arg1: int): number;
                offsetByCodePoints(arg0: int, arg1: int): number;
                getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void;
                setCharAt(arg0: int, arg1: char): void;
                append(arg0: any): StringBuffer;
                append(arg0: string): StringBuffer;
                append(arg0: StringBuffer): StringBuffer;
                append(arg0: CharSequence): StringBuffer;
                append(arg0: CharSequence, arg1: int, arg2: int): StringBuffer;
                append(arg0: char[]): StringBuffer;
                append(arg0: char[], arg1: int, arg2: int): StringBuffer;
                append(arg0: boolean): StringBuffer;
                append(arg0: char): StringBuffer;
                append(arg0: int): StringBuffer;
                appendCodePoint(arg0: int): StringBuffer;
                append(arg0: long): StringBuffer;
                append(arg0: float): StringBuffer;
                append(arg0: double): StringBuffer;
                delete(arg0: int, arg1: int): StringBuffer;
                deleteCharAt(arg0: int): StringBuffer;
                replace(arg0: int, arg1: int, arg2: string): StringBuffer;
                substring(arg0: int): string;
                subSequence(arg0: int, arg1: int): CharSequence;
                substring(arg0: int, arg1: int): string;
                insert(arg0: int, arg1: char[], arg2: int, arg3: int): StringBuffer;
                insert(arg0: int, arg1: any): StringBuffer;
                insert(arg0: int, arg1: string): StringBuffer;
                insert(arg0: int, arg1: char[]): StringBuffer;
                insert(arg0: int, arg1: CharSequence): StringBuffer;
                insert(arg0: int, arg1: CharSequence, arg2: int, arg3: int): StringBuffer;
                insert(arg0: int, arg1: boolean): StringBuffer;
                insert(arg0: int, arg1: char): StringBuffer;
                insert(arg0: int, arg1: int): StringBuffer;
                insert(arg0: int, arg1: long): StringBuffer;
                insert(arg0: int, arg1: float): StringBuffer;
                insert(arg0: int, arg1: double): StringBuffer;
                indexOf(arg0: string): number;
                indexOf(arg0: string, arg1: int): number;
                lastIndexOf(arg0: string): number;
                lastIndexOf(arg0: string, arg1: int): number;
                reverse(): StringBuffer;

            }

            abstract class ClassLoader extends java.lang.Object {
                static readonly class: JavaClass<ClassLoader>;
                /** @deprecated */ static prototype: undefined;

                static getSystemResource(arg0: string): java.net.URL;
                static getSystemResources(arg0: string): java.util.Enumeration<java.net.URL>;
                static getSystemResourceAsStream(arg0: string): java.io.InputStream;
                static getPlatformClassLoader(): ClassLoader;
                static getSystemClassLoader(): ClassLoader;

                getName(): string;
                loadClass(arg0: string): JavaClass<any>;
                getResource(arg0: string): java.net.URL;
                getResources(arg0: string): java.util.Enumeration<java.net.URL>;
                resources(arg0: string): java.util.stream.Stream<java.net.URL>;
                isRegisteredAsParallelCapable(): boolean;
                getResourceAsStream(arg0: string): java.io.InputStream;
                getParent(): ClassLoader;
                getUnnamedModule(): Module;
                getDefinedPackage(arg0: string): Package;
                getDefinedPackages(): JavaArray<Package>;
                setDefaultAssertionStatus(arg0: boolean): void;
                setPackageAssertionStatus(arg0: string, arg1: boolean): void;
                setClassAssertionStatus(arg0: string, arg1: boolean): void;
                clearAssertionStatus(): void;

            }

            interface Number extends java.io.Serializable {}
            class Number extends java.lang.Object {
                static readonly class: JavaClass<Number>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

                intValue(): number;
                longValue(): number;
                floatValue(): number;
                doubleValue(): number;
                byteValue(): number;
                shortValue(): number;

            }

            interface Module extends java.lang.reflect.AnnotatedElement {}
            abstract class Module extends java.lang.Object {
                static readonly class: JavaClass<Module>;
                /** @deprecated */ static prototype: undefined;

                isNamed(): boolean;
                getName(): string;
                getClassLoader(): ClassLoader;
                getDescriptor(): java.lang.module.ModuleDescriptor;
                getLayer(): ModuleLayer;
                canRead(arg0: Module): boolean;
                addReads(arg0: Module): Module;
                isExported(arg0: string, arg1: Module): boolean;
                isOpen(arg0: string, arg1: Module): boolean;
                isExported(arg0: string): boolean;
                isOpen(arg0: string): boolean;
                addExports(arg0: string, arg1: Module): Module;
                addOpens(arg0: string, arg1: Module): Module;
                addUses(arg0: JavaClassArg<any>): Module;
                canUse(arg0: JavaClassArg<any>): boolean;
                getPackages(): JavaSet<string>;
                getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                getResourceAsStream(arg0: string): java.io.InputStream;

            }

            interface AbstractStringBuilder extends CharSequence, Appendable {}
            abstract class AbstractStringBuilder extends java.lang.Object {
                static readonly class: JavaClass<AbstractStringBuilder>;
                /** @deprecated */ static prototype: undefined;

                length(): number;
                capacity(): number;
                ensureCapacity(arg0: int): void;
                trimToSize(): void;
                setLength(arg0: int): void;
                charAt(arg0: int): number;
                codePointAt(arg0: int): number;
                codePointBefore(arg0: int): number;
                codePointCount(arg0: int, arg1: int): number;
                offsetByCodePoints(arg0: int, arg1: int): number;
                getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void;
                setCharAt(arg0: int, arg1: char): void;
                append(arg0: any): AbstractStringBuilder;
                append(arg0: string): AbstractStringBuilder;
                append(arg0: StringBuffer): AbstractStringBuilder;
                append(arg0: CharSequence): AbstractStringBuilder;
                append(arg0: CharSequence, arg1: int, arg2: int): AbstractStringBuilder;
                append(arg0: char[]): AbstractStringBuilder;
                append(arg0: char[], arg1: int, arg2: int): AbstractStringBuilder;
                append(arg0: boolean): AbstractStringBuilder;
                append(arg0: char): AbstractStringBuilder;
                append(arg0: int): AbstractStringBuilder;
                append(arg0: long): AbstractStringBuilder;
                append(arg0: float): AbstractStringBuilder;
                append(arg0: double): AbstractStringBuilder;
                delete(arg0: int, arg1: int): AbstractStringBuilder;
                appendCodePoint(arg0: int): AbstractStringBuilder;
                deleteCharAt(arg0: int): AbstractStringBuilder;
                replace(arg0: int, arg1: int, arg2: string): AbstractStringBuilder;
                substring(arg0: int): string;
                subSequence(arg0: int, arg1: int): CharSequence;
                substring(arg0: int, arg1: int): string;
                insert(arg0: int, arg1: char[], arg2: int, arg3: int): AbstractStringBuilder;
                insert(arg0: int, arg1: any): AbstractStringBuilder;
                insert(arg0: int, arg1: string): AbstractStringBuilder;
                insert(arg0: int, arg1: char[]): AbstractStringBuilder;
                insert(arg0: int, arg1: CharSequence): AbstractStringBuilder;
                insert(arg0: int, arg1: CharSequence, arg2: int, arg3: int): AbstractStringBuilder;
                insert(arg0: int, arg1: boolean): AbstractStringBuilder;
                insert(arg0: int, arg1: char): AbstractStringBuilder;
                insert(arg0: int, arg1: int): AbstractStringBuilder;
                insert(arg0: int, arg1: long): AbstractStringBuilder;
                insert(arg0: int, arg1: float): AbstractStringBuilder;
                insert(arg0: int, arg1: double): AbstractStringBuilder;
                indexOf(arg0: string): number;
                indexOf(arg0: string, arg1: int): number;
                lastIndexOf(arg0: string): number;
                lastIndexOf(arg0: string, arg1: int): number;
                reverse(): AbstractStringBuilder;
                chars(): java.util.stream.IntStream;
                codePoints(): java.util.stream.IntStream;

            }

            interface Package extends java.lang.reflect.AnnotatedElement {}
            abstract class Package extends NamedPackage {
                static readonly class: JavaClass<Package>;
                /** @deprecated */ static prototype: undefined;

                /** @deprecated */
                static getPackage(arg0: string): Package;
                static getPackages(): JavaArray<Package>;

                getName(): string;
                getSpecificationTitle(): string;
                getSpecificationVersion(): string;
                getSpecificationVendor(): string;
                getImplementationTitle(): string;
                getImplementationVersion(): string;
                getImplementationVendor(): string;
                isSealed(): boolean;
                isSealed(arg0: java.net.URL): boolean;
                isCompatibleWith(arg0: string): boolean;
                getAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                isAnnotationPresent(arg0: JavaClassArg<java.lang.annotation.Annotation>): boolean;
                getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;
                getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                getDeclaredAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                getDeclaredAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;
                getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;

            }

            abstract class NamedPackage extends java.lang.Object {
                static readonly class: JavaClass<NamedPackage>;
                /** @deprecated */ static prototype: undefined;
            }

            abstract class ModuleLayer extends java.lang.Object {
                static readonly class: JavaClass<ModuleLayer>;
                /** @deprecated */ static prototype: undefined;

                static defineModulesWithOneLoader(arg0: java.lang.module.Configuration, arg1: JavaList<ModuleLayer>, arg2: ClassLoader): ModuleLayer$Controller;
                static defineModulesWithManyLoaders(arg0: java.lang.module.Configuration, arg1: JavaList<ModuleLayer>, arg2: ClassLoader): ModuleLayer$Controller;
                static defineModules(arg0: java.lang.module.Configuration, arg1: JavaList<ModuleLayer>, arg2: MethodWrapper<string, any, ClassLoader>): ModuleLayer$Controller;
                static empty(): ModuleLayer;
                static boot(): ModuleLayer;

                defineModulesWithOneLoader(arg0: java.lang.module.Configuration, arg1: ClassLoader): ModuleLayer;
                defineModulesWithManyLoaders(arg0: java.lang.module.Configuration, arg1: ClassLoader): ModuleLayer;
                defineModules(arg0: java.lang.module.Configuration, arg1: MethodWrapper<string, any, ClassLoader>): ModuleLayer;
                configuration(): java.lang.module.Configuration;
                parents(): JavaList<ModuleLayer>;
                modules(): JavaSet<Module>;
                findModule(arg0: string): java.util.Optional<Module>;
                findLoader(arg0: string): ClassLoader;

            }

            abstract class ModuleLayer$Controller extends java.lang.Object {
                static readonly class: JavaClass<ModuleLayer$Controller>;
                /** @deprecated */ static prototype: undefined;

                layer(): ModuleLayer;
                addReads(arg0: Module, arg1: Module): ModuleLayer$Controller;
                addExports(arg0: Module, arg1: string, arg2: Module): ModuleLayer$Controller;
                addOpens(arg0: Module, arg1: string, arg2: Module): ModuleLayer$Controller;

            }

            abstract class Cloneable extends java.lang.Interface {
                static readonly class: JavaClass<Cloneable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Cloneable {}

            interface Long extends Comparable<Long>, java.lang.constant.Constable, java.lang.constant.ConstantDesc {}
            class Long extends Number {
                static readonly class: JavaClass<Long>;
                /** @deprecated */ static prototype: undefined;

                static readonly MIN_VALUE: number;
                static readonly MAX_VALUE: number;
                static readonly TYPE: JavaClass<number>;
                static readonly SIZE: number;
                static readonly BYTES: number;

                static toString(arg0: long, arg1: int): string;
                static toUnsignedString(arg0: long, arg1: int): string;
                static toHexString(arg0: long): string;
                static toOctalString(arg0: long): string;
                static toBinaryString(arg0: long): string;
                static toString(arg0: long): string;
                static toUnsignedString(arg0: long): string;
                static parseLong(arg0: string, arg1: int): number;
                static parseLong(arg0: CharSequence, arg1: int, arg2: int, arg3: int): number;
                static parseLong(arg0: string): number;
                static parseUnsignedLong(arg0: string, arg1: int): number;
                static parseUnsignedLong(arg0: CharSequence, arg1: int, arg2: int, arg3: int): number;
                static parseUnsignedLong(arg0: string): number;
                static valueOf(arg0: string, arg1: int): number;
                static valueOf(arg0: string): number;
                static valueOf(arg0: long): number;
                static decode(arg0: string): number;
                static hashCode(arg0: long): number;
                static getLong(arg0: string): number;
                static getLong(arg0: string, arg1: long): number;
                static getLong(arg0: string, arg1: long): number;
                static compare(arg0: long, arg1: long): number;
                static compareUnsigned(arg0: long, arg1: long): number;
                static divideUnsigned(arg0: long, arg1: long): number;
                static remainderUnsigned(arg0: long, arg1: long): number;
                static highestOneBit(arg0: long): number;
                static lowestOneBit(arg0: long): number;
                static numberOfLeadingZeros(arg0: long): number;
                static numberOfTrailingZeros(arg0: long): number;
                static bitCount(arg0: long): number;
                static rotateLeft(arg0: long, arg1: int): number;
                static rotateRight(arg0: long, arg1: int): number;
                static reverse(arg0: long): number;
                static signum(arg0: long): number;
                static reverseBytes(arg0: long): number;
                static sum(arg0: long, arg1: long): number;
                static max(arg0: long, arg1: long): number;
                static min(arg0: long, arg1: long): number;

                /** @deprecated */
                constructor (arg0: long);
                /** @deprecated */
                constructor (arg0: string);

                byteValue(): number;
                shortValue(): number;
                intValue(): number;
                longValue(): number;
                floatValue(): number;
                doubleValue(): number;
                compareTo(arg0: long): number;
                describeConstable(): java.util.Optional<number>;
                resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): number;

            }

            interface Character extends Comparable<Character>, java.lang.constant.Constable, java.io.Serializable {}
            class Character extends java.lang.Object {
                static readonly class: JavaClass<Character>;
                /** @deprecated */ static prototype: undefined;

                static readonly MIN_RADIX: number;
                static readonly MAX_RADIX: number;
                static readonly MIN_VALUE: number;
                static readonly MAX_VALUE: number;
                static readonly TYPE: JavaClass<number>;
                static readonly UNASSIGNED: number;
                static readonly UPPERCASE_LETTER: number;
                static readonly LOWERCASE_LETTER: number;
                static readonly TITLECASE_LETTER: number;
                static readonly MODIFIER_LETTER: number;
                static readonly OTHER_LETTER: number;
                static readonly NON_SPACING_MARK: number;
                static readonly ENCLOSING_MARK: number;
                static readonly COMBINING_SPACING_MARK: number;
                static readonly DECIMAL_DIGIT_NUMBER: number;
                static readonly LETTER_NUMBER: number;
                static readonly OTHER_NUMBER: number;
                static readonly SPACE_SEPARATOR: number;
                static readonly LINE_SEPARATOR: number;
                static readonly PARAGRAPH_SEPARATOR: number;
                static readonly CONTROL: number;
                static readonly FORMAT: number;
                static readonly PRIVATE_USE: number;
                static readonly SURROGATE: number;
                static readonly DASH_PUNCTUATION: number;
                static readonly START_PUNCTUATION: number;
                static readonly END_PUNCTUATION: number;
                static readonly CONNECTOR_PUNCTUATION: number;
                static readonly OTHER_PUNCTUATION: number;
                static readonly MATH_SYMBOL: number;
                static readonly CURRENCY_SYMBOL: number;
                static readonly MODIFIER_SYMBOL: number;
                static readonly OTHER_SYMBOL: number;
                static readonly INITIAL_QUOTE_PUNCTUATION: number;
                static readonly FINAL_QUOTE_PUNCTUATION: number;
                static readonly DIRECTIONALITY_UNDEFINED: number;
                static readonly DIRECTIONALITY_LEFT_TO_RIGHT: number;
                static readonly DIRECTIONALITY_RIGHT_TO_LEFT: number;
                static readonly DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC: number;
                static readonly DIRECTIONALITY_EUROPEAN_NUMBER: number;
                static readonly DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR: number;
                static readonly DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR: number;
                static readonly DIRECTIONALITY_ARABIC_NUMBER: number;
                static readonly DIRECTIONALITY_COMMON_NUMBER_SEPARATOR: number;
                static readonly DIRECTIONALITY_NONSPACING_MARK: number;
                static readonly DIRECTIONALITY_BOUNDARY_NEUTRAL: number;
                static readonly DIRECTIONALITY_PARAGRAPH_SEPARATOR: number;
                static readonly DIRECTIONALITY_SEGMENT_SEPARATOR: number;
                static readonly DIRECTIONALITY_WHITESPACE: number;
                static readonly DIRECTIONALITY_OTHER_NEUTRALS: number;
                static readonly DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING: number;
                static readonly DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE: number;
                static readonly DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING: number;
                static readonly DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE: number;
                static readonly DIRECTIONALITY_POP_DIRECTIONAL_FORMAT: number;
                static readonly DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE: number;
                static readonly DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE: number;
                static readonly DIRECTIONALITY_FIRST_STRONG_ISOLATE: number;
                static readonly DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE: number;
                static readonly MIN_HIGH_SURROGATE: number;
                static readonly MAX_HIGH_SURROGATE: number;
                static readonly MIN_LOW_SURROGATE: number;
                static readonly MAX_LOW_SURROGATE: number;
                static readonly MIN_SURROGATE: number;
                static readonly MAX_SURROGATE: number;
                static readonly MIN_SUPPLEMENTARY_CODE_POINT: number;
                static readonly MIN_CODE_POINT: number;
                static readonly MAX_CODE_POINT: number;
                static readonly SIZE: number;
                static readonly BYTES: number;

                static valueOf(arg0: char): number;
                static hashCode(arg0: char): number;
                static toString(arg0: char): string;
                static toString(arg0: int): string;
                static isValidCodePoint(arg0: int): boolean;
                static isBmpCodePoint(arg0: int): boolean;
                static isSupplementaryCodePoint(arg0: int): boolean;
                static isHighSurrogate(arg0: char): boolean;
                static isLowSurrogate(arg0: char): boolean;
                static isSurrogate(arg0: char): boolean;
                static isSurrogatePair(arg0: char, arg1: char): boolean;
                static charCount(arg0: int): number;
                static toCodePoint(arg0: char, arg1: char): number;
                static codePointAt(arg0: CharSequence, arg1: int): number;
                static codePointAt(arg0: char[], arg1: int): number;
                static codePointAt(arg0: char[], arg1: int, arg2: int): number;
                static codePointBefore(arg0: CharSequence, arg1: int): number;
                static codePointBefore(arg0: char[], arg1: int): number;
                static codePointBefore(arg0: char[], arg1: int, arg2: int): number;
                static highSurrogate(arg0: int): number;
                static lowSurrogate(arg0: int): number;
                static toChars(arg0: int, arg1: char[], arg2: int): number;
                static toChars(arg0: int): JavaArray<number>;
                static codePointCount(arg0: CharSequence, arg1: int, arg2: int): number;
                static codePointCount(arg0: char[], arg1: int, arg2: int): number;
                static offsetByCodePoints(arg0: CharSequence, arg1: int, arg2: int): number;
                static offsetByCodePoints(arg0: char[], arg1: int, arg2: int, arg3: int, arg4: int): number;
                static isLowerCase(arg0: char): boolean;
                static isLowerCase(arg0: int): boolean;
                static isUpperCase(arg0: char): boolean;
                static isUpperCase(arg0: int): boolean;
                static isTitleCase(arg0: char): boolean;
                static isTitleCase(arg0: int): boolean;
                static isDigit(arg0: char): boolean;
                static isDigit(arg0: int): boolean;
                static isDefined(arg0: char): boolean;
                static isDefined(arg0: int): boolean;
                static isLetter(arg0: char): boolean;
                static isLetter(arg0: int): boolean;
                static isLetterOrDigit(arg0: char): boolean;
                static isLetterOrDigit(arg0: int): boolean;
                /** @deprecated */
                static isJavaLetter(arg0: char): boolean;
                /** @deprecated */
                static isJavaLetterOrDigit(arg0: char): boolean;
                static isAlphabetic(arg0: int): boolean;
                static isIdeographic(arg0: int): boolean;
                static isJavaIdentifierStart(arg0: char): boolean;
                static isJavaIdentifierStart(arg0: int): boolean;
                static isJavaIdentifierPart(arg0: char): boolean;
                static isJavaIdentifierPart(arg0: int): boolean;
                static isUnicodeIdentifierStart(arg0: char): boolean;
                static isUnicodeIdentifierStart(arg0: int): boolean;
                static isUnicodeIdentifierPart(arg0: char): boolean;
                static isUnicodeIdentifierPart(arg0: int): boolean;
                static isIdentifierIgnorable(arg0: char): boolean;
                static isIdentifierIgnorable(arg0: int): boolean;
                static toLowerCase(arg0: char): number;
                static toLowerCase(arg0: int): number;
                static toUpperCase(arg0: char): number;
                static toUpperCase(arg0: int): number;
                static toTitleCase(arg0: char): number;
                static toTitleCase(arg0: int): number;
                static digit(arg0: char, arg1: int): number;
                static digit(arg0: int, arg1: int): number;
                static getNumericValue(arg0: char): number;
                static getNumericValue(arg0: int): number;
                /** @deprecated */
                static isSpace(arg0: char): boolean;
                static isSpaceChar(arg0: char): boolean;
                static isSpaceChar(arg0: int): boolean;
                static isWhitespace(arg0: char): boolean;
                static isWhitespace(arg0: int): boolean;
                static isISOControl(arg0: char): boolean;
                static isISOControl(arg0: int): boolean;
                static getType(arg0: char): number;
                static getType(arg0: int): number;
                static forDigit(arg0: int, arg1: int): number;
                static getDirectionality(arg0: char): number;
                static getDirectionality(arg0: int): number;
                static isMirrored(arg0: char): boolean;
                static isMirrored(arg0: int): boolean;
                static compare(arg0: char, arg1: char): number;
                static reverseBytes(arg0: char): number;
                static getName(arg0: int): string;
                static codePointOf(arg0: string): number;

                /** @deprecated */
                constructor (arg0: char);

                describeConstable(): java.util.Optional<java.lang.constant.DynamicConstantDesc<number>>;
                charValue(): number;
                compareTo(arg0: char): number;

            }

            abstract class Void extends java.lang.Object {
                static readonly class: JavaClass<Void>;
                /** @deprecated */ static prototype: undefined;

                static readonly TYPE: JavaClass<Void>;
            }

            interface Thread extends Runnable {}
            class Thread extends java.lang.Object {
                static readonly class: JavaClass<Thread>;
                /** @deprecated */ static prototype: undefined;

                static readonly MIN_PRIORITY: number;
                static readonly NORM_PRIORITY: number;
                static readonly MAX_PRIORITY: number;

                static currentThread(): Thread;
                static yield(): void;
                static sleep(arg0: long): void;
                static sleep(arg0: long, arg1: int): void;
                static onSpinWait(): void;
                static interrupted(): boolean;
                static activeCount(): number;
                static enumerate(arg0: Thread[]): number;
                static dumpStack(): void;
                static holdsLock(arg0: any): boolean;
                static getAllStackTraces(): JavaMap<Thread, JavaArray<StackTraceElement>>;
                static setDefaultUncaughtExceptionHandler(arg0: Thread$UncaughtExceptionHandler): void;
                static getDefaultUncaughtExceptionHandler(): Thread$UncaughtExceptionHandler;

                constructor ();
                constructor (arg0: MethodWrapper);
                constructor (arg0: ThreadGroup, arg1: MethodWrapper);
                constructor (arg0: string);
                constructor (arg0: ThreadGroup, arg1: string);
                constructor (arg0: MethodWrapper, arg1: string);
                constructor (arg0: ThreadGroup, arg1: MethodWrapper, arg2: string);
                constructor (arg0: ThreadGroup, arg1: MethodWrapper, arg2: string, arg3: long);
                constructor (arg0: ThreadGroup, arg1: MethodWrapper, arg2: string, arg3: long, arg4: boolean);

                start(): void;
                run(): void;
                /** @deprecated */
                stop(): void;
                interrupt(): void;
                isInterrupted(): boolean;
                isAlive(): boolean;
                /** @deprecated */
                suspend(): void;
                /** @deprecated */
                resume(): void;
                setPriority(arg0: int): void;
                getPriority(): number;
                setName(arg0: string): void;
                getName(): string;
                getThreadGroup(): ThreadGroup;
                /** @deprecated */
                countStackFrames(): number;
                join(arg0: long): void;
                join(arg0: long, arg1: int): void;
                join(): void;
                setDaemon(arg0: boolean): void;
                isDaemon(): boolean;
                /** @deprecated */
                checkAccess(): void;
                getContextClassLoader(): ClassLoader;
                setContextClassLoader(arg0: ClassLoader): void;
                getStackTrace(): JavaArray<StackTraceElement>;
                getId(): number;
                getState(): Thread$State;
                getUncaughtExceptionHandler(): Thread$UncaughtExceptionHandler;
                setUncaughtExceptionHandler(arg0: Thread$UncaughtExceptionHandler): void;

            }

            abstract class Runnable extends java.lang.Interface {
                static readonly class: JavaClass<Runnable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Runnable {

                run(): void;

            }

            abstract class Thread$State extends Enum<Thread$State> {
                static readonly class: JavaClass<Thread$State>;
                /** @deprecated */ static prototype: undefined;

                static readonly NEW: Thread$State;
                static readonly RUNNABLE: Thread$State;
                static readonly BLOCKED: Thread$State;
                static readonly WAITING: Thread$State;
                static readonly TIMED_WAITING: Thread$State;
                static readonly TERMINATED: Thread$State;

                static values(): JavaArray<Thread$State>;
                static valueOf(arg0: string): Thread$State;

            }

            abstract class Thread$UncaughtExceptionHandler extends java.lang.Interface {
                static readonly class: JavaClass<Thread$UncaughtExceptionHandler>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Thread$UncaughtExceptionHandler {

                uncaughtException(arg0: Thread, arg1: Throwable): void;

            }

            interface ThreadGroup extends Thread$UncaughtExceptionHandler {}
            class ThreadGroup extends java.lang.Object {
                static readonly class: JavaClass<ThreadGroup>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: string);
                constructor (arg0: ThreadGroup, arg1: string);

                getName(): string;
                getParent(): ThreadGroup;
                getMaxPriority(): number;
                /** @deprecated */
                isDaemon(): boolean;
                /** @deprecated */
                isDestroyed(): boolean;
                /** @deprecated */
                setDaemon(arg0: boolean): void;
                setMaxPriority(arg0: int): void;
                parentOf(arg0: ThreadGroup): boolean;
                /** @deprecated */
                checkAccess(): void;
                activeCount(): number;
                enumerate(arg0: Thread[]): number;
                enumerate(arg0: Thread[], arg1: boolean): number;
                activeGroupCount(): number;
                enumerate(arg0: ThreadGroup[]): number;
                enumerate(arg0: ThreadGroup[], arg1: boolean): number;
                /** @deprecated */
                stop(): void;
                interrupt(): void;
                /** @deprecated */
                suspend(): void;
                /** @deprecated */
                resume(): void;
                /** @deprecated */
                destroy(): void;
                list(): void;
                uncaughtException(arg0: Thread, arg1: Throwable): void;
                /** @deprecated */
                allowThreadSuspension(arg0: boolean): boolean;

            }

            abstract class Record extends java.lang.Object {
                static readonly class: JavaClass<Record>;
                /** @deprecated */ static prototype: undefined;
            }

            interface Float extends Comparable<Float>, java.lang.constant.Constable, java.lang.constant.ConstantDesc {}
            class Float extends Number {
                static readonly class: JavaClass<Float>;
                /** @deprecated */ static prototype: undefined;

                static readonly POSITIVE_INFINITY: number;
                static readonly NEGATIVE_INFINITY: number;
                static readonly NaN: number;
                static readonly MAX_VALUE: number;
                static readonly MIN_NORMAL: number;
                static readonly MIN_VALUE: number;
                static readonly MAX_EXPONENT: number;
                static readonly MIN_EXPONENT: number;
                static readonly SIZE: number;
                static readonly BYTES: number;
                static readonly TYPE: JavaClass<number>;

                static toString(arg0: float): string;
                static toHexString(arg0: float): string;
                static valueOf(arg0: string): number;
                static valueOf(arg0: float): number;
                static parseFloat(arg0: string): number;
                static isNaN(arg0: float): boolean;
                static isInfinite(arg0: float): boolean;
                static isFinite(arg0: float): boolean;
                static hashCode(arg0: float): number;
                static floatToIntBits(arg0: float): number;
                static floatToRawIntBits(arg0: float): number;
                static intBitsToFloat(arg0: int): number;
                static compare(arg0: float, arg1: float): number;
                static sum(arg0: float, arg1: float): number;
                static max(arg0: float, arg1: float): number;
                static min(arg0: float, arg1: float): number;

                /** @deprecated */
                constructor (arg0: float);
                /** @deprecated */
                constructor (arg0: double);
                /** @deprecated */
                constructor (arg0: string);

                isNaN(): boolean;
                isInfinite(): boolean;
                byteValue(): number;
                shortValue(): number;
                intValue(): number;
                longValue(): number;
                floatValue(): number;
                doubleValue(): number;
                compareTo(arg0: float): number;
                describeConstable(): java.util.Optional<number>;
                resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): number;

            }

            abstract class Character$Subset extends java.lang.Object {
                static readonly class: JavaClass<Character$Subset>;
                /** @deprecated */ static prototype: undefined;
            }

            export {
                Boolean,
                Appendable,
                CharSequence,
                String,
                Exception,
                AutoCloseable,
                Readable,
                Integer,
                Comparable,
                Double,
                Enum,
                Enum$EnumDesc,
                StringBuilder,
                StringBuffer,
                ClassLoader,
                Number,
                Module,
                AbstractStringBuilder,
                Package,
                NamedPackage,
                ModuleLayer,
                ModuleLayer$Controller,
                Cloneable,
                Long,
                Character,
                Void,
                Thread,
                Runnable,
                Thread$State,
                Thread$UncaughtExceptionHandler,
                ThreadGroup,
                Record,
                Float,
                Character$Subset
            }

        }
        namespace lang {

            namespace annotation {

                abstract class Annotation extends java.lang.Interface {
                    static readonly class: JavaClass<Annotation>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Annotation {

                    annotationType(): JavaClass<Annotation>;

                }

                export { Annotation }

            }

            namespace constant {

                interface DynamicConstantDesc<T> extends ConstantDesc {}
                abstract class DynamicConstantDesc<T> extends java.lang.Object {
                    static readonly class: JavaClass<DynamicConstantDesc<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static ofCanonical<T>(arg0: DirectMethodHandleDesc, arg1: string, arg2: ClassDesc, arg3: ConstantDesc[]): ConstantDesc;
                    static ofNamed<T>(arg0: DirectMethodHandleDesc, arg1: string, arg2: ClassDesc, ...arg3: JavaVarArgs<ConstantDesc>): DynamicConstantDesc<T>;
                    static of<T>(arg0: DirectMethodHandleDesc, ...arg1: JavaVarArgs<ConstantDesc>): DynamicConstantDesc<T>;
                    static of<T>(arg0: DirectMethodHandleDesc): DynamicConstantDesc<T>;

                    constantName(): string;
                    constantType(): ClassDesc;
                    bootstrapMethod(): DirectMethodHandleDesc;
                    bootstrapArgs(): JavaArray<ConstantDesc>;
                    bootstrapArgsList(): JavaList<ConstantDesc>;
                    resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): T;

                }

                abstract class ConstantDesc extends java.lang.Interface {
                    static readonly class: JavaClass<ConstantDesc>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ConstantDesc {

                    resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): any;

                }

                abstract class Constable extends java.lang.Interface {
                    static readonly class: JavaClass<Constable>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Constable {

                    describeConstable(): java.util.Optional<ConstantDesc>;

                }

                abstract class DirectMethodHandleDesc extends java.lang.Interface {
                    static readonly class: JavaClass<DirectMethodHandleDesc>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DirectMethodHandleDesc extends MethodHandleDesc {

                    kind(): DirectMethodHandleDesc$Kind;
                    refKind(): number;
                    isOwnerInterface(): boolean;
                    owner(): ClassDesc;
                    methodName(): string;
                    lookupDescriptor(): string;

                }

                abstract class ClassDesc extends java.lang.Interface {
                    static readonly class: JavaClass<ClassDesc>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: string): ClassDesc;
                    static of(arg0: string, arg1: string): ClassDesc;
                    static ofDescriptor(arg0: string): ClassDesc;

                }
                interface ClassDesc extends ConstantDesc, java.lang.invoke.TypeDescriptor$OfField<ClassDesc> {

                    arrayType(): ClassDesc;
                    arrayType(arg0: int): ClassDesc;
                    nested(arg0: string): ClassDesc;
                    nested(arg0: string, ...arg1: JavaVarArgs<string>): ClassDesc;
                    isArray(): boolean;
                    isPrimitive(): boolean;
                    isClassOrInterface(): boolean;
                    componentType(): ClassDesc;
                    packageName(): string;
                    displayName(): string;
                    descriptorString(): string;

                }

                abstract class MethodHandleDesc extends java.lang.Interface {
                    static readonly class: JavaClass<MethodHandleDesc>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: DirectMethodHandleDesc$Kind, arg1: ClassDesc, arg2: string, arg3: string): DirectMethodHandleDesc;
                    static ofMethod(arg0: DirectMethodHandleDesc$Kind, arg1: ClassDesc, arg2: string, arg3: MethodTypeDesc): DirectMethodHandleDesc;
                    static ofField(arg0: DirectMethodHandleDesc$Kind, arg1: ClassDesc, arg2: string, arg3: ClassDesc): DirectMethodHandleDesc;
                    static ofConstructor(arg0: ClassDesc, ...arg1: JavaVarArgs<ClassDesc>): DirectMethodHandleDesc;

                }
                interface MethodHandleDesc extends ConstantDesc {

                    asType(arg0: MethodTypeDesc): MethodHandleDesc;
                    invocationType(): MethodTypeDesc;

                }

                abstract class DirectMethodHandleDesc$Kind extends java.lang.Enum<DirectMethodHandleDesc$Kind> {
                    static readonly class: JavaClass<DirectMethodHandleDesc$Kind>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly STATIC: DirectMethodHandleDesc$Kind;
                    static readonly INTERFACE_STATIC: DirectMethodHandleDesc$Kind;
                    static readonly VIRTUAL: DirectMethodHandleDesc$Kind;
                    static readonly INTERFACE_VIRTUAL: DirectMethodHandleDesc$Kind;
                    static readonly SPECIAL: DirectMethodHandleDesc$Kind;
                    static readonly INTERFACE_SPECIAL: DirectMethodHandleDesc$Kind;
                    static readonly CONSTRUCTOR: DirectMethodHandleDesc$Kind;
                    static readonly GETTER: DirectMethodHandleDesc$Kind;
                    static readonly SETTER: DirectMethodHandleDesc$Kind;
                    static readonly STATIC_GETTER: DirectMethodHandleDesc$Kind;
                    static readonly STATIC_SETTER: DirectMethodHandleDesc$Kind;

                    static values(): JavaArray<DirectMethodHandleDesc$Kind>;
                    static valueOf(arg0: string): DirectMethodHandleDesc$Kind;
                    static valueOf(arg0: int): DirectMethodHandleDesc$Kind;
                    static valueOf(arg0: int, arg1: boolean): DirectMethodHandleDesc$Kind;

                    readonly refKind: number;
                    readonly isInterface: boolean;
                }

                abstract class MethodTypeDesc extends java.lang.Interface {
                    static readonly class: JavaClass<MethodTypeDesc>;
                    /** @deprecated */ static prototype: undefined;

                    static ofDescriptor(arg0: string): MethodTypeDesc;
                    static of(arg0: ClassDesc, ...arg1: JavaVarArgs<ClassDesc>): MethodTypeDesc;

                }
                interface MethodTypeDesc extends java.lang.invoke.TypeDescriptor$OfMethod<ClassDesc, MethodTypeDesc>, ConstantDesc {

                    returnType(): ClassDesc;
                    parameterCount(): number;
                    parameterType(arg0: int): ClassDesc;
                    parameterList(): JavaList<ClassDesc>;
                    parameterArray(): JavaArray<ClassDesc>;
                    changeReturnType(arg0: ClassDesc): MethodTypeDesc;
                    changeParameterType(arg0: int, arg1: ClassDesc): MethodTypeDesc;
                    dropParameterTypes(arg0: int, arg1: int): MethodTypeDesc;
                    insertParameterTypes(arg0: int, ...arg1: JavaVarArgs<ClassDesc>): MethodTypeDesc;
                    descriptorString(): string;
                    displayDescriptor(): string;

                }

                export {
                    DynamicConstantDesc,
                    ConstantDesc,
                    Constable,
                    DirectMethodHandleDesc,
                    ClassDesc,
                    MethodHandleDesc,
                    DirectMethodHandleDesc$Kind,
                    MethodTypeDesc
                }

            }

            namespace invoke {

                abstract class TypeDescriptor$OfField<F extends TypeDescriptor$OfField<F>> extends java.lang.Interface {
                    static readonly class: JavaClass<TypeDescriptor$OfField<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TypeDescriptor$OfField<F extends TypeDescriptor$OfField<F>> extends TypeDescriptor {

                    isArray(): boolean;
                    isPrimitive(): boolean;
                    componentType(): F;
                    arrayType(): F;

                }

                abstract class MethodHandles$Lookup extends java.lang.Object {
                    static readonly class: JavaClass<MethodHandles$Lookup>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly PUBLIC: number;
                    static readonly PRIVATE: number;
                    static readonly PROTECTED: number;
                    static readonly PACKAGE: number;
                    static readonly MODULE: number;
                    static readonly UNCONDITIONAL: number;
                    static readonly ORIGINAL: number;

                    lookupClass(): JavaClass<any>;
                    previousLookupClass(): JavaClass<any>;
                    lookupModes(): number;
                    in(arg0: JavaClassArg<any>): MethodHandles$Lookup;
                    dropLookupMode(arg0: int): MethodHandles$Lookup;
                    defineClass(arg0: byte[]): JavaClass<any>;
                    defineHiddenClass(arg0: byte[], arg1: boolean, ...arg2: JavaVarArgs<MethodHandles$Lookup$ClassOption>): MethodHandles$Lookup;
                    defineHiddenClassWithClassData(arg0: byte[], arg1: any, arg2: boolean, ...arg3: JavaVarArgs<MethodHandles$Lookup$ClassOption>): MethodHandles$Lookup;
                    findStatic(arg0: JavaClassArg<any>, arg1: string, arg2: MethodType): MethodHandle;
                    findVirtual(arg0: JavaClassArg<any>, arg1: string, arg2: MethodType): MethodHandle;
                    findConstructor(arg0: JavaClassArg<any>, arg1: MethodType): MethodHandle;
                    findClass(arg0: string): JavaClass<any>;
                    ensureInitialized(arg0: JavaClassArg<any>): JavaClass<any>;
                    accessClass(arg0: JavaClassArg<any>): JavaClass<any>;
                    findSpecial(arg0: JavaClassArg<any>, arg1: string, arg2: MethodType, arg3: JavaClassArg<any>): MethodHandle;
                    findGetter(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): MethodHandle;
                    findSetter(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): MethodHandle;
                    findVarHandle(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): VarHandle;
                    findStaticGetter(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): MethodHandle;
                    findStaticSetter(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): MethodHandle;
                    findStaticVarHandle(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): VarHandle;
                    bind(arg0: any, arg1: string, arg2: MethodType): MethodHandle;
                    unreflect(arg0: java.lang.reflect.Method): MethodHandle;
                    unreflectSpecial(arg0: java.lang.reflect.Method, arg1: JavaClassArg<any>): MethodHandle;
                    unreflectConstructor(arg0: java.lang.reflect.Constructor<any>): MethodHandle;
                    unreflectGetter(arg0: java.lang.reflect.Field): MethodHandle;
                    unreflectSetter(arg0: java.lang.reflect.Field): MethodHandle;
                    unreflectVarHandle(arg0: java.lang.reflect.Field): VarHandle;
                    revealDirect(arg0: MethodHandle): MethodHandleInfo;
                    /** @deprecated */
                    hasPrivateAccess(): boolean;
                    hasFullPrivilegeAccess(): boolean;

                }

                abstract class TypeDescriptor extends java.lang.Interface {
                    static readonly class: JavaClass<TypeDescriptor>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TypeDescriptor {

                    descriptorString(): string;

                }

                abstract class TypeDescriptor$OfMethod<F extends TypeDescriptor$OfField<F>, M extends TypeDescriptor$OfMethod<F, M>> extends java.lang.Interface {
                    static readonly class: JavaClass<TypeDescriptor$OfMethod<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TypeDescriptor$OfMethod<F extends TypeDescriptor$OfField<F>, M extends TypeDescriptor$OfMethod<F, M>> extends TypeDescriptor {

                    parameterCount(): number;
                    parameterType(arg0: int): F;
                    returnType(): F;
                    parameterArray(): JavaArray<F>;
                    parameterList(): JavaList<F>;
                    changeReturnType(arg0: F): M;
                    changeParameterType(arg0: int, arg1: F): M;
                    dropParameterTypes(arg0: int, arg1: int): M;
                    insertParameterTypes(arg0: int, ...arg1: JavaVarArgs<F>): M;

                }

                abstract class MethodHandles$Lookup$ClassOption extends java.lang.Enum<MethodHandles$Lookup$ClassOption> {
                    static readonly class: JavaClass<MethodHandles$Lookup$ClassOption>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly NESTMATE: MethodHandles$Lookup$ClassOption;
                    static readonly STRONG: MethodHandles$Lookup$ClassOption;

                    static values(): JavaArray<MethodHandles$Lookup$ClassOption>;
                    static valueOf(arg0: string): MethodHandles$Lookup$ClassOption;

                }

                abstract class MethodHandleInfo extends java.lang.Interface {
                    static readonly class: JavaClass<MethodHandleInfo>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly REF_getField: number;
                    static readonly REF_getStatic: number;
                    static readonly REF_putField: number;
                    static readonly REF_putStatic: number;
                    static readonly REF_invokeVirtual: number;
                    static readonly REF_invokeStatic: number;
                    static readonly REF_invokeSpecial: number;
                    static readonly REF_newInvokeSpecial: number;
                    static readonly REF_invokeInterface: number;

                    static referenceKindToString(arg0: int): string;
                    static toString(arg0: int, arg1: JavaClassArg<any>, arg2: string, arg3: MethodType): string;

                }
                interface MethodHandleInfo {

                    getReferenceKind(): number;
                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getMethodType(): MethodType;
                    reflectAs<T extends java.lang.reflect.Member>(arg0: JavaClassArg<T>, arg1: MethodHandles$Lookup): T;
                    getModifiers(): number;
                    isVarArgs(): boolean;

                }

                interface MethodType extends java.lang.constant.Constable, java.io.Serializable, TypeDescriptor$OfMethod<JavaClass<any>, MethodType> {}
                abstract class MethodType extends java.lang.Object {
                    static readonly class: JavaClass<MethodType>;
                    /** @deprecated */ static prototype: undefined;

                    static methodType(arg0: JavaClassArg<any>, arg1: JavaClassArg<any>[]): MethodType;
                    static methodType(arg0: JavaClassArg<any>, arg1: JavaList<JavaClassArg<any>>): MethodType;
                    static methodType(arg0: JavaClassArg<any>, arg1: JavaClassArg<any>, ...arg2: JavaVarArgs<JavaClassArg<any>>): MethodType;
                    static methodType(arg0: JavaClassArg<any>): MethodType;
                    static methodType(arg0: JavaClassArg<any>, arg1: JavaClassArg<any>): MethodType;
                    static methodType(arg0: JavaClassArg<any>, arg1: MethodType): MethodType;
                    static genericMethodType(arg0: int, arg1: boolean): MethodType;
                    static genericMethodType(arg0: int): MethodType;
                    static fromMethodDescriptorString(arg0: string, arg1: java.lang.ClassLoader): MethodType;

                    changeParameterType(arg0: int, arg1: JavaClassArg<any>): MethodType;
                    insertParameterTypes(arg0: int, ...arg1: JavaVarArgs<JavaClassArg<any>>): MethodType;
                    appendParameterTypes(...arg0: JavaVarArgs<JavaClassArg<any>>): MethodType;
                    insertParameterTypes(arg0: int, arg1: JavaList<JavaClassArg<any>>): MethodType;
                    appendParameterTypes(arg0: JavaList<JavaClassArg<any>>): MethodType;
                    dropParameterTypes(arg0: int, arg1: int): MethodType;
                    changeReturnType(arg0: JavaClassArg<any>): MethodType;
                    hasPrimitives(): boolean;
                    hasWrappers(): boolean;
                    erase(): MethodType;
                    generic(): MethodType;
                    wrap(): MethodType;
                    unwrap(): MethodType;
                    parameterType(arg0: int): JavaClass<any>;
                    parameterCount(): number;
                    returnType(): JavaClass<any>;
                    parameterList(): JavaList<JavaClass<any>>;
                    lastParameterType(): JavaClass<any>;
                    parameterArray(): JavaArray<JavaClass<any>>;
                    toMethodDescriptorString(): string;
                    descriptorString(): string;
                    describeConstable(): java.util.Optional<java.lang.constant.MethodTypeDesc>;

                }

                interface MethodHandle extends java.lang.constant.Constable {}
                abstract class MethodHandle extends java.lang.Object {
                    static readonly class: JavaClass<MethodHandle>;
                    /** @deprecated */ static prototype: undefined;

                    type(): MethodType;
                    invokeExact(...arg0: JavaVarArgs<any>): any;
                    invoke(...arg0: JavaVarArgs<any>): any;
                    invokeWithArguments(...arg0: JavaVarArgs<any>): any;
                    invokeWithArguments(arg0: JavaList<any>): any;
                    asType(arg0: MethodType): MethodHandle;
                    asSpreader(arg0: JavaClassArg<any>, arg1: int): MethodHandle;
                    asSpreader(arg0: int, arg1: JavaClassArg<any>, arg2: int): MethodHandle;
                    withVarargs(arg0: boolean): MethodHandle;
                    asCollector(arg0: JavaClassArg<any>, arg1: int): MethodHandle;
                    asCollector(arg0: int, arg1: JavaClassArg<any>, arg2: int): MethodHandle;
                    asVarargsCollector(arg0: JavaClassArg<any>): MethodHandle;
                    isVarargsCollector(): boolean;
                    asFixedArity(): MethodHandle;
                    bindTo(arg0: any): MethodHandle;
                    describeConstable(): java.util.Optional<java.lang.constant.MethodHandleDesc>;

                }

                interface VarHandle extends java.lang.constant.Constable {}
                abstract class VarHandle extends java.lang.Object {
                    static readonly class: JavaClass<VarHandle>;
                    /** @deprecated */ static prototype: undefined;

                    static fullFence(): void;
                    static acquireFence(): void;
                    static releaseFence(): void;
                    static loadLoadFence(): void;
                    static storeStoreFence(): void;

                    hasInvokeExactBehavior(): boolean;
                    get(...arg0: JavaVarArgs<any>): any;
                    set(...arg0: JavaVarArgs<any>): void;
                    getVolatile(...arg0: JavaVarArgs<any>): any;
                    setVolatile(...arg0: JavaVarArgs<any>): void;
                    getOpaque(...arg0: JavaVarArgs<any>): any;
                    setOpaque(...arg0: JavaVarArgs<any>): void;
                    getAcquire(...arg0: JavaVarArgs<any>): any;
                    setRelease(...arg0: JavaVarArgs<any>): void;
                    compareAndSet(...arg0: JavaVarArgs<any>): boolean;
                    compareAndExchange(...arg0: JavaVarArgs<any>): any;
                    compareAndExchangeAcquire(...arg0: JavaVarArgs<any>): any;
                    compareAndExchangeRelease(...arg0: JavaVarArgs<any>): any;
                    weakCompareAndSetPlain(...arg0: JavaVarArgs<any>): boolean;
                    weakCompareAndSet(...arg0: JavaVarArgs<any>): boolean;
                    weakCompareAndSetAcquire(...arg0: JavaVarArgs<any>): boolean;
                    weakCompareAndSetRelease(...arg0: JavaVarArgs<any>): boolean;
                    getAndSet(...arg0: JavaVarArgs<any>): any;
                    getAndSetAcquire(...arg0: JavaVarArgs<any>): any;
                    getAndSetRelease(...arg0: JavaVarArgs<any>): any;
                    getAndAdd(...arg0: JavaVarArgs<any>): any;
                    getAndAddAcquire(...arg0: JavaVarArgs<any>): any;
                    getAndAddRelease(...arg0: JavaVarArgs<any>): any;
                    getAndBitwiseOr(...arg0: JavaVarArgs<any>): any;
                    getAndBitwiseOrAcquire(...arg0: JavaVarArgs<any>): any;
                    getAndBitwiseOrRelease(...arg0: JavaVarArgs<any>): any;
                    getAndBitwiseAnd(...arg0: JavaVarArgs<any>): any;
                    getAndBitwiseAndAcquire(...arg0: JavaVarArgs<any>): any;
                    getAndBitwiseAndRelease(...arg0: JavaVarArgs<any>): any;
                    getAndBitwiseXor(...arg0: JavaVarArgs<any>): any;
                    getAndBitwiseXorAcquire(...arg0: JavaVarArgs<any>): any;
                    getAndBitwiseXorRelease(...arg0: JavaVarArgs<any>): any;
                    withInvokeExactBehavior(): VarHandle;
                    withInvokeBehavior(): VarHandle;
                    varType(): JavaClass<any>;
                    coordinateTypes(): JavaList<JavaClass<any>>;
                    accessModeType(arg0: VarHandle$AccessMode): MethodType;
                    isAccessModeSupported(arg0: VarHandle$AccessMode): boolean;
                    toMethodHandle(arg0: VarHandle$AccessMode): MethodHandle;
                    describeConstable(): java.util.Optional<VarHandle$VarHandleDesc>;

                }

                abstract class VarHandle$AccessMode extends java.lang.Enum<VarHandle$AccessMode> {
                    static readonly class: JavaClass<VarHandle$AccessMode>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly GET: VarHandle$AccessMode;
                    static readonly SET: VarHandle$AccessMode;
                    static readonly GET_VOLATILE: VarHandle$AccessMode;
                    static readonly SET_VOLATILE: VarHandle$AccessMode;
                    static readonly GET_ACQUIRE: VarHandle$AccessMode;
                    static readonly SET_RELEASE: VarHandle$AccessMode;
                    static readonly GET_OPAQUE: VarHandle$AccessMode;
                    static readonly SET_OPAQUE: VarHandle$AccessMode;
                    static readonly COMPARE_AND_SET: VarHandle$AccessMode;
                    static readonly COMPARE_AND_EXCHANGE: VarHandle$AccessMode;
                    static readonly COMPARE_AND_EXCHANGE_ACQUIRE: VarHandle$AccessMode;
                    static readonly COMPARE_AND_EXCHANGE_RELEASE: VarHandle$AccessMode;
                    static readonly WEAK_COMPARE_AND_SET_PLAIN: VarHandle$AccessMode;
                    static readonly WEAK_COMPARE_AND_SET: VarHandle$AccessMode;
                    static readonly WEAK_COMPARE_AND_SET_ACQUIRE: VarHandle$AccessMode;
                    static readonly WEAK_COMPARE_AND_SET_RELEASE: VarHandle$AccessMode;
                    static readonly GET_AND_SET: VarHandle$AccessMode;
                    static readonly GET_AND_SET_ACQUIRE: VarHandle$AccessMode;
                    static readonly GET_AND_SET_RELEASE: VarHandle$AccessMode;
                    static readonly GET_AND_ADD: VarHandle$AccessMode;
                    static readonly GET_AND_ADD_ACQUIRE: VarHandle$AccessMode;
                    static readonly GET_AND_ADD_RELEASE: VarHandle$AccessMode;
                    static readonly GET_AND_BITWISE_OR: VarHandle$AccessMode;
                    static readonly GET_AND_BITWISE_OR_RELEASE: VarHandle$AccessMode;
                    static readonly GET_AND_BITWISE_OR_ACQUIRE: VarHandle$AccessMode;
                    static readonly GET_AND_BITWISE_AND: VarHandle$AccessMode;
                    static readonly GET_AND_BITWISE_AND_RELEASE: VarHandle$AccessMode;
                    static readonly GET_AND_BITWISE_AND_ACQUIRE: VarHandle$AccessMode;
                    static readonly GET_AND_BITWISE_XOR: VarHandle$AccessMode;
                    static readonly GET_AND_BITWISE_XOR_RELEASE: VarHandle$AccessMode;
                    static readonly GET_AND_BITWISE_XOR_ACQUIRE: VarHandle$AccessMode;

                    static values(): JavaArray<VarHandle$AccessMode>;
                    static valueOf(arg0: string): VarHandle$AccessMode;
                    static valueFromMethodName(arg0: string): VarHandle$AccessMode;

                    methodName(): string;

                }

                abstract class VarHandle$VarHandleDesc extends java.lang.constant.DynamicConstantDesc<VarHandle> {
                    static readonly class: JavaClass<VarHandle$VarHandleDesc>;
                    /** @deprecated */ static prototype: undefined;

                    static ofField(arg0: java.lang.constant.ClassDesc, arg1: string, arg2: java.lang.constant.ClassDesc): VarHandle$VarHandleDesc;
                    static ofStaticField(arg0: java.lang.constant.ClassDesc, arg1: string, arg2: java.lang.constant.ClassDesc): VarHandle$VarHandleDesc;
                    static ofArray(arg0: java.lang.constant.ClassDesc): VarHandle$VarHandleDesc;

                    varType(): java.lang.constant.ClassDesc;
                    resolveConstantDesc(arg0: MethodHandles$Lookup): VarHandle;

                }

                export {
                    TypeDescriptor$OfField,
                    MethodHandles$Lookup,
                    TypeDescriptor,
                    TypeDescriptor$OfMethod,
                    MethodHandles$Lookup$ClassOption,
                    MethodHandleInfo,
                    MethodType,
                    MethodHandle,
                    VarHandle,
                    VarHandle$AccessMode,
                    VarHandle$VarHandleDesc
                }

            }

            namespace module {

                interface ModuleDescriptor extends java.lang.Comparable<ModuleDescriptor> {}
                abstract class ModuleDescriptor extends java.lang.Object {
                    static readonly class: JavaClass<ModuleDescriptor>;
                    /** @deprecated */ static prototype: undefined;

                    static newModule(arg0: string, arg1: JavaSet<ModuleDescriptor$Modifier>): ModuleDescriptor$Builder;
                    static newModule(arg0: string): ModuleDescriptor$Builder;
                    static newOpenModule(arg0: string): ModuleDescriptor$Builder;
                    static newAutomaticModule(arg0: string): ModuleDescriptor$Builder;
                    static read(arg0: java.io.InputStream, arg1: MethodWrapper<any, any, JavaSet<string>>): ModuleDescriptor;
                    static read(arg0: java.io.InputStream): ModuleDescriptor;
                    static read(arg0: java.nio.ByteBuffer, arg1: MethodWrapper<any, any, JavaSet<string>>): ModuleDescriptor;
                    static read(arg0: java.nio.ByteBuffer): ModuleDescriptor;

                    name(): string;
                    modifiers(): JavaSet<ModuleDescriptor$Modifier>;
                    isOpen(): boolean;
                    isAutomatic(): boolean;
                    requires(): JavaSet<ModuleDescriptor$Requires>;
                    exports(): JavaSet<ModuleDescriptor$Exports>;
                    opens(): JavaSet<ModuleDescriptor$Opens>;
                    uses(): JavaSet<string>;
                    provides(): JavaSet<ModuleDescriptor$Provides>;
                    version(): java.util.Optional<ModuleDescriptor$Version>;
                    rawVersion(): java.util.Optional<string>;
                    toNameAndVersion(): string;
                    mainClass(): java.util.Optional<string>;
                    packages(): JavaSet<string>;
                    compareTo(arg0: ModuleDescriptor): number;

                }

                interface ModuleDescriptor$Exports extends java.lang.Comparable<ModuleDescriptor$Exports> {}
                abstract class ModuleDescriptor$Exports extends java.lang.Object {
                    static readonly class: JavaClass<ModuleDescriptor$Exports>;
                    /** @deprecated */ static prototype: undefined;

                    modifiers(): JavaSet<ModuleDescriptor$Exports$Modifier>;
                    isQualified(): boolean;
                    source(): string;
                    targets(): JavaSet<string>;
                    compareTo(arg0: ModuleDescriptor$Exports): number;

                }

                abstract class ModuleDescriptor$Builder extends java.lang.Object {
                    static readonly class: JavaClass<ModuleDescriptor$Builder>;
                    /** @deprecated */ static prototype: undefined;

                    requires(arg0: ModuleDescriptor$Requires): ModuleDescriptor$Builder;
                    requires(arg0: JavaSet<ModuleDescriptor$Requires$Modifier>, arg1: string, arg2: ModuleDescriptor$Version): ModuleDescriptor$Builder;
                    requires(arg0: JavaSet<ModuleDescriptor$Requires$Modifier>, arg1: string): ModuleDescriptor$Builder;
                    requires(arg0: string): ModuleDescriptor$Builder;
                    exports(arg0: ModuleDescriptor$Exports): ModuleDescriptor$Builder;
                    exports(arg0: JavaSet<ModuleDescriptor$Exports$Modifier>, arg1: string, arg2: JavaSet<string>): ModuleDescriptor$Builder;
                    exports(arg0: JavaSet<ModuleDescriptor$Exports$Modifier>, arg1: string): ModuleDescriptor$Builder;
                    exports(arg0: string, arg1: JavaSet<string>): ModuleDescriptor$Builder;
                    exports(arg0: string): ModuleDescriptor$Builder;
                    opens(arg0: ModuleDescriptor$Opens): ModuleDescriptor$Builder;
                    opens(arg0: JavaSet<ModuleDescriptor$Opens$Modifier>, arg1: string, arg2: JavaSet<string>): ModuleDescriptor$Builder;
                    opens(arg0: JavaSet<ModuleDescriptor$Opens$Modifier>, arg1: string): ModuleDescriptor$Builder;
                    opens(arg0: string, arg1: JavaSet<string>): ModuleDescriptor$Builder;
                    opens(arg0: string): ModuleDescriptor$Builder;
                    uses(arg0: string): ModuleDescriptor$Builder;
                    provides(arg0: ModuleDescriptor$Provides): ModuleDescriptor$Builder;
                    provides(arg0: string, arg1: JavaList<string>): ModuleDescriptor$Builder;
                    packages(arg0: JavaSet<string>): ModuleDescriptor$Builder;
                    version(arg0: ModuleDescriptor$Version): ModuleDescriptor$Builder;
                    version(arg0: string): ModuleDescriptor$Builder;
                    mainClass(arg0: string): ModuleDescriptor$Builder;
                    build(): ModuleDescriptor;

                }

                interface ModuleDescriptor$Version extends java.lang.Comparable<ModuleDescriptor$Version> {}
                abstract class ModuleDescriptor$Version extends java.lang.Object {
                    static readonly class: JavaClass<ModuleDescriptor$Version>;
                    /** @deprecated */ static prototype: undefined;

                    static parse(arg0: string): ModuleDescriptor$Version;

                    compareTo(arg0: ModuleDescriptor$Version): number;

                }

                interface ModuleDescriptor$Requires extends java.lang.Comparable<ModuleDescriptor$Requires> {}
                abstract class ModuleDescriptor$Requires extends java.lang.Object {
                    static readonly class: JavaClass<ModuleDescriptor$Requires>;
                    /** @deprecated */ static prototype: undefined;

                    modifiers(): JavaSet<ModuleDescriptor$Requires$Modifier>;
                    name(): string;
                    compiledVersion(): java.util.Optional<ModuleDescriptor$Version>;
                    rawCompiledVersion(): java.util.Optional<string>;
                    compareTo(arg0: ModuleDescriptor$Requires): number;

                }

                abstract class ModuleDescriptor$Modifier extends java.lang.Enum<ModuleDescriptor$Modifier> {
                    static readonly class: JavaClass<ModuleDescriptor$Modifier>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly OPEN: ModuleDescriptor$Modifier;
                    static readonly AUTOMATIC: ModuleDescriptor$Modifier;
                    static readonly SYNTHETIC: ModuleDescriptor$Modifier;
                    static readonly MANDATED: ModuleDescriptor$Modifier;

                    static values(): JavaArray<ModuleDescriptor$Modifier>;
                    static valueOf(arg0: string): ModuleDescriptor$Modifier;

                }

                interface ModuleDescriptor$Opens extends java.lang.Comparable<ModuleDescriptor$Opens> {}
                abstract class ModuleDescriptor$Opens extends java.lang.Object {
                    static readonly class: JavaClass<ModuleDescriptor$Opens>;
                    /** @deprecated */ static prototype: undefined;

                    modifiers(): JavaSet<ModuleDescriptor$Opens$Modifier>;
                    isQualified(): boolean;
                    source(): string;
                    targets(): JavaSet<string>;
                    compareTo(arg0: ModuleDescriptor$Opens): number;

                }

                interface ModuleDescriptor$Provides extends java.lang.Comparable<ModuleDescriptor$Provides> {}
                abstract class ModuleDescriptor$Provides extends java.lang.Object {
                    static readonly class: JavaClass<ModuleDescriptor$Provides>;
                    /** @deprecated */ static prototype: undefined;

                    service(): string;
                    providers(): JavaList<string>;
                    compareTo(arg0: ModuleDescriptor$Provides): number;

                }

                abstract class ModuleDescriptor$Requires$Modifier extends java.lang.Enum<ModuleDescriptor$Requires$Modifier> {
                    static readonly class: JavaClass<ModuleDescriptor$Requires$Modifier>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly TRANSITIVE: ModuleDescriptor$Requires$Modifier;
                    static readonly STATIC: ModuleDescriptor$Requires$Modifier;
                    static readonly SYNTHETIC: ModuleDescriptor$Requires$Modifier;
                    static readonly MANDATED: ModuleDescriptor$Requires$Modifier;

                    static values(): JavaArray<ModuleDescriptor$Requires$Modifier>;
                    static valueOf(arg0: string): ModuleDescriptor$Requires$Modifier;

                }

                abstract class ModuleDescriptor$Opens$Modifier extends java.lang.Enum<ModuleDescriptor$Opens$Modifier> {
                    static readonly class: JavaClass<ModuleDescriptor$Opens$Modifier>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly SYNTHETIC: ModuleDescriptor$Opens$Modifier;
                    static readonly MANDATED: ModuleDescriptor$Opens$Modifier;

                    static values(): JavaArray<ModuleDescriptor$Opens$Modifier>;
                    static valueOf(arg0: string): ModuleDescriptor$Opens$Modifier;

                }

                abstract class ModuleDescriptor$Exports$Modifier extends java.lang.Enum<ModuleDescriptor$Exports$Modifier> {
                    static readonly class: JavaClass<ModuleDescriptor$Exports$Modifier>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly SYNTHETIC: ModuleDescriptor$Exports$Modifier;
                    static readonly MANDATED: ModuleDescriptor$Exports$Modifier;

                    static values(): JavaArray<ModuleDescriptor$Exports$Modifier>;
                    static valueOf(arg0: string): ModuleDescriptor$Exports$Modifier;

                }

                abstract class Configuration extends java.lang.Object {
                    static readonly class: JavaClass<Configuration>;
                    /** @deprecated */ static prototype: undefined;

                    static resolve(arg0: ModuleFinder, arg1: JavaList<Configuration>, arg2: ModuleFinder, arg3: JavaCollection<string>): Configuration;
                    static resolveAndBind(arg0: ModuleFinder, arg1: JavaList<Configuration>, arg2: ModuleFinder, arg3: JavaCollection<string>): Configuration;
                    static empty(): Configuration;

                    resolve(arg0: ModuleFinder, arg1: ModuleFinder, arg2: JavaCollection<string>): Configuration;
                    resolveAndBind(arg0: ModuleFinder, arg1: ModuleFinder, arg2: JavaCollection<string>): Configuration;
                    parents(): JavaList<Configuration>;
                    modules(): JavaSet<ResolvedModule>;
                    findModule(arg0: string): java.util.Optional<ResolvedModule>;

                }

                abstract class ResolvedModule extends java.lang.Object {
                    static readonly class: JavaClass<ResolvedModule>;
                    /** @deprecated */ static prototype: undefined;

                    configuration(): Configuration;
                    reference(): ModuleReference;
                    name(): string;
                    reads(): JavaSet<ResolvedModule>;

                }

                abstract class ModuleFinder extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleFinder>;
                    /** @deprecated */ static prototype: undefined;

                    static ofSystem(): ModuleFinder;
                    static of(...arg0: JavaVarArgs<java.nio.file.Path>): ModuleFinder;
                    static compose(...arg0: JavaVarArgs<ModuleFinder>): ModuleFinder;

                }
                interface ModuleFinder {

                    find(arg0: string): java.util.Optional<ModuleReference>;
                    findAll(): JavaSet<ModuleReference>;

                }

                abstract class ModuleReference extends java.lang.Object {
                    static readonly class: JavaClass<ModuleReference>;
                    /** @deprecated */ static prototype: undefined;

                    descriptor(): ModuleDescriptor;
                    location(): java.util.Optional<java.net.URI>;
                    open(): ModuleReader;

                }

                abstract class ModuleReader extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleReader>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ModuleReader extends java.io.Closeable {

                    find(arg0: string): java.util.Optional<java.net.URI>;
                    open(arg0: string): java.util.Optional<java.io.InputStream>;
                    read(arg0: string): java.util.Optional<java.nio.ByteBuffer>;
                    release(arg0: java.nio.ByteBuffer): void;
                    list(): java.util.stream.Stream<string>;
                    close(): void;

                }

                export {
                    ModuleDescriptor,
                    ModuleDescriptor$Exports,
                    ModuleDescriptor$Builder,
                    ModuleDescriptor$Version,
                    ModuleDescriptor$Requires,
                    ModuleDescriptor$Modifier,
                    ModuleDescriptor$Opens,
                    ModuleDescriptor$Provides,
                    ModuleDescriptor$Requires$Modifier,
                    ModuleDescriptor$Opens$Modifier,
                    ModuleDescriptor$Exports$Modifier,
                    Configuration,
                    ResolvedModule,
                    ModuleFinder,
                    ModuleReference,
                    ModuleReader
                }

            }

            namespace ref {

                class WeakReference<T> extends Reference<T> {
                    static readonly class: JavaClass<WeakReference<any>>;
                    /** @deprecated */ static prototype: undefined;

                    constructor <T>(arg0: T);
                    constructor <T>(arg0: T, arg1: ReferenceQueue<T>);

                }

                abstract class Reference<T> extends java.lang.Object {
                    static readonly class: JavaClass<Reference<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static reachabilityFence(arg0: any): void;

                    get(): T;
                    refersTo(arg0: T): boolean;
                    clear(): void;
                    /** @deprecated */
                    isEnqueued(): boolean;
                    enqueue(): boolean;

                }

                class ReferenceQueue<T> extends java.lang.Object {
                    static readonly class: JavaClass<ReferenceQueue<any>>;
                    /** @deprecated */ static prototype: undefined;

                    constructor <T>();

                    poll(): Reference<T>;
                    remove(arg0: long): Reference<T>;
                    remove(): Reference<T>;

                }

                export { WeakReference, Reference, ReferenceQueue }

            }

            namespace reflect {

                abstract class Method extends Executable {
                    static readonly class: JavaClass<Method>;
                    /** @deprecated */ static prototype: undefined;

                    setAccessible(arg0: boolean): void;
                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getModifiers(): number;
                    getTypeParameters(): JavaArray<TypeVariable<Method>>;
                    getReturnType(): JavaClass<any>;
                    getGenericReturnType(): Type;
                    getParameterTypes(): JavaArray<JavaClass<any>>;
                    getParameterCount(): number;
                    getGenericParameterTypes(): JavaArray<Type>;
                    getExceptionTypes(): JavaArray<JavaClass<any>>;
                    getGenericExceptionTypes(): JavaArray<Type>;
                    toGenericString(): string;
                    invoke(arg0: any, ...arg1: JavaVarArgs<any>): any;
                    isBridge(): boolean;
                    isVarArgs(): boolean;
                    isSynthetic(): boolean;
                    isDefault(): boolean;
                    getDefaultValue(): any;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getParameterAnnotations(): JavaArray<JavaArray<java.lang.annotation.Annotation>>;
                    getAnnotatedReturnType(): AnnotatedType;

                }

                interface Field extends Member {}
                abstract class Field extends AccessibleObject {
                    static readonly class: JavaClass<Field>;
                    /** @deprecated */ static prototype: undefined;

                    setAccessible(arg0: boolean): void;
                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getModifiers(): number;
                    isEnumConstant(): boolean;
                    isSynthetic(): boolean;
                    getType(): JavaClass<any>;
                    getGenericType(): Type;
                    toGenericString(): string;
                    get(arg0: any): any;
                    getBoolean(arg0: any): boolean;
                    getByte(arg0: any): number;
                    getChar(arg0: any): number;
                    getShort(arg0: any): number;
                    getInt(arg0: any): number;
                    getLong(arg0: any): number;
                    getFloat(arg0: any): number;
                    getDouble(arg0: any): number;
                    set(arg0: any, arg1: any): void;
                    setBoolean(arg0: any, arg1: boolean): void;
                    setByte(arg0: any, arg1: byte): void;
                    setChar(arg0: any, arg1: char): void;
                    setShort(arg0: any, arg1: short): void;
                    setInt(arg0: any, arg1: int): void;
                    setLong(arg0: any, arg1: long): void;
                    setFloat(arg0: any, arg1: float): void;
                    setDouble(arg0: any, arg1: double): void;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getAnnotatedType(): AnnotatedType;

                }

                interface AccessibleObject extends AnnotatedElement {}
                abstract class AccessibleObject extends java.lang.Object {
                    static readonly class: JavaClass<AccessibleObject>;
                    /** @deprecated */ static prototype: undefined;

                    static setAccessible(arg0: AccessibleObject[], arg1: boolean): void;

                    setAccessible(arg0: boolean): void;
                    trySetAccessible(): boolean;
                    /** @deprecated */
                    isAccessible(): boolean;
                    canAccess(arg0: any): boolean;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    isAnnotationPresent(arg0: JavaClassArg<java.lang.annotation.Annotation>): boolean;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;

                }

                abstract class Member extends java.lang.Interface {
                    static readonly class: JavaClass<Member>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly PUBLIC: number;
                    static readonly DECLARED: number;
                }
                interface Member {

                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getModifiers(): number;
                    isSynthetic(): boolean;

                }

                interface Executable extends GenericDeclaration, Member {}
                abstract class Executable extends AccessibleObject {
                    static readonly class: JavaClass<Executable>;
                    /** @deprecated */ static prototype: undefined;

                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getModifiers(): number;
                    getTypeParameters(): JavaArray<TypeVariable<any>>;
                    getParameterTypes(): JavaArray<JavaClass<any>>;
                    getParameterCount(): number;
                    getGenericParameterTypes(): JavaArray<Type>;
                    getParameters(): JavaArray<Parameter>;
                    getExceptionTypes(): JavaArray<JavaClass<any>>;
                    getGenericExceptionTypes(): JavaArray<Type>;
                    toGenericString(): string;
                    isVarArgs(): boolean;
                    isSynthetic(): boolean;
                    getParameterAnnotations(): JavaArray<JavaArray<java.lang.annotation.Annotation>>;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getAnnotatedReturnType(): AnnotatedType;
                    getAnnotatedReceiverType(): AnnotatedType;
                    getAnnotatedParameterTypes(): JavaArray<AnnotatedType>;
                    getAnnotatedExceptionTypes(): JavaArray<AnnotatedType>;

                }

                abstract class AnnotatedType extends java.lang.Interface {
                    static readonly class: JavaClass<AnnotatedType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface AnnotatedType extends AnnotatedElement {

                    getAnnotatedOwnerType(): AnnotatedType;
                    getType(): Type;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;

                }

                abstract class TypeVariable<D extends GenericDeclaration> extends java.lang.Interface {
                    static readonly class: JavaClass<TypeVariable<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TypeVariable<D extends GenericDeclaration> extends AnnotatedElement, Type {

                    getBounds(): JavaArray<Type>;
                    getGenericDeclaration(): D;
                    getName(): string;
                    getAnnotatedBounds(): JavaArray<AnnotatedType>;

                }

                abstract class Type extends java.lang.Interface {
                    static readonly class: JavaClass<Type>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Type {

                    getTypeName(): string;

                }

                abstract class AnnotatedElement extends java.lang.Interface {
                    static readonly class: JavaClass<AnnotatedElement>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface AnnotatedElement {

                    isAnnotationPresent(arg0: JavaClassArg<java.lang.annotation.Annotation>): boolean;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;

                }

                abstract class GenericDeclaration extends java.lang.Interface {
                    static readonly class: JavaClass<GenericDeclaration>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface GenericDeclaration extends AnnotatedElement {

                    getTypeParameters(): JavaArray<TypeVariable<any>>;

                }

                interface Parameter extends AnnotatedElement {}
                abstract class Parameter extends java.lang.Object {
                    static readonly class: JavaClass<Parameter>;
                    /** @deprecated */ static prototype: undefined;

                    isNamePresent(): boolean;
                    getDeclaringExecutable(): Executable;
                    getModifiers(): number;
                    getName(): string;
                    getParameterizedType(): Type;
                    getType(): JavaClass<any>;
                    getAnnotatedType(): AnnotatedType;
                    isImplicit(): boolean;
                    isSynthetic(): boolean;
                    isVarArgs(): boolean;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getAnnotations(): JavaArray<java.lang.annotation.Annotation>;

                }

                abstract class Constructor<T> extends Executable {
                    static readonly class: JavaClass<Constructor<any>>;
                    /** @deprecated */ static prototype: undefined;

                    setAccessible(arg0: boolean): void;
                    getDeclaringClass(): JavaClass<T>;
                    getName(): string;
                    getModifiers(): number;
                    getTypeParameters(): JavaArray<TypeVariable<Constructor<T>>>;
                    getParameterTypes(): JavaArray<JavaClass<any>>;
                    getParameterCount(): number;
                    getGenericParameterTypes(): JavaArray<Type>;
                    getExceptionTypes(): JavaArray<JavaClass<any>>;
                    getGenericExceptionTypes(): JavaArray<Type>;
                    toGenericString(): string;
                    newInstance(...arg0: JavaVarArgs<any>): T;
                    isVarArgs(): boolean;
                    isSynthetic(): boolean;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getParameterAnnotations(): JavaArray<JavaArray<java.lang.annotation.Annotation>>;
                    getAnnotatedReturnType(): AnnotatedType;
                    getAnnotatedReceiverType(): AnnotatedType;

                }

                export {
                    Method,
                    Field,
                    AccessibleObject,
                    Member,
                    Executable,
                    AnnotatedType,
                    TypeVariable,
                    Type,
                    AnnotatedElement,
                    GenericDeclaration,
                    Parameter,
                    Constructor
                }

            }

        }

        namespace math {

            interface BigDecimal extends java.lang.Comparable<BigDecimal> {}
            class BigDecimal extends java.lang.Number {
                static readonly class: JavaClass<BigDecimal>;
                /** @deprecated */ static prototype: undefined;

                static readonly ZERO: BigDecimal;
                static readonly ONE: BigDecimal;
                static readonly TEN: BigDecimal;
                /** @deprecated */
                static readonly ROUND_UP: number;
                /** @deprecated */
                static readonly ROUND_DOWN: number;
                /** @deprecated */
                static readonly ROUND_CEILING: number;
                /** @deprecated */
                static readonly ROUND_FLOOR: number;
                /** @deprecated */
                static readonly ROUND_HALF_UP: number;
                /** @deprecated */
                static readonly ROUND_HALF_DOWN: number;
                /** @deprecated */
                static readonly ROUND_HALF_EVEN: number;
                /** @deprecated */
                static readonly ROUND_UNNECESSARY: number;

                static valueOf(arg0: long, arg1: int): BigDecimal;
                static valueOf(arg0: long): BigDecimal;
                static valueOf(arg0: double): BigDecimal;

                constructor (arg0: char[], arg1: int, arg2: int);
                constructor (arg0: char[], arg1: int, arg2: int, arg3: MathContext);
                constructor (arg0: char[]);
                constructor (arg0: char[], arg1: MathContext);
                constructor (arg0: string);
                constructor (arg0: string, arg1: MathContext);
                constructor (arg0: double);
                constructor (arg0: double, arg1: MathContext);
                constructor (arg0: BigInteger);
                constructor (arg0: BigInteger, arg1: MathContext);
                constructor (arg0: BigInteger, arg1: int);
                constructor (arg0: BigInteger, arg1: int, arg2: MathContext);
                constructor (arg0: int);
                constructor (arg0: int, arg1: MathContext);
                constructor (arg0: long);
                constructor (arg0: long, arg1: MathContext);

                add(arg0: BigDecimal): BigDecimal;
                add(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                subtract(arg0: BigDecimal): BigDecimal;
                subtract(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                multiply(arg0: BigDecimal): BigDecimal;
                multiply(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                /** @deprecated */
                divide(arg0: BigDecimal, arg1: int, arg2: int): BigDecimal;
                divide(arg0: BigDecimal, arg1: int, arg2: RoundingMode): BigDecimal;
                /** @deprecated */
                divide(arg0: BigDecimal, arg1: int): BigDecimal;
                divide(arg0: BigDecimal, arg1: RoundingMode): BigDecimal;
                divide(arg0: BigDecimal): BigDecimal;
                divide(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                divideToIntegralValue(arg0: BigDecimal): BigDecimal;
                divideToIntegralValue(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                remainder(arg0: BigDecimal): BigDecimal;
                remainder(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                divideAndRemainder(arg0: BigDecimal): JavaArray<BigDecimal>;
                divideAndRemainder(arg0: BigDecimal, arg1: MathContext): JavaArray<BigDecimal>;
                sqrt(arg0: MathContext): BigDecimal;
                pow(arg0: int): BigDecimal;
                pow(arg0: int, arg1: MathContext): BigDecimal;
                abs(): BigDecimal;
                abs(arg0: MathContext): BigDecimal;
                negate(): BigDecimal;
                negate(arg0: MathContext): BigDecimal;
                plus(): BigDecimal;
                plus(arg0: MathContext): BigDecimal;
                signum(): number;
                scale(): number;
                precision(): number;
                unscaledValue(): BigInteger;
                round(arg0: MathContext): BigDecimal;
                setScale(arg0: int, arg1: RoundingMode): BigDecimal;
                /** @deprecated */
                setScale(arg0: int, arg1: int): BigDecimal;
                setScale(arg0: int): BigDecimal;
                movePointLeft(arg0: int): BigDecimal;
                movePointRight(arg0: int): BigDecimal;
                scaleByPowerOfTen(arg0: int): BigDecimal;
                stripTrailingZeros(): BigDecimal;
                compareTo(arg0: BigDecimal): number;
                min(arg0: BigDecimal): BigDecimal;
                max(arg0: BigDecimal): BigDecimal;
                toEngineeringString(): string;
                toPlainString(): string;
                toBigInteger(): BigInteger;
                toBigIntegerExact(): BigInteger;
                longValue(): number;
                longValueExact(): number;
                intValue(): number;
                intValueExact(): number;
                shortValueExact(): number;
                byteValueExact(): number;
                floatValue(): number;
                doubleValue(): number;
                ulp(): BigDecimal;

            }

            interface BigInteger extends java.lang.Comparable<BigInteger> {}
            class BigInteger extends java.lang.Number {
                static readonly class: JavaClass<BigInteger>;
                /** @deprecated */ static prototype: undefined;

                static readonly ZERO: BigInteger;
                static readonly ONE: BigInteger;
                static readonly TWO: BigInteger;
                static readonly TEN: BigInteger;

                static probablePrime(arg0: int, arg1: java.util.Random): BigInteger;
                static valueOf(arg0: long): BigInteger;

                constructor (arg0: byte[], arg1: int, arg2: int);
                constructor (arg0: byte[]);
                constructor (arg0: int, arg1: byte[], arg2: int, arg3: int);
                constructor (arg0: int, arg1: byte[]);
                constructor (arg0: string, arg1: int);
                constructor (arg0: string);
                constructor (arg0: int, arg1: java.util.Random);
                constructor (arg0: int, arg1: int, arg2: java.util.Random);

                nextProbablePrime(): BigInteger;
                add(arg0: BigInteger): BigInteger;
                subtract(arg0: BigInteger): BigInteger;
                multiply(arg0: BigInteger): BigInteger;
                divide(arg0: BigInteger): BigInteger;
                divideAndRemainder(arg0: BigInteger): JavaArray<BigInteger>;
                remainder(arg0: BigInteger): BigInteger;
                pow(arg0: int): BigInteger;
                sqrt(): BigInteger;
                sqrtAndRemainder(): JavaArray<BigInteger>;
                gcd(arg0: BigInteger): BigInteger;
                abs(): BigInteger;
                negate(): BigInteger;
                signum(): number;
                mod(arg0: BigInteger): BigInteger;
                modPow(arg0: BigInteger, arg1: BigInteger): BigInteger;
                modInverse(arg0: BigInteger): BigInteger;
                shiftLeft(arg0: int): BigInteger;
                shiftRight(arg0: int): BigInteger;
                and(arg0: BigInteger): BigInteger;
                or(arg0: BigInteger): BigInteger;
                xor(arg0: BigInteger): BigInteger;
                not(): BigInteger;
                andNot(arg0: BigInteger): BigInteger;
                testBit(arg0: int): boolean;
                setBit(arg0: int): BigInteger;
                clearBit(arg0: int): BigInteger;
                flipBit(arg0: int): BigInteger;
                getLowestSetBit(): number;
                bitLength(): number;
                bitCount(): number;
                isProbablePrime(arg0: int): boolean;
                compareTo(arg0: BigInteger): number;
                min(arg0: BigInteger): BigInteger;
                max(arg0: BigInteger): BigInteger;
                toString(arg0: int): string;
                toString(): string;
                toByteArray(): JavaArray<number>;
                intValue(): number;
                longValue(): number;
                floatValue(): number;
                doubleValue(): number;
                longValueExact(): number;
                intValueExact(): number;
                shortValueExact(): number;
                byteValueExact(): number;

            }

            interface MathContext extends java.io.Serializable {}
            class MathContext extends java.lang.Object {
                static readonly class: JavaClass<MathContext>;
                /** @deprecated */ static prototype: undefined;

                static readonly UNLIMITED: MathContext;
                static readonly DECIMAL32: MathContext;
                static readonly DECIMAL64: MathContext;
                static readonly DECIMAL128: MathContext;

                constructor (arg0: int);
                constructor (arg0: int, arg1: RoundingMode);
                constructor (arg0: string);

                getPrecision(): number;
                getRoundingMode(): RoundingMode;

            }

            abstract class RoundingMode extends java.lang.Enum<RoundingMode> {
                static readonly class: JavaClass<RoundingMode>;
                /** @deprecated */ static prototype: undefined;

                static readonly UP: RoundingMode;
                static readonly DOWN: RoundingMode;
                static readonly CEILING: RoundingMode;
                static readonly FLOOR: RoundingMode;
                static readonly HALF_UP: RoundingMode;
                static readonly HALF_DOWN: RoundingMode;
                static readonly HALF_EVEN: RoundingMode;
                static readonly UNNECESSARY: RoundingMode;

                static values(): JavaArray<RoundingMode>;
                static valueOf(arg0: string): RoundingMode;
                static valueOf(arg0: int): RoundingMode;

            }

            export { BigDecimal, BigInteger, MathContext, RoundingMode }

        }

        namespace net {

            interface Socket extends java.io.Closeable {}
            class Socket extends java.lang.Object {
                static readonly class: JavaClass<Socket>;
                /** @deprecated */ static prototype: undefined;

                /** @deprecated */
                static setSocketImplFactory(arg0: SocketImplFactory): void;

                constructor ();
                constructor (arg0: Proxy);
                constructor (arg0: string, arg1: int);
                constructor (arg0: InetAddress, arg1: int);
                constructor (arg0: string, arg1: int, arg2: InetAddress, arg3: int);
                constructor (arg0: InetAddress, arg1: int, arg2: InetAddress, arg3: int);
                /** @deprecated */
                constructor (arg0: string, arg1: int, arg2: boolean);
                /** @deprecated */
                constructor (arg0: InetAddress, arg1: int, arg2: boolean);

                connect(arg0: SocketAddress): void;
                connect(arg0: SocketAddress, arg1: int): void;
                bind(arg0: SocketAddress): void;
                getInetAddress(): InetAddress;
                getLocalAddress(): InetAddress;
                getPort(): number;
                getLocalPort(): number;
                getRemoteSocketAddress(): SocketAddress;
                getLocalSocketAddress(): SocketAddress;
                getChannel(): java.nio.channels.SocketChannel;
                getInputStream(): java.io.InputStream;
                getOutputStream(): java.io.OutputStream;
                setTcpNoDelay(arg0: boolean): void;
                getTcpNoDelay(): boolean;
                setSoLinger(arg0: boolean, arg1: int): void;
                getSoLinger(): number;
                sendUrgentData(arg0: int): void;
                setOOBInline(arg0: boolean): void;
                getOOBInline(): boolean;
                setSoTimeout(arg0: int): void;
                getSoTimeout(): number;
                setSendBufferSize(arg0: int): void;
                getSendBufferSize(): number;
                setReceiveBufferSize(arg0: int): void;
                getReceiveBufferSize(): number;
                setKeepAlive(arg0: boolean): void;
                getKeepAlive(): boolean;
                setTrafficClass(arg0: int): void;
                getTrafficClass(): number;
                setReuseAddress(arg0: boolean): void;
                getReuseAddress(): boolean;
                close(): void;
                shutdownInput(): void;
                shutdownOutput(): void;
                isConnected(): boolean;
                isBound(): boolean;
                isClosed(): boolean;
                isInputShutdown(): boolean;
                isOutputShutdown(): boolean;
                setPerformancePreferences(arg0: int, arg1: int, arg2: int): void;
                setOption<T>(arg0: SocketOption<T>, arg1: T): Socket;
                getOption<T>(arg0: SocketOption<T>): T;
                supportedOptions(): JavaSet<SocketOption<any>>;

            }

            interface InetAddress extends java.io.Serializable {}
            abstract class InetAddress extends java.lang.Object {
                static readonly class: JavaClass<InetAddress>;
                /** @deprecated */ static prototype: undefined;

                static getByAddress(arg0: string, arg1: byte[]): InetAddress;
                static getByName(arg0: string): InetAddress;
                static getAllByName(arg0: string): JavaArray<InetAddress>;
                static getLoopbackAddress(): InetAddress;
                static getByAddress(arg0: byte[]): InetAddress;
                static getLocalHost(): InetAddress;

                isMulticastAddress(): boolean;
                isAnyLocalAddress(): boolean;
                isLoopbackAddress(): boolean;
                isLinkLocalAddress(): boolean;
                isSiteLocalAddress(): boolean;
                isMCGlobal(): boolean;
                isMCNodeLocal(): boolean;
                isMCLinkLocal(): boolean;
                isMCSiteLocal(): boolean;
                isMCOrgLocal(): boolean;
                isReachable(arg0: int): boolean;
                isReachable(arg0: NetworkInterface, arg1: int, arg2: int): boolean;
                getHostName(): string;
                getCanonicalHostName(): string;
                getAddress(): JavaArray<number>;
                getHostAddress(): string;

            }

            class Proxy extends java.lang.Object {
                static readonly class: JavaClass<Proxy>;
                /** @deprecated */ static prototype: undefined;

                static readonly NO_PROXY: Proxy;

                constructor (arg0: Proxy$Type, arg1: SocketAddress);

                type(): Proxy$Type;
                address(): SocketAddress;

            }

            abstract class SocketOption<T> extends java.lang.Interface {
                static readonly class: JavaClass<SocketOption<any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface SocketOption<T> {

                name(): string;
                type(): JavaClass<T>;

            }

            abstract class SocketImplFactory extends java.lang.Interface {
                static readonly class: JavaClass<SocketImplFactory>;
                /** @deprecated */ static prototype: undefined;
            }
            interface SocketImplFactory {

                createSocketImpl(): SocketImpl;

            }

            interface SocketAddress extends java.io.Serializable {}
            class SocketAddress extends java.lang.Object {
                static readonly class: JavaClass<SocketAddress>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

            }

            abstract class Proxy$Type extends java.lang.Enum<Proxy$Type> {
                static readonly class: JavaClass<Proxy$Type>;
                /** @deprecated */ static prototype: undefined;

                static readonly DIRECT: Proxy$Type;
                static readonly HTTP: Proxy$Type;
                static readonly SOCKS: Proxy$Type;

                static values(): JavaArray<Proxy$Type>;
                static valueOf(arg0: string): Proxy$Type;

            }

            abstract class NetworkInterface extends java.lang.Object {
                static readonly class: JavaClass<NetworkInterface>;
                /** @deprecated */ static prototype: undefined;

                static getByName(arg0: string): NetworkInterface;
                static getByIndex(arg0: int): NetworkInterface;
                static getByInetAddress(arg0: InetAddress): NetworkInterface;
                static getNetworkInterfaces(): java.util.Enumeration<NetworkInterface>;
                static networkInterfaces(): java.util.stream.Stream<NetworkInterface>;

                getName(): string;
                getInetAddresses(): java.util.Enumeration<InetAddress>;
                inetAddresses(): java.util.stream.Stream<InetAddress>;
                getInterfaceAddresses(): JavaList<InterfaceAddress>;
                getSubInterfaces(): java.util.Enumeration<NetworkInterface>;
                subInterfaces(): java.util.stream.Stream<NetworkInterface>;
                getParent(): NetworkInterface;
                getIndex(): number;
                getDisplayName(): string;
                isUp(): boolean;
                isLoopback(): boolean;
                isPointToPoint(): boolean;
                supportsMulticast(): boolean;
                getHardwareAddress(): JavaArray<number>;
                getMTU(): number;
                isVirtual(): boolean;

            }

            interface SocketImpl extends SocketOptions {}
            class SocketImpl extends java.lang.Object {
                static readonly class: JavaClass<SocketImpl>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

            }

            abstract class InterfaceAddress extends java.lang.Object {
                static readonly class: JavaClass<InterfaceAddress>;
                /** @deprecated */ static prototype: undefined;

                getAddress(): InetAddress;
                getBroadcast(): InetAddress;
                getNetworkPrefixLength(): number;

            }

            abstract class SocketOptions extends java.lang.Interface {
                static readonly class: JavaClass<SocketOptions>;
                /** @deprecated */ static prototype: undefined;

                static readonly TCP_NODELAY: number;
                static readonly SO_BINDADDR: number;
                static readonly SO_REUSEADDR: number;
                static readonly SO_REUSEPORT: number;
                static readonly SO_BROADCAST: number;
                static readonly IP_MULTICAST_IF: number;
                static readonly IP_MULTICAST_IF2: number;
                static readonly IP_MULTICAST_LOOP: number;
                static readonly IP_TOS: number;
                static readonly SO_LINGER: number;
                static readonly SO_TIMEOUT: number;
                static readonly SO_SNDBUF: number;
                static readonly SO_RCVBUF: number;
                static readonly SO_KEEPALIVE: number;
                static readonly SO_OOBINLINE: number;
            }
            interface SocketOptions {

                setOption(arg0: int, arg1: any): void;
                getOption(arg0: int): any;

            }

            abstract class ProtocolFamily extends java.lang.Interface {
                static readonly class: JavaClass<ProtocolFamily>;
                /** @deprecated */ static prototype: undefined;
            }
            interface ProtocolFamily {

                name(): string;

            }

            interface ServerSocket extends java.io.Closeable {}
            class ServerSocket extends java.lang.Object {
                static readonly class: JavaClass<ServerSocket>;
                /** @deprecated */ static prototype: undefined;

                /** @deprecated */
                static setSocketFactory(arg0: SocketImplFactory): void;

                constructor ();
                constructor (arg0: int);
                constructor (arg0: int, arg1: int);
                constructor (arg0: int, arg1: int, arg2: InetAddress);

                bind(arg0: SocketAddress): void;
                bind(arg0: SocketAddress, arg1: int): void;
                getInetAddress(): InetAddress;
                getLocalPort(): number;
                getLocalSocketAddress(): SocketAddress;
                accept(): Socket;
                close(): void;
                getChannel(): java.nio.channels.ServerSocketChannel;
                isBound(): boolean;
                isClosed(): boolean;
                setSoTimeout(arg0: int): void;
                getSoTimeout(): number;
                setReuseAddress(arg0: boolean): void;
                getReuseAddress(): boolean;
                setReceiveBufferSize(arg0: int): void;
                getReceiveBufferSize(): number;
                setPerformancePreferences(arg0: int, arg1: int, arg2: int): void;
                setOption<T>(arg0: SocketOption<T>, arg1: T): ServerSocket;
                getOption<T>(arg0: SocketOption<T>): T;
                supportedOptions(): JavaSet<SocketOption<any>>;

            }

            interface DatagramSocket extends java.io.Closeable {}
            class DatagramSocket extends java.lang.Object {
                static readonly class: JavaClass<DatagramSocket>;
                /** @deprecated */ static prototype: undefined;

                /** @deprecated */
                static setDatagramSocketImplFactory(arg0: DatagramSocketImplFactory): void;

                constructor ();
                constructor (arg0: SocketAddress);
                constructor (arg0: int);
                constructor (arg0: int, arg1: InetAddress);

                bind(arg0: SocketAddress): void;
                connect(arg0: InetAddress, arg1: int): void;
                connect(arg0: SocketAddress): void;
                disconnect(): void;
                isBound(): boolean;
                isConnected(): boolean;
                getInetAddress(): InetAddress;
                getPort(): number;
                getRemoteSocketAddress(): SocketAddress;
                getLocalSocketAddress(): SocketAddress;
                send(arg0: DatagramPacket): void;
                receive(arg0: DatagramPacket): void;
                getLocalAddress(): InetAddress;
                getLocalPort(): number;
                setSoTimeout(arg0: int): void;
                getSoTimeout(): number;
                setSendBufferSize(arg0: int): void;
                getSendBufferSize(): number;
                setReceiveBufferSize(arg0: int): void;
                getReceiveBufferSize(): number;
                setReuseAddress(arg0: boolean): void;
                getReuseAddress(): boolean;
                setBroadcast(arg0: boolean): void;
                getBroadcast(): boolean;
                setTrafficClass(arg0: int): void;
                getTrafficClass(): number;
                close(): void;
                isClosed(): boolean;
                getChannel(): java.nio.channels.DatagramChannel;
                setOption<T>(arg0: SocketOption<T>, arg1: T): DatagramSocket;
                getOption<T>(arg0: SocketOption<T>): T;
                supportedOptions(): JavaSet<SocketOption<any>>;
                joinGroup(arg0: SocketAddress, arg1: NetworkInterface): void;
                leaveGroup(arg0: SocketAddress, arg1: NetworkInterface): void;

            }

            abstract class DatagramSocketImplFactory extends java.lang.Interface {
                static readonly class: JavaClass<DatagramSocketImplFactory>;
                /** @deprecated */ static prototype: undefined;
            }
            interface DatagramSocketImplFactory {

                createDatagramSocketImpl(): DatagramSocketImpl;

            }

            class DatagramPacket extends java.lang.Object {
                static readonly class: JavaClass<DatagramPacket>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: byte[], arg1: int, arg2: int);
                constructor (arg0: byte[], arg1: int);
                constructor (arg0: byte[], arg1: int, arg2: int, arg3: InetAddress, arg4: int);
                constructor (arg0: byte[], arg1: int, arg2: int, arg3: SocketAddress);
                constructor (arg0: byte[], arg1: int, arg2: InetAddress, arg3: int);
                constructor (arg0: byte[], arg1: int, arg2: SocketAddress);

                getAddress(): InetAddress;
                getPort(): number;
                getData(): JavaArray<number>;
                getOffset(): number;
                getLength(): number;
                setData(arg0: byte[], arg1: int, arg2: int): void;
                setAddress(arg0: InetAddress): void;
                setPort(arg0: int): void;
                setSocketAddress(arg0: SocketAddress): void;
                getSocketAddress(): SocketAddress;
                setData(arg0: byte[]): void;
                setLength(arg0: int): void;

            }

            interface DatagramSocketImpl extends SocketOptions {}
            class DatagramSocketImpl extends java.lang.Object {
                static readonly class: JavaClass<DatagramSocketImpl>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

            }

            export {
                Socket,
                InetAddress,
                Proxy,
                SocketOption,
                SocketImplFactory,
                SocketAddress,
                Proxy$Type,
                NetworkInterface,
                SocketImpl,
                InterfaceAddress,
                SocketOptions,
                ProtocolFamily,
                ServerSocket,
                DatagramSocket,
                DatagramSocketImplFactory,
                DatagramPacket,
                DatagramSocketImpl
            }

        }

        namespace nio {

            abstract class MappedByteBuffer extends ByteBuffer {
                static readonly class: JavaClass<MappedByteBuffer>;
                /** @deprecated */ static prototype: undefined;

                isLoaded(): boolean;
                load(): MappedByteBuffer;
                force(): MappedByteBuffer;
                force(arg0: int, arg1: int): MappedByteBuffer;
                position(arg0: int): MappedByteBuffer;
                position(): number;
                limit(arg0: int): MappedByteBuffer;
                limit(): number;
                mark(): MappedByteBuffer;
                reset(): MappedByteBuffer;
                clear(): MappedByteBuffer;
                flip(): MappedByteBuffer;
                rewind(): MappedByteBuffer;
                slice(): MappedByteBuffer;
                slice(arg0: int, arg1: int): MappedByteBuffer;
                duplicate(): MappedByteBuffer;
                compact(): MappedByteBuffer;

            }

            interface ByteBuffer extends java.lang.Comparable<ByteBuffer> {}
            abstract class ByteBuffer extends Buffer {
                static readonly class: JavaClass<ByteBuffer>;
                /** @deprecated */ static prototype: undefined;

                static allocateDirect(arg0: int): ByteBuffer;
                static allocate(arg0: int): ByteBuffer;
                static wrap(arg0: byte[], arg1: int, arg2: int): ByteBuffer;
                static wrap(arg0: byte[]): ByteBuffer;

                slice(): ByteBuffer;
                slice(arg0: int, arg1: int): ByteBuffer;
                duplicate(): ByteBuffer;
                asReadOnlyBuffer(): ByteBuffer;
                get(): number;
                put(arg0: byte): ByteBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: byte): ByteBuffer;
                get(arg0: byte[], arg1: int, arg2: int): ByteBuffer;
                get(arg0: byte[]): ByteBuffer;
                get(arg0: int, arg1: byte[], arg2: int, arg3: int): ByteBuffer;
                get(arg0: int, arg1: byte[]): ByteBuffer;
                put(arg0: ByteBuffer): ByteBuffer;
                put(arg0: int, arg1: ByteBuffer, arg2: int, arg3: int): ByteBuffer;
                put(arg0: byte[], arg1: int, arg2: int): ByteBuffer;
                put(arg0: byte[]): ByteBuffer;
                put(arg0: int, arg1: byte[], arg2: int, arg3: int): ByteBuffer;
                put(arg0: int, arg1: byte[]): ByteBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): ByteBuffer;
                position(): number;
                limit(arg0: int): ByteBuffer;
                limit(): number;
                mark(): ByteBuffer;
                reset(): ByteBuffer;
                clear(): ByteBuffer;
                flip(): ByteBuffer;
                rewind(): ByteBuffer;
                compact(): ByteBuffer;
                isDirect(): boolean;
                compareTo(arg0: ByteBuffer): number;
                mismatch(arg0: ByteBuffer): number;
                order(): ByteOrder;
                order(arg0: ByteOrder): ByteBuffer;
                alignmentOffset(arg0: int, arg1: int): number;
                alignedSlice(arg0: int): ByteBuffer;
                getChar(): number;
                putChar(arg0: char): ByteBuffer;
                getChar(arg0: int): number;
                putChar(arg0: int, arg1: char): ByteBuffer;
                asCharBuffer(): CharBuffer;
                getShort(): number;
                putShort(arg0: short): ByteBuffer;
                getShort(arg0: int): number;
                putShort(arg0: int, arg1: short): ByteBuffer;
                asShortBuffer(): ShortBuffer;
                getInt(): number;
                putInt(arg0: int): ByteBuffer;
                getInt(arg0: int): number;
                putInt(arg0: int, arg1: int): ByteBuffer;
                asIntBuffer(): IntBuffer;
                getLong(): number;
                putLong(arg0: long): ByteBuffer;
                getLong(arg0: int): number;
                putLong(arg0: int, arg1: long): ByteBuffer;
                asLongBuffer(): LongBuffer;
                getFloat(): number;
                putFloat(arg0: float): ByteBuffer;
                getFloat(arg0: int): number;
                putFloat(arg0: int, arg1: float): ByteBuffer;
                asFloatBuffer(): FloatBuffer;
                getDouble(): number;
                putDouble(arg0: double): ByteBuffer;
                getDouble(arg0: int): number;
                putDouble(arg0: int, arg1: double): ByteBuffer;
                asDoubleBuffer(): DoubleBuffer;

            }

            interface LongBuffer extends java.lang.Comparable<LongBuffer> {}
            abstract class LongBuffer extends Buffer {
                static readonly class: JavaClass<LongBuffer>;
                /** @deprecated */ static prototype: undefined;

                static allocate(arg0: int): LongBuffer;
                static wrap(arg0: long[], arg1: int, arg2: int): LongBuffer;
                static wrap(arg0: long[]): LongBuffer;

                slice(): LongBuffer;
                slice(arg0: int, arg1: int): LongBuffer;
                duplicate(): LongBuffer;
                asReadOnlyBuffer(): LongBuffer;
                get(): number;
                put(arg0: long): LongBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: long): LongBuffer;
                get(arg0: long[], arg1: int, arg2: int): LongBuffer;
                get(arg0: long[]): LongBuffer;
                get(arg0: int, arg1: long[], arg2: int, arg3: int): LongBuffer;
                get(arg0: int, arg1: long[]): LongBuffer;
                put(arg0: LongBuffer): LongBuffer;
                put(arg0: int, arg1: LongBuffer, arg2: int, arg3: int): LongBuffer;
                put(arg0: long[], arg1: int, arg2: int): LongBuffer;
                put(arg0: long[]): LongBuffer;
                put(arg0: int, arg1: long[], arg2: int, arg3: int): LongBuffer;
                put(arg0: int, arg1: long[]): LongBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): LongBuffer;
                position(): number;
                limit(arg0: int): LongBuffer;
                limit(): number;
                mark(): LongBuffer;
                reset(): LongBuffer;
                clear(): LongBuffer;
                flip(): LongBuffer;
                rewind(): LongBuffer;
                compact(): LongBuffer;
                isDirect(): boolean;
                compareTo(arg0: LongBuffer): number;
                mismatch(arg0: LongBuffer): number;
                order(): ByteOrder;

            }

            interface DoubleBuffer extends java.lang.Comparable<DoubleBuffer> {}
            abstract class DoubleBuffer extends Buffer {
                static readonly class: JavaClass<DoubleBuffer>;
                /** @deprecated */ static prototype: undefined;

                static allocate(arg0: int): DoubleBuffer;
                static wrap(arg0: double[], arg1: int, arg2: int): DoubleBuffer;
                static wrap(arg0: double[]): DoubleBuffer;

                slice(): DoubleBuffer;
                slice(arg0: int, arg1: int): DoubleBuffer;
                duplicate(): DoubleBuffer;
                asReadOnlyBuffer(): DoubleBuffer;
                get(): number;
                put(arg0: double): DoubleBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: double): DoubleBuffer;
                get(arg0: double[], arg1: int, arg2: int): DoubleBuffer;
                get(arg0: double[]): DoubleBuffer;
                get(arg0: int, arg1: double[], arg2: int, arg3: int): DoubleBuffer;
                get(arg0: int, arg1: double[]): DoubleBuffer;
                put(arg0: DoubleBuffer): DoubleBuffer;
                put(arg0: int, arg1: DoubleBuffer, arg2: int, arg3: int): DoubleBuffer;
                put(arg0: double[], arg1: int, arg2: int): DoubleBuffer;
                put(arg0: double[]): DoubleBuffer;
                put(arg0: int, arg1: double[], arg2: int, arg3: int): DoubleBuffer;
                put(arg0: int, arg1: double[]): DoubleBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): DoubleBuffer;
                position(): number;
                limit(arg0: int): DoubleBuffer;
                limit(): number;
                mark(): DoubleBuffer;
                reset(): DoubleBuffer;
                clear(): DoubleBuffer;
                flip(): DoubleBuffer;
                rewind(): DoubleBuffer;
                compact(): DoubleBuffer;
                isDirect(): boolean;
                compareTo(arg0: DoubleBuffer): number;
                mismatch(arg0: DoubleBuffer): number;
                order(): ByteOrder;

            }

            interface CharBuffer extends java.lang.CharSequence, java.lang.Readable, java.lang.Appendable, java.lang.Comparable<CharBuffer> {}
            abstract class CharBuffer extends Buffer {
                static readonly class: JavaClass<CharBuffer>;
                /** @deprecated */ static prototype: undefined;

                static allocate(arg0: int): CharBuffer;
                static wrap(arg0: char[], arg1: int, arg2: int): CharBuffer;
                static wrap(arg0: char[]): CharBuffer;
                static wrap(arg0: java.lang.CharSequence, arg1: int, arg2: int): CharBuffer;
                static wrap(arg0: java.lang.CharSequence): CharBuffer;

                read(arg0: CharBuffer): number;
                slice(): CharBuffer;
                slice(arg0: int, arg1: int): CharBuffer;
                duplicate(): CharBuffer;
                asReadOnlyBuffer(): CharBuffer;
                get(): number;
                put(arg0: char): CharBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: char): CharBuffer;
                get(arg0: char[], arg1: int, arg2: int): CharBuffer;
                get(arg0: char[]): CharBuffer;
                get(arg0: int, arg1: char[], arg2: int, arg3: int): CharBuffer;
                get(arg0: int, arg1: char[]): CharBuffer;
                put(arg0: CharBuffer): CharBuffer;
                put(arg0: int, arg1: CharBuffer, arg2: int, arg3: int): CharBuffer;
                put(arg0: char[], arg1: int, arg2: int): CharBuffer;
                put(arg0: char[]): CharBuffer;
                put(arg0: int, arg1: char[], arg2: int, arg3: int): CharBuffer;
                put(arg0: int, arg1: char[]): CharBuffer;
                put(arg0: string, arg1: int, arg2: int): CharBuffer;
                put(arg0: string): CharBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): CharBuffer;
                position(): number;
                limit(arg0: int): CharBuffer;
                limit(): number;
                mark(): CharBuffer;
                reset(): CharBuffer;
                clear(): CharBuffer;
                flip(): CharBuffer;
                rewind(): CharBuffer;
                compact(): CharBuffer;
                isDirect(): boolean;
                compareTo(arg0: CharBuffer): number;
                mismatch(arg0: CharBuffer): number;
                length(): number;
                isEmpty(): boolean;
                charAt(arg0: int): number;
                subSequence(arg0: int, arg1: int): CharBuffer;
                append(arg0: java.lang.CharSequence): CharBuffer;
                append(arg0: java.lang.CharSequence, arg1: int, arg2: int): CharBuffer;
                append(arg0: char): CharBuffer;
                order(): ByteOrder;
                chars(): java.util.stream.IntStream;

            }

            abstract class ByteOrder extends java.lang.Object {
                static readonly class: JavaClass<ByteOrder>;
                /** @deprecated */ static prototype: undefined;

                static readonly BIG_ENDIAN: ByteOrder;
                static readonly LITTLE_ENDIAN: ByteOrder;

                static nativeOrder(): ByteOrder;

            }

            interface IntBuffer extends java.lang.Comparable<IntBuffer> {}
            abstract class IntBuffer extends Buffer {
                static readonly class: JavaClass<IntBuffer>;
                /** @deprecated */ static prototype: undefined;

                static allocate(arg0: int): IntBuffer;
                static wrap(arg0: int[], arg1: int, arg2: int): IntBuffer;
                static wrap(arg0: int[]): IntBuffer;

                slice(): IntBuffer;
                slice(arg0: int, arg1: int): IntBuffer;
                duplicate(): IntBuffer;
                asReadOnlyBuffer(): IntBuffer;
                get(): number;
                put(arg0: int): IntBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: int): IntBuffer;
                get(arg0: int[], arg1: int, arg2: int): IntBuffer;
                get(arg0: int[]): IntBuffer;
                get(arg0: int, arg1: int[], arg2: int, arg3: int): IntBuffer;
                get(arg0: int, arg1: int[]): IntBuffer;
                put(arg0: IntBuffer): IntBuffer;
                put(arg0: int, arg1: IntBuffer, arg2: int, arg3: int): IntBuffer;
                put(arg0: int[], arg1: int, arg2: int): IntBuffer;
                put(arg0: int[]): IntBuffer;
                put(arg0: int, arg1: int[], arg2: int, arg3: int): IntBuffer;
                put(arg0: int, arg1: int[]): IntBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): IntBuffer;
                position(): number;
                limit(arg0: int): IntBuffer;
                limit(): number;
                mark(): IntBuffer;
                reset(): IntBuffer;
                clear(): IntBuffer;
                flip(): IntBuffer;
                rewind(): IntBuffer;
                compact(): IntBuffer;
                isDirect(): boolean;
                compareTo(arg0: IntBuffer): number;
                mismatch(arg0: IntBuffer): number;
                order(): ByteOrder;

            }

            interface ShortBuffer extends java.lang.Comparable<ShortBuffer> {}
            abstract class ShortBuffer extends Buffer {
                static readonly class: JavaClass<ShortBuffer>;
                /** @deprecated */ static prototype: undefined;

                static allocate(arg0: int): ShortBuffer;
                static wrap(arg0: short[], arg1: int, arg2: int): ShortBuffer;
                static wrap(arg0: short[]): ShortBuffer;

                slice(): ShortBuffer;
                slice(arg0: int, arg1: int): ShortBuffer;
                duplicate(): ShortBuffer;
                asReadOnlyBuffer(): ShortBuffer;
                get(): number;
                put(arg0: short): ShortBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: short): ShortBuffer;
                get(arg0: short[], arg1: int, arg2: int): ShortBuffer;
                get(arg0: short[]): ShortBuffer;
                get(arg0: int, arg1: short[], arg2: int, arg3: int): ShortBuffer;
                get(arg0: int, arg1: short[]): ShortBuffer;
                put(arg0: ShortBuffer): ShortBuffer;
                put(arg0: int, arg1: ShortBuffer, arg2: int, arg3: int): ShortBuffer;
                put(arg0: short[], arg1: int, arg2: int): ShortBuffer;
                put(arg0: short[]): ShortBuffer;
                put(arg0: int, arg1: short[], arg2: int, arg3: int): ShortBuffer;
                put(arg0: int, arg1: short[]): ShortBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): ShortBuffer;
                position(): number;
                limit(arg0: int): ShortBuffer;
                limit(): number;
                mark(): ShortBuffer;
                reset(): ShortBuffer;
                clear(): ShortBuffer;
                flip(): ShortBuffer;
                rewind(): ShortBuffer;
                compact(): ShortBuffer;
                isDirect(): boolean;
                compareTo(arg0: ShortBuffer): number;
                mismatch(arg0: ShortBuffer): number;
                order(): ByteOrder;

            }

            abstract class Buffer extends java.lang.Object {
                static readonly class: JavaClass<Buffer>;
                /** @deprecated */ static prototype: undefined;

                capacity(): number;
                position(): number;
                position(arg0: int): Buffer;
                limit(): number;
                limit(arg0: int): Buffer;
                mark(): Buffer;
                reset(): Buffer;
                clear(): Buffer;
                flip(): Buffer;
                rewind(): Buffer;
                remaining(): number;
                hasRemaining(): boolean;
                isReadOnly(): boolean;
                hasArray(): boolean;
                array(): any;
                arrayOffset(): number;
                isDirect(): boolean;
                slice(): Buffer;
                slice(arg0: int, arg1: int): Buffer;
                duplicate(): Buffer;

            }

            interface FloatBuffer extends java.lang.Comparable<FloatBuffer> {}
            abstract class FloatBuffer extends Buffer {
                static readonly class: JavaClass<FloatBuffer>;
                /** @deprecated */ static prototype: undefined;

                static allocate(arg0: int): FloatBuffer;
                static wrap(arg0: float[], arg1: int, arg2: int): FloatBuffer;
                static wrap(arg0: float[]): FloatBuffer;

                slice(): FloatBuffer;
                slice(arg0: int, arg1: int): FloatBuffer;
                duplicate(): FloatBuffer;
                asReadOnlyBuffer(): FloatBuffer;
                get(): number;
                put(arg0: float): FloatBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: float): FloatBuffer;
                get(arg0: float[], arg1: int, arg2: int): FloatBuffer;
                get(arg0: float[]): FloatBuffer;
                get(arg0: int, arg1: float[], arg2: int, arg3: int): FloatBuffer;
                get(arg0: int, arg1: float[]): FloatBuffer;
                put(arg0: FloatBuffer): FloatBuffer;
                put(arg0: int, arg1: FloatBuffer, arg2: int, arg3: int): FloatBuffer;
                put(arg0: float[], arg1: int, arg2: int): FloatBuffer;
                put(arg0: float[]): FloatBuffer;
                put(arg0: int, arg1: float[], arg2: int, arg3: int): FloatBuffer;
                put(arg0: int, arg1: float[]): FloatBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): FloatBuffer;
                position(): number;
                limit(arg0: int): FloatBuffer;
                limit(): number;
                mark(): FloatBuffer;
                reset(): FloatBuffer;
                clear(): FloatBuffer;
                flip(): FloatBuffer;
                rewind(): FloatBuffer;
                compact(): FloatBuffer;
                isDirect(): boolean;
                compareTo(arg0: FloatBuffer): number;
                mismatch(arg0: FloatBuffer): number;
                order(): ByteOrder;

            }

            export {
                MappedByteBuffer,
                ByteBuffer,
                LongBuffer,
                DoubleBuffer,
                CharBuffer,
                ByteOrder,
                IntBuffer,
                ShortBuffer,
                Buffer,
                FloatBuffer
            }

        }
        namespace nio {

            namespace channels {

                abstract class SeekableByteChannel extends java.lang.Interface {
                    static readonly class: JavaClass<SeekableByteChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface SeekableByteChannel extends ByteChannel {

                    read(arg0: java.nio.ByteBuffer): number;
                    write(arg0: java.nio.ByteBuffer): number;
                    position(): number;
                    position(arg0: long): SeekableByteChannel;
                    size(): number;
                    truncate(arg0: long): SeekableByteChannel;

                }

                interface FileChannel extends SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel {}
                abstract class FileChannel extends java.nio.channels.spi.AbstractInterruptibleChannel {
                    static readonly class: JavaClass<FileChannel>;
                    /** @deprecated */ static prototype: undefined;

                    static open(arg0: java.nio.file.Path, arg1: JavaSet<java.nio.file.OpenOption>, ...arg2: JavaVarArgs<java.nio.file.attribute.FileAttribute<any>>): FileChannel;
                    static open(arg0: java.nio.file.Path, ...arg1: JavaVarArgs<java.nio.file.OpenOption>): FileChannel;

                    read(arg0: java.nio.ByteBuffer): number;
                    read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    read(arg0: java.nio.ByteBuffer[]): number;
                    write(arg0: java.nio.ByteBuffer): number;
                    write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    write(arg0: java.nio.ByteBuffer[]): number;
                    position(): number;
                    position(arg0: long): FileChannel;
                    size(): number;
                    truncate(arg0: long): FileChannel;
                    force(arg0: boolean): void;
                    transferTo(arg0: long, arg1: long, arg2: WritableByteChannel): number;
                    transferFrom(arg0: ReadableByteChannel, arg1: long, arg2: long): number;
                    read(arg0: java.nio.ByteBuffer, arg1: long): number;
                    write(arg0: java.nio.ByteBuffer, arg1: long): number;
                    map(arg0: FileChannel$MapMode, arg1: long, arg2: long): java.nio.MappedByteBuffer;
                    lock(arg0: long, arg1: long, arg2: boolean): FileLock;
                    lock(): FileLock;
                    tryLock(arg0: long, arg1: long, arg2: boolean): FileLock;
                    tryLock(): FileLock;

                }

                interface AsynchronousFileChannel extends AsynchronousChannel {}
                abstract class AsynchronousFileChannel extends java.lang.Object {
                    static readonly class: JavaClass<AsynchronousFileChannel>;
                    /** @deprecated */ static prototype: undefined;

                    static open(arg0: java.nio.file.Path, arg1: JavaSet<java.nio.file.OpenOption>, arg2: java.util.concurrent.ExecutorService, ...arg3: JavaVarArgs<java.nio.file.attribute.FileAttribute<any>>): AsynchronousFileChannel;
                    static open(arg0: java.nio.file.Path, ...arg1: JavaVarArgs<java.nio.file.OpenOption>): AsynchronousFileChannel;

                    size(): number;
                    truncate(arg0: long): AsynchronousFileChannel;
                    force(arg0: boolean): void;
                    lock<A>(arg0: long, arg1: long, arg2: boolean, arg3: A, arg4: CompletionHandler<FileLock, A>): void;
                    lock<A>(arg0: A, arg1: CompletionHandler<FileLock, A>): void;
                    lock(arg0: long, arg1: long, arg2: boolean): java.util.concurrent.Future<FileLock>;
                    lock(): java.util.concurrent.Future<FileLock>;
                    tryLock(arg0: long, arg1: long, arg2: boolean): FileLock;
                    tryLock(): FileLock;
                    read<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: A, arg3: CompletionHandler<int, A>): void;
                    read(arg0: java.nio.ByteBuffer, arg1: long): java.util.concurrent.Future<number>;
                    write<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: A, arg3: CompletionHandler<int, A>): void;
                    write(arg0: java.nio.ByteBuffer, arg1: long): java.util.concurrent.Future<number>;

                }

                interface FileLock extends java.lang.AutoCloseable {}
                abstract class FileLock extends java.lang.Object {
                    static readonly class: JavaClass<FileLock>;
                    /** @deprecated */ static prototype: undefined;

                    channel(): FileChannel;
                    acquiredBy(): Channel;
                    position(): number;
                    size(): number;
                    isShared(): boolean;
                    overlaps(arg0: long, arg1: long): boolean;
                    isValid(): boolean;
                    release(): void;
                    close(): void;

                }

                abstract class ScatteringByteChannel extends java.lang.Interface {
                    static readonly class: JavaClass<ScatteringByteChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ScatteringByteChannel extends ReadableByteChannel {

                    read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    read(arg0: java.nio.ByteBuffer[]): number;
                    read(arg0: java.nio.ByteBuffer): number;

                }

                abstract class CompletionHandler<V, A> extends java.lang.Interface {
                    static readonly class: JavaClass<CompletionHandler<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface CompletionHandler<V, A> {

                    completed(arg0: V, arg1: A): void;
                    failed(arg0: java.lang.Throwable, arg1: A): void;

                }

                abstract class AsynchronousChannel extends java.lang.Interface {
                    static readonly class: JavaClass<AsynchronousChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface AsynchronousChannel extends Channel {

                    close(): void;

                }

                abstract class InterruptibleChannel extends java.lang.Interface {
                    static readonly class: JavaClass<InterruptibleChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface InterruptibleChannel extends Channel {

                    close(): void;

                }

                abstract class Channel extends java.lang.Interface {
                    static readonly class: JavaClass<Channel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Channel extends java.io.Closeable {

                    isOpen(): boolean;
                    close(): void;

                }

                abstract class GatheringByteChannel extends java.lang.Interface {
                    static readonly class: JavaClass<GatheringByteChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface GatheringByteChannel extends WritableByteChannel {

                    write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    write(arg0: java.nio.ByteBuffer[]): number;
                    write(arg0: java.nio.ByteBuffer): number;

                }

                abstract class ByteChannel extends java.lang.Interface {
                    static readonly class: JavaClass<ByteChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ByteChannel extends WritableByteChannel, ReadableByteChannel {}

                abstract class WritableByteChannel extends java.lang.Interface {
                    static readonly class: JavaClass<WritableByteChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WritableByteChannel extends Channel {

                    write(arg0: java.nio.ByteBuffer): number;

                }

                abstract class ReadableByteChannel extends java.lang.Interface {
                    static readonly class: JavaClass<ReadableByteChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ReadableByteChannel extends Channel {

                    read(arg0: java.nio.ByteBuffer): number;

                }

                abstract class FileChannel$MapMode extends java.lang.Object {
                    static readonly class: JavaClass<FileChannel$MapMode>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly READ_ONLY: FileChannel$MapMode;
                    static readonly READ_WRITE: FileChannel$MapMode;
                    static readonly PRIVATE: FileChannel$MapMode;
                }

                interface SocketChannel extends NetworkChannel, GatheringByteChannel, ByteChannel, ScatteringByteChannel {}
                abstract class SocketChannel extends java.nio.channels.spi.AbstractSelectableChannel {
                    static readonly class: JavaClass<SocketChannel>;
                    /** @deprecated */ static prototype: undefined;

                    static open(): SocketChannel;
                    static open(arg0: java.net.ProtocolFamily): SocketChannel;
                    static open(arg0: java.net.SocketAddress): SocketChannel;

                    validOps(): number;
                    bind(arg0: java.net.SocketAddress): SocketChannel;
                    setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): SocketChannel;
                    shutdownInput(): SocketChannel;
                    shutdownOutput(): SocketChannel;
                    socket(): java.net.Socket;
                    isConnected(): boolean;
                    isConnectionPending(): boolean;
                    connect(arg0: java.net.SocketAddress): boolean;
                    finishConnect(): boolean;
                    getRemoteAddress(): java.net.SocketAddress;
                    read(arg0: java.nio.ByteBuffer): number;
                    read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    read(arg0: java.nio.ByteBuffer[]): number;
                    write(arg0: java.nio.ByteBuffer): number;
                    write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    write(arg0: java.nio.ByteBuffer[]): number;
                    getLocalAddress(): java.net.SocketAddress;

                }

                interface DatagramChannel extends GatheringByteChannel, ByteChannel, MulticastChannel, ScatteringByteChannel {}
                abstract class DatagramChannel extends java.nio.channels.spi.AbstractSelectableChannel {
                    static readonly class: JavaClass<DatagramChannel>;
                    /** @deprecated */ static prototype: undefined;

                    static open(): DatagramChannel;
                    static open(arg0: java.net.ProtocolFamily): DatagramChannel;

                    validOps(): number;
                    bind(arg0: java.net.SocketAddress): DatagramChannel;
                    setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): DatagramChannel;
                    socket(): java.net.DatagramSocket;
                    isConnected(): boolean;
                    connect(arg0: java.net.SocketAddress): DatagramChannel;
                    disconnect(): DatagramChannel;
                    getRemoteAddress(): java.net.SocketAddress;
                    receive(arg0: java.nio.ByteBuffer): java.net.SocketAddress;
                    send(arg0: java.nio.ByteBuffer, arg1: java.net.SocketAddress): number;
                    read(arg0: java.nio.ByteBuffer): number;
                    read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    read(arg0: java.nio.ByteBuffer[]): number;
                    write(arg0: java.nio.ByteBuffer): number;
                    write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    write(arg0: java.nio.ByteBuffer[]): number;
                    getLocalAddress(): java.net.SocketAddress;

                }

                abstract class SelectionKey extends java.lang.Object {
                    static readonly class: JavaClass<SelectionKey>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly OP_READ: number;
                    static readonly OP_WRITE: number;
                    static readonly OP_CONNECT: number;
                    static readonly OP_ACCEPT: number;

                    channel(): SelectableChannel;
                    selector(): Selector;
                    isValid(): boolean;
                    cancel(): void;
                    interestOps(): number;
                    interestOps(arg0: int): SelectionKey;
                    interestOpsOr(arg0: int): number;
                    interestOpsAnd(arg0: int): number;
                    readyOps(): number;
                    isReadable(): boolean;
                    isWritable(): boolean;
                    isConnectable(): boolean;
                    isAcceptable(): boolean;
                    attach(arg0: any): any;
                    attachment(): any;

                }

                abstract class NetworkChannel extends java.lang.Interface {
                    static readonly class: JavaClass<NetworkChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface NetworkChannel extends Channel {

                    bind(arg0: java.net.SocketAddress): NetworkChannel;
                    getLocalAddress(): java.net.SocketAddress;
                    setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): NetworkChannel;
                    getOption<T>(arg0: java.net.SocketOption<T>): T;
                    supportedOptions(): JavaSet<java.net.SocketOption<any>>;

                }

                abstract class Pipe extends java.lang.Object {
                    static readonly class: JavaClass<Pipe>;
                    /** @deprecated */ static prototype: undefined;

                    static open(): Pipe;

                    source(): Pipe$SourceChannel;
                    sink(): Pipe$SinkChannel;

                }

                interface ServerSocketChannel extends NetworkChannel {}
                abstract class ServerSocketChannel extends java.nio.channels.spi.AbstractSelectableChannel {
                    static readonly class: JavaClass<ServerSocketChannel>;
                    /** @deprecated */ static prototype: undefined;

                    static open(): ServerSocketChannel;
                    static open(arg0: java.net.ProtocolFamily): ServerSocketChannel;

                    validOps(): number;
                    bind(arg0: java.net.SocketAddress): ServerSocketChannel;
                    bind(arg0: java.net.SocketAddress, arg1: int): ServerSocketChannel;
                    setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): ServerSocketChannel;
                    socket(): java.net.ServerSocket;
                    accept(): SocketChannel;
                    getLocalAddress(): java.net.SocketAddress;

                }

                interface SelectableChannel extends Channel {}
                abstract class SelectableChannel extends java.nio.channels.spi.AbstractInterruptibleChannel {
                    static readonly class: JavaClass<SelectableChannel>;
                    /** @deprecated */ static prototype: undefined;

                    provider(): java.nio.channels.spi.SelectorProvider;
                    validOps(): number;
                    isRegistered(): boolean;
                    keyFor(arg0: Selector): SelectionKey;
                    register(arg0: Selector, arg1: int, arg2: any): SelectionKey;
                    register(arg0: Selector, arg1: int): SelectionKey;
                    configureBlocking(arg0: boolean): SelectableChannel;
                    isBlocking(): boolean;
                    blockingLock(): any;

                }

                interface Selector extends java.io.Closeable {}
                abstract class Selector extends java.lang.Object {
                    static readonly class: JavaClass<Selector>;
                    /** @deprecated */ static prototype: undefined;

                    static open(): Selector;

                    isOpen(): boolean;
                    provider(): java.nio.channels.spi.SelectorProvider;
                    keys(): JavaSet<SelectionKey>;
                    selectedKeys(): JavaSet<SelectionKey>;
                    selectNow(): number;
                    select(arg0: long): number;
                    select(): number;
                    select(arg0: MethodWrapper<SelectionKey>, arg1: long): number;
                    select(arg0: MethodWrapper<SelectionKey>): number;
                    selectNow(arg0: MethodWrapper<SelectionKey>): number;
                    wakeup(): Selector;
                    close(): void;

                }

                abstract class MulticastChannel extends java.lang.Interface {
                    static readonly class: JavaClass<MulticastChannel>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface MulticastChannel extends NetworkChannel {

                    close(): void;
                    join(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface): MembershipKey;
                    join(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface, arg2: java.net.InetAddress): MembershipKey;

                }

                interface Pipe$SinkChannel extends WritableByteChannel, GatheringByteChannel {}
                abstract class Pipe$SinkChannel extends java.nio.channels.spi.AbstractSelectableChannel {
                    static readonly class: JavaClass<Pipe$SinkChannel>;
                    /** @deprecated */ static prototype: undefined;

                    validOps(): number;

                }

                interface Pipe$SourceChannel extends ReadableByteChannel, ScatteringByteChannel {}
                abstract class Pipe$SourceChannel extends java.nio.channels.spi.AbstractSelectableChannel {
                    static readonly class: JavaClass<Pipe$SourceChannel>;
                    /** @deprecated */ static prototype: undefined;

                    validOps(): number;

                }

                abstract class MembershipKey extends java.lang.Object {
                    static readonly class: JavaClass<MembershipKey>;
                    /** @deprecated */ static prototype: undefined;

                    isValid(): boolean;
                    drop(): void;
                    block(arg0: java.net.InetAddress): MembershipKey;
                    unblock(arg0: java.net.InetAddress): MembershipKey;
                    channel(): MulticastChannel;
                    group(): java.net.InetAddress;
                    networkInterface(): java.net.NetworkInterface;
                    sourceAddress(): java.net.InetAddress;

                }

                export {
                    SeekableByteChannel,
                    FileChannel,
                    AsynchronousFileChannel,
                    FileLock,
                    ScatteringByteChannel,
                    CompletionHandler,
                    AsynchronousChannel,
                    InterruptibleChannel,
                    Channel,
                    GatheringByteChannel,
                    ByteChannel,
                    WritableByteChannel,
                    ReadableByteChannel,
                    FileChannel$MapMode,
                    SocketChannel,
                    DatagramChannel,
                    SelectionKey,
                    NetworkChannel,
                    Pipe,
                    ServerSocketChannel,
                    SelectableChannel,
                    Selector,
                    MulticastChannel,
                    Pipe$SinkChannel,
                    Pipe$SourceChannel,
                    MembershipKey
                }

            }
            namespace channels {

                namespace spi {

                    interface AbstractInterruptibleChannel extends java.nio.channels.Channel, java.nio.channels.InterruptibleChannel {}
                    abstract class AbstractInterruptibleChannel extends java.lang.Object {
                        static readonly class: JavaClass<AbstractInterruptibleChannel>;
                        /** @deprecated */ static prototype: undefined;

                        close(): void;
                        isOpen(): boolean;

                    }

                    abstract class AbstractSelectableChannel extends java.nio.channels.SelectableChannel {
                        static readonly class: JavaClass<AbstractSelectableChannel>;
                        /** @deprecated */ static prototype: undefined;

                        provider(): SelectorProvider;
                        isRegistered(): boolean;
                        keyFor(arg0: java.nio.channels.Selector): java.nio.channels.SelectionKey;
                        register(arg0: java.nio.channels.Selector, arg1: int, arg2: any): java.nio.channels.SelectionKey;
                        register(arg0: java.nio.channels.Selector, arg1: int): java.nio.channels.SelectionKey;
                        isBlocking(): boolean;
                        blockingLock(): any;
                        configureBlocking(arg0: boolean): java.nio.channels.SelectableChannel;

                    }

                    abstract class SelectorProvider extends java.lang.Object {
                        static readonly class: JavaClass<SelectorProvider>;
                        /** @deprecated */ static prototype: undefined;

                        static provider(): SelectorProvider;

                        openDatagramChannel(): java.nio.channels.DatagramChannel;
                        openDatagramChannel(arg0: java.net.ProtocolFamily): java.nio.channels.DatagramChannel;
                        openPipe(): java.nio.channels.Pipe;
                        openSelector(): AbstractSelector;
                        openServerSocketChannel(): java.nio.channels.ServerSocketChannel;
                        openSocketChannel(): java.nio.channels.SocketChannel;
                        inheritedChannel(): java.nio.channels.Channel;
                        openSocketChannel(arg0: java.net.ProtocolFamily): java.nio.channels.SocketChannel;
                        openServerSocketChannel(arg0: java.net.ProtocolFamily): java.nio.channels.ServerSocketChannel;

                    }

                    abstract class AbstractSelector extends java.nio.channels.Selector {
                        static readonly class: JavaClass<AbstractSelector>;
                        /** @deprecated */ static prototype: undefined;

                        close(): void;
                        isOpen(): boolean;
                        provider(): SelectorProvider;

                    }

                    export {
                        AbstractInterruptibleChannel,
                        AbstractSelectableChannel,
                        SelectorProvider,
                        AbstractSelector
                    }

                }

            }

            namespace charset {

                interface Charset extends java.lang.Comparable<Charset> {}
                abstract class Charset extends java.lang.Object {
                    static readonly class: JavaClass<Charset>;
                    /** @deprecated */ static prototype: undefined;

                    static isSupported(arg0: string): boolean;
                    static forName(arg0: string): Charset;
                    static availableCharsets(): java.util.SortedMap<string, Charset>;
                    static defaultCharset(): Charset;

                    name(): string;
                    aliases(): JavaSet<string>;
                    displayName(): string;
                    isRegistered(): boolean;
                    displayName(arg0: java.util.Locale): string;
                    contains(arg0: Charset): boolean;
                    newDecoder(): CharsetDecoder;
                    newEncoder(): CharsetEncoder;
                    canEncode(): boolean;
                    decode(arg0: java.nio.ByteBuffer): java.nio.CharBuffer;
                    encode(arg0: java.nio.CharBuffer): java.nio.ByteBuffer;
                    encode(arg0: string): java.nio.ByteBuffer;
                    compareTo(arg0: Charset): number;

                }

                abstract class CharsetEncoder extends java.lang.Object {
                    static readonly class: JavaClass<CharsetEncoder>;
                    /** @deprecated */ static prototype: undefined;

                    charset(): Charset;
                    replacement(): JavaArray<number>;
                    replaceWith(arg0: byte[]): CharsetEncoder;
                    isLegalReplacement(arg0: byte[]): boolean;
                    malformedInputAction(): CodingErrorAction;
                    onMalformedInput(arg0: CodingErrorAction): CharsetEncoder;
                    unmappableCharacterAction(): CodingErrorAction;
                    onUnmappableCharacter(arg0: CodingErrorAction): CharsetEncoder;
                    averageBytesPerChar(): number;
                    maxBytesPerChar(): number;
                    encode(arg0: java.nio.CharBuffer, arg1: java.nio.ByteBuffer, arg2: boolean): CoderResult;
                    flush(arg0: java.nio.ByteBuffer): CoderResult;
                    reset(): CharsetEncoder;
                    encode(arg0: java.nio.CharBuffer): java.nio.ByteBuffer;
                    canEncode(arg0: char): boolean;
                    canEncode(arg0: java.lang.CharSequence): boolean;

                }

                abstract class CharsetDecoder extends java.lang.Object {
                    static readonly class: JavaClass<CharsetDecoder>;
                    /** @deprecated */ static prototype: undefined;

                    charset(): Charset;
                    replacement(): string;
                    replaceWith(arg0: string): CharsetDecoder;
                    malformedInputAction(): CodingErrorAction;
                    onMalformedInput(arg0: CodingErrorAction): CharsetDecoder;
                    unmappableCharacterAction(): CodingErrorAction;
                    onUnmappableCharacter(arg0: CodingErrorAction): CharsetDecoder;
                    averageCharsPerByte(): number;
                    maxCharsPerByte(): number;
                    decode(arg0: java.nio.ByteBuffer, arg1: java.nio.CharBuffer, arg2: boolean): CoderResult;
                    flush(arg0: java.nio.CharBuffer): CoderResult;
                    reset(): CharsetDecoder;
                    decode(arg0: java.nio.ByteBuffer): java.nio.CharBuffer;
                    isAutoDetecting(): boolean;
                    isCharsetDetected(): boolean;
                    detectedCharset(): Charset;

                }

                abstract class CoderResult extends java.lang.Object {
                    static readonly class: JavaClass<CoderResult>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly UNDERFLOW: CoderResult;
                    static readonly OVERFLOW: CoderResult;

                    static malformedForLength(arg0: int): CoderResult;
                    static unmappableForLength(arg0: int): CoderResult;

                    isUnderflow(): boolean;
                    isOverflow(): boolean;
                    isError(): boolean;
                    isMalformed(): boolean;
                    isUnmappable(): boolean;
                    length(): number;
                    throwException(): void;

                }

                abstract class CodingErrorAction extends java.lang.Object {
                    static readonly class: JavaClass<CodingErrorAction>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly IGNORE: CodingErrorAction;
                    static readonly REPLACE: CodingErrorAction;
                    static readonly REPORT: CodingErrorAction;
                }

                export {
                    Charset,
                    CharsetEncoder,
                    CharsetDecoder,
                    CoderResult,
                    CodingErrorAction
                }

            }

            namespace file {

                abstract class Path extends java.lang.Interface {
                    static readonly class: JavaClass<Path>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: string, ...arg1: JavaVarArgs<string>): Path;
                    static of(arg0: java.net.URI): Path;

                }
                interface Path extends java.lang.Iterable<Path>, Watchable, java.lang.Comparable<Path> {

                    getFileSystem(): FileSystem;
                    isAbsolute(): boolean;
                    getRoot(): Path;
                    getFileName(): Path;
                    getParent(): Path;
                    getNameCount(): number;
                    getName(arg0: int): Path;
                    subpath(arg0: int, arg1: int): Path;
                    startsWith(arg0: Path): boolean;
                    startsWith(arg0: string): boolean;
                    endsWith(arg0: Path): boolean;
                    endsWith(arg0: string): boolean;
                    normalize(): Path;
                    resolve(arg0: Path): Path;
                    resolve(arg0: string): Path;
                    resolveSibling(arg0: Path): Path;
                    resolveSibling(arg0: string): Path;
                    relativize(arg0: Path): Path;
                    toUri(): java.net.URI;
                    toAbsolutePath(): Path;
                    toRealPath(...arg0: JavaVarArgs<LinkOption>): Path;
                    toFile(): java.io.File;
                    register(arg0: WatchService, arg1: WatchEvent$Kind<any>[], ...arg2: JavaVarArgs<WatchEvent$Modifier>): WatchKey;
                    register(arg0: WatchService, ...arg1: JavaVarArgs<WatchEvent$Kind<any>>): WatchKey;
                    iterator(): java.util.Iterator<Path>;
                    compareTo(arg0: Path): number;

                }

                abstract class WatchService extends java.lang.Interface {
                    static readonly class: JavaClass<WatchService>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WatchService extends java.io.Closeable {

                    close(): void;
                    poll(): WatchKey;
                    poll(arg0: long, arg1: java.util.concurrent.TimeUnit): WatchKey;
                    take(): WatchKey;

                }

                abstract class WatchEvent$Modifier extends java.lang.Interface {
                    static readonly class: JavaClass<WatchEvent$Modifier>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WatchEvent$Modifier {

                    name(): string;

                }

                abstract class WatchKey extends java.lang.Interface {
                    static readonly class: JavaClass<WatchKey>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WatchKey {

                    isValid(): boolean;
                    pollEvents(): JavaList<WatchEvent<any>>;
                    reset(): boolean;
                    cancel(): void;
                    watchable(): Watchable;

                }

                abstract class Watchable extends java.lang.Interface {
                    static readonly class: JavaClass<Watchable>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Watchable {

                    register(arg0: WatchService, arg1: WatchEvent$Kind<any>[], ...arg2: JavaVarArgs<WatchEvent$Modifier>): WatchKey;
                    register(arg0: WatchService, ...arg1: JavaVarArgs<WatchEvent$Kind<any>>): WatchKey;

                }

                abstract class WatchEvent$Kind<T> extends java.lang.Interface {
                    static readonly class: JavaClass<WatchEvent$Kind<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WatchEvent$Kind<T> {

                    name(): string;
                    type(): JavaClass<T>;

                }

                interface FileSystem extends java.io.Closeable {}
                abstract class FileSystem extends java.lang.Object {
                    static readonly class: JavaClass<FileSystem>;
                    /** @deprecated */ static prototype: undefined;

                    provider(): java.nio.file.spi.FileSystemProvider;
                    close(): void;
                    isOpen(): boolean;
                    isReadOnly(): boolean;
                    getSeparator(): string;
                    getRootDirectories(): java.lang.Iterable<Path>;
                    getFileStores(): java.lang.Iterable<FileStore>;
                    supportedFileAttributeViews(): JavaSet<string>;
                    getPath(arg0: string, ...arg1: JavaVarArgs<string>): Path;
                    getPathMatcher(arg0: string): PathMatcher;
                    getUserPrincipalLookupService(): java.nio.file.attribute.UserPrincipalLookupService;
                    newWatchService(): WatchService;

                }

                interface LinkOption extends OpenOption, CopyOption {}
                abstract class LinkOption extends java.lang.Enum<LinkOption> {
                    static readonly class: JavaClass<LinkOption>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly NOFOLLOW_LINKS: LinkOption;

                    static values(): JavaArray<LinkOption>;
                    static valueOf(arg0: string): LinkOption;

                }

                abstract class CopyOption extends java.lang.Interface {
                    static readonly class: JavaClass<CopyOption>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface CopyOption {}

                abstract class WatchEvent<T> extends java.lang.Interface {
                    static readonly class: JavaClass<WatchEvent<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WatchEvent<T> {

                    kind(): WatchEvent$Kind<T>;
                    count(): number;
                    context(): T;

                }

                abstract class FileStore extends java.lang.Object {
                    static readonly class: JavaClass<FileStore>;
                    /** @deprecated */ static prototype: undefined;

                    name(): string;
                    type(): string;
                    isReadOnly(): boolean;
                    getTotalSpace(): number;
                    getUsableSpace(): number;
                    getUnallocatedSpace(): number;
                    getBlockSize(): number;
                    supportsFileAttributeView(arg0: JavaClassArg<java.nio.file.attribute.FileAttributeView>): boolean;
                    supportsFileAttributeView(arg0: string): boolean;
                    getFileStoreAttributeView<V extends java.nio.file.attribute.FileStoreAttributeView>(arg0: JavaClassArg<V>): V;
                    getAttribute(arg0: string): any;

                }

                abstract class DirectoryStream$Filter<T> extends java.lang.Interface {
                    static readonly class: JavaClass<DirectoryStream$Filter<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DirectoryStream$Filter<T> {

                    accept(arg0: T): boolean;

                }

                abstract class AccessMode extends java.lang.Enum<AccessMode> {
                    static readonly class: JavaClass<AccessMode>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly READ: AccessMode;
                    static readonly WRITE: AccessMode;
                    static readonly EXECUTE: AccessMode;

                    static values(): JavaArray<AccessMode>;
                    static valueOf(arg0: string): AccessMode;

                }

                abstract class PathMatcher extends java.lang.Interface {
                    static readonly class: JavaClass<PathMatcher>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface PathMatcher {

                    matches(arg0: Path): boolean;

                }

                abstract class OpenOption extends java.lang.Interface {
                    static readonly class: JavaClass<OpenOption>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface OpenOption {}

                abstract class DirectoryStream<T> extends java.lang.Interface {
                    static readonly class: JavaClass<DirectoryStream<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DirectoryStream<T> extends java.io.Closeable, java.lang.Iterable<T> {

                    iterator(): java.util.Iterator<T>;

                }

                export {
                    Path,
                    WatchService,
                    WatchEvent$Modifier,
                    WatchKey,
                    Watchable,
                    WatchEvent$Kind,
                    FileSystem,
                    LinkOption,
                    CopyOption,
                    WatchEvent,
                    FileStore,
                    DirectoryStream$Filter,
                    AccessMode,
                    PathMatcher,
                    OpenOption,
                    DirectoryStream
                }

            }
            namespace file {

                namespace attribute {

                    abstract class BasicFileAttributes extends java.lang.Interface {
                        static readonly class: JavaClass<BasicFileAttributes>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface BasicFileAttributes {

                        lastModifiedTime(): FileTime;
                        lastAccessTime(): FileTime;
                        creationTime(): FileTime;
                        isRegularFile(): boolean;
                        isDirectory(): boolean;
                        isSymbolicLink(): boolean;
                        isOther(): boolean;
                        size(): number;
                        fileKey(): any;

                    }

                    interface FileTime extends java.lang.Comparable<FileTime> {}
                    abstract class FileTime extends java.lang.Object {
                        static readonly class: JavaClass<FileTime>;
                        /** @deprecated */ static prototype: undefined;

                        static from(arg0: long, arg1: java.util.concurrent.TimeUnit): FileTime;
                        static fromMillis(arg0: long): FileTime;
                        static from(arg0: java.time.Instant): FileTime;

                        to(arg0: java.util.concurrent.TimeUnit): number;
                        toMillis(): number;
                        toInstant(): java.time.Instant;
                        compareTo(arg0: FileTime): number;

                    }

                    abstract class UserPrincipalLookupService extends java.lang.Object {
                        static readonly class: JavaClass<UserPrincipalLookupService>;
                        /** @deprecated */ static prototype: undefined;

                        lookupPrincipalByName(arg0: string): UserPrincipal;
                        lookupPrincipalByGroupName(arg0: string): GroupPrincipal;

                    }

                    abstract class UserPrincipal extends java.lang.Interface {
                        static readonly class: JavaClass<UserPrincipal>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface UserPrincipal extends java.security.Principal {}

                    abstract class GroupPrincipal extends java.lang.Interface {
                        static readonly class: JavaClass<GroupPrincipal>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface GroupPrincipal extends UserPrincipal {}

                    abstract class FileAttribute<T> extends java.lang.Interface {
                        static readonly class: JavaClass<FileAttribute<any>>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface FileAttribute<T> {

                        name(): string;
                        value(): T;

                    }

                    abstract class FileAttributeView extends java.lang.Interface {
                        static readonly class: JavaClass<FileAttributeView>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface FileAttributeView extends AttributeView {}

                    abstract class FileStoreAttributeView extends java.lang.Interface {
                        static readonly class: JavaClass<FileStoreAttributeView>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface FileStoreAttributeView extends AttributeView {}

                    abstract class AttributeView extends java.lang.Interface {
                        static readonly class: JavaClass<AttributeView>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface AttributeView {

                        name(): string;

                    }

                    export {
                        BasicFileAttributes,
                        FileTime,
                        UserPrincipalLookupService,
                        UserPrincipal,
                        GroupPrincipal,
                        FileAttribute,
                        FileAttributeView,
                        FileStoreAttributeView,
                        AttributeView
                    }

                }

                namespace spi {

                    abstract class FileSystemProvider extends java.lang.Object {
                        static readonly class: JavaClass<FileSystemProvider>;
                        /** @deprecated */ static prototype: undefined;

                        static installedProviders(): JavaList<FileSystemProvider>;

                        getScheme(): string;
                        newFileSystem(arg0: java.net.URI, arg1: JavaMap<string, any>): java.nio.file.FileSystem;
                        getFileSystem(arg0: java.net.URI): java.nio.file.FileSystem;
                        getPath(arg0: java.net.URI): java.nio.file.Path;
                        newFileSystem(arg0: java.nio.file.Path, arg1: JavaMap<string, any>): java.nio.file.FileSystem;
                        newInputStream(arg0: java.nio.file.Path, ...arg1: JavaVarArgs<java.nio.file.OpenOption>): java.io.InputStream;
                        newOutputStream(arg0: java.nio.file.Path, ...arg1: JavaVarArgs<java.nio.file.OpenOption>): java.io.OutputStream;
                        newFileChannel(arg0: java.nio.file.Path, arg1: JavaSet<java.nio.file.OpenOption>, ...arg2: JavaVarArgs<java.nio.file.attribute.FileAttribute<any>>): java.nio.channels.FileChannel;
                        newAsynchronousFileChannel(arg0: java.nio.file.Path, arg1: JavaSet<java.nio.file.OpenOption>, arg2: java.util.concurrent.ExecutorService, ...arg3: JavaVarArgs<java.nio.file.attribute.FileAttribute<any>>): java.nio.channels.AsynchronousFileChannel;
                        newByteChannel(arg0: java.nio.file.Path, arg1: JavaSet<java.nio.file.OpenOption>, ...arg2: JavaVarArgs<java.nio.file.attribute.FileAttribute<any>>): java.nio.channels.SeekableByteChannel;
                        newDirectoryStream(arg0: java.nio.file.Path, arg1: java.nio.file.DirectoryStream$Filter<java.nio.file.Path>): java.nio.file.DirectoryStream<java.nio.file.Path>;
                        createDirectory(arg0: java.nio.file.Path, ...arg1: JavaVarArgs<java.nio.file.attribute.FileAttribute<any>>): void;
                        createSymbolicLink(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: JavaVarArgs<java.nio.file.attribute.FileAttribute<any>>): void;
                        createLink(arg0: java.nio.file.Path, arg1: java.nio.file.Path): void;
                        delete(arg0: java.nio.file.Path): void;
                        deleteIfExists(arg0: java.nio.file.Path): boolean;
                        readSymbolicLink(arg0: java.nio.file.Path): java.nio.file.Path;
                        copy(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: JavaVarArgs<java.nio.file.CopyOption>): void;
                        move(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: JavaVarArgs<java.nio.file.CopyOption>): void;
                        isSameFile(arg0: java.nio.file.Path, arg1: java.nio.file.Path): boolean;
                        isHidden(arg0: java.nio.file.Path): boolean;
                        getFileStore(arg0: java.nio.file.Path): java.nio.file.FileStore;
                        checkAccess(arg0: java.nio.file.Path, ...arg1: JavaVarArgs<java.nio.file.AccessMode>): void;
                        getFileAttributeView<V extends java.nio.file.attribute.FileAttributeView>(arg0: java.nio.file.Path, arg1: JavaClassArg<V>, ...arg2: JavaVarArgs<java.nio.file.LinkOption>): V;
                        readAttributes<A extends java.nio.file.attribute.BasicFileAttributes>(arg0: java.nio.file.Path, arg1: JavaClassArg<A>, ...arg2: JavaVarArgs<java.nio.file.LinkOption>): A;
                        readAttributes(arg0: java.nio.file.Path, arg1: string, ...arg2: JavaVarArgs<java.nio.file.LinkOption>): JavaMap<string, any>;
                        setAttribute(arg0: java.nio.file.Path, arg1: string, arg2: any, ...arg3: JavaVarArgs<java.nio.file.LinkOption>): void;

                    }

                    export { FileSystemProvider }

                }

            }

        }

        namespace security {

            abstract class Principal extends java.lang.Interface {
                static readonly class: JavaClass<Principal>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Principal {

                getName(): string;
                implies(arg0: javax.security.auth.Subject): boolean;

            }

            abstract class PublicKey extends java.lang.Interface {
                static readonly class: JavaClass<PublicKey>;
                /** @deprecated */ static prototype: undefined;

                /** @deprecated */
                static readonly serialVersionUID: number;
            }
            interface PublicKey extends Key {}

            /** @deprecated */
            class AccessControlContext extends java.lang.Object {
                static readonly class: JavaClass<AccessControlContext>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: ProtectionDomain[]);
                constructor (arg0: AccessControlContext, arg1: DomainCombiner);

                getDomainCombiner(): DomainCombiner;
                checkPermission(arg0: Permission): void;

            }

            abstract class PrivilegedExceptionAction<T> extends java.lang.Interface {
                static readonly class: JavaClass<PrivilegedExceptionAction<any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface PrivilegedExceptionAction<T> {

                run(): T;

            }

            abstract class PrivilegedAction<T> extends java.lang.Interface {
                static readonly class: JavaClass<PrivilegedAction<any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface PrivilegedAction<T> {

                run(): T;

            }

            /** @deprecated */
            abstract class DomainCombiner extends java.lang.Interface {
                static readonly class: JavaClass<DomainCombiner>;
                /** @deprecated */ static prototype: undefined;
            }
            interface DomainCombiner {

                combine(arg0: ProtectionDomain[], arg1: ProtectionDomain[]): JavaArray<ProtectionDomain>;

            }

            abstract class Key extends java.lang.Interface {
                static readonly class: JavaClass<Key>;
                /** @deprecated */ static prototype: undefined;

                /** @deprecated */
                static readonly serialVersionUID: number;
            }
            interface Key extends java.io.Serializable {

                getAlgorithm(): string;
                getFormat(): string;
                getEncoded(): JavaArray<number>;

            }

            class ProtectionDomain extends java.lang.Object {
                static readonly class: JavaClass<ProtectionDomain>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: CodeSource, arg1: PermissionCollection);
                constructor (arg0: CodeSource, arg1: PermissionCollection, arg2: java.lang.ClassLoader, arg3: Principal[]);

                getCodeSource(): CodeSource;
                getClassLoader(): java.lang.ClassLoader;
                getPrincipals(): JavaArray<Principal>;
                getPermissions(): PermissionCollection;
                staticPermissionsOnly(): boolean;
                implies(arg0: Permission): boolean;

            }

            interface Permission extends Guard, java.io.Serializable {}
            class Permission extends java.lang.Object {
                static readonly class: JavaClass<Permission>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: string);

                checkGuard(arg0: any): void;
                implies(arg0: Permission): boolean;
                getName(): string;
                getActions(): string;
                newPermissionCollection(): PermissionCollection;

            }

            interface PermissionCollection extends java.io.Serializable {}
            class PermissionCollection extends java.lang.Object {
                static readonly class: JavaClass<PermissionCollection>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

                add(arg0: Permission): void;
                implies(arg0: Permission): boolean;
                elements(): java.util.Enumeration<Permission>;
                elementsAsStream(): java.util.stream.Stream<Permission>;
                setReadOnly(): void;
                isReadOnly(): boolean;

            }

            abstract class Guard extends java.lang.Interface {
                static readonly class: JavaClass<Guard>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Guard {

                checkGuard(arg0: any): void;

            }

            interface CodeSource extends java.io.Serializable {}
            class CodeSource extends java.lang.Object {
                static readonly class: JavaClass<CodeSource>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: java.net.URL, arg1: java.security.cert.Certificate[]);
                constructor (arg0: java.net.URL, arg1: CodeSigner[]);

                getLocation(): java.net.URL;
                getCertificates(): JavaArray<java.security.cert.Certificate>;
                getCodeSigners(): JavaArray<CodeSigner>;
                implies(arg0: CodeSource): boolean;

            }

            abstract class Provider extends java.util.Properties {
                static readonly class: JavaClass<Provider>;
                /** @deprecated */ static prototype: undefined;

                configure(arg0: string): Provider;
                isConfigured(): boolean;
                getName(): string;
                /** @deprecated */
                getVersion(): number;
                getVersionStr(): string;
                getInfo(): string;
                clear(): void;
                load(arg0: java.io.InputStream): void;
                load(arg0: java.io.Reader): void;
                putAll(arg0: JavaMap<any, any>): void;
                entrySet(): JavaSet<java.util.Map$Entry<any, any>>;
                keySet(): JavaSet<any>;
                values(): JavaCollection<any>;
                put(arg0: any, arg1: any): any;
                putIfAbsent(arg0: any, arg1: any): any;
                remove(arg0: any): any;
                remove(arg0: any, arg1: any): boolean;
                replace(arg0: any, arg1: any, arg2: any): boolean;
                replace(arg0: any, arg1: any): any;
                replaceAll(arg0: MethodWrapper<any, any, any>): void;
                compute(arg0: any, arg1: MethodWrapper<any, any, any>): any;
                computeIfAbsent(arg0: any, arg1: MethodWrapper<any, any, any>): any;
                computeIfPresent(arg0: any, arg1: MethodWrapper<any, any, any>): any;
                merge(arg0: any, arg1: any, arg2: MethodWrapper<any, any, any>): any;
                get(arg0: any): any;
                getOrDefault(arg0: any, arg1: any): any;
                forEach(arg0: MethodWrapper<any, any>): void;
                keys(): java.util.Enumeration<any>;
                elements(): java.util.Enumeration<any>;
                getProperty(arg0: string): string;
                getProperty(arg0: string, arg1: string): string;
                getService(arg0: string, arg1: string): Provider$Service;
                getServices(): JavaSet<Provider$Service>;

            }

            interface CodeSigner extends java.io.Serializable {}
            class CodeSigner extends java.lang.Object {
                static readonly class: JavaClass<CodeSigner>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: java.security.cert.CertPath, arg1: Timestamp);

                getSignerCertPath(): java.security.cert.CertPath;
                getTimestamp(): Timestamp;

            }

            class Provider$Service extends java.lang.Object {
                static readonly class: JavaClass<Provider$Service>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: Provider, arg1: string, arg2: string, arg3: string, arg4: JavaList<string>, arg5: JavaMap<string, string>);

                getType(): string;
                getAlgorithm(): string;
                getProvider(): Provider;
                getClassName(): string;
                getAttribute(arg0: string): string;
                newInstance(arg0: any): any;
                supportsParameter(arg0: any): boolean;

            }

            interface Timestamp extends java.io.Serializable {}
            class Timestamp extends java.lang.Object {
                static readonly class: JavaClass<Timestamp>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: java.util.Date, arg1: java.security.cert.CertPath);

                getTimestamp(): java.util.Date;
                getSignerCertPath(): java.security.cert.CertPath;

            }

            export {
                Principal,
                PublicKey,
                AccessControlContext,
                PrivilegedExceptionAction,
                PrivilegedAction,
                DomainCombiner,
                Key,
                ProtectionDomain,
                Permission,
                PermissionCollection,
                Guard,
                CodeSource,
                Provider,
                CodeSigner,
                Provider$Service,
                Timestamp
            }

        }
        namespace security {

            namespace cert {

                interface Certificate extends java.io.Serializable {}
                abstract class Certificate extends java.lang.Object {
                    static readonly class: JavaClass<Certificate>;
                    /** @deprecated */ static prototype: undefined;

                    getType(): string;
                    getEncoded(): JavaArray<number>;
                    verify(arg0: java.security.PublicKey): void;
                    verify(arg0: java.security.PublicKey, arg1: string): void;
                    verify(arg0: java.security.PublicKey, arg1: java.security.Provider): void;
                    getPublicKey(): java.security.PublicKey;

                }

                interface CertPath extends java.io.Serializable {}
                abstract class CertPath extends java.lang.Object {
                    static readonly class: JavaClass<CertPath>;
                    /** @deprecated */ static prototype: undefined;

                    getType(): string;
                    getEncodings(): java.util.Iterator<string>;
                    getEncoded(): JavaArray<number>;
                    getEncoded(arg0: string): JavaArray<number>;
                    getCertificates(): JavaList<Certificate>;

                }

                export { Certificate, CertPath }

            }

        }

        namespace text {

            interface Format extends java.lang.Cloneable, java.io.Serializable {}
            abstract class Format extends java.lang.Object {
                static readonly class: JavaClass<Format>;
                /** @deprecated */ static prototype: undefined;

                format(arg0: any): string;
                format(arg0: any, arg1: java.lang.StringBuffer, arg2: FieldPosition): java.lang.StringBuffer;
                formatToCharacterIterator(arg0: any): AttributedCharacterIterator;
                parseObject(arg0: string, arg1: ParsePosition): any;
                parseObject(arg0: string): any;
                clone(): any;

            }

            class ParsePosition extends java.lang.Object {
                static readonly class: JavaClass<ParsePosition>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: int);

                getIndex(): number;
                setIndex(arg0: int): void;
                setErrorIndex(arg0: int): void;
                getErrorIndex(): number;

            }

            abstract class AttributedCharacterIterator extends java.lang.Interface {
                static readonly class: JavaClass<AttributedCharacterIterator>;
                /** @deprecated */ static prototype: undefined;
            }
            interface AttributedCharacterIterator extends CharacterIterator {

                getRunStart(): number;
                getRunStart(arg0: AttributedCharacterIterator$Attribute): number;
                getRunStart(arg0: JavaSet<AttributedCharacterIterator$Attribute>): number;
                getRunLimit(): number;
                getRunLimit(arg0: AttributedCharacterIterator$Attribute): number;
                getRunLimit(arg0: JavaSet<AttributedCharacterIterator$Attribute>): number;
                getAttributes(): JavaMap<AttributedCharacterIterator$Attribute, any>;
                getAttribute(arg0: AttributedCharacterIterator$Attribute): any;
                getAllAttributeKeys(): JavaSet<AttributedCharacterIterator$Attribute>;

            }

            class FieldPosition extends java.lang.Object {
                static readonly class: JavaClass<FieldPosition>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: int);
                constructor (arg0: Format$Field);
                constructor (arg0: Format$Field, arg1: int);

                getFieldAttribute(): Format$Field;
                getField(): number;
                getBeginIndex(): number;
                getEndIndex(): number;
                setBeginIndex(arg0: int): void;
                setEndIndex(arg0: int): void;

            }

            interface AttributedCharacterIterator$Attribute extends java.io.Serializable {}
            abstract class AttributedCharacterIterator$Attribute extends java.lang.Object {
                static readonly class: JavaClass<AttributedCharacterIterator$Attribute>;
                /** @deprecated */ static prototype: undefined;

                static readonly LANGUAGE: AttributedCharacterIterator$Attribute;
                static readonly READING: AttributedCharacterIterator$Attribute;
                static readonly INPUT_METHOD_SEGMENT: AttributedCharacterIterator$Attribute;
            }

            abstract class CharacterIterator extends java.lang.Interface {
                static readonly class: JavaClass<CharacterIterator>;
                /** @deprecated */ static prototype: undefined;

                static readonly DONE: number;
            }
            interface CharacterIterator extends java.lang.Cloneable {

                first(): number;
                last(): number;
                current(): number;
                next(): number;
                previous(): number;
                setIndex(arg0: int): number;
                getBeginIndex(): number;
                getEndIndex(): number;
                getIndex(): number;
                clone(): any;

            }

            abstract class Format$Field extends AttributedCharacterIterator$Attribute {
                static readonly class: JavaClass<Format$Field>;
                /** @deprecated */ static prototype: undefined;
            }

            abstract class NumberFormat extends Format {
                static readonly class: JavaClass<NumberFormat>;
                /** @deprecated */ static prototype: undefined;

                static readonly INTEGER_FIELD: number;
                static readonly FRACTION_FIELD: number;

                static getInstance(): NumberFormat;
                static getInstance(arg0: java.util.Locale): NumberFormat;
                static getNumberInstance(): NumberFormat;
                static getNumberInstance(arg0: java.util.Locale): NumberFormat;
                static getIntegerInstance(): NumberFormat;
                static getIntegerInstance(arg0: java.util.Locale): NumberFormat;
                static getCurrencyInstance(): NumberFormat;
                static getCurrencyInstance(arg0: java.util.Locale): NumberFormat;
                static getPercentInstance(): NumberFormat;
                static getPercentInstance(arg0: java.util.Locale): NumberFormat;
                static getCompactNumberInstance(): NumberFormat;
                static getCompactNumberInstance(arg0: java.util.Locale, arg1: NumberFormat$Style): NumberFormat;
                static getAvailableLocales(): JavaArray<java.util.Locale>;

                format(arg0: any, arg1: java.lang.StringBuffer, arg2: FieldPosition): java.lang.StringBuffer;
                format(arg0: any): string;
                parseObject(arg0: string, arg1: ParsePosition): any;
                parseObject(arg0: string): any;
                format(arg0: double): string;
                format(arg0: long): string;
                format(arg0: double, arg1: java.lang.StringBuffer, arg2: FieldPosition): java.lang.StringBuffer;
                format(arg0: long, arg1: java.lang.StringBuffer, arg2: FieldPosition): java.lang.StringBuffer;
                parse(arg0: string, arg1: ParsePosition): number;
                parse(arg0: string): number;
                isParseIntegerOnly(): boolean;
                setParseIntegerOnly(arg0: boolean): void;
                clone(): any;
                isGroupingUsed(): boolean;
                setGroupingUsed(arg0: boolean): void;
                getMaximumIntegerDigits(): number;
                setMaximumIntegerDigits(arg0: int): void;
                getMinimumIntegerDigits(): number;
                setMinimumIntegerDigits(arg0: int): void;
                getMaximumFractionDigits(): number;
                setMaximumFractionDigits(arg0: int): void;
                getMinimumFractionDigits(): number;
                setMinimumFractionDigits(arg0: int): void;
                getCurrency(): java.util.Currency;
                setCurrency(arg0: java.util.Currency): void;
                getRoundingMode(): java.math.RoundingMode;
                setRoundingMode(arg0: java.math.RoundingMode): void;

            }

            abstract class NumberFormat$Style extends java.lang.Enum<NumberFormat$Style> {
                static readonly class: JavaClass<NumberFormat$Style>;
                /** @deprecated */ static prototype: undefined;

                static readonly SHORT: NumberFormat$Style;
                static readonly LONG: NumberFormat$Style;

                static values(): JavaArray<NumberFormat$Style>;
                static valueOf(arg0: string): NumberFormat$Style;

            }

            export {
                Format,
                ParsePosition,
                AttributedCharacterIterator,
                FieldPosition,
                AttributedCharacterIterator$Attribute,
                CharacterIterator,
                Format$Field,
                NumberFormat,
                NumberFormat$Style
            }

        }

        namespace time {

            interface Duration extends java.lang.Comparable<Duration>, java.io.Serializable, java.time.temporal.TemporalAmount {}
            abstract class Duration extends java.lang.Object {
                static readonly class: JavaClass<Duration>;
                /** @deprecated */ static prototype: undefined;

                static readonly ZERO: Duration;

                static ofDays(arg0: long): Duration;
                static ofHours(arg0: long): Duration;
                static ofMinutes(arg0: long): Duration;
                static ofSeconds(arg0: long): Duration;
                static ofSeconds(arg0: long, arg1: long): Duration;
                static ofMillis(arg0: long): Duration;
                static ofNanos(arg0: long): Duration;
                static of(arg0: long, arg1: java.time.temporal.TemporalUnit): Duration;
                static from(arg0: java.time.temporal.TemporalAmount): Duration;
                static parse(arg0: java.lang.CharSequence): Duration;
                static between(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.Temporal): Duration;

                get(arg0: java.time.temporal.TemporalUnit): number;
                getUnits(): JavaList<java.time.temporal.TemporalUnit>;
                isZero(): boolean;
                isNegative(): boolean;
                getSeconds(): number;
                getNano(): number;
                withSeconds(arg0: long): Duration;
                withNanos(arg0: int): Duration;
                plus(arg0: Duration): Duration;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): Duration;
                plusDays(arg0: long): Duration;
                plusHours(arg0: long): Duration;
                plusMinutes(arg0: long): Duration;
                plusSeconds(arg0: long): Duration;
                plusMillis(arg0: long): Duration;
                plusNanos(arg0: long): Duration;
                minus(arg0: Duration): Duration;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): Duration;
                minusDays(arg0: long): Duration;
                minusHours(arg0: long): Duration;
                minusMinutes(arg0: long): Duration;
                minusSeconds(arg0: long): Duration;
                minusMillis(arg0: long): Duration;
                minusNanos(arg0: long): Duration;
                multipliedBy(arg0: long): Duration;
                dividedBy(arg0: long): Duration;
                dividedBy(arg0: Duration): number;
                negated(): Duration;
                abs(): Duration;
                addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                toDays(): number;
                toHours(): number;
                toMinutes(): number;
                toSeconds(): number;
                toMillis(): number;
                toNanos(): number;
                toDaysPart(): number;
                toHoursPart(): number;
                toMinutesPart(): number;
                toSecondsPart(): number;
                toMillisPart(): number;
                toNanosPart(): number;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): Duration;
                compareTo(arg0: Duration): number;

            }

            interface Instant extends java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable<Instant> {}
            abstract class Instant extends java.lang.Object {
                static readonly class: JavaClass<Instant>;
                /** @deprecated */ static prototype: undefined;

                static readonly EPOCH: Instant;
                static readonly MIN: Instant;
                static readonly MAX: Instant;

                static now(): Instant;
                static now(arg0: Clock): Instant;
                static ofEpochSecond(arg0: long): Instant;
                static ofEpochSecond(arg0: long, arg1: long): Instant;
                static ofEpochMilli(arg0: long): Instant;
                static from(arg0: java.time.temporal.TemporalAccessor): Instant;
                static parse(arg0: java.lang.CharSequence): Instant;

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getEpochSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): Instant;
                with(arg0: java.time.temporal.TemporalField, arg1: long): Instant;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): Instant;
                plus(arg0: java.time.temporal.TemporalAmount): Instant;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): Instant;
                plusSeconds(arg0: long): Instant;
                plusMillis(arg0: long): Instant;
                plusNanos(arg0: long): Instant;
                minus(arg0: java.time.temporal.TemporalAmount): Instant;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): Instant;
                minusSeconds(arg0: long): Instant;
                minusMillis(arg0: long): Instant;
                minusNanos(arg0: long): Instant;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                atOffset(arg0: ZoneOffset): OffsetDateTime;
                atZone(arg0: ZoneId): ZonedDateTime;
                toEpochMilli(): number;
                compareTo(arg0: Instant): number;
                isAfter(arg0: Instant): boolean;
                isBefore(arg0: Instant): boolean;

            }

            interface ZoneOffset extends java.lang.Comparable<ZoneOffset>, java.time.temporal.TemporalAccessor, java.io.Serializable, java.time.temporal.TemporalAdjuster {}
            abstract class ZoneOffset extends ZoneId {
                static readonly class: JavaClass<ZoneOffset>;
                /** @deprecated */ static prototype: undefined;

                static readonly UTC: ZoneOffset;
                static readonly MIN: ZoneOffset;
                static readonly MAX: ZoneOffset;

                static of(arg0: string): ZoneOffset;
                static ofHours(arg0: int): ZoneOffset;
                static ofHoursMinutes(arg0: int, arg1: int): ZoneOffset;
                static ofHoursMinutesSeconds(arg0: int, arg1: int, arg2: int): ZoneOffset;
                static from(arg0: java.time.temporal.TemporalAccessor): ZoneOffset;
                static ofTotalSeconds(arg0: int): ZoneOffset;

                getTotalSeconds(): number;
                getId(): string;
                getRules(): java.time.zone.ZoneRules;
                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                compareTo(arg0: ZoneOffset): number;

            }

            interface ZonedDateTime extends java.time.chrono.ChronoZonedDateTime<LocalDate>, java.io.Serializable, java.time.temporal.Temporal {}
            abstract class ZonedDateTime extends java.lang.Object {
                static readonly class: JavaClass<ZonedDateTime>;
                /** @deprecated */ static prototype: undefined;

                static now(): ZonedDateTime;
                static now(arg0: ZoneId): ZonedDateTime;
                static now(arg0: Clock): ZonedDateTime;
                static of(arg0: LocalDate, arg1: LocalTime, arg2: ZoneId): ZonedDateTime;
                static of(arg0: LocalDateTime, arg1: ZoneId): ZonedDateTime;
                static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: ZoneId): ZonedDateTime;
                static ofLocal(arg0: LocalDateTime, arg1: ZoneId, arg2: ZoneOffset): ZonedDateTime;
                static ofInstant(arg0: Instant, arg1: ZoneId): ZonedDateTime;
                static ofInstant(arg0: LocalDateTime, arg1: ZoneOffset, arg2: ZoneId): ZonedDateTime;
                static ofStrict(arg0: LocalDateTime, arg1: ZoneOffset, arg2: ZoneId): ZonedDateTime;
                static from(arg0: java.time.temporal.TemporalAccessor): ZonedDateTime;
                static parse(arg0: java.lang.CharSequence): ZonedDateTime;
                static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): ZonedDateTime;

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getOffset(): ZoneOffset;
                withEarlierOffsetAtOverlap(): ZonedDateTime;
                withLaterOffsetAtOverlap(): ZonedDateTime;
                getZone(): ZoneId;
                withZoneSameLocal(arg0: ZoneId): ZonedDateTime;
                withZoneSameInstant(arg0: ZoneId): ZonedDateTime;
                withFixedOffsetZone(): ZonedDateTime;
                toLocalDateTime(): LocalDateTime;
                toLocalDate(): LocalDate;
                getYear(): number;
                getMonthValue(): number;
                getMonth(): Month;
                getDayOfMonth(): number;
                getDayOfYear(): number;
                getDayOfWeek(): DayOfWeek;
                toLocalTime(): LocalTime;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): ZonedDateTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): ZonedDateTime;
                withYear(arg0: int): ZonedDateTime;
                withMonth(arg0: int): ZonedDateTime;
                withDayOfMonth(arg0: int): ZonedDateTime;
                withDayOfYear(arg0: int): ZonedDateTime;
                withHour(arg0: int): ZonedDateTime;
                withMinute(arg0: int): ZonedDateTime;
                withSecond(arg0: int): ZonedDateTime;
                withNano(arg0: int): ZonedDateTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): ZonedDateTime;
                plus(arg0: java.time.temporal.TemporalAmount): ZonedDateTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): ZonedDateTime;
                plusYears(arg0: long): ZonedDateTime;
                plusMonths(arg0: long): ZonedDateTime;
                plusWeeks(arg0: long): ZonedDateTime;
                plusDays(arg0: long): ZonedDateTime;
                plusHours(arg0: long): ZonedDateTime;
                plusMinutes(arg0: long): ZonedDateTime;
                plusSeconds(arg0: long): ZonedDateTime;
                plusNanos(arg0: long): ZonedDateTime;
                minus(arg0: java.time.temporal.TemporalAmount): ZonedDateTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): ZonedDateTime;
                minusYears(arg0: long): ZonedDateTime;
                minusMonths(arg0: long): ZonedDateTime;
                minusWeeks(arg0: long): ZonedDateTime;
                minusDays(arg0: long): ZonedDateTime;
                minusHours(arg0: long): ZonedDateTime;
                minusMinutes(arg0: long): ZonedDateTime;
                minusSeconds(arg0: long): ZonedDateTime;
                minusNanos(arg0: long): ZonedDateTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                toOffsetDateTime(): OffsetDateTime;

            }

            interface OffsetDateTime extends java.lang.Comparable<OffsetDateTime>, java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster {}
            abstract class OffsetDateTime extends java.lang.Object {
                static readonly class: JavaClass<OffsetDateTime>;
                /** @deprecated */ static prototype: undefined;

                static readonly MIN: OffsetDateTime;
                static readonly MAX: OffsetDateTime;

                static timeLineOrder(): MethodWrapper<OffsetDateTime, OffsetDateTime, int>;
                static now(): OffsetDateTime;
                static now(arg0: ZoneId): OffsetDateTime;
                static now(arg0: Clock): OffsetDateTime;
                static of(arg0: LocalDate, arg1: LocalTime, arg2: ZoneOffset): OffsetDateTime;
                static of(arg0: LocalDateTime, arg1: ZoneOffset): OffsetDateTime;
                static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: ZoneOffset): OffsetDateTime;
                static ofInstant(arg0: Instant, arg1: ZoneId): OffsetDateTime;
                static from(arg0: java.time.temporal.TemporalAccessor): OffsetDateTime;
                static parse(arg0: java.lang.CharSequence): OffsetDateTime;
                static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): OffsetDateTime;

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getOffset(): ZoneOffset;
                withOffsetSameLocal(arg0: ZoneOffset): OffsetDateTime;
                withOffsetSameInstant(arg0: ZoneOffset): OffsetDateTime;
                toLocalDateTime(): LocalDateTime;
                toLocalDate(): LocalDate;
                getYear(): number;
                getMonthValue(): number;
                getMonth(): Month;
                getDayOfMonth(): number;
                getDayOfYear(): number;
                getDayOfWeek(): DayOfWeek;
                toLocalTime(): LocalTime;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): OffsetDateTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): OffsetDateTime;
                withYear(arg0: int): OffsetDateTime;
                withMonth(arg0: int): OffsetDateTime;
                withDayOfMonth(arg0: int): OffsetDateTime;
                withDayOfYear(arg0: int): OffsetDateTime;
                withHour(arg0: int): OffsetDateTime;
                withMinute(arg0: int): OffsetDateTime;
                withSecond(arg0: int): OffsetDateTime;
                withNano(arg0: int): OffsetDateTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): OffsetDateTime;
                plus(arg0: java.time.temporal.TemporalAmount): OffsetDateTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): OffsetDateTime;
                plusYears(arg0: long): OffsetDateTime;
                plusMonths(arg0: long): OffsetDateTime;
                plusWeeks(arg0: long): OffsetDateTime;
                plusDays(arg0: long): OffsetDateTime;
                plusHours(arg0: long): OffsetDateTime;
                plusMinutes(arg0: long): OffsetDateTime;
                plusSeconds(arg0: long): OffsetDateTime;
                plusNanos(arg0: long): OffsetDateTime;
                minus(arg0: java.time.temporal.TemporalAmount): OffsetDateTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): OffsetDateTime;
                minusYears(arg0: long): OffsetDateTime;
                minusMonths(arg0: long): OffsetDateTime;
                minusWeeks(arg0: long): OffsetDateTime;
                minusDays(arg0: long): OffsetDateTime;
                minusHours(arg0: long): OffsetDateTime;
                minusMinutes(arg0: long): OffsetDateTime;
                minusSeconds(arg0: long): OffsetDateTime;
                minusNanos(arg0: long): OffsetDateTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atZoneSameInstant(arg0: ZoneId): ZonedDateTime;
                atZoneSimilarLocal(arg0: ZoneId): ZonedDateTime;
                toOffsetTime(): OffsetTime;
                toZonedDateTime(): ZonedDateTime;
                toInstant(): Instant;
                toEpochSecond(): number;
                compareTo(arg0: OffsetDateTime): number;
                isAfter(arg0: OffsetDateTime): boolean;
                isBefore(arg0: OffsetDateTime): boolean;
                isEqual(arg0: OffsetDateTime): boolean;

            }

            interface ZoneId extends java.io.Serializable {}
            abstract class ZoneId extends java.lang.Object {
                static readonly class: JavaClass<ZoneId>;
                /** @deprecated */ static prototype: undefined;

                static readonly SHORT_IDS: JavaMap<string, string>;

                static systemDefault(): ZoneId;
                static getAvailableZoneIds(): JavaSet<string>;
                static of(arg0: string, arg1: JavaMap<string, string>): ZoneId;
                static of(arg0: string): ZoneId;
                static ofOffset(arg0: string, arg1: ZoneOffset): ZoneId;
                static from(arg0: java.time.temporal.TemporalAccessor): ZoneId;

                getId(): string;
                getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;
                getRules(): java.time.zone.ZoneRules;
                normalized(): ZoneId;

            }

            interface Clock extends InstantSource {}
            abstract class Clock extends java.lang.Object {
                static readonly class: JavaClass<Clock>;
                /** @deprecated */ static prototype: undefined;

                static systemUTC(): Clock;
                static systemDefaultZone(): Clock;
                static system(arg0: ZoneId): Clock;
                static tickMillis(arg0: ZoneId): Clock;
                static tickSeconds(arg0: ZoneId): Clock;
                static tickMinutes(arg0: ZoneId): Clock;
                static tick(arg0: Clock, arg1: Duration): Clock;
                static fixed(arg0: Instant, arg1: ZoneId): Clock;
                static offset(arg0: Clock, arg1: Duration): Clock;

                getZone(): ZoneId;
                withZone(arg0: ZoneId): Clock;
                millis(): number;
                instant(): Instant;

            }

            interface Month extends java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster {}
            abstract class Month extends java.lang.Enum<Month> {
                static readonly class: JavaClass<Month>;
                /** @deprecated */ static prototype: undefined;

                static readonly JANUARY: Month;
                static readonly FEBRUARY: Month;
                static readonly MARCH: Month;
                static readonly APRIL: Month;
                static readonly MAY: Month;
                static readonly JUNE: Month;
                static readonly JULY: Month;
                static readonly AUGUST: Month;
                static readonly SEPTEMBER: Month;
                static readonly OCTOBER: Month;
                static readonly NOVEMBER: Month;
                static readonly DECEMBER: Month;

                static values(): JavaArray<Month>;
                static valueOf(arg0: string): Month;
                static of(arg0: int): Month;
                static from(arg0: java.time.temporal.TemporalAccessor): Month;

                getValue(): number;
                getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;
                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                plus(arg0: long): Month;
                minus(arg0: long): Month;
                length(arg0: boolean): number;
                minLength(): number;
                maxLength(): number;
                firstDayOfYear(arg0: boolean): number;
                firstMonthOfQuarter(): Month;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;

            }

            interface Period extends java.time.chrono.ChronoPeriod, java.io.Serializable {}
            abstract class Period extends java.lang.Object {
                static readonly class: JavaClass<Period>;
                /** @deprecated */ static prototype: undefined;

                static readonly ZERO: Period;

                static ofYears(arg0: int): Period;
                static ofMonths(arg0: int): Period;
                static ofWeeks(arg0: int): Period;
                static ofDays(arg0: int): Period;
                static of(arg0: int, arg1: int, arg2: int): Period;
                static from(arg0: java.time.temporal.TemporalAmount): Period;
                static parse(arg0: java.lang.CharSequence): Period;
                static between(arg0: LocalDate, arg1: LocalDate): Period;

                get(arg0: java.time.temporal.TemporalUnit): number;
                getUnits(): JavaList<java.time.temporal.TemporalUnit>;
                getChronology(): java.time.chrono.IsoChronology;
                isZero(): boolean;
                isNegative(): boolean;
                getYears(): number;
                getMonths(): number;
                getDays(): number;
                withYears(arg0: int): Period;
                withMonths(arg0: int): Period;
                withDays(arg0: int): Period;
                plus(arg0: java.time.temporal.TemporalAmount): Period;
                plusYears(arg0: long): Period;
                plusMonths(arg0: long): Period;
                plusDays(arg0: long): Period;
                minus(arg0: java.time.temporal.TemporalAmount): Period;
                minusYears(arg0: long): Period;
                minusMonths(arg0: long): Period;
                minusDays(arg0: long): Period;
                multipliedBy(arg0: int): Period;
                negated(): Period;
                normalized(): Period;
                toTotalMonths(): number;
                addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;

            }

            interface LocalTime extends java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable<LocalTime> {}
            abstract class LocalTime extends java.lang.Object {
                static readonly class: JavaClass<LocalTime>;
                /** @deprecated */ static prototype: undefined;

                static readonly MIN: LocalTime;
                static readonly MAX: LocalTime;
                static readonly MIDNIGHT: LocalTime;
                static readonly NOON: LocalTime;

                static now(): LocalTime;
                static now(arg0: ZoneId): LocalTime;
                static now(arg0: Clock): LocalTime;
                static of(arg0: int, arg1: int): LocalTime;
                static of(arg0: int, arg1: int, arg2: int): LocalTime;
                static of(arg0: int, arg1: int, arg2: int, arg3: int): LocalTime;
                static ofInstant(arg0: Instant, arg1: ZoneId): LocalTime;
                static ofSecondOfDay(arg0: long): LocalTime;
                static ofNanoOfDay(arg0: long): LocalTime;
                static from(arg0: java.time.temporal.TemporalAccessor): LocalTime;
                static parse(arg0: java.lang.CharSequence): LocalTime;
                static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): LocalTime;

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): LocalTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): LocalTime;
                withHour(arg0: int): LocalTime;
                withMinute(arg0: int): LocalTime;
                withSecond(arg0: int): LocalTime;
                withNano(arg0: int): LocalTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): LocalTime;
                plus(arg0: java.time.temporal.TemporalAmount): LocalTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalTime;
                plusHours(arg0: long): LocalTime;
                plusMinutes(arg0: long): LocalTime;
                plusSeconds(arg0: long): LocalTime;
                plusNanos(arg0: long): LocalTime;
                minus(arg0: java.time.temporal.TemporalAmount): LocalTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalTime;
                minusHours(arg0: long): LocalTime;
                minusMinutes(arg0: long): LocalTime;
                minusSeconds(arg0: long): LocalTime;
                minusNanos(arg0: long): LocalTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atDate(arg0: LocalDate): LocalDateTime;
                atOffset(arg0: ZoneOffset): OffsetTime;
                toSecondOfDay(): number;
                toNanoOfDay(): number;
                toEpochSecond(arg0: LocalDate, arg1: ZoneOffset): number;
                compareTo(arg0: LocalTime): number;
                isAfter(arg0: LocalTime): boolean;
                isBefore(arg0: LocalTime): boolean;

            }

            abstract class InstantSource extends java.lang.Interface {
                static readonly class: JavaClass<InstantSource>;
                /** @deprecated */ static prototype: undefined;

                static system(): InstantSource;
                static tick(arg0: InstantSource, arg1: Duration): InstantSource;
                static fixed(arg0: Instant): InstantSource;
                static offset(arg0: InstantSource, arg1: Duration): InstantSource;

            }
            interface InstantSource {

                instant(): Instant;
                millis(): number;
                withZone(arg0: ZoneId): Clock;

            }

            interface DayOfWeek extends java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster {}
            abstract class DayOfWeek extends java.lang.Enum<DayOfWeek> {
                static readonly class: JavaClass<DayOfWeek>;
                /** @deprecated */ static prototype: undefined;

                static readonly MONDAY: DayOfWeek;
                static readonly TUESDAY: DayOfWeek;
                static readonly WEDNESDAY: DayOfWeek;
                static readonly THURSDAY: DayOfWeek;
                static readonly FRIDAY: DayOfWeek;
                static readonly SATURDAY: DayOfWeek;
                static readonly SUNDAY: DayOfWeek;

                static values(): JavaArray<DayOfWeek>;
                static valueOf(arg0: string): DayOfWeek;
                static of(arg0: int): DayOfWeek;
                static from(arg0: java.time.temporal.TemporalAccessor): DayOfWeek;

                getValue(): number;
                getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;
                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                plus(arg0: long): DayOfWeek;
                minus(arg0: long): DayOfWeek;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;

            }

            interface LocalDateTime extends java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.time.chrono.ChronoLocalDateTime<LocalDate> {}
            abstract class LocalDateTime extends java.lang.Object {
                static readonly class: JavaClass<LocalDateTime>;
                /** @deprecated */ static prototype: undefined;

                static readonly MIN: LocalDateTime;
                static readonly MAX: LocalDateTime;

                static now(): LocalDateTime;
                static now(arg0: ZoneId): LocalDateTime;
                static now(arg0: Clock): LocalDateTime;
                static of(arg0: int, arg1: Month, arg2: int, arg3: int, arg4: int): LocalDateTime;
                static of(arg0: int, arg1: Month, arg2: int, arg3: int, arg4: int, arg5: int): LocalDateTime;
                static of(arg0: int, arg1: Month, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int): LocalDateTime;
                static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int): LocalDateTime;
                static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): LocalDateTime;
                static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int): LocalDateTime;
                static of(arg0: LocalDate, arg1: LocalTime): LocalDateTime;
                static ofInstant(arg0: Instant, arg1: ZoneId): LocalDateTime;
                static ofEpochSecond(arg0: long, arg1: int, arg2: ZoneOffset): LocalDateTime;
                static from(arg0: java.time.temporal.TemporalAccessor): LocalDateTime;
                static parse(arg0: java.lang.CharSequence): LocalDateTime;
                static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): LocalDateTime;

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                toLocalDate(): LocalDate;
                getYear(): number;
                getMonthValue(): number;
                getMonth(): Month;
                getDayOfMonth(): number;
                getDayOfYear(): number;
                getDayOfWeek(): DayOfWeek;
                toLocalTime(): LocalTime;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): LocalDateTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): LocalDateTime;
                withYear(arg0: int): LocalDateTime;
                withMonth(arg0: int): LocalDateTime;
                withDayOfMonth(arg0: int): LocalDateTime;
                withDayOfYear(arg0: int): LocalDateTime;
                withHour(arg0: int): LocalDateTime;
                withMinute(arg0: int): LocalDateTime;
                withSecond(arg0: int): LocalDateTime;
                withNano(arg0: int): LocalDateTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): LocalDateTime;
                plus(arg0: java.time.temporal.TemporalAmount): LocalDateTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalDateTime;
                plusYears(arg0: long): LocalDateTime;
                plusMonths(arg0: long): LocalDateTime;
                plusWeeks(arg0: long): LocalDateTime;
                plusDays(arg0: long): LocalDateTime;
                plusHours(arg0: long): LocalDateTime;
                plusMinutes(arg0: long): LocalDateTime;
                plusSeconds(arg0: long): LocalDateTime;
                plusNanos(arg0: long): LocalDateTime;
                minus(arg0: java.time.temporal.TemporalAmount): LocalDateTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalDateTime;
                minusYears(arg0: long): LocalDateTime;
                minusMonths(arg0: long): LocalDateTime;
                minusWeeks(arg0: long): LocalDateTime;
                minusDays(arg0: long): LocalDateTime;
                minusHours(arg0: long): LocalDateTime;
                minusMinutes(arg0: long): LocalDateTime;
                minusSeconds(arg0: long): LocalDateTime;
                minusNanos(arg0: long): LocalDateTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atOffset(arg0: ZoneOffset): OffsetDateTime;
                atZone(arg0: ZoneId): ZonedDateTime;
                compareTo(arg0: java.time.chrono.ChronoLocalDateTime<any>): number;
                isAfter(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean;
                isBefore(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean;
                isEqual(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean;

            }

            interface LocalDate extends java.time.chrono.ChronoLocalDate, java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster {}
            abstract class LocalDate extends java.lang.Object {
                static readonly class: JavaClass<LocalDate>;
                /** @deprecated */ static prototype: undefined;

                static readonly MIN: LocalDate;
                static readonly MAX: LocalDate;
                static readonly EPOCH: LocalDate;

                static now(): LocalDate;
                static now(arg0: ZoneId): LocalDate;
                static now(arg0: Clock): LocalDate;
                static of(arg0: int, arg1: Month, arg2: int): LocalDate;
                static of(arg0: int, arg1: int, arg2: int): LocalDate;
                static ofYearDay(arg0: int, arg1: int): LocalDate;
                static ofInstant(arg0: Instant, arg1: ZoneId): LocalDate;
                static ofEpochDay(arg0: long): LocalDate;
                static from(arg0: java.time.temporal.TemporalAccessor): LocalDate;
                static parse(arg0: java.lang.CharSequence): LocalDate;
                static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): LocalDate;

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getChronology(): java.time.chrono.IsoChronology;
                getEra(): java.time.chrono.IsoEra;
                getYear(): number;
                getMonthValue(): number;
                getMonth(): Month;
                getDayOfMonth(): number;
                getDayOfYear(): number;
                getDayOfWeek(): DayOfWeek;
                isLeapYear(): boolean;
                lengthOfMonth(): number;
                lengthOfYear(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): LocalDate;
                with(arg0: java.time.temporal.TemporalField, arg1: long): LocalDate;
                withYear(arg0: int): LocalDate;
                withMonth(arg0: int): LocalDate;
                withDayOfMonth(arg0: int): LocalDate;
                withDayOfYear(arg0: int): LocalDate;
                plus(arg0: java.time.temporal.TemporalAmount): LocalDate;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalDate;
                plusYears(arg0: long): LocalDate;
                plusMonths(arg0: long): LocalDate;
                plusWeeks(arg0: long): LocalDate;
                plusDays(arg0: long): LocalDate;
                minus(arg0: java.time.temporal.TemporalAmount): LocalDate;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalDate;
                minusYears(arg0: long): LocalDate;
                minusMonths(arg0: long): LocalDate;
                minusWeeks(arg0: long): LocalDate;
                minusDays(arg0: long): LocalDate;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                until(arg0: java.time.chrono.ChronoLocalDate): Period;
                datesUntil(arg0: LocalDate): java.util.stream.Stream<LocalDate>;
                datesUntil(arg0: LocalDate, arg1: Period): java.util.stream.Stream<LocalDate>;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atTime(arg0: LocalTime): LocalDateTime;
                atTime(arg0: int, arg1: int): LocalDateTime;
                atTime(arg0: int, arg1: int, arg2: int): LocalDateTime;
                atTime(arg0: int, arg1: int, arg2: int, arg3: int): LocalDateTime;
                atTime(arg0: OffsetTime): OffsetDateTime;
                atStartOfDay(): LocalDateTime;
                atStartOfDay(arg0: ZoneId): ZonedDateTime;
                toEpochDay(): number;
                toEpochSecond(arg0: LocalTime, arg1: ZoneOffset): number;
                compareTo(arg0: java.time.chrono.ChronoLocalDate): number;
                isAfter(arg0: java.time.chrono.ChronoLocalDate): boolean;
                isBefore(arg0: java.time.chrono.ChronoLocalDate): boolean;
                isEqual(arg0: java.time.chrono.ChronoLocalDate): boolean;

            }

            interface OffsetTime extends java.lang.Comparable<OffsetTime>, java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster {}
            abstract class OffsetTime extends java.lang.Object {
                static readonly class: JavaClass<OffsetTime>;
                /** @deprecated */ static prototype: undefined;

                static readonly MIN: OffsetTime;
                static readonly MAX: OffsetTime;

                static now(): OffsetTime;
                static now(arg0: ZoneId): OffsetTime;
                static now(arg0: Clock): OffsetTime;
                static of(arg0: LocalTime, arg1: ZoneOffset): OffsetTime;
                static of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: ZoneOffset): OffsetTime;
                static ofInstant(arg0: Instant, arg1: ZoneId): OffsetTime;
                static from(arg0: java.time.temporal.TemporalAccessor): OffsetTime;
                static parse(arg0: java.lang.CharSequence): OffsetTime;
                static parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): OffsetTime;

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getOffset(): ZoneOffset;
                withOffsetSameLocal(arg0: ZoneOffset): OffsetTime;
                withOffsetSameInstant(arg0: ZoneOffset): OffsetTime;
                toLocalTime(): LocalTime;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): OffsetTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): OffsetTime;
                withHour(arg0: int): OffsetTime;
                withMinute(arg0: int): OffsetTime;
                withSecond(arg0: int): OffsetTime;
                withNano(arg0: int): OffsetTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): OffsetTime;
                plus(arg0: java.time.temporal.TemporalAmount): OffsetTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): OffsetTime;
                plusHours(arg0: long): OffsetTime;
                plusMinutes(arg0: long): OffsetTime;
                plusSeconds(arg0: long): OffsetTime;
                plusNanos(arg0: long): OffsetTime;
                minus(arg0: java.time.temporal.TemporalAmount): OffsetTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): OffsetTime;
                minusHours(arg0: long): OffsetTime;
                minusMinutes(arg0: long): OffsetTime;
                minusSeconds(arg0: long): OffsetTime;
                minusNanos(arg0: long): OffsetTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atDate(arg0: LocalDate): OffsetDateTime;
                toEpochSecond(arg0: LocalDate): number;
                compareTo(arg0: OffsetTime): number;
                isAfter(arg0: OffsetTime): boolean;
                isBefore(arg0: OffsetTime): boolean;
                isEqual(arg0: OffsetTime): boolean;

            }

            export {
                Duration,
                Instant,
                ZoneOffset,
                ZonedDateTime,
                OffsetDateTime,
                ZoneId,
                Clock,
                Month,
                Period,
                LocalTime,
                InstantSource,
                DayOfWeek,
                LocalDateTime,
                LocalDate,
                OffsetTime
            }

        }
        namespace time {

            namespace chrono {

                abstract class Chronology extends java.lang.Interface {
                    static readonly class: JavaClass<Chronology>;
                    /** @deprecated */ static prototype: undefined;

                    static from(arg0: java.time.temporal.TemporalAccessor): Chronology;
                    static ofLocale(arg0: java.util.Locale): Chronology;
                    static of(arg0: string): Chronology;
                    static getAvailableChronologies(): JavaSet<Chronology>;

                }
                interface Chronology extends java.lang.Comparable<Chronology> {

                    getId(): string;
                    getCalendarType(): string;
                    date(arg0: Era, arg1: int, arg2: int, arg3: int): ChronoLocalDate;
                    date(arg0: int, arg1: int, arg2: int): ChronoLocalDate;
                    dateYearDay(arg0: Era, arg1: int, arg2: int): ChronoLocalDate;
                    dateYearDay(arg0: int, arg1: int): ChronoLocalDate;
                    dateEpochDay(arg0: long): ChronoLocalDate;
                    dateNow(): ChronoLocalDate;
                    dateNow(arg0: java.time.ZoneId): ChronoLocalDate;
                    dateNow(arg0: java.time.Clock): ChronoLocalDate;
                    date(arg0: java.time.temporal.TemporalAccessor): ChronoLocalDate;
                    localDateTime(arg0: java.time.temporal.TemporalAccessor): ChronoLocalDateTime<ChronoLocalDate>;
                    zonedDateTime(arg0: java.time.temporal.TemporalAccessor): ChronoZonedDateTime<ChronoLocalDate>;
                    zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): ChronoZonedDateTime<ChronoLocalDate>;
                    isLeapYear(arg0: long): boolean;
                    prolepticYear(arg0: Era, arg1: int): number;
                    eraOf(arg0: int): Era;
                    eras(): JavaList<Era>;
                    range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange;
                    getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;
                    resolveDate(arg0: JavaMap<java.time.temporal.TemporalField, long>, arg1: java.time.format.ResolverStyle): ChronoLocalDate;
                    period(arg0: int, arg1: int, arg2: int): ChronoPeriod;
                    epochSecond(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: java.time.ZoneOffset): number;
                    epochSecond(arg0: Era, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: java.time.ZoneOffset): number;
                    compareTo(arg0: Chronology): number;

                }

                abstract class ChronoZonedDateTime<D extends ChronoLocalDate> extends java.lang.Interface {
                    static readonly class: JavaClass<ChronoZonedDateTime<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static timeLineOrder(): MethodWrapper<ChronoZonedDateTime<any>, ChronoZonedDateTime<any>, int>;
                    static from(arg0: java.time.temporal.TemporalAccessor): ChronoZonedDateTime<any>;

                }
                interface ChronoZonedDateTime<D extends ChronoLocalDate> extends java.lang.Comparable<ChronoZonedDateTime<any>>, java.time.temporal.Temporal {

                    range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                    get(arg0: java.time.temporal.TemporalField): number;
                    getLong(arg0: java.time.temporal.TemporalField): number;
                    toLocalDate(): D;
                    toLocalTime(): java.time.LocalTime;
                    toLocalDateTime(): ChronoLocalDateTime<D>;
                    getChronology(): Chronology;
                    getOffset(): java.time.ZoneOffset;
                    getZone(): java.time.ZoneId;
                    withEarlierOffsetAtOverlap(): ChronoZonedDateTime<D>;
                    withLaterOffsetAtOverlap(): ChronoZonedDateTime<D>;
                    withZoneSameLocal(arg0: java.time.ZoneId): ChronoZonedDateTime<D>;
                    withZoneSameInstant(arg0: java.time.ZoneId): ChronoZonedDateTime<D>;
                    isSupported(arg0: java.time.temporal.TemporalField): boolean;
                    isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                    with(arg0: java.time.temporal.TemporalAdjuster): ChronoZonedDateTime<D>;
                    with(arg0: java.time.temporal.TemporalField, arg1: long): ChronoZonedDateTime<D>;
                    plus(arg0: java.time.temporal.TemporalAmount): ChronoZonedDateTime<D>;
                    plus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoZonedDateTime<D>;
                    minus(arg0: java.time.temporal.TemporalAmount): ChronoZonedDateTime<D>;
                    minus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoZonedDateTime<D>;
                    query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                    format(arg0: java.time.format.DateTimeFormatter): string;
                    toInstant(): java.time.Instant;
                    toEpochSecond(): number;
                    compareTo(arg0: ChronoZonedDateTime<any>): number;
                    isBefore(arg0: ChronoZonedDateTime<any>): boolean;
                    isAfter(arg0: ChronoZonedDateTime<any>): boolean;
                    isEqual(arg0: ChronoZonedDateTime<any>): boolean;

                }

                abstract class ChronoLocalDate extends java.lang.Interface {
                    static readonly class: JavaClass<ChronoLocalDate>;
                    /** @deprecated */ static prototype: undefined;

                    static timeLineOrder(): MethodWrapper<ChronoLocalDate, ChronoLocalDate, int>;
                    static from(arg0: java.time.temporal.TemporalAccessor): ChronoLocalDate;

                }
                interface ChronoLocalDate extends java.lang.Comparable<ChronoLocalDate>, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster {

                    getChronology(): Chronology;
                    getEra(): Era;
                    isLeapYear(): boolean;
                    lengthOfMonth(): number;
                    lengthOfYear(): number;
                    isSupported(arg0: java.time.temporal.TemporalField): boolean;
                    isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                    with(arg0: java.time.temporal.TemporalAdjuster): ChronoLocalDate;
                    with(arg0: java.time.temporal.TemporalField, arg1: long): ChronoLocalDate;
                    plus(arg0: java.time.temporal.TemporalAmount): ChronoLocalDate;
                    plus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoLocalDate;
                    minus(arg0: java.time.temporal.TemporalAmount): ChronoLocalDate;
                    minus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoLocalDate;
                    query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                    adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                    until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                    until(arg0: ChronoLocalDate): ChronoPeriod;
                    format(arg0: java.time.format.DateTimeFormatter): string;
                    atTime(arg0: java.time.LocalTime): ChronoLocalDateTime<any>;
                    toEpochDay(): number;
                    compareTo(arg0: ChronoLocalDate): number;
                    isAfter(arg0: ChronoLocalDate): boolean;
                    isBefore(arg0: ChronoLocalDate): boolean;
                    isEqual(arg0: ChronoLocalDate): boolean;

                }

                abstract class Era extends java.lang.Interface {
                    static readonly class: JavaClass<Era>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Era extends java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster {

                    getValue(): number;
                    isSupported(arg0: java.time.temporal.TemporalField): boolean;
                    range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                    get(arg0: java.time.temporal.TemporalField): number;
                    getLong(arg0: java.time.temporal.TemporalField): number;
                    query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                    adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                    getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;

                }

                abstract class ChronoPeriod extends java.lang.Interface {
                    static readonly class: JavaClass<ChronoPeriod>;
                    /** @deprecated */ static prototype: undefined;

                    static between(arg0: ChronoLocalDate, arg1: ChronoLocalDate): ChronoPeriod;

                }
                interface ChronoPeriod extends java.time.temporal.TemporalAmount {

                    get(arg0: java.time.temporal.TemporalUnit): number;
                    getUnits(): JavaList<java.time.temporal.TemporalUnit>;
                    getChronology(): Chronology;
                    isZero(): boolean;
                    isNegative(): boolean;
                    plus(arg0: java.time.temporal.TemporalAmount): ChronoPeriod;
                    minus(arg0: java.time.temporal.TemporalAmount): ChronoPeriod;
                    multipliedBy(arg0: int): ChronoPeriod;
                    negated(): ChronoPeriod;
                    normalized(): ChronoPeriod;
                    addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                    subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;

                }

                abstract class ChronoLocalDateTime<D extends ChronoLocalDate> extends java.lang.Interface {
                    static readonly class: JavaClass<ChronoLocalDateTime<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static timeLineOrder(): MethodWrapper<ChronoLocalDateTime<any>, ChronoLocalDateTime<any>, int>;
                    static from(arg0: java.time.temporal.TemporalAccessor): ChronoLocalDateTime<any>;

                }
                interface ChronoLocalDateTime<D extends ChronoLocalDate> extends java.time.temporal.Temporal, java.lang.Comparable<ChronoLocalDateTime<any>>, java.time.temporal.TemporalAdjuster {

                    getChronology(): Chronology;
                    toLocalDate(): D;
                    toLocalTime(): java.time.LocalTime;
                    isSupported(arg0: java.time.temporal.TemporalField): boolean;
                    isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                    with(arg0: java.time.temporal.TemporalAdjuster): ChronoLocalDateTime<D>;
                    with(arg0: java.time.temporal.TemporalField, arg1: long): ChronoLocalDateTime<D>;
                    plus(arg0: java.time.temporal.TemporalAmount): ChronoLocalDateTime<D>;
                    plus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoLocalDateTime<D>;
                    minus(arg0: java.time.temporal.TemporalAmount): ChronoLocalDateTime<D>;
                    minus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoLocalDateTime<D>;
                    query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                    adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                    format(arg0: java.time.format.DateTimeFormatter): string;
                    atZone(arg0: java.time.ZoneId): ChronoZonedDateTime<D>;
                    toInstant(arg0: java.time.ZoneOffset): java.time.Instant;
                    toEpochSecond(arg0: java.time.ZoneOffset): number;
                    compareTo(arg0: ChronoLocalDateTime<any>): number;
                    isAfter(arg0: ChronoLocalDateTime<any>): boolean;
                    isBefore(arg0: ChronoLocalDateTime<any>): boolean;
                    isEqual(arg0: ChronoLocalDateTime<any>): boolean;

                }

                interface IsoEra extends Era {}
                abstract class IsoEra extends java.lang.Enum<IsoEra> {
                    static readonly class: JavaClass<IsoEra>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly BCE: IsoEra;
                    static readonly CE: IsoEra;

                    static values(): JavaArray<IsoEra>;
                    static valueOf(arg0: string): IsoEra;
                    static of(arg0: int): IsoEra;

                    getValue(): number;

                }

                interface IsoChronology extends java.io.Serializable {}
                abstract class IsoChronology extends AbstractChronology {
                    static readonly class: JavaClass<IsoChronology>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly INSTANCE: IsoChronology;

                    getId(): string;
                    getCalendarType(): string;
                    date(arg0: Era, arg1: int, arg2: int, arg3: int): java.time.LocalDate;
                    date(arg0: int, arg1: int, arg2: int): java.time.LocalDate;
                    dateYearDay(arg0: Era, arg1: int, arg2: int): java.time.LocalDate;
                    dateYearDay(arg0: int, arg1: int): java.time.LocalDate;
                    dateEpochDay(arg0: long): java.time.LocalDate;
                    date(arg0: java.time.temporal.TemporalAccessor): java.time.LocalDate;
                    epochSecond(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: java.time.ZoneOffset): number;
                    epochSecond(arg0: Era, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: java.time.ZoneOffset): number;
                    localDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.LocalDateTime;
                    zonedDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.ZonedDateTime;
                    zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.ZonedDateTime;
                    dateNow(): java.time.LocalDate;
                    dateNow(arg0: java.time.ZoneId): java.time.LocalDate;
                    dateNow(arg0: java.time.Clock): java.time.LocalDate;
                    isLeapYear(arg0: long): boolean;
                    prolepticYear(arg0: Era, arg1: int): number;
                    eraOf(arg0: int): IsoEra;
                    eras(): JavaList<Era>;
                    resolveDate(arg0: JavaMap<java.time.temporal.TemporalField, long>, arg1: java.time.format.ResolverStyle): java.time.LocalDate;
                    range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange;
                    period(arg0: int, arg1: int, arg2: int): java.time.Period;

                }

                interface AbstractChronology extends Chronology {}
                abstract class AbstractChronology extends java.lang.Object {
                    static readonly class: JavaClass<AbstractChronology>;
                    /** @deprecated */ static prototype: undefined;

                    resolveDate(arg0: JavaMap<java.time.temporal.TemporalField, long>, arg1: java.time.format.ResolverStyle): ChronoLocalDate;
                    compareTo(arg0: Chronology): number;

                }

                export {
                    Chronology,
                    ChronoZonedDateTime,
                    ChronoLocalDate,
                    Era,
                    ChronoPeriod,
                    ChronoLocalDateTime,
                    IsoEra,
                    IsoChronology,
                    AbstractChronology
                }

            }

            namespace format {

                abstract class ResolverStyle extends java.lang.Enum<ResolverStyle> {
                    static readonly class: JavaClass<ResolverStyle>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly STRICT: ResolverStyle;
                    static readonly SMART: ResolverStyle;
                    static readonly LENIENT: ResolverStyle;

                    static values(): JavaArray<ResolverStyle>;
                    static valueOf(arg0: string): ResolverStyle;

                }

                abstract class TextStyle extends java.lang.Enum<TextStyle> {
                    static readonly class: JavaClass<TextStyle>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly FULL: TextStyle;
                    static readonly FULL_STANDALONE: TextStyle;
                    static readonly SHORT: TextStyle;
                    static readonly SHORT_STANDALONE: TextStyle;
                    static readonly NARROW: TextStyle;
                    static readonly NARROW_STANDALONE: TextStyle;

                    static values(): JavaArray<TextStyle>;
                    static valueOf(arg0: string): TextStyle;

                    isStandalone(): boolean;
                    asStandalone(): TextStyle;
                    asNormal(): TextStyle;

                }

                abstract class DateTimeFormatter extends java.lang.Object {
                    static readonly class: JavaClass<DateTimeFormatter>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly ISO_LOCAL_DATE: DateTimeFormatter;
                    static readonly ISO_OFFSET_DATE: DateTimeFormatter;
                    static readonly ISO_DATE: DateTimeFormatter;
                    static readonly ISO_LOCAL_TIME: DateTimeFormatter;
                    static readonly ISO_OFFSET_TIME: DateTimeFormatter;
                    static readonly ISO_TIME: DateTimeFormatter;
                    static readonly ISO_LOCAL_DATE_TIME: DateTimeFormatter;
                    static readonly ISO_OFFSET_DATE_TIME: DateTimeFormatter;
                    static readonly ISO_ZONED_DATE_TIME: DateTimeFormatter;
                    static readonly ISO_DATE_TIME: DateTimeFormatter;
                    static readonly ISO_ORDINAL_DATE: DateTimeFormatter;
                    static readonly ISO_WEEK_DATE: DateTimeFormatter;
                    static readonly ISO_INSTANT: DateTimeFormatter;
                    static readonly BASIC_ISO_DATE: DateTimeFormatter;
                    static readonly RFC_1123_DATE_TIME: DateTimeFormatter;

                    static ofPattern(arg0: string): DateTimeFormatter;
                    static ofPattern(arg0: string, arg1: java.util.Locale): DateTimeFormatter;
                    static ofLocalizedDate(arg0: FormatStyle): DateTimeFormatter;
                    static ofLocalizedTime(arg0: FormatStyle): DateTimeFormatter;
                    static ofLocalizedDateTime(arg0: FormatStyle): DateTimeFormatter;
                    static ofLocalizedDateTime(arg0: FormatStyle, arg1: FormatStyle): DateTimeFormatter;
                    static parsedExcessDays(): java.time.temporal.TemporalQuery<java.time.Period>;
                    static parsedLeapSecond(): java.time.temporal.TemporalQuery<boolean>;

                    getLocale(): java.util.Locale;
                    withLocale(arg0: java.util.Locale): DateTimeFormatter;
                    localizedBy(arg0: java.util.Locale): DateTimeFormatter;
                    getDecimalStyle(): DecimalStyle;
                    withDecimalStyle(arg0: DecimalStyle): DateTimeFormatter;
                    getChronology(): java.time.chrono.Chronology;
                    withChronology(arg0: java.time.chrono.Chronology): DateTimeFormatter;
                    getZone(): java.time.ZoneId;
                    withZone(arg0: java.time.ZoneId): DateTimeFormatter;
                    getResolverStyle(): ResolverStyle;
                    withResolverStyle(arg0: ResolverStyle): DateTimeFormatter;
                    getResolverFields(): JavaSet<java.time.temporal.TemporalField>;
                    withResolverFields(...arg0: JavaVarArgs<java.time.temporal.TemporalField>): DateTimeFormatter;
                    withResolverFields(arg0: JavaSet<java.time.temporal.TemporalField>): DateTimeFormatter;
                    format(arg0: java.time.temporal.TemporalAccessor): string;
                    formatTo(arg0: java.time.temporal.TemporalAccessor, arg1: java.lang.Appendable): void;
                    parse(arg0: java.lang.CharSequence): java.time.temporal.TemporalAccessor;
                    parse(arg0: java.lang.CharSequence, arg1: java.text.ParsePosition): java.time.temporal.TemporalAccessor;
                    parse<T>(arg0: java.lang.CharSequence, arg1: java.time.temporal.TemporalQuery<T>): T;
                    parseBest(arg0: java.lang.CharSequence, ...arg1: JavaVarArgs<java.time.temporal.TemporalQuery<any>>): java.time.temporal.TemporalAccessor;
                    parseUnresolved(arg0: java.lang.CharSequence, arg1: java.text.ParsePosition): java.time.temporal.TemporalAccessor;
                    toFormat(): java.text.Format;
                    toFormat(arg0: java.time.temporal.TemporalQuery<any>): java.text.Format;

                }

                abstract class FormatStyle extends java.lang.Enum<FormatStyle> {
                    static readonly class: JavaClass<FormatStyle>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly FULL: FormatStyle;
                    static readonly LONG: FormatStyle;
                    static readonly MEDIUM: FormatStyle;
                    static readonly SHORT: FormatStyle;

                    static values(): JavaArray<FormatStyle>;
                    static valueOf(arg0: string): FormatStyle;

                }

                abstract class DecimalStyle extends java.lang.Object {
                    static readonly class: JavaClass<DecimalStyle>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly STANDARD: DecimalStyle;

                    static getAvailableLocales(): JavaSet<java.util.Locale>;
                    static ofDefaultLocale(): DecimalStyle;
                    static of(arg0: java.util.Locale): DecimalStyle;

                    getZeroDigit(): number;
                    withZeroDigit(arg0: char): DecimalStyle;
                    getPositiveSign(): number;
                    withPositiveSign(arg0: char): DecimalStyle;
                    getNegativeSign(): number;
                    withNegativeSign(arg0: char): DecimalStyle;
                    getDecimalSeparator(): number;
                    withDecimalSeparator(arg0: char): DecimalStyle;

                }

                export {
                    ResolverStyle,
                    TextStyle,
                    DateTimeFormatter,
                    FormatStyle,
                    DecimalStyle
                }

            }

            namespace temporal {

                interface ValueRange extends java.io.Serializable {}
                abstract class ValueRange extends java.lang.Object {
                    static readonly class: JavaClass<ValueRange>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: long, arg1: long): ValueRange;
                    static of(arg0: long, arg1: long, arg2: long): ValueRange;
                    static of(arg0: long, arg1: long, arg2: long, arg3: long): ValueRange;

                    isFixed(): boolean;
                    getMinimum(): number;
                    getLargestMinimum(): number;
                    getSmallestMaximum(): number;
                    getMaximum(): number;
                    isIntValue(): boolean;
                    isValidValue(arg0: long): boolean;
                    isValidIntValue(arg0: long): boolean;
                    checkValidValue(arg0: long, arg1: TemporalField): number;
                    checkValidIntValue(arg0: long, arg1: TemporalField): number;

                }

                abstract class TemporalAccessor extends java.lang.Interface {
                    static readonly class: JavaClass<TemporalAccessor>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TemporalAccessor {

                    isSupported(arg0: TemporalField): boolean;
                    range(arg0: TemporalField): ValueRange;
                    get(arg0: TemporalField): number;
                    getLong(arg0: TemporalField): number;
                    query<R>(arg0: TemporalQuery<R>): R;

                }

                interface ChronoUnit extends TemporalUnit {}
                abstract class ChronoUnit extends java.lang.Enum<ChronoUnit> {
                    static readonly class: JavaClass<ChronoUnit>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly NANOS: ChronoUnit;
                    static readonly MICROS: ChronoUnit;
                    static readonly MILLIS: ChronoUnit;
                    static readonly SECONDS: ChronoUnit;
                    static readonly MINUTES: ChronoUnit;
                    static readonly HOURS: ChronoUnit;
                    static readonly HALF_DAYS: ChronoUnit;
                    static readonly DAYS: ChronoUnit;
                    static readonly WEEKS: ChronoUnit;
                    static readonly MONTHS: ChronoUnit;
                    static readonly YEARS: ChronoUnit;
                    static readonly DECADES: ChronoUnit;
                    static readonly CENTURIES: ChronoUnit;
                    static readonly MILLENNIA: ChronoUnit;
                    static readonly ERAS: ChronoUnit;
                    static readonly FOREVER: ChronoUnit;

                    static values(): JavaArray<ChronoUnit>;
                    static valueOf(arg0: string): ChronoUnit;

                    getDuration(): java.time.Duration;
                    isDurationEstimated(): boolean;
                    isDateBased(): boolean;
                    isTimeBased(): boolean;
                    isSupportedBy(arg0: Temporal): boolean;
                    addTo<R extends Temporal>(arg0: R, arg1: long): R;
                    between(arg0: Temporal, arg1: Temporal): number;

                }

                abstract class TemporalQuery<R> extends java.lang.Interface {
                    static readonly class: JavaClass<TemporalQuery<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TemporalQuery<R> {

                    queryFrom(arg0: TemporalAccessor): R;

                }

                abstract class TemporalField extends java.lang.Interface {
                    static readonly class: JavaClass<TemporalField>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TemporalField {

                    getDisplayName(arg0: java.util.Locale): string;
                    getBaseUnit(): TemporalUnit;
                    getRangeUnit(): TemporalUnit;
                    range(): ValueRange;
                    isDateBased(): boolean;
                    isTimeBased(): boolean;
                    isSupportedBy(arg0: TemporalAccessor): boolean;
                    rangeRefinedBy(arg0: TemporalAccessor): ValueRange;
                    getFrom(arg0: TemporalAccessor): number;
                    adjustInto<R extends Temporal>(arg0: R, arg1: long): R;
                    resolve(arg0: JavaMap<TemporalField, long>, arg1: TemporalAccessor, arg2: java.time.format.ResolverStyle): TemporalAccessor;

                }

                abstract class TemporalUnit extends java.lang.Interface {
                    static readonly class: JavaClass<TemporalUnit>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TemporalUnit {

                    getDuration(): java.time.Duration;
                    isDurationEstimated(): boolean;
                    isDateBased(): boolean;
                    isTimeBased(): boolean;
                    isSupportedBy(arg0: Temporal): boolean;
                    addTo<R extends Temporal>(arg0: R, arg1: long): R;
                    between(arg0: Temporal, arg1: Temporal): number;

                }

                abstract class TemporalAmount extends java.lang.Interface {
                    static readonly class: JavaClass<TemporalAmount>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TemporalAmount {

                    get(arg0: TemporalUnit): number;
                    getUnits(): JavaList<TemporalUnit>;
                    addTo(arg0: Temporal): Temporal;
                    subtractFrom(arg0: Temporal): Temporal;

                }

                abstract class Temporal extends java.lang.Interface {
                    static readonly class: JavaClass<Temporal>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Temporal extends TemporalAccessor {

                    isSupported(arg0: TemporalUnit): boolean;
                    isSupported(arg0: TemporalField): boolean;
                    with(arg0: TemporalAdjuster): Temporal;
                    with(arg0: TemporalField, arg1: long): Temporal;
                    plus(arg0: TemporalAmount): Temporal;
                    plus(arg0: long, arg1: TemporalUnit): Temporal;
                    minus(arg0: TemporalAmount): Temporal;
                    minus(arg0: long, arg1: TemporalUnit): Temporal;
                    until(arg0: Temporal, arg1: TemporalUnit): number;

                }

                abstract class TemporalAdjuster extends java.lang.Interface {
                    static readonly class: JavaClass<TemporalAdjuster>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TemporalAdjuster {

                    adjustInto(arg0: Temporal): Temporal;

                }

                interface ChronoField extends TemporalField {}
                abstract class ChronoField extends java.lang.Enum<ChronoField> {
                    static readonly class: JavaClass<ChronoField>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly NANO_OF_SECOND: ChronoField;
                    static readonly NANO_OF_DAY: ChronoField;
                    static readonly MICRO_OF_SECOND: ChronoField;
                    static readonly MICRO_OF_DAY: ChronoField;
                    static readonly MILLI_OF_SECOND: ChronoField;
                    static readonly MILLI_OF_DAY: ChronoField;
                    static readonly SECOND_OF_MINUTE: ChronoField;
                    static readonly SECOND_OF_DAY: ChronoField;
                    static readonly MINUTE_OF_HOUR: ChronoField;
                    static readonly MINUTE_OF_DAY: ChronoField;
                    static readonly HOUR_OF_AMPM: ChronoField;
                    static readonly CLOCK_HOUR_OF_AMPM: ChronoField;
                    static readonly HOUR_OF_DAY: ChronoField;
                    static readonly CLOCK_HOUR_OF_DAY: ChronoField;
                    static readonly AMPM_OF_DAY: ChronoField;
                    static readonly DAY_OF_WEEK: ChronoField;
                    static readonly ALIGNED_DAY_OF_WEEK_IN_MONTH: ChronoField;
                    static readonly ALIGNED_DAY_OF_WEEK_IN_YEAR: ChronoField;
                    static readonly DAY_OF_MONTH: ChronoField;
                    static readonly DAY_OF_YEAR: ChronoField;
                    static readonly EPOCH_DAY: ChronoField;
                    static readonly ALIGNED_WEEK_OF_MONTH: ChronoField;
                    static readonly ALIGNED_WEEK_OF_YEAR: ChronoField;
                    static readonly MONTH_OF_YEAR: ChronoField;
                    static readonly PROLEPTIC_MONTH: ChronoField;
                    static readonly YEAR_OF_ERA: ChronoField;
                    static readonly YEAR: ChronoField;
                    static readonly ERA: ChronoField;
                    static readonly INSTANT_SECONDS: ChronoField;
                    static readonly OFFSET_SECONDS: ChronoField;

                    static values(): JavaArray<ChronoField>;
                    static valueOf(arg0: string): ChronoField;

                    getDisplayName(arg0: java.util.Locale): string;
                    getBaseUnit(): TemporalUnit;
                    getRangeUnit(): TemporalUnit;
                    range(): ValueRange;
                    isDateBased(): boolean;
                    isTimeBased(): boolean;
                    checkValidValue(arg0: long): number;
                    checkValidIntValue(arg0: long): number;
                    isSupportedBy(arg0: TemporalAccessor): boolean;
                    rangeRefinedBy(arg0: TemporalAccessor): ValueRange;
                    getFrom(arg0: TemporalAccessor): number;
                    adjustInto<R extends Temporal>(arg0: R, arg1: long): R;

                }

                export {
                    ValueRange,
                    TemporalAccessor,
                    ChronoUnit,
                    TemporalQuery,
                    TemporalField,
                    TemporalUnit,
                    TemporalAmount,
                    Temporal,
                    TemporalAdjuster,
                    ChronoField
                }

            }

            namespace zone {

                interface ZoneRules extends java.io.Serializable {}
                abstract class ZoneRules extends java.lang.Object {
                    static readonly class: JavaClass<ZoneRules>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: java.time.ZoneOffset, arg1: java.time.ZoneOffset, arg2: JavaList<ZoneOffsetTransition>, arg3: JavaList<ZoneOffsetTransition>, arg4: JavaList<ZoneOffsetTransitionRule>): ZoneRules;
                    static of(arg0: java.time.ZoneOffset): ZoneRules;

                    isFixedOffset(): boolean;
                    getOffset(arg0: java.time.Instant): java.time.ZoneOffset;
                    getOffset(arg0: java.time.LocalDateTime): java.time.ZoneOffset;
                    getValidOffsets(arg0: java.time.LocalDateTime): JavaList<java.time.ZoneOffset>;
                    getTransition(arg0: java.time.LocalDateTime): ZoneOffsetTransition;
                    getStandardOffset(arg0: java.time.Instant): java.time.ZoneOffset;
                    getDaylightSavings(arg0: java.time.Instant): java.time.Duration;
                    isDaylightSavings(arg0: java.time.Instant): boolean;
                    isValidOffset(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset): boolean;
                    nextTransition(arg0: java.time.Instant): ZoneOffsetTransition;
                    previousTransition(arg0: java.time.Instant): ZoneOffsetTransition;
                    getTransitions(): JavaList<ZoneOffsetTransition>;
                    getTransitionRules(): JavaList<ZoneOffsetTransitionRule>;

                }

                interface ZoneOffsetTransition extends java.lang.Comparable<ZoneOffsetTransition>, java.io.Serializable {}
                abstract class ZoneOffsetTransition extends java.lang.Object {
                    static readonly class: JavaClass<ZoneOffsetTransition>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset, arg2: java.time.ZoneOffset): ZoneOffsetTransition;

                    getInstant(): java.time.Instant;
                    toEpochSecond(): number;
                    getDateTimeBefore(): java.time.LocalDateTime;
                    getDateTimeAfter(): java.time.LocalDateTime;
                    getOffsetBefore(): java.time.ZoneOffset;
                    getOffsetAfter(): java.time.ZoneOffset;
                    getDuration(): java.time.Duration;
                    isGap(): boolean;
                    isOverlap(): boolean;
                    isValidOffset(arg0: java.time.ZoneOffset): boolean;
                    compareTo(arg0: ZoneOffsetTransition): number;

                }

                interface ZoneOffsetTransitionRule extends java.io.Serializable {}
                abstract class ZoneOffsetTransitionRule extends java.lang.Object {
                    static readonly class: JavaClass<ZoneOffsetTransitionRule>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: java.time.Month, arg1: int, arg2: java.time.DayOfWeek, arg3: java.time.LocalTime, arg4: boolean, arg5: ZoneOffsetTransitionRule$TimeDefinition, arg6: java.time.ZoneOffset, arg7: java.time.ZoneOffset, arg8: java.time.ZoneOffset): ZoneOffsetTransitionRule;

                    getMonth(): java.time.Month;
                    getDayOfMonthIndicator(): number;
                    getDayOfWeek(): java.time.DayOfWeek;
                    getLocalTime(): java.time.LocalTime;
                    isMidnightEndOfDay(): boolean;
                    getTimeDefinition(): ZoneOffsetTransitionRule$TimeDefinition;
                    getStandardOffset(): java.time.ZoneOffset;
                    getOffsetBefore(): java.time.ZoneOffset;
                    getOffsetAfter(): java.time.ZoneOffset;
                    createTransition(arg0: int): ZoneOffsetTransition;

                }

                abstract class ZoneOffsetTransitionRule$TimeDefinition extends java.lang.Enum<ZoneOffsetTransitionRule$TimeDefinition> {
                    static readonly class: JavaClass<ZoneOffsetTransitionRule$TimeDefinition>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly UTC: ZoneOffsetTransitionRule$TimeDefinition;
                    static readonly WALL: ZoneOffsetTransitionRule$TimeDefinition;
                    static readonly STANDARD: ZoneOffsetTransitionRule$TimeDefinition;

                    static values(): JavaArray<ZoneOffsetTransitionRule$TimeDefinition>;
                    static valueOf(arg0: string): ZoneOffsetTransitionRule$TimeDefinition;

                    createDateTime(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset, arg2: java.time.ZoneOffset): java.time.LocalDateTime;

                }

                export {
                    ZoneRules,
                    ZoneOffsetTransition,
                    ZoneOffsetTransitionRule,
                    ZoneOffsetTransitionRule$TimeDefinition
                }

            }

        }

        namespace util {

            abstract class Iterator<E> extends java.lang.Interface {
                static readonly class: JavaClass<Iterator<any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Iterator<E> {

                hasNext(): boolean;
                next(): E;
                remove(): void;
                forEachRemaining(arg0: MethodWrapper<E>): void;

            }

            abstract class Optional<T> extends java.lang.Object {
                static readonly class: JavaClass<Optional<any>>;
                /** @deprecated */ static prototype: undefined;

                static empty<T>(): Optional<T>;
                static of<T>(arg0: T): Optional<T>;
                static ofNullable<T>(arg0: T): Optional<T>;

                get(): T;
                isPresent(): boolean;
                isEmpty(): boolean;
                ifPresent(arg0: MethodWrapper<T>): void;
                ifPresentOrElse(arg0: MethodWrapper<T>, arg1: MethodWrapper): void;
                filter(arg0: MethodWrapper<T, any, boolean>): Optional<T>;
                map<U>(arg0: MethodWrapper<T, any, U>): Optional<U>;
                flatMap<U>(arg0: MethodWrapper<T, any, Optional<U>>): Optional<U>;
                or(arg0: MethodWrapper<any, any, Optional<T>>): Optional<T>;
                stream(): java.util.stream.Stream<T>;
                orElse(arg0: T): T;
                orElseGet(arg0: MethodWrapper<any, any, T>): T;
                orElseThrow(): T;
                orElseThrow<X extends java.lang.Throwable>(arg0: MethodWrapper<any, any, X>): T;

            }

            interface ArrayList<E> extends JavaList<E>, RandomAccess, java.lang.Cloneable, java.io.Serializable {}
            class ArrayList<E> extends AbstractList<E> {
                static readonly class: JavaClass<ArrayList<any>>;
                /** @deprecated */ static prototype: undefined;

                constructor <E>(arg0: int);
                constructor <E>();
                constructor <E>(arg0: JavaCollection<E>);

                trimToSize(): void;
                ensureCapacity(arg0: int): void;
                size(): number;
                isEmpty(): boolean;
                contains(arg0: any): boolean;
                indexOf(arg0: any): number;
                lastIndexOf(arg0: any): number;
                clone(): any;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;
                toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
                get(arg0: int): E;
                set(arg0: int, arg1: E): E;
                add(arg0: E): boolean;
                add(arg0: int, arg1: E): void;
                remove(arg0: int): E;
                remove(arg0: any): boolean;
                clear(): void;
                addAll(arg0: JavaCollection<E>): boolean;
                addAll(arg0: int, arg1: JavaCollection<E>): boolean;
                removeAll(arg0: JavaCollection<any>): boolean;
                retainAll(arg0: JavaCollection<any>): boolean;
                listIterator(arg0: int): ListIterator<E>;
                listIterator(): ListIterator<E>;
                iterator(): Iterator<E>;
                subList(arg0: int, arg1: int): JavaList<E>;
                forEach(arg0: MethodWrapper<E>): void;
                spliterator(): Spliterator<E>;
                removeIf(arg0: MethodWrapper<E, any, boolean>): boolean;
                replaceAll(arg0: java.util.function.UnaryOperator<E>): void;
                sort(arg0: MethodWrapper<E, E, int>): void;

            }

            interface SplittableRandom extends java.util.random.RandomGenerator, java.util.random.RandomGenerator$SplittableGenerator {}
            class SplittableRandom extends java.lang.Object {
                static readonly class: JavaClass<SplittableRandom>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: long);
                constructor ();

                split(): SplittableRandom;
                split(arg0: java.util.random.RandomGenerator$SplittableGenerator): SplittableRandom;
                nextInt(): number;
                nextInt(arg0: int): number;
                nextInt(arg0: int, arg1: int): number;
                nextLong(): number;
                nextLong(arg0: long): number;
                nextLong(arg0: long, arg1: long): number;
                nextBytes(arg0: byte[]): void;
                splits(): java.util.stream.Stream<java.util.random.RandomGenerator$SplittableGenerator>;
                splits(arg0: long): java.util.stream.Stream<java.util.random.RandomGenerator$SplittableGenerator>;
                splits(arg0: java.util.random.RandomGenerator$SplittableGenerator): java.util.stream.Stream<java.util.random.RandomGenerator$SplittableGenerator>;
                splits(arg0: long, arg1: java.util.random.RandomGenerator$SplittableGenerator): java.util.stream.Stream<java.util.random.RandomGenerator$SplittableGenerator>;
                ints(arg0: long): java.util.stream.IntStream;
                ints(): java.util.stream.IntStream;
                ints(arg0: long, arg1: int, arg2: int): java.util.stream.IntStream;
                ints(arg0: int, arg1: int): java.util.stream.IntStream;
                longs(arg0: long): java.util.stream.LongStream;
                longs(): java.util.stream.LongStream;
                longs(arg0: long, arg1: long, arg2: long): java.util.stream.LongStream;
                longs(arg0: long, arg1: long): java.util.stream.LongStream;
                doubles(arg0: long): java.util.stream.DoubleStream;
                doubles(): java.util.stream.DoubleStream;
                doubles(arg0: long, arg1: double, arg2: double): java.util.stream.DoubleStream;
                doubles(arg0: double, arg1: double): java.util.stream.DoubleStream;

            }

            interface Locale extends java.lang.Cloneable, java.io.Serializable {}
            class Locale extends java.lang.Object {
                static readonly class: JavaClass<Locale>;
                /** @deprecated */ static prototype: undefined;

                static readonly ENGLISH: Locale;
                static readonly FRENCH: Locale;
                static readonly GERMAN: Locale;
                static readonly ITALIAN: Locale;
                static readonly JAPANESE: Locale;
                static readonly KOREAN: Locale;
                static readonly CHINESE: Locale;
                static readonly SIMPLIFIED_CHINESE: Locale;
                static readonly TRADITIONAL_CHINESE: Locale;
                static readonly FRANCE: Locale;
                static readonly GERMANY: Locale;
                static readonly ITALY: Locale;
                static readonly JAPAN: Locale;
                static readonly KOREA: Locale;
                static readonly UK: Locale;
                static readonly US: Locale;
                static readonly CANADA: Locale;
                static readonly CANADA_FRENCH: Locale;
                static readonly ROOT: Locale;
                static readonly CHINA: Locale;
                static readonly PRC: Locale;
                static readonly TAIWAN: Locale;
                static readonly PRIVATE_USE_EXTENSION: number;
                static readonly UNICODE_LOCALE_EXTENSION: number;

                static getDefault(): Locale;
                static getDefault(arg0: Locale$Category): Locale;
                static setDefault(arg0: Locale): void;
                static setDefault(arg0: Locale$Category, arg1: Locale): void;
                static getAvailableLocales(): JavaArray<Locale>;
                static getISOCountries(): JavaArray<string>;
                static getISOCountries(arg0: Locale$IsoCountryCode): JavaSet<string>;
                static getISOLanguages(): JavaArray<string>;
                static forLanguageTag(arg0: string): Locale;
                static filter(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<Locale>, arg2: Locale$FilteringMode): JavaList<Locale>;
                static filter(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<Locale>): JavaList<Locale>;
                static filterTags(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<string>, arg2: Locale$FilteringMode): JavaList<string>;
                static filterTags(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<string>): JavaList<string>;
                static lookup(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<Locale>): Locale;
                static lookupTag(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<string>): string;

                constructor (arg0: string, arg1: string, arg2: string);
                constructor (arg0: string, arg1: string);
                constructor (arg0: string);

                getLanguage(): string;
                getScript(): string;
                getCountry(): string;
                getVariant(): string;
                hasExtensions(): boolean;
                stripExtensions(): Locale;
                getExtension(arg0: char): string;
                getExtensionKeys(): JavaSet<number>;
                getUnicodeLocaleAttributes(): JavaSet<string>;
                getUnicodeLocaleType(arg0: string): string;
                getUnicodeLocaleKeys(): JavaSet<string>;
                toLanguageTag(): string;
                getISO3Language(): string;
                getISO3Country(): string;
                getDisplayLanguage(): string;
                getDisplayLanguage(arg0: Locale): string;
                getDisplayScript(): string;
                getDisplayScript(arg0: Locale): string;
                getDisplayCountry(): string;
                getDisplayCountry(arg0: Locale): string;
                getDisplayVariant(): string;
                getDisplayVariant(arg0: Locale): string;
                getDisplayName(): string;
                getDisplayName(arg0: Locale): string;
                clone(): any;

            }

            interface HashSet<E> extends java.lang.Cloneable, JavaSet<E>, java.io.Serializable {}
            class HashSet<E> extends AbstractSet<E> {
                static readonly class: JavaClass<HashSet<any>>;
                /** @deprecated */ static prototype: undefined;

                constructor <E>();
                constructor <E>(arg0: JavaCollection<E>);
                constructor <E>(arg0: int, arg1: float);
                constructor <E>(arg0: int);

                iterator(): Iterator<E>;
                size(): number;
                isEmpty(): boolean;
                contains(arg0: any): boolean;
                add(arg0: E): boolean;
                remove(arg0: any): boolean;
                clear(): void;
                clone(): any;
                spliterator(): Spliterator<E>;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;
                toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;

            }

            interface HashMap<K, V> extends JavaMap<K, V>, java.lang.Cloneable, java.io.Serializable {}
            class HashMap<K, V> extends AbstractMap<K, V> {
                static readonly class: JavaClass<HashMap<any, any>>;
                /** @deprecated */ static prototype: undefined;

                constructor <K, V>(arg0: int, arg1: float);
                constructor <K, V>(arg0: int);
                constructor <K, V>();
                constructor <K, V>(arg0: JavaMap<K, V>);

                size(): number;
                isEmpty(): boolean;
                get(arg0: any): V;
                containsKey(arg0: any): boolean;
                put(arg0: K, arg1: V): V;
                putAll(arg0: JavaMap<K, V>): void;
                remove(arg0: any): V;
                clear(): void;
                containsValue(arg0: any): boolean;
                keySet(): JavaSet<K>;
                values(): JavaCollection<V>;
                entrySet(): JavaSet<Map$Entry<K, V>>;
                getOrDefault(arg0: any, arg1: V): V;
                putIfAbsent(arg0: K, arg1: V): V;
                remove(arg0: any, arg1: any): boolean;
                replace(arg0: K, arg1: V, arg2: V): boolean;
                replace(arg0: K, arg1: V): V;
                computeIfAbsent(arg0: K, arg1: MethodWrapper<K, any, V>): V;
                computeIfPresent(arg0: K, arg1: MethodWrapper<K, V, V>): V;
                compute(arg0: K, arg1: MethodWrapper<K, V, V>): V;
                merge(arg0: K, arg1: V, arg2: MethodWrapper<V, V, V>): V;
                forEach(arg0: MethodWrapper<K, V>): void;
                replaceAll(arg0: MethodWrapper<K, V, V>): void;
                clone(): any;

            }

            abstract class Enumeration<E> extends java.lang.Interface {
                static readonly class: JavaClass<Enumeration<any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Enumeration<E> {

                hasMoreElements(): boolean;
                nextElement(): E;
                asIterator(): Iterator<E>;

            }

            class Locale$LanguageRange extends java.lang.Object {
                static readonly class: JavaClass<Locale$LanguageRange>;
                /** @deprecated */ static prototype: undefined;

                static readonly MAX_WEIGHT: number;
                static readonly MIN_WEIGHT: number;

                static parse(arg0: string): JavaList<Locale$LanguageRange>;
                static parse(arg0: string, arg1: JavaMap<string, JavaList<string>>): JavaList<Locale$LanguageRange>;
                static mapEquivalents(arg0: JavaList<Locale$LanguageRange>, arg1: JavaMap<string, JavaList<string>>): JavaList<Locale$LanguageRange>;

                constructor (arg0: string);
                constructor (arg0: string, arg1: double);

                getRange(): string;
                getWeight(): number;

            }

            abstract class Spliterator$OfInt extends java.lang.Interface {
                static readonly class: JavaClass<Spliterator$OfInt>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Spliterator$OfInt extends Spliterator$OfPrimitive<java.lang.Integer, java.util.function.IntConsumer, Spliterator$OfInt> {

                trySplit(): Spliterator$OfInt;
                tryAdvance(arg0: java.util.function.IntConsumer): boolean;
                forEachRemaining(arg0: java.util.function.IntConsumer): void;
                tryAdvance(arg0: MethodWrapper<int>): boolean;
                forEachRemaining(arg0: MethodWrapper<int>): void;

            }

            abstract class RandomAccess extends java.lang.Interface {
                static readonly class: JavaClass<RandomAccess>;
                /** @deprecated */ static prototype: undefined;
            }
            interface RandomAccess {}

            abstract class ListIterator<E> extends java.lang.Interface {
                static readonly class: JavaClass<ListIterator<any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface ListIterator<E> extends Iterator<E> {

                hasNext(): boolean;
                next(): E;
                hasPrevious(): boolean;
                previous(): E;
                nextIndex(): number;
                previousIndex(): number;
                remove(): void;
                set(arg0: E): void;
                add(arg0: E): void;

            }

            interface LongSummaryStatistics extends java.util.function.IntConsumer, java.util.function.LongConsumer {}
            class LongSummaryStatistics extends java.lang.Object {
                static readonly class: JavaClass<LongSummaryStatistics>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: long, arg1: long, arg2: long, arg3: long);

                accept(arg0: int): void;
                accept(arg0: long): void;
                combine(arg0: LongSummaryStatistics): void;
                getCount(): number;
                getSum(): number;
                getMin(): number;
                getMax(): number;
                getAverage(): number;

            }

            interface AbstractSet<E> extends JavaSet<E> {}
            abstract class AbstractSet<E> extends AbstractCollection<E> {
                static readonly class: JavaClass<AbstractSet<any>>;
                /** @deprecated */ static prototype: undefined;

                removeAll(arg0: JavaCollection<any>): boolean;

            }

            abstract class Locale$FilteringMode extends java.lang.Enum<Locale$FilteringMode> {
                static readonly class: JavaClass<Locale$FilteringMode>;
                /** @deprecated */ static prototype: undefined;

                static readonly AUTOSELECT_FILTERING: Locale$FilteringMode;
                static readonly EXTENDED_FILTERING: Locale$FilteringMode;
                static readonly IGNORE_EXTENDED_RANGES: Locale$FilteringMode;
                static readonly MAP_EXTENDED_RANGES: Locale$FilteringMode;
                static readonly REJECT_EXTENDED_RANGES: Locale$FilteringMode;

                static values(): JavaArray<Locale$FilteringMode>;
                static valueOf(arg0: string): Locale$FilteringMode;

            }

            interface IntSummaryStatistics extends java.util.function.IntConsumer {}
            class IntSummaryStatistics extends java.lang.Object {
                static readonly class: JavaClass<IntSummaryStatistics>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: long, arg1: int, arg2: int, arg3: long);

                accept(arg0: int): void;
                combine(arg0: IntSummaryStatistics): void;
                getCount(): number;
                getSum(): number;
                getMin(): number;
                getMax(): number;
                getAverage(): number;

            }

            abstract class PrimitiveIterator$OfInt extends java.lang.Interface {
                static readonly class: JavaClass<PrimitiveIterator$OfInt>;
                /** @deprecated */ static prototype: undefined;
            }
            interface PrimitiveIterator$OfInt extends PrimitiveIterator<java.lang.Integer, java.util.function.IntConsumer> {

                nextInt(): number;
                forEachRemaining(arg0: java.util.function.IntConsumer): void;
                next(): number;
                forEachRemaining(arg0: MethodWrapper<int>): void;

            }

            abstract class Spliterator$OfDouble extends java.lang.Interface {
                static readonly class: JavaClass<Spliterator$OfDouble>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Spliterator$OfDouble extends Spliterator$OfPrimitive<java.lang.Double, java.util.function.DoubleConsumer, Spliterator$OfDouble> {

                trySplit(): Spliterator$OfDouble;
                tryAdvance(arg0: java.util.function.DoubleConsumer): boolean;
                forEachRemaining(arg0: java.util.function.DoubleConsumer): void;
                tryAdvance(arg0: MethodWrapper<double>): boolean;
                forEachRemaining(arg0: MethodWrapper<double>): void;

            }

            abstract class Map$Entry<K, V> extends java.lang.Interface {
                static readonly class: JavaClass<Map$Entry<any, any>>;
                /** @deprecated */ static prototype: undefined;

                static comparingByKey<K extends java.lang.Comparable<K>, V>(): MethodWrapper<Map$Entry<K, V>, Map$Entry<K, V>, int>;
                static comparingByValue<K, V extends java.lang.Comparable<V>>(): MethodWrapper<Map$Entry<K, V>, Map$Entry<K, V>, int>;
                static comparingByKey<K, V>(arg0: MethodWrapper<K, K, int>): MethodWrapper<Map$Entry<K, V>, Map$Entry<K, V>, int>;
                static comparingByValue<K, V>(arg0: MethodWrapper<V, V, int>): MethodWrapper<Map$Entry<K, V>, Map$Entry<K, V>, int>;
                static copyOf<K, V>(arg0: Map$Entry<K, V>): Map$Entry<K, V>;

            }
            interface Map$Entry<K, V> {

                getKey(): K;
                getValue(): V;
                setValue(arg0: V): V;

            }

            abstract class PrimitiveIterator$OfDouble extends java.lang.Interface {
                static readonly class: JavaClass<PrimitiveIterator$OfDouble>;
                /** @deprecated */ static prototype: undefined;
            }
            interface PrimitiveIterator$OfDouble extends PrimitiveIterator<java.lang.Double, java.util.function.DoubleConsumer> {

                nextDouble(): number;
                forEachRemaining(arg0: java.util.function.DoubleConsumer): void;
                next(): number;
                forEachRemaining(arg0: MethodWrapper<double>): void;

            }

            abstract class Spliterator$OfLong extends java.lang.Interface {
                static readonly class: JavaClass<Spliterator$OfLong>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Spliterator$OfLong extends Spliterator$OfPrimitive<java.lang.Long, java.util.function.LongConsumer, Spliterator$OfLong> {

                trySplit(): Spliterator$OfLong;
                tryAdvance(arg0: java.util.function.LongConsumer): boolean;
                forEachRemaining(arg0: java.util.function.LongConsumer): void;
                tryAdvance(arg0: MethodWrapper<long>): boolean;
                forEachRemaining(arg0: MethodWrapper<long>): void;

            }

            interface AbstractCollection<E> extends JavaCollection<E> {}
            abstract class AbstractCollection<E> extends java.lang.Object {
                static readonly class: JavaClass<AbstractCollection<any>>;
                /** @deprecated */ static prototype: undefined;

                iterator(): Iterator<E>;
                size(): number;
                isEmpty(): boolean;
                contains(arg0: any): boolean;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;
                toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
                add(arg0: E): boolean;
                remove(arg0: any): boolean;
                containsAll(arg0: JavaCollection<any>): boolean;
                addAll(arg0: JavaCollection<E>): boolean;
                removeAll(arg0: JavaCollection<any>): boolean;
                retainAll(arg0: JavaCollection<any>): boolean;
                clear(): void;

            }

            abstract class Spliterator<T> extends java.lang.Interface {
                static readonly class: JavaClass<Spliterator<any>>;
                /** @deprecated */ static prototype: undefined;

                static readonly ORDERED: number;
                static readonly DISTINCT: number;
                static readonly SORTED: number;
                static readonly SIZED: number;
                static readonly NONNULL: number;
                static readonly IMMUTABLE: number;
                static readonly CONCURRENT: number;
                static readonly SUBSIZED: number;
            }
            interface Spliterator<T> {

                tryAdvance(arg0: MethodWrapper<T>): boolean;
                forEachRemaining(arg0: MethodWrapper<T>): void;
                trySplit(): Spliterator<T>;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                hasCharacteristics(arg0: int): boolean;
                getComparator(): MethodWrapper<T, T, int>;

            }

            abstract class OptionalLong extends java.lang.Object {
                static readonly class: JavaClass<OptionalLong>;
                /** @deprecated */ static prototype: undefined;

                static empty(): OptionalLong;
                static of(arg0: long): OptionalLong;

                getAsLong(): number;
                isPresent(): boolean;
                isEmpty(): boolean;
                ifPresent(arg0: java.util.function.LongConsumer): void;
                ifPresentOrElse(arg0: java.util.function.LongConsumer, arg1: MethodWrapper): void;
                stream(): java.util.stream.LongStream;
                orElse(arg0: long): number;
                orElseGet(arg0: java.util.function.LongSupplier): number;
                orElseThrow(): number;
                orElseThrow<X extends java.lang.Throwable>(arg0: MethodWrapper<any, any, X>): number;

            }

            abstract class PrimitiveIterator$OfLong extends java.lang.Interface {
                static readonly class: JavaClass<PrimitiveIterator$OfLong>;
                /** @deprecated */ static prototype: undefined;
            }
            interface PrimitiveIterator$OfLong extends PrimitiveIterator<java.lang.Long, java.util.function.LongConsumer> {

                nextLong(): number;
                forEachRemaining(arg0: java.util.function.LongConsumer): void;
                next(): number;
                forEachRemaining(arg0: MethodWrapper<long>): void;

            }

            interface DoubleSummaryStatistics extends java.util.function.DoubleConsumer {}
            class DoubleSummaryStatistics extends java.lang.Object {
                static readonly class: JavaClass<DoubleSummaryStatistics>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: long, arg1: double, arg2: double, arg3: double);

                accept(arg0: double): void;
                combine(arg0: DoubleSummaryStatistics): void;
                getCount(): number;
                getSum(): number;
                getMin(): number;
                getMax(): number;
                getAverage(): number;

            }

            abstract class OptionalDouble extends java.lang.Object {
                static readonly class: JavaClass<OptionalDouble>;
                /** @deprecated */ static prototype: undefined;

                static empty(): OptionalDouble;
                static of(arg0: double): OptionalDouble;

                getAsDouble(): number;
                isPresent(): boolean;
                isEmpty(): boolean;
                ifPresent(arg0: java.util.function.DoubleConsumer): void;
                ifPresentOrElse(arg0: java.util.function.DoubleConsumer, arg1: MethodWrapper): void;
                stream(): java.util.stream.DoubleStream;
                orElse(arg0: double): number;
                orElseGet(arg0: java.util.function.DoubleSupplier): number;
                orElseThrow(): number;
                orElseThrow<X extends java.lang.Throwable>(arg0: MethodWrapper<any, any, X>): number;

            }

            abstract class Locale$IsoCountryCode extends java.lang.Enum<Locale$IsoCountryCode> {
                static readonly class: JavaClass<Locale$IsoCountryCode>;
                /** @deprecated */ static prototype: undefined;

                static readonly PART1_ALPHA2: Locale$IsoCountryCode;
                static readonly PART1_ALPHA3: Locale$IsoCountryCode;
                static readonly PART3: Locale$IsoCountryCode;

                static values(): JavaArray<Locale$IsoCountryCode>;
                static valueOf(arg0: string): Locale$IsoCountryCode;

            }

            interface AbstractMap<K, V> extends JavaMap<K, V> {}
            abstract class AbstractMap<K, V> extends java.lang.Object {
                static readonly class: JavaClass<AbstractMap<any, any>>;
                /** @deprecated */ static prototype: undefined;

                size(): number;
                isEmpty(): boolean;
                containsValue(arg0: any): boolean;
                containsKey(arg0: any): boolean;
                get(arg0: any): V;
                put(arg0: K, arg1: V): V;
                remove(arg0: any): V;
                remove(arg0: any, arg1: any): boolean;
                putAll(arg0: JavaMap<K, V>): void;
                clear(): void;
                keySet(): JavaSet<K>;
                values(): JavaCollection<V>;
                entrySet(): JavaSet<Map$Entry<K, V>>;

            }

            interface AbstractList<E> extends JavaList<E> {}
            abstract class AbstractList<E> extends AbstractCollection<E> {
                static readonly class: JavaClass<AbstractList<any>>;
                /** @deprecated */ static prototype: undefined;

                add(arg0: E): boolean;
                get(arg0: int): E;
                set(arg0: int, arg1: E): E;
                add(arg0: int, arg1: E): void;
                remove(arg0: int): E;
                remove(arg0: any): boolean;
                indexOf(arg0: any): number;
                lastIndexOf(arg0: any): number;
                clear(): void;
                addAll(arg0: int, arg1: JavaCollection<E>): boolean;
                addAll(arg0: JavaCollection<E>): boolean;
                iterator(): Iterator<E>;
                listIterator(): ListIterator<E>;
                listIterator(arg0: int): ListIterator<E>;
                subList(arg0: int, arg1: int): JavaList<E>;

            }

            abstract class Locale$Category extends java.lang.Enum<Locale$Category> {
                static readonly class: JavaClass<Locale$Category>;
                /** @deprecated */ static prototype: undefined;

                static readonly DISPLAY: Locale$Category;
                static readonly FORMAT: Locale$Category;

                static values(): JavaArray<Locale$Category>;
                static valueOf(arg0: string): Locale$Category;

            }

            abstract class OptionalInt extends java.lang.Object {
                static readonly class: JavaClass<OptionalInt>;
                /** @deprecated */ static prototype: undefined;

                static empty(): OptionalInt;
                static of(arg0: int): OptionalInt;

                getAsInt(): number;
                isPresent(): boolean;
                isEmpty(): boolean;
                ifPresent(arg0: java.util.function.IntConsumer): void;
                ifPresentOrElse(arg0: java.util.function.IntConsumer, arg1: MethodWrapper): void;
                stream(): java.util.stream.IntStream;
                orElse(arg0: int): number;
                orElseGet(arg0: java.util.function.IntSupplier): number;
                orElseThrow(): number;
                orElseThrow<X extends java.lang.Throwable>(arg0: MethodWrapper<any, any, X>): number;

            }

            abstract class PrimitiveIterator<T, T_CONS> extends java.lang.Interface {
                static readonly class: JavaClass<PrimitiveIterator<any, any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface PrimitiveIterator<T, T_CONS> extends Iterator<T> {

                forEachRemaining(arg0: T_CONS): void;
                forEachRemaining(arg0: MethodWrapper<E>): void;

            }

            abstract class Spliterator$OfPrimitive<T, T_CONS, T_SPLITR extends Spliterator$OfPrimitive<T, T_CONS, T_SPLITR>> extends java.lang.Interface {
                static readonly class: JavaClass<Spliterator$OfPrimitive<any, any, any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Spliterator$OfPrimitive<T, T_CONS, T_SPLITR extends Spliterator$OfPrimitive<T, T_CONS, T_SPLITR>> extends Spliterator<T> {

                trySplit(): T_SPLITR;
                tryAdvance(arg0: T_CONS): boolean;
                tryAdvance(arg0: MethodWrapper<T>): boolean;
                forEachRemaining(arg0: T_CONS): void;
                forEachRemaining(arg0: MethodWrapper<T>): void;

            }

            abstract class SortedMap<K, V> extends java.lang.Interface {
                static readonly class: JavaClass<SortedMap<any, any>>;
                /** @deprecated */ static prototype: undefined;
            }
            interface SortedMap<K, V> extends JavaMap<K, V> {

                comparator(): MethodWrapper<K, K, int>;
                subMap(arg0: K, arg1: K): SortedMap<K, V>;
                headMap(arg0: K): SortedMap<K, V>;
                tailMap(arg0: K): SortedMap<K, V>;
                firstKey(): K;
                lastKey(): K;
                keySet(): JavaSet<K>;
                values(): JavaCollection<V>;
                entrySet(): JavaSet<Map$Entry<K, V>>;

            }

            abstract class Comparator<T> extends java.lang.Interface {
                static readonly class: JavaClass<Comparator<any>>;
                /** @deprecated */ static prototype: undefined;

                static reverseOrder<T extends java.lang.Comparable<T>>(): MethodWrapper<T, T, int>;
                static naturalOrder<T extends java.lang.Comparable<T>>(): MethodWrapper<T, T, int>;
                static nullsFirst<T>(arg0: MethodWrapper<T, T, int>): MethodWrapper<T, T, int>;
                static nullsLast<T>(arg0: MethodWrapper<T, T, int>): MethodWrapper<T, T, int>;
                static comparing<T, U>(arg0: MethodWrapper<T, any, U>, arg1: MethodWrapper<U, U, int>): MethodWrapper<T, T, int>;
                static comparing<T, U extends java.lang.Comparable<U>>(arg0: MethodWrapper<T, any, U>): MethodWrapper<T, T, int>;
                static comparingInt<T>(arg0: java.util.function.ToIntFunction<T>): MethodWrapper<T, T, int>;
                static comparingLong<T>(arg0: java.util.function.ToLongFunction<T>): MethodWrapper<T, T, int>;
                static comparingDouble<T>(arg0: java.util.function.ToDoubleFunction<T>): MethodWrapper<T, T, int>;

            }
            interface Comparator<T> {

                compare(arg0: T, arg1: T): number;
                reversed(): MethodWrapper<T, T, int>;
                thenComparing(arg0: MethodWrapper<T, T, int>): MethodWrapper<T, T, int>;
                thenComparing<U>(arg0: MethodWrapper<T, any, U>, arg1: MethodWrapper<U, U, int>): MethodWrapper<T, T, int>;
                thenComparing<U extends java.lang.Comparable<U>>(arg0: MethodWrapper<T, any, U>): MethodWrapper<T, T, int>;
                thenComparingInt(arg0: java.util.function.ToIntFunction<T>): MethodWrapper<T, T, int>;
                thenComparingLong(arg0: java.util.function.ToLongFunction<T>): MethodWrapper<T, T, int>;
                thenComparingDouble(arg0: java.util.function.ToDoubleFunction<T>): MethodWrapper<T, T, int>;

            }

            interface UUID extends java.lang.Comparable<UUID>, java.io.Serializable {}
            class UUID extends java.lang.Object {
                static readonly class: JavaClass<UUID>;
                /** @deprecated */ static prototype: undefined;

                static randomUUID(): UUID;
                static nameUUIDFromBytes(arg0: byte[]): UUID;
                static fromString(arg0: string): UUID;

                constructor (arg0: long, arg1: long);

                getLeastSignificantBits(): number;
                getMostSignificantBits(): number;
                version(): number;
                variant(): number;
                timestamp(): number;
                clockSequence(): number;
                node(): number;
                compareTo(arg0: UUID): number;

            }

            interface Date extends java.lang.Cloneable, java.lang.Comparable<Date>, java.io.Serializable {}
            class Date extends java.lang.Object {
                static readonly class: JavaClass<Date>;
                /** @deprecated */ static prototype: undefined;

                /** @deprecated */
                static UTC(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): number;
                /** @deprecated */
                static parse(arg0: string): number;
                static from(arg0: java.time.Instant): Date;

                constructor ();
                constructor (arg0: long);
                /** @deprecated */
                constructor (arg0: int, arg1: int, arg2: int);
                /** @deprecated */
                constructor (arg0: int, arg1: int, arg2: int, arg3: int, arg4: int);
                /** @deprecated */
                constructor (arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int);
                /** @deprecated */
                constructor (arg0: string);

                clone(): any;
                /** @deprecated */
                getYear(): number;
                /** @deprecated */
                setYear(arg0: int): void;
                /** @deprecated */
                getMonth(): number;
                /** @deprecated */
                setMonth(arg0: int): void;
                /** @deprecated */
                getDate(): number;
                /** @deprecated */
                setDate(arg0: int): void;
                /** @deprecated */
                getDay(): number;
                /** @deprecated */
                getHours(): number;
                /** @deprecated */
                setHours(arg0: int): void;
                /** @deprecated */
                getMinutes(): number;
                /** @deprecated */
                setMinutes(arg0: int): void;
                /** @deprecated */
                getSeconds(): number;
                /** @deprecated */
                setSeconds(arg0: int): void;
                getTime(): number;
                setTime(arg0: long): void;
                before(arg0: Date): boolean;
                after(arg0: Date): boolean;
                compareTo(arg0: Date): number;
                /** @deprecated */
                toLocaleString(): string;
                /** @deprecated */
                toGMTString(): string;
                /** @deprecated */
                getTimezoneOffset(): number;
                toInstant(): java.time.Instant;

            }

            interface BitSet extends java.lang.Cloneable, java.io.Serializable {}
            class BitSet extends java.lang.Object {
                static readonly class: JavaClass<BitSet>;
                /** @deprecated */ static prototype: undefined;

                static valueOf(arg0: long[]): BitSet;
                static valueOf(arg0: java.nio.LongBuffer): BitSet;
                static valueOf(arg0: byte[]): BitSet;
                static valueOf(arg0: java.nio.ByteBuffer): BitSet;

                constructor ();
                constructor (arg0: int);

                toByteArray(): JavaArray<number>;
                toLongArray(): JavaArray<number>;
                flip(arg0: int): void;
                flip(arg0: int, arg1: int): void;
                set(arg0: int): void;
                set(arg0: int, arg1: boolean): void;
                set(arg0: int, arg1: int): void;
                set(arg0: int, arg1: int, arg2: boolean): void;
                clear(arg0: int): void;
                clear(arg0: int, arg1: int): void;
                clear(): void;
                get(arg0: int): boolean;
                get(arg0: int, arg1: int): BitSet;
                nextSetBit(arg0: int): number;
                nextClearBit(arg0: int): number;
                previousSetBit(arg0: int): number;
                previousClearBit(arg0: int): number;
                length(): number;
                isEmpty(): boolean;
                intersects(arg0: BitSet): boolean;
                cardinality(): number;
                and(arg0: BitSet): void;
                or(arg0: BitSet): void;
                xor(arg0: BitSet): void;
                andNot(arg0: BitSet): void;
                size(): number;
                clone(): any;
                stream(): java.util.stream.IntStream;

            }

            abstract class EventListener extends java.lang.Interface {
                static readonly class: JavaClass<EventListener>;
                /** @deprecated */ static prototype: undefined;
            }
            interface EventListener {}

            interface EventObject extends java.io.Serializable {}
            class EventObject extends java.lang.Object {
                static readonly class: JavaClass<EventObject>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: any);

                getSource(): any;

            }

            interface Currency extends java.io.Serializable {}
            abstract class Currency extends java.lang.Object {
                static readonly class: JavaClass<Currency>;
                /** @deprecated */ static prototype: undefined;

                static getInstance(arg0: string): Currency;
                static getInstance(arg0: Locale): Currency;
                static getAvailableCurrencies(): JavaSet<Currency>;

                getCurrencyCode(): string;
                getSymbol(): string;
                getSymbol(arg0: Locale): string;
                getDefaultFractionDigits(): number;
                getNumericCode(): number;
                getNumericCodeAsString(): string;
                getDisplayName(): string;
                getDisplayName(arg0: Locale): string;

            }

            class Properties extends Hashtable<java.lang.Object, java.lang.Object> {
                static readonly class: JavaClass<Properties>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: int);
                constructor (arg0: Properties);

                setProperty(arg0: string, arg1: string): any;
                load(arg0: java.io.Reader): void;
                load(arg0: java.io.InputStream): void;
                /** @deprecated */
                save(arg0: java.io.OutputStream, arg1: string): void;
                store(arg0: java.io.Writer, arg1: string): void;
                store(arg0: java.io.OutputStream, arg1: string): void;
                loadFromXML(arg0: java.io.InputStream): void;
                storeToXML(arg0: java.io.OutputStream, arg1: string): void;
                storeToXML(arg0: java.io.OutputStream, arg1: string, arg2: string): void;
                storeToXML(arg0: java.io.OutputStream, arg1: string, arg2: java.nio.charset.Charset): void;
                getProperty(arg0: string): string;
                getProperty(arg0: string, arg1: string): string;
                propertyNames(): Enumeration<any>;
                stringPropertyNames(): JavaSet<string>;
                list(arg0: java.io.PrintStream): void;
                list(arg0: java.io.PrintWriter): void;
                size(): number;
                isEmpty(): boolean;
                keys(): Enumeration<any>;
                elements(): Enumeration<any>;
                contains(arg0: any): boolean;
                containsValue(arg0: any): boolean;
                containsKey(arg0: any): boolean;
                get(arg0: any): any;
                put(arg0: any, arg1: any): any;
                remove(arg0: any): any;
                putAll(arg0: JavaMap<any, any>): void;
                clear(): void;
                keySet(): JavaSet<any>;
                values(): JavaCollection<any>;
                entrySet(): JavaSet<Map$Entry<any, any>>;
                getOrDefault(arg0: any, arg1: any): any;
                forEach(arg0: MethodWrapper<any, any>): void;
                replaceAll(arg0: MethodWrapper<any, any, any>): void;
                putIfAbsent(arg0: any, arg1: any): any;
                remove(arg0: any, arg1: any): boolean;
                replace(arg0: any, arg1: any, arg2: any): boolean;
                replace(arg0: any, arg1: any): any;
                computeIfAbsent(arg0: any, arg1: MethodWrapper<any, any, any>): any;
                computeIfPresent(arg0: any, arg1: MethodWrapper<any, any, any>): any;
                compute(arg0: any, arg1: MethodWrapper<any, any, any>): any;
                merge(arg0: any, arg1: any, arg2: MethodWrapper<any, any, any>): any;
                clone(): any;

            }

            class Dictionary<K, V> extends java.lang.Object {
                static readonly class: JavaClass<Dictionary<any, any>>;
                /** @deprecated */ static prototype: undefined;

                constructor <K, V>();

                size(): number;
                isEmpty(): boolean;
                keys(): Enumeration<K>;
                elements(): Enumeration<V>;
                get(arg0: any): V;
                put(arg0: K, arg1: V): V;
                remove(arg0: any): V;

            }

            interface Vector<E> extends RandomAccess, java.lang.Cloneable, java.io.Serializable, JavaList<E> {}
            class Vector<E> extends AbstractList<E> {
                static readonly class: JavaClass<Vector<any>>;
                /** @deprecated */ static prototype: undefined;

                constructor <E>(arg0: int, arg1: int);
                constructor <E>(arg0: int);
                constructor <E>();
                constructor <E>(arg0: JavaCollection<E>);

                copyInto(arg0: any[]): void;
                trimToSize(): void;
                ensureCapacity(arg0: int): void;
                setSize(arg0: int): void;
                capacity(): number;
                size(): number;
                isEmpty(): boolean;
                elements(): Enumeration<E>;
                contains(arg0: any): boolean;
                indexOf(arg0: any): number;
                indexOf(arg0: any, arg1: int): number;
                lastIndexOf(arg0: any): number;
                lastIndexOf(arg0: any, arg1: int): number;
                elementAt(arg0: int): E;
                firstElement(): E;
                lastElement(): E;
                setElementAt(arg0: E, arg1: int): void;
                removeElementAt(arg0: int): void;
                insertElementAt(arg0: E, arg1: int): void;
                addElement(arg0: E): void;
                removeElement(arg0: any): boolean;
                removeAllElements(): void;
                clone(): any;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;
                toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
                get(arg0: int): E;
                set(arg0: int, arg1: E): E;
                add(arg0: E): boolean;
                remove(arg0: any): boolean;
                add(arg0: int, arg1: E): void;
                remove(arg0: int): E;
                clear(): void;
                containsAll(arg0: JavaCollection<any>): boolean;
                addAll(arg0: JavaCollection<E>): boolean;
                removeAll(arg0: JavaCollection<any>): boolean;
                retainAll(arg0: JavaCollection<any>): boolean;
                removeIf(arg0: MethodWrapper<E, any, boolean>): boolean;
                addAll(arg0: int, arg1: JavaCollection<E>): boolean;
                subList(arg0: int, arg1: int): JavaList<E>;
                listIterator(arg0: int): ListIterator<E>;
                listIterator(): ListIterator<E>;
                iterator(): Iterator<E>;
                forEach(arg0: MethodWrapper<E>): void;
                replaceAll(arg0: java.util.function.UnaryOperator<E>): void;
                sort(arg0: MethodWrapper<E, E, int>): void;
                spliterator(): Spliterator<E>;

            }

            interface Hashtable<K, V> extends java.lang.Cloneable, java.io.Serializable, JavaMap<K, V> {}
            class Hashtable<K, V> extends Dictionary<K, V> {
                static readonly class: JavaClass<Hashtable<any, any>>;
                /** @deprecated */ static prototype: undefined;

                constructor <K, V>(arg0: int, arg1: float);
                constructor <K, V>(arg0: int);
                constructor <K, V>();
                constructor <K, V>(arg0: JavaMap<K, V>);

                size(): number;
                isEmpty(): boolean;
                keys(): Enumeration<K>;
                elements(): Enumeration<V>;
                contains(arg0: any): boolean;
                containsValue(arg0: any): boolean;
                containsKey(arg0: any): boolean;
                get(arg0: any): V;
                put(arg0: K, arg1: V): V;
                remove(arg0: any): V;
                putAll(arg0: JavaMap<K, V>): void;
                clear(): void;
                clone(): any;
                keySet(): JavaSet<K>;
                entrySet(): JavaSet<Map$Entry<K, V>>;
                values(): JavaCollection<V>;
                getOrDefault(arg0: any, arg1: V): V;
                forEach(arg0: MethodWrapper<K, V>): void;
                replaceAll(arg0: MethodWrapper<K, V, V>): void;
                putIfAbsent(arg0: K, arg1: V): V;
                remove(arg0: any, arg1: any): boolean;
                replace(arg0: K, arg1: V, arg2: V): boolean;
                replace(arg0: K, arg1: V): V;
                computeIfAbsent(arg0: K, arg1: MethodWrapper<K, any, V>): V;
                computeIfPresent(arg0: K, arg1: MethodWrapper<K, V, V>): V;
                compute(arg0: K, arg1: MethodWrapper<K, V, V>): V;
                merge(arg0: K, arg1: V, arg2: MethodWrapper<V, V, V>): V;

            }

            class ResourceBundle extends java.lang.Object {
                static readonly class: JavaClass<ResourceBundle>;
                /** @deprecated */ static prototype: undefined;

                static getBundle(arg0: string): ResourceBundle;
                static getBundle(arg0: string, arg1: ResourceBundle$Control): ResourceBundle;
                static getBundle(arg0: string, arg1: Locale): ResourceBundle;
                static getBundle(arg0: string, arg1: java.lang.Module): ResourceBundle;
                static getBundle(arg0: string, arg1: Locale, arg2: java.lang.Module): ResourceBundle;
                static getBundle(arg0: string, arg1: Locale, arg2: ResourceBundle$Control): ResourceBundle;
                static getBundle(arg0: string, arg1: Locale, arg2: java.lang.ClassLoader): ResourceBundle;
                static getBundle(arg0: string, arg1: Locale, arg2: java.lang.ClassLoader, arg3: ResourceBundle$Control): ResourceBundle;
                static clearCache(): void;
                static clearCache(arg0: java.lang.ClassLoader): void;

                constructor ();

                getBaseBundleName(): string;
                getString(arg0: string): string;
                getStringArray(arg0: string): JavaArray<string>;
                getObject(arg0: string): any;
                getLocale(): Locale;
                getKeys(): Enumeration<string>;
                containsKey(arg0: string): boolean;
                keySet(): JavaSet<string>;

            }

            interface Random extends java.util.random.RandomGenerator, java.io.Serializable {}
            class Random extends java.lang.Object {
                static readonly class: JavaClass<Random>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: long);

                setSeed(arg0: long): void;
                nextBytes(arg0: byte[]): void;
                nextInt(): number;
                nextInt(arg0: int): number;
                nextInt(arg0: int, arg1: int): number;
                nextLong(): number;
                nextLong(arg0: long): number;
                nextLong(arg0: long, arg1: long): number;
                nextBoolean(): boolean;
                nextFloat(): number;
                nextFloat(arg0: float): number;
                nextFloat(arg0: float, arg1: float): number;
                nextDouble(): number;
                nextDouble(arg0: double): number;
                nextDouble(arg0: double, arg1: double): number;
                nextGaussian(): number;
                nextGaussian(arg0: double, arg1: double): number;
                ints(arg0: long): java.util.stream.IntStream;
                ints(): java.util.stream.IntStream;
                ints(arg0: long, arg1: int, arg2: int): java.util.stream.IntStream;
                ints(arg0: int, arg1: int): java.util.stream.IntStream;
                longs(arg0: long): java.util.stream.LongStream;
                longs(): java.util.stream.LongStream;
                longs(arg0: long, arg1: long, arg2: long): java.util.stream.LongStream;
                longs(arg0: long, arg1: long): java.util.stream.LongStream;
                doubles(arg0: long): java.util.stream.DoubleStream;
                doubles(): java.util.stream.DoubleStream;
                doubles(arg0: long, arg1: double, arg2: double): java.util.stream.DoubleStream;
                doubles(arg0: double, arg1: double): java.util.stream.DoubleStream;

            }

            abstract class ResourceBundle$Control extends java.lang.Object {
                static readonly class: JavaClass<ResourceBundle$Control>;
                /** @deprecated */ static prototype: undefined;

                static readonly FORMAT_DEFAULT: JavaList<string>;
                static readonly FORMAT_CLASS: JavaList<string>;
                static readonly FORMAT_PROPERTIES: JavaList<string>;
                static readonly TTL_DONT_CACHE: number;
                static readonly TTL_NO_EXPIRATION_CONTROL: number;

                static getControl(arg0: JavaList<string>): ResourceBundle$Control;
                static getNoFallbackControl(arg0: JavaList<string>): ResourceBundle$Control;

                getFormats(arg0: string): JavaList<string>;
                getCandidateLocales(arg0: string, arg1: Locale): JavaList<Locale>;
                getFallbackLocale(arg0: string, arg1: Locale): Locale;
                newBundle(arg0: string, arg1: Locale, arg2: string, arg3: java.lang.ClassLoader, arg4: boolean): ResourceBundle;
                getTimeToLive(arg0: string, arg1: Locale): number;
                needsReload(arg0: string, arg1: Locale, arg2: string, arg3: java.lang.ClassLoader, arg4: ResourceBundle, arg5: long): boolean;
                toBundleName(arg0: string, arg1: Locale): string;
                toResourceName(arg0: string, arg1: string): string;

            }

            namespace _function {

                abstract class BinaryOperator<T> extends java.lang.Interface {
                    static readonly class: JavaClass<BinaryOperator<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static minBy<T>(arg0: MethodWrapper<T, T, int>): BinaryOperator<T>;
                    static maxBy<T>(arg0: MethodWrapper<T, T, int>): BinaryOperator<T>;

                }
                interface BinaryOperator<T> extends BiFunction<T, T, T> {}

                abstract class IntSupplier extends java.lang.Interface {
                    static readonly class: JavaClass<IntSupplier>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntSupplier {

                    getAsInt(): number;

                }

                abstract class Consumer<T> extends java.lang.Interface {
                    static readonly class: JavaClass<Consumer<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Consumer<T> {

                    accept(arg0: T): void;
                    andThen(arg0: MethodWrapper<T>): MethodWrapper<T>;

                }

                abstract class DoubleToIntFunction extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleToIntFunction>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DoubleToIntFunction {

                    applyAsInt(arg0: double): number;

                }

                abstract class IntConsumer extends java.lang.Interface {
                    static readonly class: JavaClass<IntConsumer>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntConsumer {

                    accept(arg0: int): void;
                    andThen(arg0: IntConsumer): IntConsumer;

                }

                abstract class LongUnaryOperator extends java.lang.Interface {
                    static readonly class: JavaClass<LongUnaryOperator>;
                    /** @deprecated */ static prototype: undefined;

                    static identity(): LongUnaryOperator;

                }
                interface LongUnaryOperator {

                    applyAsLong(arg0: long): number;
                    compose(arg0: LongUnaryOperator): LongUnaryOperator;
                    andThen(arg0: LongUnaryOperator): LongUnaryOperator;

                }

                abstract class ToIntFunction<T> extends java.lang.Interface {
                    static readonly class: JavaClass<ToIntFunction<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ToIntFunction<T> {

                    applyAsInt(arg0: T): number;

                }

                abstract class IntPredicate extends java.lang.Interface {
                    static readonly class: JavaClass<IntPredicate>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntPredicate {

                    test(arg0: int): boolean;
                    and(arg0: IntPredicate): IntPredicate;
                    negate(): IntPredicate;
                    or(arg0: IntPredicate): IntPredicate;

                }

                abstract class IntToDoubleFunction extends java.lang.Interface {
                    static readonly class: JavaClass<IntToDoubleFunction>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntToDoubleFunction {

                    applyAsDouble(arg0: int): number;

                }

                abstract class IntUnaryOperator extends java.lang.Interface {
                    static readonly class: JavaClass<IntUnaryOperator>;
                    /** @deprecated */ static prototype: undefined;

                    static identity(): IntUnaryOperator;

                }
                interface IntUnaryOperator {

                    applyAsInt(arg0: int): number;
                    compose(arg0: IntUnaryOperator): IntUnaryOperator;
                    andThen(arg0: IntUnaryOperator): IntUnaryOperator;

                }

                abstract class LongSupplier extends java.lang.Interface {
                    static readonly class: JavaClass<LongSupplier>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LongSupplier {

                    getAsLong(): number;

                }

                abstract class LongToDoubleFunction extends java.lang.Interface {
                    static readonly class: JavaClass<LongToDoubleFunction>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LongToDoubleFunction {

                    applyAsDouble(arg0: long): number;

                }

                abstract class ObjIntConsumer<T> extends java.lang.Interface {
                    static readonly class: JavaClass<ObjIntConsumer<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ObjIntConsumer<T> {

                    accept(arg0: T, arg1: int): void;

                }

                abstract class DoubleConsumer extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleConsumer>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DoubleConsumer {

                    accept(arg0: double): void;
                    andThen(arg0: DoubleConsumer): DoubleConsumer;

                }

                abstract class LongBinaryOperator extends java.lang.Interface {
                    static readonly class: JavaClass<LongBinaryOperator>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LongBinaryOperator {

                    applyAsLong(arg0: long, arg1: long): number;

                }

                abstract class ToDoubleFunction<T> extends java.lang.Interface {
                    static readonly class: JavaClass<ToDoubleFunction<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ToDoubleFunction<T> {

                    applyAsDouble(arg0: T): number;

                }

                abstract class IntToLongFunction extends java.lang.Interface {
                    static readonly class: JavaClass<IntToLongFunction>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntToLongFunction {

                    applyAsLong(arg0: int): number;

                }

                abstract class LongConsumer extends java.lang.Interface {
                    static readonly class: JavaClass<LongConsumer>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LongConsumer {

                    accept(arg0: long): void;
                    andThen(arg0: LongConsumer): LongConsumer;

                }

                abstract class DoubleBinaryOperator extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleBinaryOperator>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DoubleBinaryOperator {

                    applyAsDouble(arg0: double, arg1: double): number;

                }

                abstract class ToLongFunction<T> extends java.lang.Interface {
                    static readonly class: JavaClass<ToLongFunction<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ToLongFunction<T> {

                    applyAsLong(arg0: T): number;

                }

                abstract class ObjDoubleConsumer<T> extends java.lang.Interface {
                    static readonly class: JavaClass<ObjDoubleConsumer<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ObjDoubleConsumer<T> {

                    accept(arg0: T, arg1: double): void;

                }

                abstract class LongFunction<R> extends java.lang.Interface {
                    static readonly class: JavaClass<LongFunction<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LongFunction<R> {

                    apply(arg0: long): R;

                }

                abstract class LongPredicate extends java.lang.Interface {
                    static readonly class: JavaClass<LongPredicate>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LongPredicate {

                    test(arg0: long): boolean;
                    and(arg0: LongPredicate): LongPredicate;
                    negate(): LongPredicate;
                    or(arg0: LongPredicate): LongPredicate;

                }

                abstract class IntFunction<R> extends java.lang.Interface {
                    static readonly class: JavaClass<IntFunction<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntFunction<R> {

                    apply(arg0: int): R;

                }

                abstract class IntBinaryOperator extends java.lang.Interface {
                    static readonly class: JavaClass<IntBinaryOperator>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntBinaryOperator {

                    applyAsInt(arg0: int, arg1: int): number;

                }

                abstract class DoubleSupplier extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleSupplier>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DoubleSupplier {

                    getAsDouble(): number;

                }

                abstract class UnaryOperator<T> extends java.lang.Interface {
                    static readonly class: JavaClass<UnaryOperator<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static identity<T>(): UnaryOperator<T>;

                }
                interface UnaryOperator<T> extends Function<T, T> {}

                abstract class DoubleFunction<R> extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleFunction<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DoubleFunction<R> {

                    apply(arg0: double): R;

                }

                abstract class DoubleUnaryOperator extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleUnaryOperator>;
                    /** @deprecated */ static prototype: undefined;

                    static identity(): DoubleUnaryOperator;

                }
                interface DoubleUnaryOperator {

                    applyAsDouble(arg0: double): number;
                    compose(arg0: DoubleUnaryOperator): DoubleUnaryOperator;
                    andThen(arg0: DoubleUnaryOperator): DoubleUnaryOperator;

                }

                abstract class DoubleToLongFunction extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleToLongFunction>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DoubleToLongFunction {

                    applyAsLong(arg0: double): number;

                }

                abstract class DoublePredicate extends java.lang.Interface {
                    static readonly class: JavaClass<DoublePredicate>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DoublePredicate {

                    test(arg0: double): boolean;
                    and(arg0: DoublePredicate): DoublePredicate;
                    negate(): DoublePredicate;
                    or(arg0: DoublePredicate): DoublePredicate;

                }

                abstract class ObjLongConsumer<T> extends java.lang.Interface {
                    static readonly class: JavaClass<ObjLongConsumer<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ObjLongConsumer<T> {

                    accept(arg0: T, arg1: long): void;

                }

                abstract class LongToIntFunction extends java.lang.Interface {
                    static readonly class: JavaClass<LongToIntFunction>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LongToIntFunction {

                    applyAsInt(arg0: long): number;

                }

                abstract class Function<T, R> extends java.lang.Interface {
                    static readonly class: JavaClass<Function<any, any>>;
                    /** @deprecated */ static prototype: undefined;

                    static identity<T>(): MethodWrapper<T, any, T>;

                }
                interface Function<T, R> {

                    apply(arg0: T): R;
                    compose<V>(arg0: MethodWrapper<V, any, T>): MethodWrapper<V, any, R>;
                    andThen<V>(arg0: MethodWrapper<R, any, V>): MethodWrapper<T, any, V>;

                }

                abstract class BiFunction<T, U, R> extends java.lang.Interface {
                    static readonly class: JavaClass<BiFunction<any, any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface BiFunction<T, U, R> {

                    apply(arg0: T, arg1: U): R;
                    andThen<V>(arg0: MethodWrapper<R, any, V>): MethodWrapper<T, U, V>;

                }

                abstract class BiPredicate<T, U> extends java.lang.Interface {
                    static readonly class: JavaClass<BiPredicate<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface BiPredicate<T, U> {

                    test(arg0: T, arg1: U): boolean;
                    and(arg0: MethodWrapper<T, U, boolean>): MethodWrapper<T, U, boolean>;
                    negate(): MethodWrapper<T, U, boolean>;
                    or(arg0: MethodWrapper<T, U, boolean>): MethodWrapper<T, U, boolean>;

                }

                abstract class Predicate<T> extends java.lang.Interface {
                    static readonly class: JavaClass<Predicate<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static isEqual<T>(arg0: any): MethodWrapper<T, any, boolean>;
                    static not<T>(arg0: MethodWrapper<T, any, boolean>): MethodWrapper<T, any, boolean>;

                }
                interface Predicate<T> {

                    test(arg0: T): boolean;
                    and(arg0: MethodWrapper<T, any, boolean>): MethodWrapper<T, any, boolean>;
                    negate(): MethodWrapper<T, any, boolean>;
                    or(arg0: MethodWrapper<T, any, boolean>): MethodWrapper<T, any, boolean>;

                }

                abstract class Supplier<T> extends java.lang.Interface {
                    static readonly class: JavaClass<Supplier<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Supplier<T> {

                    get(): T;

                }

                abstract class BiConsumer<T, U> extends java.lang.Interface {
                    static readonly class: JavaClass<BiConsumer<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface BiConsumer<T, U> {

                    accept(arg0: T, arg1: U): void;
                    andThen(arg0: MethodWrapper<T, U>): MethodWrapper<T, U>;

                }

                export {
                    BinaryOperator,
                    IntSupplier,
                    Consumer,
                    DoubleToIntFunction,
                    IntConsumer,
                    LongUnaryOperator,
                    ToIntFunction,
                    IntPredicate,
                    IntToDoubleFunction,
                    IntUnaryOperator,
                    LongSupplier,
                    LongToDoubleFunction,
                    ObjIntConsumer,
                    DoubleConsumer,
                    LongBinaryOperator,
                    ToDoubleFunction,
                    IntToLongFunction,
                    LongConsumer,
                    DoubleBinaryOperator,
                    ToLongFunction,
                    ObjDoubleConsumer,
                    LongFunction,
                    LongPredicate,
                    IntFunction,
                    IntBinaryOperator,
                    DoubleSupplier,
                    UnaryOperator,
                    DoubleFunction,
                    DoubleUnaryOperator,
                    DoubleToLongFunction,
                    DoublePredicate,
                    ObjLongConsumer,
                    LongToIntFunction,
                    Function,
                    BiFunction,
                    BiPredicate,
                    Predicate,
                    Supplier,
                    BiConsumer
                }

            }

            export {
                Iterator,
                Optional,
                ArrayList,
                SplittableRandom,
                Locale,
                HashSet,
                HashMap,
                Enumeration,
                Locale$LanguageRange,
                Spliterator$OfInt,
                RandomAccess,
                ListIterator,
                LongSummaryStatistics,
                AbstractSet,
                Locale$FilteringMode,
                IntSummaryStatistics,
                PrimitiveIterator$OfInt,
                Spliterator$OfDouble,
                Map$Entry,
                PrimitiveIterator$OfDouble,
                Spliterator$OfLong,
                AbstractCollection,
                Spliterator,
                OptionalLong,
                PrimitiveIterator$OfLong,
                DoubleSummaryStatistics,
                OptionalDouble,
                Locale$IsoCountryCode,
                AbstractMap,
                AbstractList,
                Locale$Category,
                OptionalInt,
                PrimitiveIterator,
                Spliterator$OfPrimitive,
                SortedMap,
                Comparator,
                UUID,
                Date,
                BitSet,
                EventListener,
                EventObject,
                Currency,
                Properties,
                Dictionary,
                Vector,
                Hashtable,
                ResourceBundle,
                Random,
                ResourceBundle$Control,
                _function as function
            }

        }
        namespace util {

            namespace concurrent {

                abstract class ExecutorService extends java.lang.Interface {
                    static readonly class: JavaClass<ExecutorService>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ExecutorService extends Executor {

                    shutdown(): void;
                    shutdownNow(): JavaList<MethodWrapper>;
                    isShutdown(): boolean;
                    isTerminated(): boolean;
                    awaitTermination(arg0: long, arg1: TimeUnit): boolean;
                    submit<T>(arg0: Callable<T>): Future<T>;
                    submit<T>(arg0: MethodWrapper, arg1: T): Future<T>;
                    submit(arg0: MethodWrapper): Future<any>;
                    invokeAll<T>(arg0: JavaCollection<Callable<T>>): JavaList<Future<T>>;
                    invokeAll<T>(arg0: JavaCollection<Callable<T>>, arg1: long, arg2: TimeUnit): JavaList<Future<T>>;
                    invokeAny<T>(arg0: JavaCollection<Callable<T>>): T;
                    invokeAny<T>(arg0: JavaCollection<Callable<T>>, arg1: long, arg2: TimeUnit): T;

                }

                abstract class TimeUnit extends java.lang.Enum<TimeUnit> {
                    static readonly class: JavaClass<TimeUnit>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly NANOSECONDS: TimeUnit;
                    static readonly MICROSECONDS: TimeUnit;
                    static readonly MILLISECONDS: TimeUnit;
                    static readonly SECONDS: TimeUnit;
                    static readonly MINUTES: TimeUnit;
                    static readonly HOURS: TimeUnit;
                    static readonly DAYS: TimeUnit;

                    static values(): JavaArray<TimeUnit>;
                    static valueOf(arg0: string): TimeUnit;
                    static of(arg0: java.time.temporal.ChronoUnit): TimeUnit;

                    convert(arg0: long, arg1: TimeUnit): number;
                    convert(arg0: java.time.Duration): number;
                    toNanos(arg0: long): number;
                    toMicros(arg0: long): number;
                    toMillis(arg0: long): number;
                    toSeconds(arg0: long): number;
                    toMinutes(arg0: long): number;
                    toHours(arg0: long): number;
                    toDays(arg0: long): number;
                    timedWait(arg0: any, arg1: long): void;
                    timedJoin(arg0: java.lang.Thread, arg1: long): void;
                    sleep(arg0: long): void;
                    toChronoUnit(): java.time.temporal.ChronoUnit;

                }

                interface CompletableFuture<T> extends Future<T>, CompletionStage<T> {}
                class CompletableFuture<T> extends java.lang.Object {
                    static readonly class: JavaClass<CompletableFuture<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static supplyAsync<U>(arg0: MethodWrapper<any, any, U>): CompletableFuture<U>;
                    static supplyAsync<U>(arg0: MethodWrapper<any, any, U>, arg1: Executor): CompletableFuture<U>;
                    static runAsync(arg0: MethodWrapper): CompletableFuture<java.lang.Void>;
                    static runAsync(arg0: MethodWrapper, arg1: Executor): CompletableFuture<java.lang.Void>;
                    static completedFuture<U>(arg0: U): CompletableFuture<U>;
                    static allOf(...arg0: JavaVarArgs<CompletableFuture<any>>): CompletableFuture<java.lang.Void>;
                    static anyOf(...arg0: JavaVarArgs<CompletableFuture<any>>): CompletableFuture<any>;
                    static delayedExecutor(arg0: long, arg1: TimeUnit, arg2: Executor): Executor;
                    static delayedExecutor(arg0: long, arg1: TimeUnit): Executor;
                    static completedStage<U>(arg0: U): CompletionStage<U>;
                    static failedFuture<U>(arg0: java.lang.Throwable): CompletableFuture<U>;
                    static failedStage<U>(arg0: java.lang.Throwable): CompletionStage<U>;

                    constructor <T>();

                    isDone(): boolean;
                    get(): T;
                    get(arg0: long, arg1: TimeUnit): T;
                    join(): T;
                    getNow(arg0: T): T;
                    complete(arg0: T): boolean;
                    completeExceptionally(arg0: java.lang.Throwable): boolean;
                    thenApply<U>(arg0: MethodWrapper<T, any, U>): CompletableFuture<U>;
                    thenApplyAsync<U>(arg0: MethodWrapper<T, any, U>): CompletableFuture<U>;
                    thenApplyAsync<U>(arg0: MethodWrapper<T, any, U>, arg1: Executor): CompletableFuture<U>;
                    thenAccept(arg0: MethodWrapper<T>): CompletableFuture<java.lang.Void>;
                    thenAcceptAsync(arg0: MethodWrapper<T>): CompletableFuture<java.lang.Void>;
                    thenAcceptAsync(arg0: MethodWrapper<T>, arg1: Executor): CompletableFuture<java.lang.Void>;
                    thenRun(arg0: MethodWrapper): CompletableFuture<java.lang.Void>;
                    thenRunAsync(arg0: MethodWrapper): CompletableFuture<java.lang.Void>;
                    thenRunAsync(arg0: MethodWrapper, arg1: Executor): CompletableFuture<java.lang.Void>;
                    thenCombine<U, V>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U, V>): CompletableFuture<V>;
                    thenCombineAsync<U, V>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U, V>): CompletableFuture<V>;
                    thenCombineAsync<U, V>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U, V>, arg2: Executor): CompletableFuture<V>;
                    thenAcceptBoth<U>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U>): CompletableFuture<java.lang.Void>;
                    thenAcceptBothAsync<U>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U>): CompletableFuture<java.lang.Void>;
                    thenAcceptBothAsync<U>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U>, arg2: Executor): CompletableFuture<java.lang.Void>;
                    runAfterBoth(arg0: CompletionStage<any>, arg1: MethodWrapper): CompletableFuture<java.lang.Void>;
                    runAfterBothAsync(arg0: CompletionStage<any>, arg1: MethodWrapper): CompletableFuture<java.lang.Void>;
                    runAfterBothAsync(arg0: CompletionStage<any>, arg1: MethodWrapper, arg2: Executor): CompletableFuture<java.lang.Void>;
                    applyToEither<U>(arg0: CompletionStage<T>, arg1: MethodWrapper<T, any, U>): CompletableFuture<U>;
                    applyToEitherAsync<U>(arg0: CompletionStage<T>, arg1: MethodWrapper<T, any, U>): CompletableFuture<U>;
                    applyToEitherAsync<U>(arg0: CompletionStage<T>, arg1: MethodWrapper<T, any, U>, arg2: Executor): CompletableFuture<U>;
                    acceptEither(arg0: CompletionStage<T>, arg1: MethodWrapper<T>): CompletableFuture<java.lang.Void>;
                    acceptEitherAsync(arg0: CompletionStage<T>, arg1: MethodWrapper<T>): CompletableFuture<java.lang.Void>;
                    acceptEitherAsync(arg0: CompletionStage<T>, arg1: MethodWrapper<T>, arg2: Executor): CompletableFuture<java.lang.Void>;
                    runAfterEither(arg0: CompletionStage<any>, arg1: MethodWrapper): CompletableFuture<java.lang.Void>;
                    runAfterEitherAsync(arg0: CompletionStage<any>, arg1: MethodWrapper): CompletableFuture<java.lang.Void>;
                    runAfterEitherAsync(arg0: CompletionStage<any>, arg1: MethodWrapper, arg2: Executor): CompletableFuture<java.lang.Void>;
                    thenCompose<U>(arg0: MethodWrapper<T, any, CompletionStage<U>>): CompletableFuture<U>;
                    thenComposeAsync<U>(arg0: MethodWrapper<T, any, CompletionStage<U>>): CompletableFuture<U>;
                    thenComposeAsync<U>(arg0: MethodWrapper<T, any, CompletionStage<U>>, arg1: Executor): CompletableFuture<U>;
                    whenComplete(arg0: MethodWrapper<T, java.lang.Throwable>): CompletableFuture<T>;
                    whenCompleteAsync(arg0: MethodWrapper<T, java.lang.Throwable>): CompletableFuture<T>;
                    whenCompleteAsync(arg0: MethodWrapper<T, java.lang.Throwable>, arg1: Executor): CompletableFuture<T>;
                    handle<U>(arg0: MethodWrapper<T, java.lang.Throwable, U>): CompletableFuture<U>;
                    handleAsync<U>(arg0: MethodWrapper<T, java.lang.Throwable, U>): CompletableFuture<U>;
                    handleAsync<U>(arg0: MethodWrapper<T, java.lang.Throwable, U>, arg1: Executor): CompletableFuture<U>;
                    toCompletableFuture(): CompletableFuture<T>;
                    exceptionally(arg0: MethodWrapper<java.lang.Throwable, any, T>): CompletableFuture<T>;
                    exceptionallyAsync(arg0: MethodWrapper<java.lang.Throwable, any, T>): CompletableFuture<T>;
                    exceptionallyAsync(arg0: MethodWrapper<java.lang.Throwable, any, T>, arg1: Executor): CompletableFuture<T>;
                    exceptionallyCompose(arg0: MethodWrapper<java.lang.Throwable, any, CompletionStage<T>>): CompletableFuture<T>;
                    exceptionallyComposeAsync(arg0: MethodWrapper<java.lang.Throwable, any, CompletionStage<T>>): CompletableFuture<T>;
                    exceptionallyComposeAsync(arg0: MethodWrapper<java.lang.Throwable, any, CompletionStage<T>>, arg1: Executor): CompletableFuture<T>;
                    cancel(arg0: boolean): boolean;
                    isCancelled(): boolean;
                    isCompletedExceptionally(): boolean;
                    obtrudeValue(arg0: T): void;
                    obtrudeException(arg0: java.lang.Throwable): void;
                    getNumberOfDependents(): number;
                    newIncompleteFuture<U>(): CompletableFuture<U>;
                    defaultExecutor(): Executor;
                    copy(): CompletableFuture<T>;
                    minimalCompletionStage(): CompletionStage<T>;
                    completeAsync(arg0: MethodWrapper<any, any, T>, arg1: Executor): CompletableFuture<T>;
                    completeAsync(arg0: MethodWrapper<any, any, T>): CompletableFuture<T>;
                    orTimeout(arg0: long, arg1: TimeUnit): CompletableFuture<T>;
                    completeOnTimeout(arg0: T, arg1: long, arg2: TimeUnit): CompletableFuture<T>;

                }

                abstract class Future<V> extends java.lang.Interface {
                    static readonly class: JavaClass<Future<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Future<V> {

                    cancel(arg0: boolean): boolean;
                    isCancelled(): boolean;
                    isDone(): boolean;
                    get(): V;
                    get(arg0: long, arg1: TimeUnit): V;

                }

                abstract class CompletionStage<T> extends java.lang.Interface {
                    static readonly class: JavaClass<CompletionStage<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface CompletionStage<T> {

                    thenApply<U>(arg0: MethodWrapper<T, any, U>): CompletionStage<U>;
                    thenApplyAsync<U>(arg0: MethodWrapper<T, any, U>): CompletionStage<U>;
                    thenApplyAsync<U>(arg0: MethodWrapper<T, any, U>, arg1: Executor): CompletionStage<U>;
                    thenAccept(arg0: MethodWrapper<T>): CompletionStage<java.lang.Void>;
                    thenAcceptAsync(arg0: MethodWrapper<T>): CompletionStage<java.lang.Void>;
                    thenAcceptAsync(arg0: MethodWrapper<T>, arg1: Executor): CompletionStage<java.lang.Void>;
                    thenRun(arg0: MethodWrapper): CompletionStage<java.lang.Void>;
                    thenRunAsync(arg0: MethodWrapper): CompletionStage<java.lang.Void>;
                    thenRunAsync(arg0: MethodWrapper, arg1: Executor): CompletionStage<java.lang.Void>;
                    thenCombine<U, V>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U, V>): CompletionStage<V>;
                    thenCombineAsync<U, V>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U, V>): CompletionStage<V>;
                    thenCombineAsync<U, V>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U, V>, arg2: Executor): CompletionStage<V>;
                    thenAcceptBoth<U>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U>): CompletionStage<java.lang.Void>;
                    thenAcceptBothAsync<U>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U>): CompletionStage<java.lang.Void>;
                    thenAcceptBothAsync<U>(arg0: CompletionStage<U>, arg1: MethodWrapper<T, U>, arg2: Executor): CompletionStage<java.lang.Void>;
                    runAfterBoth(arg0: CompletionStage<any>, arg1: MethodWrapper): CompletionStage<java.lang.Void>;
                    runAfterBothAsync(arg0: CompletionStage<any>, arg1: MethodWrapper): CompletionStage<java.lang.Void>;
                    runAfterBothAsync(arg0: CompletionStage<any>, arg1: MethodWrapper, arg2: Executor): CompletionStage<java.lang.Void>;
                    applyToEither<U>(arg0: CompletionStage<T>, arg1: MethodWrapper<T, any, U>): CompletionStage<U>;
                    applyToEitherAsync<U>(arg0: CompletionStage<T>, arg1: MethodWrapper<T, any, U>): CompletionStage<U>;
                    applyToEitherAsync<U>(arg0: CompletionStage<T>, arg1: MethodWrapper<T, any, U>, arg2: Executor): CompletionStage<U>;
                    acceptEither(arg0: CompletionStage<T>, arg1: MethodWrapper<T>): CompletionStage<java.lang.Void>;
                    acceptEitherAsync(arg0: CompletionStage<T>, arg1: MethodWrapper<T>): CompletionStage<java.lang.Void>;
                    acceptEitherAsync(arg0: CompletionStage<T>, arg1: MethodWrapper<T>, arg2: Executor): CompletionStage<java.lang.Void>;
                    runAfterEither(arg0: CompletionStage<any>, arg1: MethodWrapper): CompletionStage<java.lang.Void>;
                    runAfterEitherAsync(arg0: CompletionStage<any>, arg1: MethodWrapper): CompletionStage<java.lang.Void>;
                    runAfterEitherAsync(arg0: CompletionStage<any>, arg1: MethodWrapper, arg2: Executor): CompletionStage<java.lang.Void>;
                    thenCompose<U>(arg0: MethodWrapper<T, any, CompletionStage<U>>): CompletionStage<U>;
                    thenComposeAsync<U>(arg0: MethodWrapper<T, any, CompletionStage<U>>): CompletionStage<U>;
                    thenComposeAsync<U>(arg0: MethodWrapper<T, any, CompletionStage<U>>, arg1: Executor): CompletionStage<U>;
                    handle<U>(arg0: MethodWrapper<T, java.lang.Throwable, U>): CompletionStage<U>;
                    handleAsync<U>(arg0: MethodWrapper<T, java.lang.Throwable, U>): CompletionStage<U>;
                    handleAsync<U>(arg0: MethodWrapper<T, java.lang.Throwable, U>, arg1: Executor): CompletionStage<U>;
                    whenComplete(arg0: MethodWrapper<T, java.lang.Throwable>): CompletionStage<T>;
                    whenCompleteAsync(arg0: MethodWrapper<T, java.lang.Throwable>): CompletionStage<T>;
                    whenCompleteAsync(arg0: MethodWrapper<T, java.lang.Throwable>, arg1: Executor): CompletionStage<T>;
                    exceptionally(arg0: MethodWrapper<java.lang.Throwable, any, T>): CompletionStage<T>;
                    exceptionallyAsync(arg0: MethodWrapper<java.lang.Throwable, any, T>): CompletionStage<T>;
                    exceptionallyAsync(arg0: MethodWrapper<java.lang.Throwable, any, T>, arg1: Executor): CompletionStage<T>;
                    exceptionallyCompose(arg0: MethodWrapper<java.lang.Throwable, any, CompletionStage<T>>): CompletionStage<T>;
                    exceptionallyComposeAsync(arg0: MethodWrapper<java.lang.Throwable, any, CompletionStage<T>>): CompletionStage<T>;
                    exceptionallyComposeAsync(arg0: MethodWrapper<java.lang.Throwable, any, CompletionStage<T>>, arg1: Executor): CompletionStage<T>;
                    toCompletableFuture(): CompletableFuture<T>;

                }

                abstract class Executor extends java.lang.Interface {
                    static readonly class: JavaClass<Executor>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Executor {

                    execute(arg0: MethodWrapper): void;

                }

                abstract class Callable<V> extends java.lang.Interface {
                    static readonly class: JavaClass<Callable<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Callable<V> {

                    call(): V;

                }

                export {
                    ExecutorService,
                    TimeUnit,
                    CompletableFuture,
                    Future,
                    CompletionStage,
                    Executor,
                    Callable
                }

            }

            namespace random {

                abstract class RandomGenerator$SplittableGenerator extends java.lang.Interface {
                    static readonly class: JavaClass<RandomGenerator$SplittableGenerator>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: string): RandomGenerator$SplittableGenerator;

                }
                interface RandomGenerator$SplittableGenerator extends RandomGenerator$StreamableGenerator {

                    split(): RandomGenerator$SplittableGenerator;
                    split(arg0: RandomGenerator$SplittableGenerator): RandomGenerator$SplittableGenerator;
                    splits(): java.util.stream.Stream<RandomGenerator$SplittableGenerator>;
                    splits(arg0: long): java.util.stream.Stream<RandomGenerator$SplittableGenerator>;
                    splits(arg0: RandomGenerator$SplittableGenerator): java.util.stream.Stream<RandomGenerator$SplittableGenerator>;
                    splits(arg0: long, arg1: RandomGenerator$SplittableGenerator): java.util.stream.Stream<RandomGenerator$SplittableGenerator>;
                    rngs(): java.util.stream.Stream<RandomGenerator>;
                    rngs(arg0: long): java.util.stream.Stream<RandomGenerator>;

                }

                abstract class RandomGenerator extends java.lang.Interface {
                    static readonly class: JavaClass<RandomGenerator>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: string): RandomGenerator;
                    static getDefault(): RandomGenerator;

                }
                interface RandomGenerator {

                    isDeprecated(): boolean;
                    doubles(): java.util.stream.DoubleStream;
                    doubles(arg0: double, arg1: double): java.util.stream.DoubleStream;
                    doubles(arg0: long): java.util.stream.DoubleStream;
                    doubles(arg0: long, arg1: double, arg2: double): java.util.stream.DoubleStream;
                    ints(): java.util.stream.IntStream;
                    ints(arg0: int, arg1: int): java.util.stream.IntStream;
                    ints(arg0: long): java.util.stream.IntStream;
                    ints(arg0: long, arg1: int, arg2: int): java.util.stream.IntStream;
                    longs(): java.util.stream.LongStream;
                    longs(arg0: long, arg1: long): java.util.stream.LongStream;
                    longs(arg0: long): java.util.stream.LongStream;
                    longs(arg0: long, arg1: long, arg2: long): java.util.stream.LongStream;
                    nextBoolean(): boolean;
                    nextBytes(arg0: byte[]): void;
                    nextFloat(): number;
                    nextFloat(arg0: float): number;
                    nextFloat(arg0: float, arg1: float): number;
                    nextDouble(): number;
                    nextDouble(arg0: double): number;
                    nextDouble(arg0: double, arg1: double): number;
                    nextInt(): number;
                    nextInt(arg0: int): number;
                    nextInt(arg0: int, arg1: int): number;
                    nextLong(): number;
                    nextLong(arg0: long): number;
                    nextLong(arg0: long, arg1: long): number;
                    nextGaussian(): number;
                    nextGaussian(arg0: double, arg1: double): number;
                    nextExponential(): number;

                }

                abstract class RandomGenerator$StreamableGenerator extends java.lang.Interface {
                    static readonly class: JavaClass<RandomGenerator$StreamableGenerator>;
                    /** @deprecated */ static prototype: undefined;

                    static of(arg0: string): RandomGenerator$StreamableGenerator;

                }
                interface RandomGenerator$StreamableGenerator extends RandomGenerator {

                    rngs(): java.util.stream.Stream<RandomGenerator>;
                    rngs(arg0: long): java.util.stream.Stream<RandomGenerator>;

                }

                export {
                    RandomGenerator$SplittableGenerator,
                    RandomGenerator,
                    RandomGenerator$StreamableGenerator
                }

            }

            namespace regex {

                interface Pattern extends java.io.Serializable {}
                abstract class Pattern extends java.lang.Object {
                    static readonly class: JavaClass<Pattern>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly UNIX_LINES: number;
                    static readonly CASE_INSENSITIVE: number;
                    static readonly COMMENTS: number;
                    static readonly MULTILINE: number;
                    static readonly LITERAL: number;
                    static readonly DOTALL: number;
                    static readonly UNICODE_CASE: number;
                    static readonly CANON_EQ: number;
                    static readonly UNICODE_CHARACTER_CLASS: number;

                    static compile(arg0: string): Pattern;
                    static compile(arg0: string, arg1: int): Pattern;
                    static matches(arg0: string, arg1: java.lang.CharSequence): boolean;
                    static quote(arg0: string): string;

                    pattern(): string;
                    matcher(arg0: java.lang.CharSequence): Matcher;
                    flags(): number;
                    split(arg0: java.lang.CharSequence, arg1: int): JavaArray<string>;
                    split(arg0: java.lang.CharSequence): JavaArray<string>;
                    asPredicate(): MethodWrapper<string, any, boolean>;
                    asMatchPredicate(): MethodWrapper<string, any, boolean>;
                    splitAsStream(arg0: java.lang.CharSequence): java.util.stream.Stream<string>;

                }

                interface Matcher extends MatchResult {}
                abstract class Matcher extends java.lang.Object {
                    static readonly class: JavaClass<Matcher>;
                    /** @deprecated */ static prototype: undefined;

                    static quoteReplacement(arg0: string): string;

                    pattern(): Pattern;
                    toMatchResult(): MatchResult;
                    usePattern(arg0: Pattern): Matcher;
                    reset(): Matcher;
                    reset(arg0: java.lang.CharSequence): Matcher;
                    start(): number;
                    start(arg0: int): number;
                    start(arg0: string): number;
                    end(): number;
                    end(arg0: int): number;
                    end(arg0: string): number;
                    group(): string;
                    group(arg0: int): string;
                    group(arg0: string): string;
                    groupCount(): number;
                    matches(): boolean;
                    find(): boolean;
                    find(arg0: int): boolean;
                    lookingAt(): boolean;
                    appendReplacement(arg0: java.lang.StringBuffer, arg1: string): Matcher;
                    appendReplacement(arg0: java.lang.StringBuilder, arg1: string): Matcher;
                    appendTail(arg0: java.lang.StringBuffer): java.lang.StringBuffer;
                    appendTail(arg0: java.lang.StringBuilder): java.lang.StringBuilder;
                    replaceAll(arg0: string): string;
                    replaceAll(arg0: MethodWrapper<MatchResult, any, string>): string;
                    results(): java.util.stream.Stream<MatchResult>;
                    replaceFirst(arg0: string): string;
                    replaceFirst(arg0: MethodWrapper<MatchResult, any, string>): string;
                    region(arg0: int, arg1: int): Matcher;
                    regionStart(): number;
                    regionEnd(): number;
                    hasTransparentBounds(): boolean;
                    useTransparentBounds(arg0: boolean): Matcher;
                    hasAnchoringBounds(): boolean;
                    useAnchoringBounds(arg0: boolean): Matcher;
                    hitEnd(): boolean;
                    requireEnd(): boolean;

                }

                abstract class MatchResult extends java.lang.Interface {
                    static readonly class: JavaClass<MatchResult>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface MatchResult {

                    start(): number;
                    start(arg0: int): number;
                    end(): number;
                    end(arg0: int): number;
                    group(): string;
                    group(arg0: int): string;
                    groupCount(): number;

                }

                export { Pattern, Matcher, MatchResult }

            }

            namespace stream {

                abstract class DoubleStream extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleStream>;
                    /** @deprecated */ static prototype: undefined;

                    static builder(): DoubleStream$Builder;
                    static empty(): DoubleStream;
                    static of(arg0: double): DoubleStream;
                    static of(...arg0: JavaVarArgs<double>): DoubleStream;
                    static iterate(arg0: double, arg1: java.util.function.DoubleUnaryOperator): DoubleStream;
                    static iterate(arg0: double, arg1: java.util.function.DoublePredicate, arg2: java.util.function.DoubleUnaryOperator): DoubleStream;
                    static generate(arg0: java.util.function.DoubleSupplier): DoubleStream;
                    static concat(arg0: DoubleStream, arg1: DoubleStream): DoubleStream;

                }
                interface DoubleStream extends BaseStream<java.lang.Double, DoubleStream> {

                    filter(arg0: java.util.function.DoublePredicate): DoubleStream;
                    map(arg0: java.util.function.DoubleUnaryOperator): DoubleStream;
                    mapToObj<U>(arg0: java.util.function.DoubleFunction<U>): Stream<U>;
                    mapToInt(arg0: java.util.function.DoubleToIntFunction): IntStream;
                    mapToLong(arg0: java.util.function.DoubleToLongFunction): LongStream;
                    flatMap(arg0: java.util.function.DoubleFunction<DoubleStream>): DoubleStream;
                    mapMulti(arg0: DoubleStream$DoubleMapMultiConsumer): DoubleStream;
                    distinct(): DoubleStream;
                    sorted(): DoubleStream;
                    peek(arg0: java.util.function.DoubleConsumer): DoubleStream;
                    limit(arg0: long): DoubleStream;
                    skip(arg0: long): DoubleStream;
                    takeWhile(arg0: java.util.function.DoublePredicate): DoubleStream;
                    dropWhile(arg0: java.util.function.DoublePredicate): DoubleStream;
                    forEach(arg0: java.util.function.DoubleConsumer): void;
                    forEachOrdered(arg0: java.util.function.DoubleConsumer): void;
                    toArray(): JavaArray<number>;
                    reduce(arg0: double, arg1: java.util.function.DoubleBinaryOperator): number;
                    reduce(arg0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                    collect<R>(arg0: MethodWrapper<any, any, R>, arg1: java.util.function.ObjDoubleConsumer<R>, arg2: MethodWrapper<R, R>): R;
                    sum(): number;
                    min(): java.util.OptionalDouble;
                    max(): java.util.OptionalDouble;
                    count(): number;
                    average(): java.util.OptionalDouble;
                    summaryStatistics(): java.util.DoubleSummaryStatistics;
                    anyMatch(arg0: java.util.function.DoublePredicate): boolean;
                    allMatch(arg0: java.util.function.DoublePredicate): boolean;
                    noneMatch(arg0: java.util.function.DoublePredicate): boolean;
                    findFirst(): java.util.OptionalDouble;
                    findAny(): java.util.OptionalDouble;
                    boxed(): Stream<number>;
                    sequential(): DoubleStream;
                    parallel(): DoubleStream;
                    iterator(): java.util.PrimitiveIterator$OfDouble;
                    spliterator(): java.util.Spliterator$OfDouble;

                }

                abstract class LongStream extends java.lang.Interface {
                    static readonly class: JavaClass<LongStream>;
                    /** @deprecated */ static prototype: undefined;

                    static builder(): LongStream$Builder;
                    static empty(): LongStream;
                    static of(arg0: long): LongStream;
                    static of(...arg0: JavaVarArgs<long>): LongStream;
                    static iterate(arg0: long, arg1: java.util.function.LongUnaryOperator): LongStream;
                    static iterate(arg0: long, arg1: java.util.function.LongPredicate, arg2: java.util.function.LongUnaryOperator): LongStream;
                    static generate(arg0: java.util.function.LongSupplier): LongStream;
                    static range(arg0: long, arg1: long): LongStream;
                    static rangeClosed(arg0: long, arg1: long): LongStream;
                    static concat(arg0: LongStream, arg1: LongStream): LongStream;

                }
                interface LongStream extends BaseStream<java.lang.Long, LongStream> {

                    filter(arg0: java.util.function.LongPredicate): LongStream;
                    map(arg0: java.util.function.LongUnaryOperator): LongStream;
                    mapToObj<U>(arg0: java.util.function.LongFunction<U>): Stream<U>;
                    mapToInt(arg0: java.util.function.LongToIntFunction): IntStream;
                    mapToDouble(arg0: java.util.function.LongToDoubleFunction): DoubleStream;
                    flatMap(arg0: java.util.function.LongFunction<LongStream>): LongStream;
                    mapMulti(arg0: LongStream$LongMapMultiConsumer): LongStream;
                    distinct(): LongStream;
                    sorted(): LongStream;
                    peek(arg0: java.util.function.LongConsumer): LongStream;
                    limit(arg0: long): LongStream;
                    skip(arg0: long): LongStream;
                    takeWhile(arg0: java.util.function.LongPredicate): LongStream;
                    dropWhile(arg0: java.util.function.LongPredicate): LongStream;
                    forEach(arg0: java.util.function.LongConsumer): void;
                    forEachOrdered(arg0: java.util.function.LongConsumer): void;
                    toArray(): JavaArray<number>;
                    reduce(arg0: long, arg1: java.util.function.LongBinaryOperator): number;
                    reduce(arg0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                    collect<R>(arg0: MethodWrapper<any, any, R>, arg1: java.util.function.ObjLongConsumer<R>, arg2: MethodWrapper<R, R>): R;
                    sum(): number;
                    min(): java.util.OptionalLong;
                    max(): java.util.OptionalLong;
                    count(): number;
                    average(): java.util.OptionalDouble;
                    summaryStatistics(): java.util.LongSummaryStatistics;
                    anyMatch(arg0: java.util.function.LongPredicate): boolean;
                    allMatch(arg0: java.util.function.LongPredicate): boolean;
                    noneMatch(arg0: java.util.function.LongPredicate): boolean;
                    findFirst(): java.util.OptionalLong;
                    findAny(): java.util.OptionalLong;
                    asDoubleStream(): DoubleStream;
                    boxed(): Stream<number>;
                    sequential(): LongStream;
                    parallel(): LongStream;
                    iterator(): java.util.PrimitiveIterator$OfLong;
                    spliterator(): java.util.Spliterator$OfLong;

                }

                abstract class Stream<T> extends java.lang.Interface {
                    static readonly class: JavaClass<Stream<any>>;
                    /** @deprecated */ static prototype: undefined;

                    static builder<T>(): Stream$Builder<T>;
                    static empty<T>(): Stream<T>;
                    static of<T>(arg0: T): Stream<T>;
                    static ofNullable<T>(arg0: T): Stream<T>;
                    static of<T>(...arg0: JavaVarArgs<T>): Stream<T>;
                    static iterate<T>(arg0: T, arg1: java.util.function.UnaryOperator<T>): Stream<T>;
                    static iterate<T>(arg0: T, arg1: MethodWrapper<T, any, boolean>, arg2: java.util.function.UnaryOperator<T>): Stream<T>;
                    static generate<T>(arg0: MethodWrapper<any, any, T>): Stream<T>;
                    static concat<T>(arg0: Stream<T>, arg1: Stream<T>): Stream<T>;

                }
                interface Stream<T> extends BaseStream<T, Stream<T>> {

                    filter(arg0: MethodWrapper<T, any, boolean>): Stream<T>;
                    map<R>(arg0: MethodWrapper<T, any, R>): Stream<R>;
                    mapToInt(arg0: java.util.function.ToIntFunction<T>): IntStream;
                    mapToLong(arg0: java.util.function.ToLongFunction<T>): LongStream;
                    mapToDouble(arg0: java.util.function.ToDoubleFunction<T>): DoubleStream;
                    flatMap<R>(arg0: MethodWrapper<T, any, Stream<R>>): Stream<R>;
                    flatMapToInt(arg0: MethodWrapper<T, any, IntStream>): IntStream;
                    flatMapToLong(arg0: MethodWrapper<T, any, LongStream>): LongStream;
                    flatMapToDouble(arg0: MethodWrapper<T, any, DoubleStream>): DoubleStream;
                    mapMulti<R>(arg0: MethodWrapper<T, MethodWrapper<R>>): Stream<R>;
                    mapMultiToInt(arg0: MethodWrapper<T, java.util.function.IntConsumer>): IntStream;
                    mapMultiToLong(arg0: MethodWrapper<T, java.util.function.LongConsumer>): LongStream;
                    mapMultiToDouble(arg0: MethodWrapper<T, java.util.function.DoubleConsumer>): DoubleStream;
                    distinct(): Stream<T>;
                    sorted(): Stream<T>;
                    sorted(arg0: MethodWrapper<T, T, int>): Stream<T>;
                    peek(arg0: MethodWrapper<T>): Stream<T>;
                    limit(arg0: long): Stream<T>;
                    skip(arg0: long): Stream<T>;
                    takeWhile(arg0: MethodWrapper<T, any, boolean>): Stream<T>;
                    dropWhile(arg0: MethodWrapper<T, any, boolean>): Stream<T>;
                    forEach(arg0: MethodWrapper<T>): void;
                    forEachOrdered(arg0: MethodWrapper<T>): void;
                    toArray(): JavaArray<any>;
                    toArray<A>(arg0: java.util.function.IntFunction<A[]>): JavaArray<A>;
                    reduce(arg0: T, arg1: java.util.function.BinaryOperator<T>): T;
                    reduce(arg0: java.util.function.BinaryOperator<T>): java.util.Optional<T>;
                    reduce<U>(arg0: U, arg1: MethodWrapper<U, T, U>, arg2: java.util.function.BinaryOperator<U>): U;
                    collect<R>(arg0: MethodWrapper<any, any, R>, arg1: MethodWrapper<R, T>, arg2: MethodWrapper<R, R>): R;
                    collect<R, A>(arg0: Collector<T, A, R>): R;
                    toList(): JavaList<T>;
                    min(arg0: MethodWrapper<T, T, int>): java.util.Optional<T>;
                    max(arg0: MethodWrapper<T, T, int>): java.util.Optional<T>;
                    count(): number;
                    anyMatch(arg0: MethodWrapper<T, any, boolean>): boolean;
                    allMatch(arg0: MethodWrapper<T, any, boolean>): boolean;
                    noneMatch(arg0: MethodWrapper<T, any, boolean>): boolean;
                    findFirst(): java.util.Optional<T>;
                    findAny(): java.util.Optional<T>;

                }

                abstract class IntStream extends java.lang.Interface {
                    static readonly class: JavaClass<IntStream>;
                    /** @deprecated */ static prototype: undefined;

                    static builder(): IntStream$Builder;
                    static empty(): IntStream;
                    static of(arg0: int): IntStream;
                    static of(...arg0: JavaVarArgs<int>): IntStream;
                    static iterate(arg0: int, arg1: java.util.function.IntUnaryOperator): IntStream;
                    static iterate(arg0: int, arg1: java.util.function.IntPredicate, arg2: java.util.function.IntUnaryOperator): IntStream;
                    static generate(arg0: java.util.function.IntSupplier): IntStream;
                    static range(arg0: int, arg1: int): IntStream;
                    static rangeClosed(arg0: int, arg1: int): IntStream;
                    static concat(arg0: IntStream, arg1: IntStream): IntStream;

                }
                interface IntStream extends BaseStream<java.lang.Integer, IntStream> {

                    filter(arg0: java.util.function.IntPredicate): IntStream;
                    map(arg0: java.util.function.IntUnaryOperator): IntStream;
                    mapToObj<U>(arg0: java.util.function.IntFunction<U>): Stream<U>;
                    mapToLong(arg0: java.util.function.IntToLongFunction): LongStream;
                    mapToDouble(arg0: java.util.function.IntToDoubleFunction): DoubleStream;
                    flatMap(arg0: java.util.function.IntFunction<IntStream>): IntStream;
                    mapMulti(arg0: IntStream$IntMapMultiConsumer): IntStream;
                    distinct(): IntStream;
                    sorted(): IntStream;
                    peek(arg0: java.util.function.IntConsumer): IntStream;
                    limit(arg0: long): IntStream;
                    skip(arg0: long): IntStream;
                    takeWhile(arg0: java.util.function.IntPredicate): IntStream;
                    dropWhile(arg0: java.util.function.IntPredicate): IntStream;
                    forEach(arg0: java.util.function.IntConsumer): void;
                    forEachOrdered(arg0: java.util.function.IntConsumer): void;
                    toArray(): JavaArray<number>;
                    reduce(arg0: int, arg1: java.util.function.IntBinaryOperator): number;
                    reduce(arg0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                    collect<R>(arg0: MethodWrapper<any, any, R>, arg1: java.util.function.ObjIntConsumer<R>, arg2: MethodWrapper<R, R>): R;
                    sum(): number;
                    min(): java.util.OptionalInt;
                    max(): java.util.OptionalInt;
                    count(): number;
                    average(): java.util.OptionalDouble;
                    summaryStatistics(): java.util.IntSummaryStatistics;
                    anyMatch(arg0: java.util.function.IntPredicate): boolean;
                    allMatch(arg0: java.util.function.IntPredicate): boolean;
                    noneMatch(arg0: java.util.function.IntPredicate): boolean;
                    findFirst(): java.util.OptionalInt;
                    findAny(): java.util.OptionalInt;
                    asLongStream(): LongStream;
                    asDoubleStream(): DoubleStream;
                    boxed(): Stream<number>;
                    sequential(): IntStream;
                    parallel(): IntStream;
                    iterator(): java.util.PrimitiveIterator$OfInt;
                    spliterator(): java.util.Spliterator$OfInt;

                }

                abstract class LongStream$Builder extends java.lang.Interface {
                    static readonly class: JavaClass<LongStream$Builder>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LongStream$Builder extends java.util.function.LongConsumer {

                    accept(arg0: long): void;
                    add(arg0: long): LongStream$Builder;
                    build(): LongStream;

                }

                abstract class IntStream$Builder extends java.lang.Interface {
                    static readonly class: JavaClass<IntStream$Builder>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntStream$Builder extends java.util.function.IntConsumer {

                    accept(arg0: int): void;
                    add(arg0: int): IntStream$Builder;
                    build(): IntStream;

                }

                abstract class Stream$Builder<T> extends java.lang.Interface {
                    static readonly class: JavaClass<Stream$Builder<any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Stream$Builder<T> extends java.util.function.Consumer<T> {

                    accept(arg0: T): void;
                    add(arg0: T): Stream$Builder<T>;
                    build(): Stream<T>;

                }

                abstract class LongStream$LongMapMultiConsumer extends java.lang.Interface {
                    static readonly class: JavaClass<LongStream$LongMapMultiConsumer>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LongStream$LongMapMultiConsumer {

                    accept(arg0: long, arg1: java.util.function.LongConsumer): void;

                }

                abstract class Collector<T, A, R> extends java.lang.Interface {
                    static readonly class: JavaClass<Collector<any, any, any>>;
                    /** @deprecated */ static prototype: undefined;

                    static of<T, R>(arg0: MethodWrapper<any, any, R>, arg1: MethodWrapper<R, T>, arg2: java.util.function.BinaryOperator<R>, ...arg3: JavaVarArgs<Collector$Characteristics>): Collector<T, R, R>;
                    static of<T, A, R>(arg0: MethodWrapper<any, any, A>, arg1: MethodWrapper<A, T>, arg2: java.util.function.BinaryOperator<A>, arg3: MethodWrapper<A, any, R>, ...arg4: JavaVarArgs<Collector$Characteristics>): Collector<T, A, R>;

                }
                interface Collector<T, A, R> {

                    supplier(): MethodWrapper<any, any, A>;
                    accumulator(): MethodWrapper<A, T>;
                    combiner(): java.util.function.BinaryOperator<A>;
                    finisher(): MethodWrapper<A, any, R>;
                    characteristics(): JavaSet<Collector$Characteristics>;

                }

                abstract class DoubleStream$DoubleMapMultiConsumer extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleStream$DoubleMapMultiConsumer>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DoubleStream$DoubleMapMultiConsumer {

                    accept(arg0: double, arg1: java.util.function.DoubleConsumer): void;

                }

                abstract class DoubleStream$Builder extends java.lang.Interface {
                    static readonly class: JavaClass<DoubleStream$Builder>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DoubleStream$Builder extends java.util.function.DoubleConsumer {

                    accept(arg0: double): void;
                    add(arg0: double): DoubleStream$Builder;
                    build(): DoubleStream;

                }

                abstract class IntStream$IntMapMultiConsumer extends java.lang.Interface {
                    static readonly class: JavaClass<IntStream$IntMapMultiConsumer>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntStream$IntMapMultiConsumer {

                    accept(arg0: int, arg1: java.util.function.IntConsumer): void;

                }

                abstract class BaseStream<T, S extends BaseStream<T, S>> extends java.lang.Interface {
                    static readonly class: JavaClass<BaseStream<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface BaseStream<T, S extends BaseStream<T, S>> extends java.lang.AutoCloseable {

                    iterator(): java.util.Iterator<T>;
                    spliterator(): java.util.Spliterator<T>;
                    isParallel(): boolean;
                    sequential(): S;
                    parallel(): S;
                    unordered(): S;
                    onClose(arg0: MethodWrapper): S;
                    close(): void;

                }

                abstract class Collector$Characteristics extends java.lang.Enum<Collector$Characteristics> {
                    static readonly class: JavaClass<Collector$Characteristics>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly CONCURRENT: Collector$Characteristics;
                    static readonly UNORDERED: Collector$Characteristics;
                    static readonly IDENTITY_FINISH: Collector$Characteristics;

                    static values(): JavaArray<Collector$Characteristics>;
                    static valueOf(arg0: string): Collector$Characteristics;

                }

                export {
                    DoubleStream,
                    LongStream,
                    Stream,
                    IntStream,
                    LongStream$Builder,
                    IntStream$Builder,
                    Stream$Builder,
                    LongStream$LongMapMultiConsumer,
                    Collector,
                    DoubleStream$DoubleMapMultiConsumer,
                    DoubleStream$Builder,
                    IntStream$IntMapMultiConsumer,
                    BaseStream,
                    Collector$Characteristics
                }

            }

        }

    }

    namespace javassist {

        abstract class CtBehavior extends CtMember {
            static readonly class: JavaClass<CtBehavior>;
            /** @deprecated */ static prototype: undefined;

            getLongName(): string;
            getMethodInfo(): javassist.bytecode.MethodInfo;
            getMethodInfo2(): javassist.bytecode.MethodInfo;
            getModifiers(): number;
            setModifiers(arg0: int): void;
            hasAnnotation(arg0: string): boolean;
            hasAnnotation(arg0: JavaClassArg<any>): boolean;
            getAnnotation(arg0: JavaClassArg<any>): any;
            getAnnotations(): JavaArray<any>;
            getAvailableAnnotations(): JavaArray<any>;
            getParameterAnnotations(): JavaArray<JavaArray<any>>;
            getAvailableParameterAnnotations(): JavaArray<JavaArray<any>>;
            getParameterTypes(): JavaArray<CtClass>;
            getSignature(): string;
            getGenericSignature(): string;
            setGenericSignature(arg0: string): void;
            getExceptionTypes(): JavaArray<CtClass>;
            setExceptionTypes(arg0: CtClass[]): void;
            isEmpty(): boolean;
            setBody(arg0: string): void;
            setBody(arg0: string, arg1: string, arg2: string): void;
            getAttribute(arg0: string): JavaArray<number>;
            setAttribute(arg0: string, arg1: byte[]): void;
            useCflow(arg0: string): void;
            addLocalVariable(arg0: string, arg1: CtClass): void;
            insertParameter(arg0: CtClass): void;
            addParameter(arg0: CtClass): void;
            instrument(arg0: CodeConverter): void;
            instrument(arg0: javassist.expr.ExprEditor): void;
            insertBefore(arg0: string): void;
            insertAfter(arg0: string): void;
            insertAfter(arg0: string, arg1: boolean): void;
            insertAfter(arg0: string, arg1: boolean, arg2: boolean): void;
            addCatch(arg0: string, arg1: CtClass): void;
            addCatch(arg0: string, arg1: CtClass, arg2: string): void;
            insertAt(arg0: int, arg1: string): number;
            insertAt(arg0: int, arg1: boolean, arg2: string): number;

        }

        class CtField$Initializer extends java.lang.Object {
            static readonly class: JavaClass<CtField$Initializer>;
            /** @deprecated */ static prototype: undefined;

            static constant(arg0: int): CtField$Initializer;
            static constant(arg0: boolean): CtField$Initializer;
            static constant(arg0: long): CtField$Initializer;
            static constant(arg0: float): CtField$Initializer;
            static constant(arg0: double): CtField$Initializer;
            static constant(arg0: string): CtField$Initializer;
            static byParameter(arg0: int): CtField$Initializer;
            static byNew(arg0: CtClass): CtField$Initializer;
            static byNew(arg0: CtClass, arg1: string[]): CtField$Initializer;
            static byNewWithParams(arg0: CtClass): CtField$Initializer;
            static byNewWithParams(arg0: CtClass, arg1: string[]): CtField$Initializer;
            static byCall(arg0: CtClass, arg1: string): CtField$Initializer;
            static byCall(arg0: CtClass, arg1: string, arg2: string[]): CtField$Initializer;
            static byCallWithParams(arg0: CtClass, arg1: string): CtField$Initializer;
            static byCallWithParams(arg0: CtClass, arg1: string, arg2: string[]): CtField$Initializer;
            static byNewArray(arg0: CtClass, arg1: int): CtField$Initializer;
            static byNewArray(arg0: CtClass, arg1: int[]): CtField$Initializer;
            static byExpr(arg0: string): CtField$Initializer;

            constructor ();

        }

        abstract class CtClass extends java.lang.Object {
            static readonly class: JavaClass<CtClass>;
            /** @deprecated */ static prototype: undefined;

            static debugDump: string;
            static readonly version: string;
            static booleanType: CtClass;
            static charType: CtClass;
            static byteType: CtClass;
            static shortType: CtClass;
            static intType: CtClass;
            static longType: CtClass;
            static floatType: CtClass;
            static doubleType: CtClass;
            static voidType: CtClass;

            static main(arg0: string[]): void;

            getClassPool(): ClassPool;
            getClassFile(): javassist.bytecode.ClassFile;
            getClassFile2(): javassist.bytecode.ClassFile;
            getAccessorMaker(): javassist.compiler.AccessorMaker;
            getURL(): java.net.URL;
            isModified(): boolean;
            isFrozen(): boolean;
            freeze(): void;
            defrost(): void;
            isPrimitive(): boolean;
            isArray(): boolean;
            isKotlin(): boolean;
            getComponentType(): CtClass;
            subtypeOf(arg0: CtClass): boolean;
            getName(): string;
            getSimpleName(): string;
            getPackageName(): string;
            setName(arg0: string): void;
            getGenericSignature(): string;
            setGenericSignature(arg0: string): void;
            replaceClassName(arg0: string, arg1: string): void;
            replaceClassName(arg0: ClassMap): void;
            getRefClasses(): JavaCollection<string>;
            isInterface(): boolean;
            isAnnotation(): boolean;
            isEnum(): boolean;
            getModifiers(): number;
            hasAnnotation(arg0: JavaClassArg<any>): boolean;
            hasAnnotation(arg0: string): boolean;
            getAnnotation(arg0: JavaClassArg<any>): any;
            getAnnotations(): JavaArray<any>;
            getAvailableAnnotations(): JavaArray<any>;
            getDeclaredClasses(): JavaArray<CtClass>;
            getNestedClasses(): JavaArray<CtClass>;
            setModifiers(arg0: int): void;
            subclassOf(arg0: CtClass): boolean;
            getSuperclass(): CtClass;
            setSuperclass(arg0: CtClass): void;
            getInterfaces(): JavaArray<CtClass>;
            setInterfaces(arg0: CtClass[]): void;
            addInterface(arg0: CtClass): void;
            getDeclaringClass(): CtClass;
            /** @deprecated */
            getEnclosingMethod(): CtMethod;
            getEnclosingBehavior(): CtBehavior;
            makeNestedClass(arg0: string, arg1: boolean): CtClass;
            getFields(): JavaArray<CtField>;
            getField(arg0: string): CtField;
            getField(arg0: string, arg1: string): CtField;
            getDeclaredFields(): JavaArray<CtField>;
            getDeclaredField(arg0: string): CtField;
            getDeclaredField(arg0: string, arg1: string): CtField;
            getDeclaredBehaviors(): JavaArray<CtBehavior>;
            getConstructors(): JavaArray<CtConstructor>;
            getConstructor(arg0: string): CtConstructor;
            getDeclaredConstructors(): JavaArray<CtConstructor>;
            getDeclaredConstructor(arg0: CtClass[]): CtConstructor;
            getClassInitializer(): CtConstructor;
            getMethods(): JavaArray<CtMethod>;
            getMethod(arg0: string, arg1: string): CtMethod;
            getDeclaredMethods(): JavaArray<CtMethod>;
            getDeclaredMethod(arg0: string, arg1: CtClass[]): CtMethod;
            getDeclaredMethods(arg0: string): JavaArray<CtMethod>;
            getDeclaredMethod(arg0: string): CtMethod;
            makeClassInitializer(): CtConstructor;
            addConstructor(arg0: CtConstructor): void;
            removeConstructor(arg0: CtConstructor): void;
            addMethod(arg0: CtMethod): void;
            removeMethod(arg0: CtMethod): void;
            addField(arg0: CtField): void;
            addField(arg0: CtField, arg1: string): void;
            addField(arg0: CtField, arg1: CtField$Initializer): void;
            removeField(arg0: CtField): void;
            getAttribute(arg0: string): JavaArray<number>;
            setAttribute(arg0: string, arg1: byte[]): void;
            instrument(arg0: CodeConverter): void;
            instrument(arg0: javassist.expr.ExprEditor): void;
            toClass(): JavaClass<any>;
            toClass(arg0: JavaClassArg<any>): JavaClass<any>;
            toClass(arg0: java.lang.invoke.MethodHandles$Lookup): JavaClass<any>;
            toClass(arg0: java.lang.ClassLoader, arg1: java.security.ProtectionDomain): JavaClass<any>;
            /** @deprecated */
            toClass(arg0: java.lang.ClassLoader): JavaClass<any>;
            detach(): void;
            stopPruning(arg0: boolean): boolean;
            prune(): void;
            rebuildClassFile(): void;
            toBytecode(): JavaArray<number>;
            writeFile(): void;
            writeFile(arg0: string): void;
            debugWriteFile(): void;
            debugWriteFile(arg0: string): void;
            toBytecode(arg0: java.io.DataOutputStream): void;
            makeUniqueName(arg0: string): string;

        }

        class ClassPool extends java.lang.Object {
            static readonly class: JavaClass<ClassPool>;
            /** @deprecated */ static prototype: undefined;

            static doPruning: boolean;
            static releaseUnmodifiedClassFile: boolean;
            static cacheOpenedJarFile: boolean;

            static getDefault(): ClassPool;

            constructor ();
            constructor (arg0: boolean);
            constructor (arg0: ClassPool);

            childFirstLookup: boolean;

            importPackage(arg0: string): void;
            clearImportedPackages(): void;
            getImportedPackages(): java.util.Iterator<string>;
            /** @deprecated */
            recordInvalidClassName(arg0: string): void;
            lookupCflow(arg0: string): JavaArray<any>;
            getAndRename(arg0: string, arg1: string): CtClass;
            get(arg0: string): CtClass;
            getOrNull(arg0: string): CtClass;
            getCtClass(arg0: string): CtClass;
            find(arg0: string): java.net.URL;
            get(arg0: string[]): JavaArray<CtClass>;
            getMethod(arg0: string, arg1: string): CtMethod;
            makeClass(arg0: java.io.InputStream): CtClass;
            makeClass(arg0: java.io.InputStream, arg1: boolean): CtClass;
            makeClass(arg0: javassist.bytecode.ClassFile): CtClass;
            makeClass(arg0: javassist.bytecode.ClassFile, arg1: boolean): CtClass;
            makeClassIfNew(arg0: java.io.InputStream): CtClass;
            makeClass(arg0: string): CtClass;
            makeClass(arg0: string, arg1: CtClass): CtClass;
            makeInterface(arg0: string): CtClass;
            makeInterface(arg0: string, arg1: CtClass): CtClass;
            makeAnnotation(arg0: string): CtClass;
            appendSystemPath(): ClassPath;
            insertClassPath(arg0: ClassPath): ClassPath;
            appendClassPath(arg0: ClassPath): ClassPath;
            insertClassPath(arg0: string): ClassPath;
            appendClassPath(arg0: string): ClassPath;
            removeClassPath(arg0: ClassPath): void;
            appendPathList(arg0: string): void;
            toClass(arg0: CtClass): JavaClass;
            getClassLoader(): java.lang.ClassLoader;
            /** @deprecated */
            toClass(arg0: CtClass, arg1: java.lang.ClassLoader): JavaClass;
            /** @deprecated */
            toClass(arg0: CtClass, arg1: java.lang.ClassLoader, arg2: java.security.ProtectionDomain): JavaClass;
            toClass(arg0: CtClass, arg1: JavaClassArg<any>): JavaClass<any>;
            toClass(arg0: CtClass, arg1: java.lang.invoke.MethodHandles$Lookup): JavaClass<any>;
            toClass(arg0: CtClass, arg1: JavaClassArg<any>, arg2: java.lang.ClassLoader, arg3: java.security.ProtectionDomain): JavaClass;
            /** @deprecated */
            makePackage(arg0: java.lang.ClassLoader, arg1: string): void;

        }

        class CtMethod extends CtBehavior {
            static readonly class: JavaClass<CtMethod>;
            /** @deprecated */ static prototype: undefined;

            static make(arg0: string, arg1: CtClass): CtMethod;
            static make(arg0: javassist.bytecode.MethodInfo, arg1: CtClass): CtMethod;

            constructor (arg0: CtClass, arg1: string, arg2: CtClass[], arg3: CtClass);
            constructor (arg0: CtMethod, arg1: CtClass, arg2: ClassMap);

            getLongName(): string;
            getName(): string;
            setName(arg0: string): void;
            getReturnType(): CtClass;
            isEmpty(): boolean;
            setBody(arg0: CtMethod, arg1: ClassMap): void;
            setBody(arg0: string): void;
            setBody(arg0: string, arg1: string, arg2: string): void;
            setWrappedBody(arg0: CtMethod, arg1: CtMethod$ConstParameter): void;

        }

        class CtField extends CtMember {
            static readonly class: JavaClass<CtField>;
            /** @deprecated */ static prototype: undefined;

            static make(arg0: string, arg1: CtClass): CtField;

            constructor (arg0: CtClass, arg1: string, arg2: CtClass);
            constructor (arg0: CtField, arg1: CtClass);

            getFieldInfo(): javassist.bytecode.FieldInfo;
            getFieldInfo2(): javassist.bytecode.FieldInfo;
            getDeclaringClass(): CtClass;
            getName(): string;
            setName(arg0: string): void;
            getModifiers(): number;
            setModifiers(arg0: int): void;
            hasAnnotation(arg0: string): boolean;
            hasAnnotation(arg0: JavaClassArg<any>): boolean;
            getAnnotation(arg0: JavaClassArg<any>): any;
            getAnnotations(): JavaArray<any>;
            getAvailableAnnotations(): JavaArray<any>;
            getSignature(): string;
            getGenericSignature(): string;
            setGenericSignature(arg0: string): void;
            getType(): CtClass;
            setType(arg0: CtClass): void;
            getConstantValue(): any;
            getAttribute(arg0: string): JavaArray<number>;
            setAttribute(arg0: string, arg1: byte[]): void;

        }

        class CtConstructor extends CtBehavior {
            static readonly class: JavaClass<CtConstructor>;
            /** @deprecated */ static prototype: undefined;

            constructor (arg0: CtClass[], arg1: CtClass);
            constructor (arg0: CtConstructor, arg1: CtClass, arg2: ClassMap);

            isConstructor(): boolean;
            isClassInitializer(): boolean;
            getLongName(): string;
            getName(): string;
            isEmpty(): boolean;
            callsSuper(): boolean;
            setBody(arg0: string): void;
            setBody(arg0: CtConstructor, arg1: ClassMap): void;
            setBody(arg0: string, arg1: string, arg2: string): void;
            insertBeforeBody(arg0: string): void;
            toMethod(arg0: string, arg1: CtClass): CtMethod;
            toMethod(arg0: string, arg1: CtClass, arg2: ClassMap): CtMethod;

        }

        class CodeConverter extends java.lang.Object {
            static readonly class: JavaClass<CodeConverter>;
            /** @deprecated */ static prototype: undefined;

            constructor ();

            replaceNew(arg0: CtClass, arg1: CtClass, arg2: string): void;
            replaceNew(arg0: CtClass, arg1: CtClass): void;
            redirectFieldAccess(arg0: CtField, arg1: CtClass, arg2: string): void;
            replaceFieldRead(arg0: CtField, arg1: CtClass, arg2: string): void;
            replaceFieldWrite(arg0: CtField, arg1: CtClass, arg2: string): void;
            replaceArrayAccess(arg0: CtClass, arg1: CodeConverter$ArrayAccessReplacementMethodNames): void;
            redirectMethodCall(arg0: CtMethod, arg1: CtMethod): void;
            redirectMethodCall(arg0: string, arg1: CtMethod): void;
            redirectMethodCallToStatic(arg0: CtMethod, arg1: CtMethod): void;
            insertBeforeMethod(arg0: CtMethod, arg1: CtMethod): void;
            insertAfterMethod(arg0: CtMethod, arg1: CtMethod): void;

        }

        abstract class CtMember extends java.lang.Object {
            static readonly class: JavaClass<CtMember>;
            /** @deprecated */ static prototype: undefined;

            getDeclaringClass(): CtClass;
            visibleFrom(arg0: CtClass): boolean;
            getModifiers(): number;
            setModifiers(arg0: int): void;
            hasAnnotation(arg0: JavaClassArg<any>): boolean;
            hasAnnotation(arg0: string): boolean;
            getAnnotation(arg0: JavaClassArg<any>): any;
            getAnnotations(): JavaArray<any>;
            getAvailableAnnotations(): JavaArray<any>;
            getName(): string;
            getSignature(): string;
            getGenericSignature(): string;
            setGenericSignature(arg0: string): void;
            getAttribute(arg0: string): JavaArray<number>;
            setAttribute(arg0: string, arg1: byte[]): void;

        }

        class ClassMap extends java.util.HashMap<java.lang.String, java.lang.String> {
            static readonly class: JavaClass<ClassMap>;
            /** @deprecated */ static prototype: undefined;

            static toJvmName(arg0: string): string;
            static toJavaName(arg0: string): string;

            constructor ();

            put(arg0: CtClass, arg1: CtClass): void;
            put(arg0: string, arg1: string): string;
            putIfNone(arg0: string, arg1: string): void;
            get(arg0: any): string;
            fix(arg0: CtClass): void;
            fix(arg0: string): void;

        }

        abstract class ClassPath extends java.lang.Interface {
            static readonly class: JavaClass<ClassPath>;
            /** @deprecated */ static prototype: undefined;
        }
        interface ClassPath {

            openClassfile(arg0: string): java.io.InputStream;
            find(arg0: string): java.net.URL;

        }

        abstract class CtMethod$ConstParameter extends java.lang.Object {
            static readonly class: JavaClass<CtMethod$ConstParameter>;
            /** @deprecated */ static prototype: undefined;

            static integer(arg0: int): CtMethod$ConstParameter;
            static integer(arg0: long): CtMethod$ConstParameter;
            static string(arg0: string): CtMethod$ConstParameter;

        }

        abstract class CodeConverter$ArrayAccessReplacementMethodNames extends java.lang.Interface {
            static readonly class: JavaClass<CodeConverter$ArrayAccessReplacementMethodNames>;
            /** @deprecated */ static prototype: undefined;
        }
        interface CodeConverter$ArrayAccessReplacementMethodNames {

            byteOrBooleanRead(): string;
            byteOrBooleanWrite(): string;
            charRead(): string;
            charWrite(): string;
            doubleRead(): string;
            doubleWrite(): string;
            floatRead(): string;
            floatWrite(): string;
            intRead(): string;
            intWrite(): string;
            longRead(): string;
            longWrite(): string;
            objectRead(): string;
            objectWrite(): string;
            shortRead(): string;
            shortWrite(): string;

        }

        export {
            CtBehavior,
            CtField$Initializer,
            CtClass,
            ClassPool,
            CtMethod,
            CtField,
            CtConstructor,
            CodeConverter,
            CtMember,
            ClassMap,
            ClassPath,
            CtMethod$ConstParameter,
            CodeConverter$ArrayAccessReplacementMethodNames
        }

    }
    namespace javassist {

        namespace bytecode {

            class ClassFile extends java.lang.Object {
                static readonly class: JavaClass<ClassFile>;
                /** @deprecated */ static prototype: undefined;

                static readonly JAVA_1: number;
                static readonly JAVA_2: number;
                static readonly JAVA_3: number;
                static readonly JAVA_4: number;
                static readonly JAVA_5: number;
                static readonly JAVA_6: number;
                static readonly JAVA_7: number;
                static readonly JAVA_8: number;
                static readonly JAVA_9: number;
                static readonly JAVA_10: number;
                static readonly JAVA_11: number;
                static readonly MAJOR_VERSION: number;

                constructor (arg0: java.io.DataInputStream);
                constructor (arg0: boolean, arg1: string, arg2: string);

                compact(): void;
                prune(): void;
                getConstPool(): ConstPool;
                isInterface(): boolean;
                isFinal(): boolean;
                isAbstract(): boolean;
                getAccessFlags(): number;
                setAccessFlags(arg0: int): void;
                getInnerAccessFlags(): number;
                getName(): string;
                setName(arg0: string): void;
                getSuperclass(): string;
                getSuperclassId(): number;
                setSuperclass(arg0: string): void;
                renameClass(arg0: string, arg1: string): void;
                renameClass(arg0: JavaMap<string, string>): void;
                getRefClasses(arg0: JavaMap<string, string>): void;
                getInterfaces(): JavaArray<string>;
                setInterfaces(arg0: string[]): void;
                addInterface(arg0: string): void;
                getFields(): JavaList<FieldInfo>;
                addField(arg0: FieldInfo): void;
                addField2(arg0: FieldInfo): void;
                getMethods(): JavaList<MethodInfo>;
                getMethod(arg0: string): MethodInfo;
                getStaticInitializer(): MethodInfo;
                addMethod(arg0: MethodInfo): void;
                addMethod2(arg0: MethodInfo): void;
                getAttributes(): JavaList<AttributeInfo>;
                getAttribute(arg0: string): AttributeInfo;
                removeAttribute(arg0: string): AttributeInfo;
                addAttribute(arg0: AttributeInfo): void;
                getSourceFile(): string;
                write(arg0: java.io.DataOutputStream): void;
                getMajorVersion(): number;
                setMajorVersion(arg0: int): void;
                getMinorVersion(): number;
                setMinorVersion(arg0: int): void;
                setVersionToJava5(): void;

            }

            class MethodInfo extends java.lang.Object {
                static readonly class: JavaClass<MethodInfo>;
                /** @deprecated */ static prototype: undefined;

                static doPreverify: boolean;
                static readonly nameInit: string;
                static readonly nameClinit: string;

                constructor (arg0: ConstPool, arg1: string, arg2: string);
                constructor (arg0: ConstPool, arg1: string, arg2: MethodInfo, arg3: JavaMap<string, string>);

                getName(): string;
                setName(arg0: string): void;
                isMethod(): boolean;
                getConstPool(): ConstPool;
                isConstructor(): boolean;
                isStaticInitializer(): boolean;
                getAccessFlags(): number;
                setAccessFlags(arg0: int): void;
                getDescriptor(): string;
                setDescriptor(arg0: string): void;
                getAttributes(): JavaList<AttributeInfo>;
                getAttribute(arg0: string): AttributeInfo;
                removeAttribute(arg0: string): AttributeInfo;
                addAttribute(arg0: AttributeInfo): void;
                getExceptionsAttribute(): ExceptionsAttribute;
                getCodeAttribute(): CodeAttribute;
                removeExceptionsAttribute(): void;
                setExceptionsAttribute(arg0: ExceptionsAttribute): void;
                removeCodeAttribute(): void;
                setCodeAttribute(arg0: CodeAttribute): void;
                rebuildStackMapIf6(arg0: javassist.ClassPool, arg1: ClassFile): void;
                rebuildStackMap(arg0: javassist.ClassPool): void;
                rebuildStackMapForME(arg0: javassist.ClassPool): void;
                getLineNumber(arg0: int): number;
                setSuperclass(arg0: string): void;

            }

            abstract class Opcode extends java.lang.Interface {
                static readonly class: JavaClass<Opcode>;
                /** @deprecated */ static prototype: undefined;

                static readonly AALOAD: number;
                static readonly AASTORE: number;
                static readonly ACONST_NULL: number;
                static readonly ALOAD: number;
                static readonly ALOAD_0: number;
                static readonly ALOAD_1: number;
                static readonly ALOAD_2: number;
                static readonly ALOAD_3: number;
                static readonly ANEWARRAY: number;
                static readonly ARETURN: number;
                static readonly ARRAYLENGTH: number;
                static readonly ASTORE: number;
                static readonly ASTORE_0: number;
                static readonly ASTORE_1: number;
                static readonly ASTORE_2: number;
                static readonly ASTORE_3: number;
                static readonly ATHROW: number;
                static readonly BALOAD: number;
                static readonly BASTORE: number;
                static readonly BIPUSH: number;
                static readonly CALOAD: number;
                static readonly CASTORE: number;
                static readonly CHECKCAST: number;
                static readonly D2F: number;
                static readonly D2I: number;
                static readonly D2L: number;
                static readonly DADD: number;
                static readonly DALOAD: number;
                static readonly DASTORE: number;
                static readonly DCMPG: number;
                static readonly DCMPL: number;
                static readonly DCONST_0: number;
                static readonly DCONST_1: number;
                static readonly DDIV: number;
                static readonly DLOAD: number;
                static readonly DLOAD_0: number;
                static readonly DLOAD_1: number;
                static readonly DLOAD_2: number;
                static readonly DLOAD_3: number;
                static readonly DMUL: number;
                static readonly DNEG: number;
                static readonly DREM: number;
                static readonly DRETURN: number;
                static readonly DSTORE: number;
                static readonly DSTORE_0: number;
                static readonly DSTORE_1: number;
                static readonly DSTORE_2: number;
                static readonly DSTORE_3: number;
                static readonly DSUB: number;
                static readonly DUP: number;
                static readonly DUP2: number;
                static readonly DUP2_X1: number;
                static readonly DUP2_X2: number;
                static readonly DUP_X1: number;
                static readonly DUP_X2: number;
                static readonly F2D: number;
                static readonly F2I: number;
                static readonly F2L: number;
                static readonly FADD: number;
                static readonly FALOAD: number;
                static readonly FASTORE: number;
                static readonly FCMPG: number;
                static readonly FCMPL: number;
                static readonly FCONST_0: number;
                static readonly FCONST_1: number;
                static readonly FCONST_2: number;
                static readonly FDIV: number;
                static readonly FLOAD: number;
                static readonly FLOAD_0: number;
                static readonly FLOAD_1: number;
                static readonly FLOAD_2: number;
                static readonly FLOAD_3: number;
                static readonly FMUL: number;
                static readonly FNEG: number;
                static readonly FREM: number;
                static readonly FRETURN: number;
                static readonly FSTORE: number;
                static readonly FSTORE_0: number;
                static readonly FSTORE_1: number;
                static readonly FSTORE_2: number;
                static readonly FSTORE_3: number;
                static readonly FSUB: number;
                static readonly GETFIELD: number;
                static readonly GETSTATIC: number;
                static readonly GOTO: number;
                static readonly GOTO_W: number;
                static readonly I2B: number;
                static readonly I2C: number;
                static readonly I2D: number;
                static readonly I2F: number;
                static readonly I2L: number;
                static readonly I2S: number;
                static readonly IADD: number;
                static readonly IALOAD: number;
                static readonly IAND: number;
                static readonly IASTORE: number;
                static readonly ICONST_0: number;
                static readonly ICONST_1: number;
                static readonly ICONST_2: number;
                static readonly ICONST_3: number;
                static readonly ICONST_4: number;
                static readonly ICONST_5: number;
                static readonly ICONST_M1: number;
                static readonly IDIV: number;
                static readonly IFEQ: number;
                static readonly IFGE: number;
                static readonly IFGT: number;
                static readonly IFLE: number;
                static readonly IFLT: number;
                static readonly IFNE: number;
                static readonly IFNONNULL: number;
                static readonly IFNULL: number;
                static readonly IF_ACMPEQ: number;
                static readonly IF_ACMPNE: number;
                static readonly IF_ICMPEQ: number;
                static readonly IF_ICMPGE: number;
                static readonly IF_ICMPGT: number;
                static readonly IF_ICMPLE: number;
                static readonly IF_ICMPLT: number;
                static readonly IF_ICMPNE: number;
                static readonly IINC: number;
                static readonly ILOAD: number;
                static readonly ILOAD_0: number;
                static readonly ILOAD_1: number;
                static readonly ILOAD_2: number;
                static readonly ILOAD_3: number;
                static readonly IMUL: number;
                static readonly INEG: number;
                static readonly INSTANCEOF: number;
                static readonly INVOKEDYNAMIC: number;
                static readonly INVOKEINTERFACE: number;
                static readonly INVOKESPECIAL: number;
                static readonly INVOKESTATIC: number;
                static readonly INVOKEVIRTUAL: number;
                static readonly IOR: number;
                static readonly IREM: number;
                static readonly IRETURN: number;
                static readonly ISHL: number;
                static readonly ISHR: number;
                static readonly ISTORE: number;
                static readonly ISTORE_0: number;
                static readonly ISTORE_1: number;
                static readonly ISTORE_2: number;
                static readonly ISTORE_3: number;
                static readonly ISUB: number;
                static readonly IUSHR: number;
                static readonly IXOR: number;
                static readonly JSR: number;
                static readonly JSR_W: number;
                static readonly L2D: number;
                static readonly L2F: number;
                static readonly L2I: number;
                static readonly LADD: number;
                static readonly LALOAD: number;
                static readonly LAND: number;
                static readonly LASTORE: number;
                static readonly LCMP: number;
                static readonly LCONST_0: number;
                static readonly LCONST_1: number;
                static readonly LDC: number;
                static readonly LDC2_W: number;
                static readonly LDC_W: number;
                static readonly LDIV: number;
                static readonly LLOAD: number;
                static readonly LLOAD_0: number;
                static readonly LLOAD_1: number;
                static readonly LLOAD_2: number;
                static readonly LLOAD_3: number;
                static readonly LMUL: number;
                static readonly LNEG: number;
                static readonly LOOKUPSWITCH: number;
                static readonly LOR: number;
                static readonly LREM: number;
                static readonly LRETURN: number;
                static readonly LSHL: number;
                static readonly LSHR: number;
                static readonly LSTORE: number;
                static readonly LSTORE_0: number;
                static readonly LSTORE_1: number;
                static readonly LSTORE_2: number;
                static readonly LSTORE_3: number;
                static readonly LSUB: number;
                static readonly LUSHR: number;
                static readonly LXOR: number;
                static readonly MONITORENTER: number;
                static readonly MONITOREXIT: number;
                static readonly MULTIANEWARRAY: number;
                static readonly NEW: number;
                static readonly NEWARRAY: number;
                static readonly NOP: number;
                static readonly POP: number;
                static readonly POP2: number;
                static readonly PUTFIELD: number;
                static readonly PUTSTATIC: number;
                static readonly RET: number;
                static readonly RETURN: number;
                static readonly SALOAD: number;
                static readonly SASTORE: number;
                static readonly SIPUSH: number;
                static readonly SWAP: number;
                static readonly TABLESWITCH: number;
                static readonly WIDE: number;
                static readonly T_BOOLEAN: number;
                static readonly T_CHAR: number;
                static readonly T_FLOAT: number;
                static readonly T_DOUBLE: number;
                static readonly T_BYTE: number;
                static readonly T_SHORT: number;
                static readonly T_INT: number;
                static readonly T_LONG: number;
                static readonly STACK_GROW: JavaArray<number>;
            }
            interface Opcode {}

            class ConstPool extends java.lang.Object {
                static readonly class: JavaClass<ConstPool>;
                /** @deprecated */ static prototype: undefined;

                static readonly CONST_Class: number;
                static readonly CONST_Fieldref: number;
                static readonly CONST_Methodref: number;
                static readonly CONST_InterfaceMethodref: number;
                static readonly CONST_String: number;
                static readonly CONST_Integer: number;
                static readonly CONST_Float: number;
                static readonly CONST_Long: number;
                static readonly CONST_Double: number;
                static readonly CONST_NameAndType: number;
                static readonly CONST_Utf8: number;
                static readonly CONST_MethodHandle: number;
                static readonly CONST_MethodType: number;
                static readonly CONST_Dynamic: number;
                static readonly CONST_DynamicCallSite: number;
                static readonly CONST_InvokeDynamic: number;
                static readonly CONST_Module: number;
                static readonly CONST_Package: number;
                static readonly THIS: javassist.CtClass;
                static readonly REF_getField: number;
                static readonly REF_getStatic: number;
                static readonly REF_putField: number;
                static readonly REF_putStatic: number;
                static readonly REF_invokeVirtual: number;
                static readonly REF_invokeStatic: number;
                static readonly REF_invokeSpecial: number;
                static readonly REF_newInvokeSpecial: number;
                static readonly REF_invokeInterface: number;

                constructor (arg0: string);
                constructor (arg0: java.io.DataInputStream);

                getSize(): number;
                getClassName(): string;
                getThisClassInfo(): number;
                getTag(arg0: int): number;
                getClassInfo(arg0: int): string;
                getClassInfoByDescriptor(arg0: int): string;
                getNameAndTypeName(arg0: int): number;
                getNameAndTypeDescriptor(arg0: int): number;
                getMemberClass(arg0: int): number;
                getMemberNameAndType(arg0: int): number;
                getFieldrefClass(arg0: int): number;
                getFieldrefClassName(arg0: int): string;
                getFieldrefNameAndType(arg0: int): number;
                getFieldrefName(arg0: int): string;
                getFieldrefType(arg0: int): string;
                getMethodrefClass(arg0: int): number;
                getMethodrefClassName(arg0: int): string;
                getMethodrefNameAndType(arg0: int): number;
                getMethodrefName(arg0: int): string;
                getMethodrefType(arg0: int): string;
                getInterfaceMethodrefClass(arg0: int): number;
                getInterfaceMethodrefClassName(arg0: int): string;
                getInterfaceMethodrefNameAndType(arg0: int): number;
                getInterfaceMethodrefName(arg0: int): string;
                getInterfaceMethodrefType(arg0: int): string;
                getLdcValue(arg0: int): any;
                getIntegerInfo(arg0: int): number;
                getFloatInfo(arg0: int): number;
                getLongInfo(arg0: int): number;
                getDoubleInfo(arg0: int): number;
                getStringInfo(arg0: int): string;
                getUtf8Info(arg0: int): string;
                getMethodHandleKind(arg0: int): number;
                getMethodHandleIndex(arg0: int): number;
                getMethodTypeInfo(arg0: int): number;
                getInvokeDynamicBootstrap(arg0: int): number;
                getInvokeDynamicNameAndType(arg0: int): number;
                getInvokeDynamicType(arg0: int): string;
                getDynamicBootstrap(arg0: int): number;
                getDynamicNameAndType(arg0: int): number;
                getDynamicType(arg0: int): string;
                getModuleInfo(arg0: int): string;
                getPackageInfo(arg0: int): string;
                isConstructor(arg0: string, arg1: int): number;
                isMember(arg0: string, arg1: string, arg2: int): number;
                eqMember(arg0: string, arg1: string, arg2: int): string;
                copy(arg0: int, arg1: ConstPool, arg2: JavaMap<string, string>): number;
                addClassInfo(arg0: javassist.CtClass): number;
                addClassInfo(arg0: string): number;
                addNameAndTypeInfo(arg0: string, arg1: string): number;
                addNameAndTypeInfo(arg0: int, arg1: int): number;
                addFieldrefInfo(arg0: int, arg1: string, arg2: string): number;
                addFieldrefInfo(arg0: int, arg1: int): number;
                addMethodrefInfo(arg0: int, arg1: string, arg2: string): number;
                addMethodrefInfo(arg0: int, arg1: int): number;
                addInterfaceMethodrefInfo(arg0: int, arg1: string, arg2: string): number;
                addInterfaceMethodrefInfo(arg0: int, arg1: int): number;
                addStringInfo(arg0: string): number;
                addIntegerInfo(arg0: int): number;
                addFloatInfo(arg0: float): number;
                addLongInfo(arg0: long): number;
                addDoubleInfo(arg0: double): number;
                addUtf8Info(arg0: string): number;
                addMethodHandleInfo(arg0: int, arg1: int): number;
                addMethodTypeInfo(arg0: int): number;
                addInvokeDynamicInfo(arg0: int, arg1: int): number;
                addDynamicInfo(arg0: int, arg1: int): number;
                addModuleInfo(arg0: int): number;
                addPackageInfo(arg0: int): number;
                getClassNames(): JavaSet<string>;
                renameClass(arg0: string, arg1: string): void;
                renameClass(arg0: JavaMap<string, string>): void;
                write(arg0: java.io.DataOutputStream): void;
                print(): void;
                print(arg0: java.io.PrintWriter): void;

            }

            class FieldInfo extends java.lang.Object {
                static readonly class: JavaClass<FieldInfo>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: ConstPool, arg1: string, arg2: string);

                getConstPool(): ConstPool;
                getName(): string;
                setName(arg0: string): void;
                getAccessFlags(): number;
                setAccessFlags(arg0: int): void;
                getDescriptor(): string;
                setDescriptor(arg0: string): void;
                getConstantValue(): number;
                getAttributes(): JavaList<AttributeInfo>;
                getAttribute(arg0: string): AttributeInfo;
                removeAttribute(arg0: string): AttributeInfo;
                addAttribute(arg0: AttributeInfo): void;

            }

            class ExceptionsAttribute extends AttributeInfo {
                static readonly class: JavaClass<ExceptionsAttribute>;
                /** @deprecated */ static prototype: undefined;

                static readonly tag: string;

                constructor (arg0: ConstPool);

                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;
                getExceptionIndexes(): JavaArray<number>;
                getExceptions(): JavaArray<string>;
                setExceptionIndexes(arg0: int[]): void;
                setExceptions(arg0: string[]): void;
                tableLength(): number;
                getException(arg0: int): number;

            }

            interface CodeAttribute extends Opcode {}
            class CodeAttribute extends AttributeInfo {
                static readonly class: JavaClass<CodeAttribute>;
                /** @deprecated */ static prototype: undefined;

                static readonly tag: string;

                constructor (arg0: ConstPool, arg1: int, arg2: int, arg3: byte[], arg4: ExceptionTable);

                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;
                length(): number;
                get(): JavaArray<number>;
                set(arg0: byte[]): void;
                getDeclaringClass(): string;
                getMaxStack(): number;
                setMaxStack(arg0: int): void;
                computeMaxStack(): number;
                getMaxLocals(): number;
                setMaxLocals(arg0: int): void;
                getCodeLength(): number;
                getCode(): JavaArray<number>;
                iterator(): CodeIterator;
                getExceptionTable(): ExceptionTable;
                getAttributes(): JavaList<AttributeInfo>;
                getAttribute(arg0: string): AttributeInfo;
                setAttribute(arg0: StackMapTable): void;
                setAttribute(arg0: StackMap): void;
                insertLocalVar(arg0: int, arg1: int): void;

            }

            class AttributeInfo extends java.lang.Object {
                static readonly class: JavaClass<AttributeInfo>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: ConstPool, arg1: string, arg2: byte[]);

                getName(): string;
                getConstPool(): ConstPool;
                length(): number;
                get(): JavaArray<number>;
                set(arg0: byte[]): void;
                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;

            }

            interface ExceptionTable extends java.lang.Cloneable {}
            class ExceptionTable extends java.lang.Object {
                static readonly class: JavaClass<ExceptionTable>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: ConstPool);

                clone(): any;
                size(): number;
                startPc(arg0: int): number;
                setStartPc(arg0: int, arg1: int): void;
                endPc(arg0: int): number;
                setEndPc(arg0: int, arg1: int): void;
                handlerPc(arg0: int): number;
                setHandlerPc(arg0: int, arg1: int): void;
                catchType(arg0: int): number;
                setCatchType(arg0: int, arg1: int): void;
                add(arg0: int, arg1: ExceptionTable, arg2: int): void;
                add(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int): void;
                add(arg0: int, arg1: int, arg2: int, arg3: int): void;
                remove(arg0: int): void;
                copy(arg0: ConstPool, arg1: JavaMap<string, string>): ExceptionTable;

            }

            abstract class StackMapTable extends AttributeInfo {
                static readonly class: JavaClass<StackMapTable>;
                /** @deprecated */ static prototype: undefined;

                static readonly tag: string;
                static readonly TOP: number;
                static readonly INTEGER: number;
                static readonly FLOAT: number;
                static readonly DOUBLE: number;
                static readonly LONG: number;
                static readonly NULL: number;
                static readonly THIS: number;
                static readonly OBJECT: number;
                static readonly UNINIT: number;

                static typeTagOf(arg0: char): number;

                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;
                insertLocal(arg0: int, arg1: int, arg2: int): void;
                println(arg0: java.io.PrintWriter): void;
                println(arg0: java.io.PrintStream): void;
                removeNew(arg0: int): void;

            }

            abstract class StackMap extends AttributeInfo {
                static readonly class: JavaClass<StackMap>;
                /** @deprecated */ static prototype: undefined;

                static readonly tag: string;
                static readonly TOP: number;
                static readonly INTEGER: number;
                static readonly FLOAT: number;
                static readonly DOUBLE: number;
                static readonly LONG: number;
                static readonly NULL: number;
                static readonly THIS: number;
                static readonly OBJECT: number;
                static readonly UNINIT: number;

                numOfEntries(): number;
                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;
                insertLocal(arg0: int, arg1: int, arg2: int): void;
                removeNew(arg0: int): void;
                print(arg0: java.io.PrintWriter): void;

            }

            interface CodeIterator extends Opcode {}
            abstract class CodeIterator extends java.lang.Object {
                static readonly class: JavaClass<CodeIterator>;
                /** @deprecated */ static prototype: undefined;

                begin(): void;
                move(arg0: int): void;
                setMark(arg0: int): void;
                setMark2(arg0: int): void;
                getMark(): number;
                getMark2(): number;
                get(): CodeAttribute;
                getCodeLength(): number;
                byteAt(arg0: int): number;
                signedByteAt(arg0: int): number;
                writeByte(arg0: int, arg1: int): void;
                u16bitAt(arg0: int): number;
                s16bitAt(arg0: int): number;
                write16bit(arg0: int, arg1: int): void;
                s32bitAt(arg0: int): number;
                write32bit(arg0: int, arg1: int): void;
                write(arg0: byte[], arg1: int): void;
                hasNext(): boolean;
                next(): number;
                lookAhead(): number;
                skipConstructor(): number;
                skipSuperConstructor(): number;
                skipThisConstructor(): number;
                insert(arg0: byte[]): number;
                insert(arg0: int, arg1: byte[]): void;
                insertAt(arg0: int, arg1: byte[]): number;
                insertEx(arg0: byte[]): number;
                insertEx(arg0: int, arg1: byte[]): void;
                insertExAt(arg0: int, arg1: byte[]): number;
                insertGap(arg0: int): number;
                insertGap(arg0: int, arg1: int): number;
                insertExGap(arg0: int): number;
                insertExGap(arg0: int, arg1: int): number;
                insertGapAt(arg0: int, arg1: int, arg2: boolean): CodeIterator$Gap;
                insert(arg0: ExceptionTable, arg1: int): void;
                append(arg0: byte[]): number;
                appendGap(arg0: int): void;
                append(arg0: ExceptionTable, arg1: int): void;

            }

            class CodeIterator$Gap extends java.lang.Object {
                static readonly class: JavaClass<CodeIterator$Gap>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

                position: number;
                length: number;
            }

            export {
                ClassFile,
                MethodInfo,
                Opcode,
                ConstPool,
                FieldInfo,
                ExceptionsAttribute,
                CodeAttribute,
                AttributeInfo,
                ExceptionTable,
                StackMapTable,
                StackMap,
                CodeIterator,
                CodeIterator$Gap
            }

        }

        namespace compiler {

            class AccessorMaker extends java.lang.Object {
                static readonly class: JavaClass<AccessorMaker>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: javassist.CtClass);

                getConstructor(arg0: javassist.CtClass, arg1: string, arg2: javassist.bytecode.MethodInfo): string;
                getMethodAccessor(arg0: string, arg1: string, arg2: string, arg3: javassist.bytecode.MethodInfo): string;
                getFieldGetter(arg0: javassist.bytecode.FieldInfo, arg1: boolean): javassist.bytecode.MethodInfo;
                getFieldSetter(arg0: javassist.bytecode.FieldInfo, arg1: boolean): javassist.bytecode.MethodInfo;

            }

            export { AccessorMaker }

        }

        namespace expr {

            class ExprEditor extends java.lang.Object {
                static readonly class: JavaClass<ExprEditor>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

                doit(arg0: javassist.CtClass, arg1: javassist.bytecode.MethodInfo): boolean;
                edit(arg0: NewExpr): void;
                edit(arg0: NewArray): void;
                edit(arg0: MethodCall): void;
                edit(arg0: ConstructorCall): void;
                edit(arg0: FieldAccess): void;
                edit(arg0: Instanceof): void;
                edit(arg0: Cast): void;
                edit(arg0: Handler): void;

            }

            abstract class Cast extends Expr {
                static readonly class: JavaClass<Cast>;
                /** @deprecated */ static prototype: undefined;

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                getType(): javassist.CtClass;
                mayThrow(): JavaArray<javassist.CtClass>;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;

            }

            abstract class ConstructorCall extends MethodCall {
                static readonly class: JavaClass<ConstructorCall>;
                /** @deprecated */ static prototype: undefined;

                getMethodName(): string;
                getMethod(): javassist.CtMethod;
                getConstructor(): javassist.CtConstructor;
                isSuper(): boolean;

            }

            abstract class MethodCall extends Expr {
                static readonly class: JavaClass<MethodCall>;
                /** @deprecated */ static prototype: undefined;

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                getClassName(): string;
                getMethodName(): string;
                getMethod(): javassist.CtMethod;
                getSignature(): string;
                mayThrow(): JavaArray<javassist.CtClass>;
                isSuper(): boolean;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;

            }

            abstract class NewArray extends Expr {
                static readonly class: JavaClass<NewArray>;
                /** @deprecated */ static prototype: undefined;

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                mayThrow(): JavaArray<javassist.CtClass>;
                getComponentType(): javassist.CtClass;
                getDimension(): number;
                getCreatedDimensions(): number;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;

            }

            abstract class NewExpr extends Expr {
                static readonly class: JavaClass<NewExpr>;
                /** @deprecated */ static prototype: undefined;

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                getClassName(): string;
                getSignature(): string;
                getConstructor(): javassist.CtConstructor;
                mayThrow(): JavaArray<javassist.CtClass>;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;

            }

            abstract class Instanceof extends Expr {
                static readonly class: JavaClass<Instanceof>;
                /** @deprecated */ static prototype: undefined;

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                getType(): javassist.CtClass;
                mayThrow(): JavaArray<javassist.CtClass>;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;

            }

            abstract class FieldAccess extends Expr {
                static readonly class: JavaClass<FieldAccess>;
                /** @deprecated */ static prototype: undefined;

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                isStatic(): boolean;
                isReader(): boolean;
                isWriter(): boolean;
                getClassName(): string;
                getFieldName(): string;
                getField(): javassist.CtField;
                mayThrow(): JavaArray<javassist.CtClass>;
                getSignature(): string;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;

            }

            abstract class Handler extends Expr {
                static readonly class: JavaClass<Handler>;
                /** @deprecated */ static prototype: undefined;

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                mayThrow(): JavaArray<javassist.CtClass>;
                getType(): javassist.CtClass;
                isFinally(): boolean;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;
                insertBefore(arg0: string): void;

            }

            interface Expr extends javassist.bytecode.Opcode {}
            abstract class Expr extends java.lang.Object {
                static readonly class: JavaClass<Expr>;
                /** @deprecated */ static prototype: undefined;

                getEnclosingClass(): javassist.CtClass;
                where(): javassist.CtBehavior;
                mayThrow(): JavaArray<javassist.CtClass>;
                indexOfBytecode(): number;
                getLineNumber(): number;
                getFileName(): string;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;

            }

            export {
                ExprEditor,
                Cast,
                ConstructorCall,
                MethodCall,
                NewArray,
                NewExpr,
                Instanceof,
                FieldAccess,
                Handler,
                Expr
            }

        }

        namespace util.proxy {

            class ProxyFactory extends java.lang.Object {
                static readonly class: JavaClass<ProxyFactory>;
                /** @deprecated */ static prototype: undefined;

                static onlyPublicMethods: boolean;
                static useCache: boolean;
                static useWriteReplace: boolean;
                static classLoaderProvider: ProxyFactory$ClassLoaderProvider;
                static nameGenerator: ProxyFactory$UniqueName;

                static isProxyClass(arg0: JavaClassArg<any>): boolean;
                static getHandler(arg0: Proxy): MethodHandler;

                constructor ();

                writeDirectory: string;

                isUseCache(): boolean;
                setUseCache(arg0: boolean): void;
                isUseWriteReplace(): boolean;
                setUseWriteReplace(arg0: boolean): void;
                setSuperclass(arg0: JavaClassArg<any>): void;
                getSuperclass(): JavaClass<any>;
                setInterfaces(arg0: JavaClassArg<any>[]): void;
                getInterfaces(): JavaArray<JavaClass<any>>;
                setFilter(arg0: MethodFilter): void;
                setGenericSignature(arg0: string): void;
                createClass(): JavaClass<any>;
                createClass(arg0: MethodFilter): JavaClass<any>;
                createClass(arg0: java.lang.invoke.MethodHandles$Lookup): JavaClass<any>;
                createClass(arg0: java.lang.invoke.MethodHandles$Lookup, arg1: MethodFilter): JavaClass<any>;
                getKey(arg0: JavaClassArg<any>, arg1: JavaClassArg<any>[], arg2: byte[], arg3: boolean): string;
                create(arg0: JavaClassArg<any>[], arg1: any[], arg2: MethodHandler): any;
                create(arg0: JavaClassArg<any>[], arg1: any[]): any;
                /** @deprecated */
                setHandler(arg0: MethodHandler): void;

            }

            abstract class Proxy extends java.lang.Interface {
                static readonly class: JavaClass<Proxy>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Proxy {

                setHandler(arg0: MethodHandler): void;

            }

            abstract class ProxyFactory$ClassLoaderProvider extends java.lang.Interface {
                static readonly class: JavaClass<ProxyFactory$ClassLoaderProvider>;
                /** @deprecated */ static prototype: undefined;
            }
            interface ProxyFactory$ClassLoaderProvider {

                get(arg0: ProxyFactory): java.lang.ClassLoader;

            }

            abstract class MethodHandler extends java.lang.Interface {
                static readonly class: JavaClass<MethodHandler>;
                /** @deprecated */ static prototype: undefined;
            }
            interface MethodHandler {

                invoke(arg0: any, arg1: java.lang.reflect.Method, arg2: java.lang.reflect.Method, arg3: any[]): any;

            }

            abstract class MethodFilter extends java.lang.Interface {
                static readonly class: JavaClass<MethodFilter>;
                /** @deprecated */ static prototype: undefined;
            }
            interface MethodFilter {

                isHandled(arg0: java.lang.reflect.Method): boolean;

            }

            abstract class ProxyFactory$UniqueName extends java.lang.Interface {
                static readonly class: JavaClass<ProxyFactory$UniqueName>;
                /** @deprecated */ static prototype: undefined;
            }
            interface ProxyFactory$UniqueName {

                get(arg0: string): string;

            }

            export {
                ProxyFactory,
                Proxy,
                ProxyFactory$ClassLoaderProvider,
                MethodHandler,
                MethodFilter,
                ProxyFactory$UniqueName
            }

        }

    }

    namespace javax {

        namespace accessibility {

            abstract class AccessibleContext extends java.lang.Object {
                static readonly class: JavaClass<AccessibleContext>;
                /** @deprecated */ static prototype: undefined;

                static readonly ACCESSIBLE_NAME_PROPERTY: string;
                static readonly ACCESSIBLE_DESCRIPTION_PROPERTY: string;
                static readonly ACCESSIBLE_STATE_PROPERTY: string;
                static readonly ACCESSIBLE_VALUE_PROPERTY: string;
                static readonly ACCESSIBLE_SELECTION_PROPERTY: string;
                static readonly ACCESSIBLE_CARET_PROPERTY: string;
                static readonly ACCESSIBLE_VISIBLE_DATA_PROPERTY: string;
                static readonly ACCESSIBLE_CHILD_PROPERTY: string;
                static readonly ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY: string;
                static readonly ACCESSIBLE_TABLE_CAPTION_CHANGED: string;
                static readonly ACCESSIBLE_TABLE_SUMMARY_CHANGED: string;
                static readonly ACCESSIBLE_TABLE_MODEL_CHANGED: string;
                static readonly ACCESSIBLE_TABLE_ROW_HEADER_CHANGED: string;
                static readonly ACCESSIBLE_TABLE_ROW_DESCRIPTION_CHANGED: string;
                static readonly ACCESSIBLE_TABLE_COLUMN_HEADER_CHANGED: string;
                static readonly ACCESSIBLE_TABLE_COLUMN_DESCRIPTION_CHANGED: string;
                static readonly ACCESSIBLE_ACTION_PROPERTY: string;
                static readonly ACCESSIBLE_HYPERTEXT_OFFSET: string;
                static readonly ACCESSIBLE_TEXT_PROPERTY: string;
                static readonly ACCESSIBLE_INVALIDATE_CHILDREN: string;
                static readonly ACCESSIBLE_TEXT_ATTRIBUTES_CHANGED: string;
                static readonly ACCESSIBLE_COMPONENT_BOUNDS_CHANGED: string;

                getAccessibleName(): string;
                setAccessibleName(arg0: string): void;
                getAccessibleDescription(): string;
                setAccessibleDescription(arg0: string): void;
                getAccessibleRole(): AccessibleRole;
                getAccessibleStateSet(): AccessibleStateSet;
                getAccessibleParent(): Accessible;
                setAccessibleParent(arg0: Accessible): void;
                getAccessibleIndexInParent(): number;
                getAccessibleChildrenCount(): number;
                getAccessibleChild(arg0: int): Accessible;
                getLocale(): java.util.Locale;
                addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                removePropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                getAccessibleAction(): AccessibleAction;
                getAccessibleComponent(): AccessibleComponent;
                getAccessibleSelection(): AccessibleSelection;
                getAccessibleText(): AccessibleText;
                getAccessibleEditableText(): AccessibleEditableText;
                getAccessibleValue(): AccessibleValue;
                getAccessibleIcon(): JavaArray<AccessibleIcon>;
                getAccessibleRelationSet(): AccessibleRelationSet;
                getAccessibleTable(): AccessibleTable;
                firePropertyChange(arg0: string, arg1: any, arg2: any): void;

            }

            abstract class Accessible extends java.lang.Interface {
                static readonly class: JavaClass<Accessible>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Accessible {

                getAccessibleContext(): AccessibleContext;

            }

            abstract class AccessibleRole extends AccessibleBundle {
                static readonly class: JavaClass<AccessibleRole>;
                /** @deprecated */ static prototype: undefined;

                static readonly ALERT: AccessibleRole;
                static readonly COLUMN_HEADER: AccessibleRole;
                static readonly CANVAS: AccessibleRole;
                static readonly COMBO_BOX: AccessibleRole;
                static readonly DESKTOP_ICON: AccessibleRole;
                static readonly HTML_CONTAINER: AccessibleRole;
                static readonly INTERNAL_FRAME: AccessibleRole;
                static readonly DESKTOP_PANE: AccessibleRole;
                static readonly OPTION_PANE: AccessibleRole;
                static readonly WINDOW: AccessibleRole;
                static readonly FRAME: AccessibleRole;
                static readonly DIALOG: AccessibleRole;
                static readonly COLOR_CHOOSER: AccessibleRole;
                static readonly DIRECTORY_PANE: AccessibleRole;
                static readonly FILE_CHOOSER: AccessibleRole;
                static readonly FILLER: AccessibleRole;
                static readonly HYPERLINK: AccessibleRole;
                static readonly ICON: AccessibleRole;
                static readonly LABEL: AccessibleRole;
                static readonly ROOT_PANE: AccessibleRole;
                static readonly GLASS_PANE: AccessibleRole;
                static readonly LAYERED_PANE: AccessibleRole;
                static readonly LIST: AccessibleRole;
                static readonly LIST_ITEM: AccessibleRole;
                static readonly MENU_BAR: AccessibleRole;
                static readonly POPUP_MENU: AccessibleRole;
                static readonly MENU: AccessibleRole;
                static readonly MENU_ITEM: AccessibleRole;
                static readonly SEPARATOR: AccessibleRole;
                static readonly PAGE_TAB_LIST: AccessibleRole;
                static readonly PAGE_TAB: AccessibleRole;
                static readonly PANEL: AccessibleRole;
                static readonly PROGRESS_BAR: AccessibleRole;
                static readonly PASSWORD_TEXT: AccessibleRole;
                static readonly PUSH_BUTTON: AccessibleRole;
                static readonly TOGGLE_BUTTON: AccessibleRole;
                static readonly CHECK_BOX: AccessibleRole;
                static readonly RADIO_BUTTON: AccessibleRole;
                static readonly ROW_HEADER: AccessibleRole;
                static readonly SCROLL_PANE: AccessibleRole;
                static readonly SCROLL_BAR: AccessibleRole;
                static readonly VIEWPORT: AccessibleRole;
                static readonly SLIDER: AccessibleRole;
                static readonly SPLIT_PANE: AccessibleRole;
                static readonly TABLE: AccessibleRole;
                static readonly TEXT: AccessibleRole;
                static readonly TREE: AccessibleRole;
                static readonly TOOL_BAR: AccessibleRole;
                static readonly TOOL_TIP: AccessibleRole;
                static readonly AWT_COMPONENT: AccessibleRole;
                static readonly SWING_COMPONENT: AccessibleRole;
                static readonly UNKNOWN: AccessibleRole;
                static readonly STATUS_BAR: AccessibleRole;
                static readonly DATE_EDITOR: AccessibleRole;
                static readonly SPIN_BOX: AccessibleRole;
                static readonly FONT_CHOOSER: AccessibleRole;
                static readonly GROUP_BOX: AccessibleRole;
                static readonly HEADER: AccessibleRole;
                static readonly FOOTER: AccessibleRole;
                static readonly PARAGRAPH: AccessibleRole;
                static readonly RULER: AccessibleRole;
                static readonly EDITBAR: AccessibleRole;
                static readonly PROGRESS_MONITOR: AccessibleRole;
            }

            abstract class AccessibleAction extends java.lang.Interface {
                static readonly class: JavaClass<AccessibleAction>;
                /** @deprecated */ static prototype: undefined;

                static readonly TOGGLE_EXPAND: string;
                static readonly INCREMENT: string;
                static readonly DECREMENT: string;
                static readonly CLICK: string;
                static readonly TOGGLE_POPUP: string;
            }
            interface AccessibleAction {

                getAccessibleActionCount(): number;
                getAccessibleActionDescription(arg0: int): string;
                doAccessibleAction(arg0: int): boolean;

            }

            abstract class AccessibleIcon extends java.lang.Interface {
                static readonly class: JavaClass<AccessibleIcon>;
                /** @deprecated */ static prototype: undefined;
            }
            interface AccessibleIcon {

                getAccessibleIconDescription(): string;
                setAccessibleIconDescription(arg0: string): void;
                getAccessibleIconWidth(): number;
                getAccessibleIconHeight(): number;

            }

            abstract class AccessibleText extends java.lang.Interface {
                static readonly class: JavaClass<AccessibleText>;
                /** @deprecated */ static prototype: undefined;

                static readonly CHARACTER: number;
                static readonly WORD: number;
                static readonly SENTENCE: number;
            }
            interface AccessibleText {

                getIndexAtPoint(arg0: java.awt.Point): number;
                getCharacterBounds(arg0: int): java.awt.Rectangle;
                getCharCount(): number;
                getCaretPosition(): number;
                getAtIndex(arg0: int, arg1: int): string;
                getAfterIndex(arg0: int, arg1: int): string;
                getBeforeIndex(arg0: int, arg1: int): string;
                getCharacterAttribute(arg0: int): javax.swing.text.AttributeSet;
                getSelectionStart(): number;
                getSelectionEnd(): number;
                getSelectedText(): string;

            }

            abstract class AccessibleEditableText extends java.lang.Interface {
                static readonly class: JavaClass<AccessibleEditableText>;
                /** @deprecated */ static prototype: undefined;
            }
            interface AccessibleEditableText extends AccessibleText {

                setTextContents(arg0: string): void;
                insertTextAtIndex(arg0: int, arg1: string): void;
                getTextRange(arg0: int, arg1: int): string;
                delete(arg0: int, arg1: int): void;
                cut(arg0: int, arg1: int): void;
                paste(arg0: int): void;
                replaceText(arg0: int, arg1: int, arg2: string): void;
                selectText(arg0: int, arg1: int): void;
                setAttributes(arg0: int, arg1: int, arg2: javax.swing.text.AttributeSet): void;

            }

            class AccessibleStateSet extends java.lang.Object {
                static readonly class: JavaClass<AccessibleStateSet>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: AccessibleState[]);

                add(arg0: AccessibleState): boolean;
                addAll(arg0: AccessibleState[]): void;
                remove(arg0: AccessibleState): boolean;
                clear(): void;
                contains(arg0: AccessibleState): boolean;
                toArray(): JavaArray<AccessibleState>;

            }

            abstract class AccessibleComponent extends java.lang.Interface {
                static readonly class: JavaClass<AccessibleComponent>;
                /** @deprecated */ static prototype: undefined;
            }
            interface AccessibleComponent {

                getBackground(): java.awt.Color;
                setBackground(arg0: java.awt.Color): void;
                getForeground(): java.awt.Color;
                setForeground(arg0: java.awt.Color): void;
                getCursor(): java.awt.Cursor;
                setCursor(arg0: java.awt.Cursor): void;
                getFont(): java.awt.Font;
                setFont(arg0: java.awt.Font): void;
                getFontMetrics(arg0: java.awt.Font): java.awt.FontMetrics;
                isEnabled(): boolean;
                setEnabled(arg0: boolean): void;
                isVisible(): boolean;
                setVisible(arg0: boolean): void;
                isShowing(): boolean;
                contains(arg0: java.awt.Point): boolean;
                getLocationOnScreen(): java.awt.Point;
                getLocation(): java.awt.Point;
                setLocation(arg0: java.awt.Point): void;
                getBounds(): java.awt.Rectangle;
                setBounds(arg0: java.awt.Rectangle): void;
                getSize(): java.awt.Dimension;
                setSize(arg0: java.awt.Dimension): void;
                getAccessibleAt(arg0: java.awt.Point): Accessible;
                isFocusTraversable(): boolean;
                requestFocus(): void;
                addFocusListener(arg0: java.awt.event.FocusListener): void;
                removeFocusListener(arg0: java.awt.event.FocusListener): void;

            }

            abstract class AccessibleValue extends java.lang.Interface {
                static readonly class: JavaClass<AccessibleValue>;
                /** @deprecated */ static prototype: undefined;
            }
            interface AccessibleValue {

                getCurrentAccessibleValue(): number;
                setCurrentAccessibleValue(arg0: number): boolean;
                getMinimumAccessibleValue(): number;
                getMaximumAccessibleValue(): number;

            }

            class AccessibleRelationSet extends java.lang.Object {
                static readonly class: JavaClass<AccessibleRelationSet>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: AccessibleRelation[]);

                add(arg0: AccessibleRelation): boolean;
                addAll(arg0: AccessibleRelation[]): void;
                remove(arg0: AccessibleRelation): boolean;
                clear(): void;
                size(): number;
                contains(arg0: string): boolean;
                get(arg0: string): AccessibleRelation;
                toArray(): JavaArray<AccessibleRelation>;

            }

            abstract class AccessibleSelection extends java.lang.Interface {
                static readonly class: JavaClass<AccessibleSelection>;
                /** @deprecated */ static prototype: undefined;
            }
            interface AccessibleSelection {

                getAccessibleSelectionCount(): number;
                getAccessibleSelection(arg0: int): Accessible;
                isAccessibleChildSelected(arg0: int): boolean;
                addAccessibleSelection(arg0: int): void;
                removeAccessibleSelection(arg0: int): void;
                clearAccessibleSelection(): void;
                selectAllAccessibleSelection(): void;

            }

            abstract class AccessibleTable extends java.lang.Interface {
                static readonly class: JavaClass<AccessibleTable>;
                /** @deprecated */ static prototype: undefined;
            }
            interface AccessibleTable {

                getAccessibleCaption(): Accessible;
                setAccessibleCaption(arg0: Accessible): void;
                getAccessibleSummary(): Accessible;
                setAccessibleSummary(arg0: Accessible): void;
                getAccessibleRowCount(): number;
                getAccessibleColumnCount(): number;
                getAccessibleAt(arg0: int, arg1: int): Accessible;
                getAccessibleRowExtentAt(arg0: int, arg1: int): number;
                getAccessibleColumnExtentAt(arg0: int, arg1: int): number;
                getAccessibleRowHeader(): AccessibleTable;
                setAccessibleRowHeader(arg0: AccessibleTable): void;
                getAccessibleColumnHeader(): AccessibleTable;
                setAccessibleColumnHeader(arg0: AccessibleTable): void;
                getAccessibleRowDescription(arg0: int): Accessible;
                setAccessibleRowDescription(arg0: int, arg1: Accessible): void;
                getAccessibleColumnDescription(arg0: int): Accessible;
                setAccessibleColumnDescription(arg0: int, arg1: Accessible): void;
                isAccessibleSelected(arg0: int, arg1: int): boolean;
                isAccessibleRowSelected(arg0: int): boolean;
                isAccessibleColumnSelected(arg0: int): boolean;
                getSelectedAccessibleRows(): JavaArray<number>;
                getSelectedAccessibleColumns(): JavaArray<number>;

            }

            class AccessibleBundle extends java.lang.Object {
                static readonly class: JavaClass<AccessibleBundle>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

                toDisplayString(arg0: java.util.Locale): string;
                toDisplayString(): string;

            }

            class AccessibleRelation extends AccessibleBundle {
                static readonly class: JavaClass<AccessibleRelation>;
                /** @deprecated */ static prototype: undefined;

                static readonly LABEL_FOR: string;
                static readonly LABELED_BY: string;
                static readonly MEMBER_OF: string;
                static readonly CONTROLLER_FOR: string;
                static readonly CONTROLLED_BY: string;
                static readonly FLOWS_TO: string;
                static readonly FLOWS_FROM: string;
                static readonly SUBWINDOW_OF: string;
                static readonly PARENT_WINDOW_OF: string;
                static readonly EMBEDS: string;
                static readonly EMBEDDED_BY: string;
                static readonly CHILD_NODE_OF: string;
                static readonly LABEL_FOR_PROPERTY: string;
                static readonly LABELED_BY_PROPERTY: string;
                static readonly MEMBER_OF_PROPERTY: string;
                static readonly CONTROLLER_FOR_PROPERTY: string;
                static readonly CONTROLLED_BY_PROPERTY: string;
                static readonly FLOWS_TO_PROPERTY: string;
                static readonly FLOWS_FROM_PROPERTY: string;
                static readonly SUBWINDOW_OF_PROPERTY: string;
                static readonly PARENT_WINDOW_OF_PROPERTY: string;
                static readonly EMBEDS_PROPERTY: string;
                static readonly EMBEDDED_BY_PROPERTY: string;
                static readonly CHILD_NODE_OF_PROPERTY: string;

                constructor (arg0: string);
                constructor (arg0: string, arg1: any);
                constructor (arg0: string, arg1: any[]);

                getKey(): string;
                getTarget(): JavaArray<any>;
                setTarget(arg0: any): void;
                setTarget(arg0: any[]): void;

            }

            abstract class AccessibleState extends AccessibleBundle {
                static readonly class: JavaClass<AccessibleState>;
                /** @deprecated */ static prototype: undefined;

                static readonly ACTIVE: AccessibleState;
                static readonly PRESSED: AccessibleState;
                static readonly ARMED: AccessibleState;
                static readonly BUSY: AccessibleState;
                static readonly CHECKED: AccessibleState;
                static readonly EDITABLE: AccessibleState;
                static readonly EXPANDABLE: AccessibleState;
                static readonly COLLAPSED: AccessibleState;
                static readonly EXPANDED: AccessibleState;
                static readonly ENABLED: AccessibleState;
                static readonly FOCUSABLE: AccessibleState;
                static readonly FOCUSED: AccessibleState;
                static readonly ICONIFIED: AccessibleState;
                static readonly MODAL: AccessibleState;
                static readonly OPAQUE: AccessibleState;
                static readonly RESIZABLE: AccessibleState;
                static readonly MULTISELECTABLE: AccessibleState;
                static readonly SELECTABLE: AccessibleState;
                static readonly SELECTED: AccessibleState;
                static readonly SHOWING: AccessibleState;
                static readonly VISIBLE: AccessibleState;
                static readonly VERTICAL: AccessibleState;
                static readonly HORIZONTAL: AccessibleState;
                static readonly SINGLE_LINE: AccessibleState;
                static readonly MULTI_LINE: AccessibleState;
                static readonly TRANSIENT: AccessibleState;
                static readonly MANAGES_DESCENDANTS: AccessibleState;
                static readonly INDETERMINATE: AccessibleState;
                static readonly TRUNCATED: AccessibleState;
            }

            export {
                AccessibleContext,
                Accessible,
                AccessibleRole,
                AccessibleAction,
                AccessibleIcon,
                AccessibleText,
                AccessibleEditableText,
                AccessibleStateSet,
                AccessibleComponent,
                AccessibleValue,
                AccessibleRelationSet,
                AccessibleSelection,
                AccessibleTable,
                AccessibleBundle,
                AccessibleRelation,
                AccessibleState
            }

        }

        namespace annotation.processing {

            abstract class Processor extends java.lang.Interface {
                static readonly class: JavaClass<Processor>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Processor {

                getSupportedOptions(): JavaSet<string>;
                getSupportedAnnotationTypes(): JavaSet<string>;
                getSupportedSourceVersion(): javax.lang.model.SourceVersion;
                init(arg0: ProcessingEnvironment): void;
                process(arg0: JavaSet<javax.lang.model.element.TypeElement>, arg1: RoundEnvironment): boolean;
                getCompletions(arg0: javax.lang.model.element.Element, arg1: javax.lang.model.element.AnnotationMirror, arg2: javax.lang.model.element.ExecutableElement, arg3: string): java.lang.Iterable<Completion>;

            }

            abstract class RoundEnvironment extends java.lang.Interface {
                static readonly class: JavaClass<RoundEnvironment>;
                /** @deprecated */ static prototype: undefined;
            }
            interface RoundEnvironment {

                processingOver(): boolean;
                errorRaised(): boolean;
                getRootElements(): JavaSet<javax.lang.model.element.Element>;
                getElementsAnnotatedWith(arg0: javax.lang.model.element.TypeElement): JavaSet<javax.lang.model.element.Element>;
                getElementsAnnotatedWithAny(...arg0: JavaVarArgs<javax.lang.model.element.TypeElement>): JavaSet<javax.lang.model.element.Element>;
                getElementsAnnotatedWith(arg0: JavaClassArg<java.lang.annotation.Annotation>): JavaSet<javax.lang.model.element.Element>;
                getElementsAnnotatedWithAny(arg0: JavaSet<JavaClassArg<java.lang.annotation.Annotation>>): JavaSet<javax.lang.model.element.Element>;

            }

            abstract class ProcessingEnvironment extends java.lang.Interface {
                static readonly class: JavaClass<ProcessingEnvironment>;
                /** @deprecated */ static prototype: undefined;
            }
            interface ProcessingEnvironment {

                getOptions(): JavaMap<string, string>;
                getMessager(): Messager;
                getFiler(): Filer;
                getElementUtils(): javax.lang.model.util.Elements;
                getTypeUtils(): javax.lang.model.util.Types;
                getSourceVersion(): javax.lang.model.SourceVersion;
                getLocale(): java.util.Locale;
                isPreviewEnabled(): boolean;

            }

            abstract class Completion extends java.lang.Interface {
                static readonly class: JavaClass<Completion>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Completion {

                getValue(): string;
                getMessage(): string;

            }

            abstract class Filer extends java.lang.Interface {
                static readonly class: JavaClass<Filer>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Filer {

                createSourceFile(arg0: java.lang.CharSequence, ...arg1: JavaVarArgs<javax.lang.model.element.Element>): javax.tools.JavaFileObject;
                createClassFile(arg0: java.lang.CharSequence, ...arg1: JavaVarArgs<javax.lang.model.element.Element>): javax.tools.JavaFileObject;
                createResource(arg0: javax.tools.JavaFileManager$Location, arg1: java.lang.CharSequence, arg2: java.lang.CharSequence, ...arg3: JavaVarArgs<javax.lang.model.element.Element>): javax.tools.FileObject;
                getResource(arg0: javax.tools.JavaFileManager$Location, arg1: java.lang.CharSequence, arg2: java.lang.CharSequence): javax.tools.FileObject;

            }

            abstract class Messager extends java.lang.Interface {
                static readonly class: JavaClass<Messager>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Messager {

                printMessage(arg0: javax.tools.Diagnostic$Kind, arg1: java.lang.CharSequence): void;
                printMessage(arg0: javax.tools.Diagnostic$Kind, arg1: java.lang.CharSequence, arg2: javax.lang.model.element.Element): void;
                printMessage(arg0: javax.tools.Diagnostic$Kind, arg1: java.lang.CharSequence, arg2: javax.lang.model.element.Element, arg3: javax.lang.model.element.AnnotationMirror): void;
                printMessage(arg0: javax.tools.Diagnostic$Kind, arg1: java.lang.CharSequence, arg2: javax.lang.model.element.Element, arg3: javax.lang.model.element.AnnotationMirror, arg4: javax.lang.model.element.AnnotationValue): void;

            }

            export {
                Processor,
                RoundEnvironment,
                ProcessingEnvironment,
                Completion,
                Filer,
                Messager
            }

        }

        namespace lang.model {

            abstract class SourceVersion extends java.lang.Enum<SourceVersion> {
                static readonly class: JavaClass<SourceVersion>;
                /** @deprecated */ static prototype: undefined;

                static readonly RELEASE_0: SourceVersion;
                static readonly RELEASE_1: SourceVersion;
                static readonly RELEASE_2: SourceVersion;
                static readonly RELEASE_3: SourceVersion;
                static readonly RELEASE_4: SourceVersion;
                static readonly RELEASE_5: SourceVersion;
                static readonly RELEASE_6: SourceVersion;
                static readonly RELEASE_7: SourceVersion;
                static readonly RELEASE_8: SourceVersion;
                static readonly RELEASE_9: SourceVersion;
                static readonly RELEASE_10: SourceVersion;
                static readonly RELEASE_11: SourceVersion;
                static readonly RELEASE_12: SourceVersion;
                static readonly RELEASE_13: SourceVersion;
                static readonly RELEASE_14: SourceVersion;
                static readonly RELEASE_15: SourceVersion;
                static readonly RELEASE_16: SourceVersion;
                static readonly RELEASE_17: SourceVersion;

                static values(): JavaArray<SourceVersion>;
                static valueOf(arg0: string): SourceVersion;
                static latest(): SourceVersion;
                static latestSupported(): SourceVersion;
                static isIdentifier(arg0: java.lang.CharSequence): boolean;
                static isName(arg0: java.lang.CharSequence): boolean;
                static isName(arg0: java.lang.CharSequence, arg1: SourceVersion): boolean;
                static isKeyword(arg0: java.lang.CharSequence): boolean;
                static isKeyword(arg0: java.lang.CharSequence, arg1: SourceVersion): boolean;

            }

            abstract class AnnotatedConstruct extends java.lang.Interface {
                static readonly class: JavaClass<AnnotatedConstruct>;
                /** @deprecated */ static prototype: undefined;
            }
            interface AnnotatedConstruct {

                getAnnotationMirrors(): JavaList<javax.lang.model.element.AnnotationMirror>;
                getAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;

            }

            export { SourceVersion, AnnotatedConstruct }

        }
        namespace lang.model {

            namespace element {

                abstract class AnnotationValue extends java.lang.Interface {
                    static readonly class: JavaClass<AnnotationValue>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface AnnotationValue {

                    getValue(): any;
                    accept<R, P>(arg0: AnnotationValueVisitor<R, P>, arg1: P): R;

                }

                abstract class Name extends java.lang.Interface {
                    static readonly class: JavaClass<Name>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Name extends java.lang.CharSequence {

                    contentEquals(arg0: java.lang.CharSequence): boolean;

                }

                abstract class TypeElement extends java.lang.Interface {
                    static readonly class: JavaClass<TypeElement>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TypeElement extends Parameterizable, Element, QualifiedNameable {

                    asType(): javax.lang.model.type.TypeMirror;
                    getEnclosedElements(): JavaList<Element>;
                    getNestingKind(): NestingKind;
                    getQualifiedName(): Name;
                    getSimpleName(): Name;
                    getSuperclass(): javax.lang.model.type.TypeMirror;
                    getInterfaces(): JavaList<javax.lang.model.type.TypeMirror>;
                    getTypeParameters(): JavaList<TypeParameterElement>;
                    getRecordComponents(): JavaList<RecordComponentElement>;
                    getPermittedSubclasses(): JavaList<javax.lang.model.type.TypeMirror>;
                    getEnclosingElement(): Element;

                }

                abstract class PackageElement extends java.lang.Interface {
                    static readonly class: JavaClass<PackageElement>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface PackageElement extends Element, QualifiedNameable {

                    asType(): javax.lang.model.type.TypeMirror;
                    getQualifiedName(): Name;
                    getSimpleName(): Name;
                    getEnclosedElements(): JavaList<Element>;
                    isUnnamed(): boolean;
                    getEnclosingElement(): Element;

                }

                abstract class Element extends java.lang.Interface {
                    static readonly class: JavaClass<Element>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Element extends javax.lang.model.AnnotatedConstruct {

                    asType(): javax.lang.model.type.TypeMirror;
                    getKind(): ElementKind;
                    getModifiers(): JavaSet<Modifier>;
                    getSimpleName(): Name;
                    getEnclosingElement(): Element;
                    getEnclosedElements(): JavaList<Element>;
                    getAnnotationMirrors(): JavaList<AnnotationMirror>;
                    getAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                    getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;
                    accept<R, P>(arg0: ElementVisitor<R, P>, arg1: P): R;

                }

                abstract class ModuleElement$Directive extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleElement$Directive>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ModuleElement$Directive {

                    getKind(): ModuleElement$DirectiveKind;
                    accept<R, P>(arg0: ModuleElement$DirectiveVisitor<R, P>, arg1: P): R;

                }

                abstract class ModuleElement extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleElement>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ModuleElement extends Element, QualifiedNameable {

                    asType(): javax.lang.model.type.TypeMirror;
                    getQualifiedName(): Name;
                    getSimpleName(): Name;
                    getEnclosedElements(): JavaList<Element>;
                    isOpen(): boolean;
                    isUnnamed(): boolean;
                    getEnclosingElement(): Element;
                    getDirectives(): JavaList<ModuleElement$Directive>;

                }

                abstract class ExecutableElement extends java.lang.Interface {
                    static readonly class: JavaClass<ExecutableElement>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ExecutableElement extends Parameterizable, Element {

                    asType(): javax.lang.model.type.TypeMirror;
                    getTypeParameters(): JavaList<TypeParameterElement>;
                    getReturnType(): javax.lang.model.type.TypeMirror;
                    getParameters(): JavaList<VariableElement>;
                    getReceiverType(): javax.lang.model.type.TypeMirror;
                    isVarArgs(): boolean;
                    isDefault(): boolean;
                    getThrownTypes(): JavaList<javax.lang.model.type.TypeMirror>;
                    getDefaultValue(): AnnotationValue;
                    getSimpleName(): Name;

                }

                abstract class RecordComponentElement extends java.lang.Interface {
                    static readonly class: JavaClass<RecordComponentElement>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface RecordComponentElement extends Element {

                    getEnclosingElement(): Element;
                    getSimpleName(): Name;
                    getAccessor(): ExecutableElement;

                }

                abstract class AnnotationMirror extends java.lang.Interface {
                    static readonly class: JavaClass<AnnotationMirror>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface AnnotationMirror {

                    getAnnotationType(): javax.lang.model.type.DeclaredType;
                    getElementValues(): JavaMap<ExecutableElement, AnnotationValue>;

                }

                abstract class QualifiedNameable extends java.lang.Interface {
                    static readonly class: JavaClass<QualifiedNameable>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface QualifiedNameable extends Element {

                    getQualifiedName(): Name;

                }

                abstract class TypeParameterElement extends java.lang.Interface {
                    static readonly class: JavaClass<TypeParameterElement>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TypeParameterElement extends Element {

                    asType(): javax.lang.model.type.TypeMirror;
                    getGenericElement(): Element;
                    getBounds(): JavaList<javax.lang.model.type.TypeMirror>;
                    getEnclosingElement(): Element;

                }

                abstract class ModuleElement$DirectiveKind extends java.lang.Enum<ModuleElement$DirectiveKind> {
                    static readonly class: JavaClass<ModuleElement$DirectiveKind>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly REQUIRES: ModuleElement$DirectiveKind;
                    static readonly EXPORTS: ModuleElement$DirectiveKind;
                    static readonly OPENS: ModuleElement$DirectiveKind;
                    static readonly USES: ModuleElement$DirectiveKind;
                    static readonly PROVIDES: ModuleElement$DirectiveKind;

                    static values(): JavaArray<ModuleElement$DirectiveKind>;
                    static valueOf(arg0: string): ModuleElement$DirectiveKind;

                }

                abstract class ElementKind extends java.lang.Enum<ElementKind> {
                    static readonly class: JavaClass<ElementKind>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly PACKAGE: ElementKind;
                    static readonly ENUM: ElementKind;
                    static readonly CLASS: ElementKind;
                    static readonly ANNOTATION_TYPE: ElementKind;
                    static readonly INTERFACE: ElementKind;
                    static readonly ENUM_CONSTANT: ElementKind;
                    static readonly FIELD: ElementKind;
                    static readonly PARAMETER: ElementKind;
                    static readonly LOCAL_VARIABLE: ElementKind;
                    static readonly EXCEPTION_PARAMETER: ElementKind;
                    static readonly METHOD: ElementKind;
                    static readonly CONSTRUCTOR: ElementKind;
                    static readonly STATIC_INIT: ElementKind;
                    static readonly INSTANCE_INIT: ElementKind;
                    static readonly TYPE_PARAMETER: ElementKind;
                    static readonly OTHER: ElementKind;
                    static readonly RESOURCE_VARIABLE: ElementKind;
                    static readonly MODULE: ElementKind;
                    static readonly RECORD: ElementKind;
                    static readonly RECORD_COMPONENT: ElementKind;
                    static readonly BINDING_VARIABLE: ElementKind;

                    static values(): JavaArray<ElementKind>;
                    static valueOf(arg0: string): ElementKind;

                    isClass(): boolean;
                    isInterface(): boolean;
                    isField(): boolean;

                }

                abstract class Parameterizable extends java.lang.Interface {
                    static readonly class: JavaClass<Parameterizable>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Parameterizable extends Element {

                    getTypeParameters(): JavaList<TypeParameterElement>;

                }

                abstract class AnnotationValueVisitor<R, P> extends java.lang.Interface {
                    static readonly class: JavaClass<AnnotationValueVisitor<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface AnnotationValueVisitor<R, P> {

                    visit(arg0: AnnotationValue, arg1: P): R;
                    visit(arg0: AnnotationValue): R;
                    visitBoolean(arg0: boolean, arg1: P): R;
                    visitByte(arg0: byte, arg1: P): R;
                    visitChar(arg0: char, arg1: P): R;
                    visitDouble(arg0: double, arg1: P): R;
                    visitFloat(arg0: float, arg1: P): R;
                    visitInt(arg0: int, arg1: P): R;
                    visitLong(arg0: long, arg1: P): R;
                    visitShort(arg0: short, arg1: P): R;
                    visitString(arg0: string, arg1: P): R;
                    visitType(arg0: javax.lang.model.type.TypeMirror, arg1: P): R;
                    visitEnumConstant(arg0: VariableElement, arg1: P): R;
                    visitAnnotation(arg0: AnnotationMirror, arg1: P): R;
                    visitArray(arg0: JavaList<AnnotationValue>, arg1: P): R;
                    visitUnknown(arg0: AnnotationValue, arg1: P): R;

                }

                abstract class VariableElement extends java.lang.Interface {
                    static readonly class: JavaClass<VariableElement>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface VariableElement extends Element {

                    asType(): javax.lang.model.type.TypeMirror;
                    getConstantValue(): any;
                    getSimpleName(): Name;
                    getEnclosingElement(): Element;

                }

                abstract class ModuleElement$DirectiveVisitor<R, P> extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleElement$DirectiveVisitor<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ModuleElement$DirectiveVisitor<R, P> {

                    visit(arg0: ModuleElement$Directive): R;
                    visit(arg0: ModuleElement$Directive, arg1: P): R;
                    visitRequires(arg0: ModuleElement$RequiresDirective, arg1: P): R;
                    visitExports(arg0: ModuleElement$ExportsDirective, arg1: P): R;
                    visitOpens(arg0: ModuleElement$OpensDirective, arg1: P): R;
                    visitUses(arg0: ModuleElement$UsesDirective, arg1: P): R;
                    visitProvides(arg0: ModuleElement$ProvidesDirective, arg1: P): R;
                    visitUnknown(arg0: ModuleElement$Directive, arg1: P): R;

                }

                abstract class NestingKind extends java.lang.Enum<NestingKind> {
                    static readonly class: JavaClass<NestingKind>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly TOP_LEVEL: NestingKind;
                    static readonly MEMBER: NestingKind;
                    static readonly LOCAL: NestingKind;
                    static readonly ANONYMOUS: NestingKind;

                    static values(): JavaArray<NestingKind>;
                    static valueOf(arg0: string): NestingKind;

                    isNested(): boolean;

                }

                abstract class ElementVisitor<R, P> extends java.lang.Interface {
                    static readonly class: JavaClass<ElementVisitor<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ElementVisitor<R, P> {

                    visit(arg0: Element, arg1: P): R;
                    visit(arg0: Element): R;
                    visitPackage(arg0: PackageElement, arg1: P): R;
                    visitType(arg0: TypeElement, arg1: P): R;
                    visitVariable(arg0: VariableElement, arg1: P): R;
                    visitExecutable(arg0: ExecutableElement, arg1: P): R;
                    visitTypeParameter(arg0: TypeParameterElement, arg1: P): R;
                    visitUnknown(arg0: Element, arg1: P): R;
                    visitModule(arg0: ModuleElement, arg1: P): R;
                    visitRecordComponent(arg0: RecordComponentElement, arg1: P): R;

                }

                abstract class Modifier extends java.lang.Enum<Modifier> {
                    static readonly class: JavaClass<Modifier>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly PUBLIC: Modifier;
                    static readonly PROTECTED: Modifier;
                    static readonly PRIVATE: Modifier;
                    static readonly ABSTRACT: Modifier;
                    static readonly DEFAULT: Modifier;
                    static readonly STATIC: Modifier;
                    static readonly SEALED: Modifier;
                    static readonly NON_SEALED: Modifier;
                    static readonly FINAL: Modifier;
                    static readonly TRANSIENT: Modifier;
                    static readonly VOLATILE: Modifier;
                    static readonly SYNCHRONIZED: Modifier;
                    static readonly NATIVE: Modifier;
                    static readonly STRICTFP: Modifier;

                    static values(): JavaArray<Modifier>;
                    static valueOf(arg0: string): Modifier;

                }

                abstract class ModuleElement$OpensDirective extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleElement$OpensDirective>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ModuleElement$OpensDirective extends ModuleElement$Directive {

                    getPackage(): PackageElement;
                    getTargetModules(): JavaList<ModuleElement>;

                }

                abstract class ModuleElement$UsesDirective extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleElement$UsesDirective>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ModuleElement$UsesDirective extends ModuleElement$Directive {

                    getService(): TypeElement;

                }

                abstract class ModuleElement$ProvidesDirective extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleElement$ProvidesDirective>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ModuleElement$ProvidesDirective extends ModuleElement$Directive {

                    getService(): TypeElement;
                    getImplementations(): JavaList<TypeElement>;

                }

                abstract class ModuleElement$RequiresDirective extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleElement$RequiresDirective>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ModuleElement$RequiresDirective extends ModuleElement$Directive {

                    isStatic(): boolean;
                    isTransitive(): boolean;
                    getDependency(): ModuleElement;

                }

                abstract class ModuleElement$ExportsDirective extends java.lang.Interface {
                    static readonly class: JavaClass<ModuleElement$ExportsDirective>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ModuleElement$ExportsDirective extends ModuleElement$Directive {

                    getPackage(): PackageElement;
                    getTargetModules(): JavaList<ModuleElement>;

                }

                export {
                    AnnotationValue,
                    Name,
                    TypeElement,
                    PackageElement,
                    Element,
                    ModuleElement$Directive,
                    ModuleElement,
                    ExecutableElement,
                    RecordComponentElement,
                    AnnotationMirror,
                    QualifiedNameable,
                    TypeParameterElement,
                    ModuleElement$DirectiveKind,
                    ElementKind,
                    Parameterizable,
                    AnnotationValueVisitor,
                    VariableElement,
                    ModuleElement$DirectiveVisitor,
                    NestingKind,
                    ElementVisitor,
                    Modifier,
                    ModuleElement$OpensDirective,
                    ModuleElement$UsesDirective,
                    ModuleElement$ProvidesDirective,
                    ModuleElement$RequiresDirective,
                    ModuleElement$ExportsDirective
                }

            }

            namespace type {

                abstract class PrimitiveType extends java.lang.Interface {
                    static readonly class: JavaClass<PrimitiveType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface PrimitiveType extends TypeMirror {}

                abstract class NoType extends java.lang.Interface {
                    static readonly class: JavaClass<NoType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface NoType extends TypeMirror {}

                abstract class ArrayType extends java.lang.Interface {
                    static readonly class: JavaClass<ArrayType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ArrayType extends ReferenceType {

                    getComponentType(): TypeMirror;

                }

                abstract class NullType extends java.lang.Interface {
                    static readonly class: JavaClass<NullType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface NullType extends ReferenceType {}

                abstract class TypeKind extends java.lang.Enum<TypeKind> {
                    static readonly class: JavaClass<TypeKind>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly BOOLEAN: TypeKind;
                    static readonly BYTE: TypeKind;
                    static readonly SHORT: TypeKind;
                    static readonly INT: TypeKind;
                    static readonly LONG: TypeKind;
                    static readonly CHAR: TypeKind;
                    static readonly FLOAT: TypeKind;
                    static readonly DOUBLE: TypeKind;
                    static readonly VOID: TypeKind;
                    static readonly NONE: TypeKind;
                    static readonly NULL: TypeKind;
                    static readonly ARRAY: TypeKind;
                    static readonly DECLARED: TypeKind;
                    static readonly ERROR: TypeKind;
                    static readonly TYPEVAR: TypeKind;
                    static readonly WILDCARD: TypeKind;
                    static readonly PACKAGE: TypeKind;
                    static readonly EXECUTABLE: TypeKind;
                    static readonly OTHER: TypeKind;
                    static readonly UNION: TypeKind;
                    static readonly INTERSECTION: TypeKind;
                    static readonly MODULE: TypeKind;

                    static values(): JavaArray<TypeKind>;
                    static valueOf(arg0: string): TypeKind;

                    isPrimitive(): boolean;

                }

                abstract class DeclaredType extends java.lang.Interface {
                    static readonly class: JavaClass<DeclaredType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface DeclaredType extends ReferenceType {

                    asElement(): javax.lang.model.element.Element;
                    getEnclosingType(): TypeMirror;
                    getTypeArguments(): JavaList<TypeMirror>;

                }

                abstract class ExecutableType extends java.lang.Interface {
                    static readonly class: JavaClass<ExecutableType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ExecutableType extends TypeMirror {

                    getTypeVariables(): JavaList<TypeVariable>;
                    getReturnType(): TypeMirror;
                    getParameterTypes(): JavaList<TypeMirror>;
                    getReceiverType(): TypeMirror;
                    getThrownTypes(): JavaList<TypeMirror>;

                }

                abstract class WildcardType extends java.lang.Interface {
                    static readonly class: JavaClass<WildcardType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface WildcardType extends TypeMirror {

                    getExtendsBound(): TypeMirror;
                    getSuperBound(): TypeMirror;

                }

                abstract class TypeMirror extends java.lang.Interface {
                    static readonly class: JavaClass<TypeMirror>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TypeMirror extends javax.lang.model.AnnotatedConstruct {

                    getKind(): TypeKind;
                    getAnnotationMirrors(): JavaList<javax.lang.model.element.AnnotationMirror>;
                    getAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                    getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;
                    accept<R, P>(arg0: TypeVisitor<R, P>, arg1: P): R;

                }

                abstract class TypeVisitor<R, P> extends java.lang.Interface {
                    static readonly class: JavaClass<TypeVisitor<any, any>>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TypeVisitor<R, P> {

                    visit(arg0: TypeMirror, arg1: P): R;
                    visit(arg0: TypeMirror): R;
                    visitPrimitive(arg0: PrimitiveType, arg1: P): R;
                    visitNull(arg0: NullType, arg1: P): R;
                    visitArray(arg0: ArrayType, arg1: P): R;
                    visitDeclared(arg0: DeclaredType, arg1: P): R;
                    visitError(arg0: ErrorType, arg1: P): R;
                    visitTypeVariable(arg0: TypeVariable, arg1: P): R;
                    visitWildcard(arg0: WildcardType, arg1: P): R;
                    visitExecutable(arg0: ExecutableType, arg1: P): R;
                    visitNoType(arg0: NoType, arg1: P): R;
                    visitUnknown(arg0: TypeMirror, arg1: P): R;
                    visitUnion(arg0: UnionType, arg1: P): R;
                    visitIntersection(arg0: IntersectionType, arg1: P): R;

                }

                abstract class TypeVariable extends java.lang.Interface {
                    static readonly class: JavaClass<TypeVariable>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface TypeVariable extends ReferenceType {

                    asElement(): javax.lang.model.element.Element;
                    getUpperBound(): TypeMirror;
                    getLowerBound(): TypeMirror;

                }

                abstract class ReferenceType extends java.lang.Interface {
                    static readonly class: JavaClass<ReferenceType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ReferenceType extends TypeMirror {}

                abstract class UnionType extends java.lang.Interface {
                    static readonly class: JavaClass<UnionType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface UnionType extends TypeMirror {

                    getAlternatives(): JavaList<TypeMirror>;

                }

                abstract class ErrorType extends java.lang.Interface {
                    static readonly class: JavaClass<ErrorType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface ErrorType extends DeclaredType {}

                abstract class IntersectionType extends java.lang.Interface {
                    static readonly class: JavaClass<IntersectionType>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IntersectionType extends TypeMirror {

                    getBounds(): JavaList<TypeMirror>;

                }

                export {
                    PrimitiveType,
                    NoType,
                    ArrayType,
                    NullType,
                    TypeKind,
                    DeclaredType,
                    ExecutableType,
                    WildcardType,
                    TypeMirror,
                    TypeVisitor,
                    TypeVariable,
                    ReferenceType,
                    UnionType,
                    ErrorType,
                    IntersectionType
                }

            }

            namespace util {

                abstract class Types extends java.lang.Interface {
                    static readonly class: JavaClass<Types>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Types {

                    asElement(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.element.Element;
                    isSameType(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): boolean;
                    isSubtype(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): boolean;
                    isAssignable(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): boolean;
                    contains(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): boolean;
                    isSubsignature(arg0: javax.lang.model.type.ExecutableType, arg1: javax.lang.model.type.ExecutableType): boolean;
                    directSupertypes(arg0: javax.lang.model.type.TypeMirror): JavaList<javax.lang.model.type.TypeMirror>;
                    erasure(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.type.TypeMirror;
                    boxedClass(arg0: javax.lang.model.type.PrimitiveType): javax.lang.model.element.TypeElement;
                    unboxedType(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.type.PrimitiveType;
                    capture(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.type.TypeMirror;
                    getPrimitiveType(arg0: javax.lang.model.type.TypeKind): javax.lang.model.type.PrimitiveType;
                    getNullType(): javax.lang.model.type.NullType;
                    getNoType(arg0: javax.lang.model.type.TypeKind): javax.lang.model.type.NoType;
                    getArrayType(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.type.ArrayType;
                    getWildcardType(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): javax.lang.model.type.WildcardType;
                    getDeclaredType(arg0: javax.lang.model.element.TypeElement, ...arg1: JavaVarArgs<javax.lang.model.type.TypeMirror>): javax.lang.model.type.DeclaredType;
                    getDeclaredType(arg0: javax.lang.model.type.DeclaredType, arg1: javax.lang.model.element.TypeElement, ...arg2: JavaVarArgs<javax.lang.model.type.TypeMirror>): javax.lang.model.type.DeclaredType;
                    asMemberOf(arg0: javax.lang.model.type.DeclaredType, arg1: javax.lang.model.element.Element): javax.lang.model.type.TypeMirror;

                }

                abstract class Elements extends java.lang.Interface {
                    static readonly class: JavaClass<Elements>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface Elements {

                    getPackageElement(arg0: java.lang.CharSequence): javax.lang.model.element.PackageElement;
                    getPackageElement(arg0: javax.lang.model.element.ModuleElement, arg1: java.lang.CharSequence): javax.lang.model.element.PackageElement;
                    getAllPackageElements(arg0: java.lang.CharSequence): JavaSet<javax.lang.model.element.PackageElement>;
                    getTypeElement(arg0: java.lang.CharSequence): javax.lang.model.element.TypeElement;
                    getTypeElement(arg0: javax.lang.model.element.ModuleElement, arg1: java.lang.CharSequence): javax.lang.model.element.TypeElement;
                    getAllTypeElements(arg0: java.lang.CharSequence): JavaSet<javax.lang.model.element.TypeElement>;
                    getModuleElement(arg0: java.lang.CharSequence): javax.lang.model.element.ModuleElement;
                    getAllModuleElements(): JavaSet<javax.lang.model.element.ModuleElement>;
                    getElementValuesWithDefaults(arg0: javax.lang.model.element.AnnotationMirror): JavaMap<javax.lang.model.element.ExecutableElement, javax.lang.model.element.AnnotationValue>;
                    getDocComment(arg0: javax.lang.model.element.Element): string;
                    isDeprecated(arg0: javax.lang.model.element.Element): boolean;
                    getOrigin(arg0: javax.lang.model.element.Element): Elements$Origin;
                    getOrigin(arg0: javax.lang.model.AnnotatedConstruct, arg1: javax.lang.model.element.AnnotationMirror): Elements$Origin;
                    getOrigin(arg0: javax.lang.model.element.ModuleElement, arg1: javax.lang.model.element.ModuleElement$Directive): Elements$Origin;
                    isBridge(arg0: javax.lang.model.element.ExecutableElement): boolean;
                    getBinaryName(arg0: javax.lang.model.element.TypeElement): javax.lang.model.element.Name;
                    getPackageOf(arg0: javax.lang.model.element.Element): javax.lang.model.element.PackageElement;
                    getModuleOf(arg0: javax.lang.model.element.Element): javax.lang.model.element.ModuleElement;
                    getAllMembers(arg0: javax.lang.model.element.TypeElement): JavaList<javax.lang.model.element.Element>;
                    getAllAnnotationMirrors(arg0: javax.lang.model.element.Element): JavaList<javax.lang.model.element.AnnotationMirror>;
                    hides(arg0: javax.lang.model.element.Element, arg1: javax.lang.model.element.Element): boolean;
                    overrides(arg0: javax.lang.model.element.ExecutableElement, arg1: javax.lang.model.element.ExecutableElement, arg2: javax.lang.model.element.TypeElement): boolean;
                    getConstantExpression(arg0: any): string;
                    printElements(arg0: java.io.Writer, ...arg1: JavaVarArgs<javax.lang.model.element.Element>): void;
                    getName(arg0: java.lang.CharSequence): javax.lang.model.element.Name;
                    isFunctionalInterface(arg0: javax.lang.model.element.TypeElement): boolean;
                    isAutomaticModule(arg0: javax.lang.model.element.ModuleElement): boolean;
                    recordComponentFor(arg0: javax.lang.model.element.ExecutableElement): javax.lang.model.element.RecordComponentElement;

                }

                abstract class Elements$Origin extends java.lang.Enum<Elements$Origin> {
                    static readonly class: JavaClass<Elements$Origin>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly EXPLICIT: Elements$Origin;
                    static readonly MANDATED: Elements$Origin;
                    static readonly SYNTHETIC: Elements$Origin;

                    static values(): JavaArray<Elements$Origin>;
                    static valueOf(arg0: string): Elements$Origin;

                    isDeclared(): boolean;

                }

                export { Types, Elements, Elements$Origin }

            }

        }

        namespace security.auth {

            interface Subject extends java.io.Serializable {}
            class Subject extends java.lang.Object {
                static readonly class: JavaClass<Subject>;
                /** @deprecated */ static prototype: undefined;

                /** @deprecated */
                static getSubject(arg0: java.security.AccessControlContext): Subject;
                static doAs<T>(arg0: Subject, arg1: java.security.PrivilegedAction<T>): T;
                static doAs<T>(arg0: Subject, arg1: java.security.PrivilegedExceptionAction<T>): T;
                /** @deprecated */
                static doAsPrivileged<T>(arg0: Subject, arg1: java.security.PrivilegedAction<T>, arg2: java.security.AccessControlContext): T;
                /** @deprecated */
                static doAsPrivileged<T>(arg0: Subject, arg1: java.security.PrivilegedExceptionAction<T>, arg2: java.security.AccessControlContext): T;

                constructor ();
                constructor (arg0: boolean, arg1: JavaSet<java.security.Principal>, arg2: JavaSet<any>, arg3: JavaSet<any>);

                setReadOnly(): void;
                isReadOnly(): boolean;
                getPrincipals(): JavaSet<java.security.Principal>;
                getPrincipals<T extends java.security.Principal>(arg0: JavaClassArg<T>): JavaSet<T>;
                getPublicCredentials(): JavaSet<any>;
                getPrivateCredentials(): JavaSet<any>;
                getPublicCredentials<T>(arg0: JavaClassArg<T>): JavaSet<T>;
                getPrivateCredentials<T>(arg0: JavaClassArg<T>): JavaSet<T>;

            }

            export { Subject }

        }

        namespace sound.sampled {

            abstract class Clip extends java.lang.Interface {
                static readonly class: JavaClass<Clip>;
                /** @deprecated */ static prototype: undefined;

                static readonly LOOP_CONTINUOUSLY: number;
            }
            interface Clip extends DataLine {

                open(arg0: AudioFormat, arg1: byte[], arg2: int, arg3: int): void;
                open(arg0: AudioInputStream): void;
                open(): void;
                getFrameLength(): number;
                getMicrosecondLength(): number;
                setFramePosition(arg0: int): void;
                setMicrosecondPosition(arg0: long): void;
                setLoopPoints(arg0: int, arg1: int): void;
                loop(arg0: int): void;

            }

            abstract class DataLine extends java.lang.Interface {
                static readonly class: JavaClass<DataLine>;
                /** @deprecated */ static prototype: undefined;
            }
            interface DataLine extends Line {

                drain(): void;
                flush(): void;
                start(): void;
                stop(): void;
                isRunning(): boolean;
                isActive(): boolean;
                getFormat(): AudioFormat;
                getBufferSize(): number;
                available(): number;
                getFramePosition(): number;
                getLongFramePosition(): number;
                getMicrosecondPosition(): number;
                getLevel(): number;

            }

            abstract class Line extends java.lang.Interface {
                static readonly class: JavaClass<Line>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Line extends java.lang.AutoCloseable {

                getLineInfo(): Line$Info;
                open(): void;
                close(): void;
                isOpen(): boolean;
                getControls(): JavaArray<Control>;
                isControlSupported(arg0: Control$Type): boolean;
                getControl(arg0: Control$Type): Control;
                addLineListener(arg0: LineListener): void;
                removeLineListener(arg0: LineListener): void;

            }

            class AudioFormat extends java.lang.Object {
                static readonly class: JavaClass<AudioFormat>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: AudioFormat$Encoding, arg1: float, arg2: int, arg3: int, arg4: int, arg5: float, arg6: boolean);
                constructor (arg0: AudioFormat$Encoding, arg1: float, arg2: int, arg3: int, arg4: int, arg5: float, arg6: boolean, arg7: JavaMap<string, any>);
                constructor (arg0: float, arg1: int, arg2: int, arg3: boolean, arg4: boolean);

                getEncoding(): AudioFormat$Encoding;
                getSampleRate(): number;
                getSampleSizeInBits(): number;
                getChannels(): number;
                getFrameSize(): number;
                getFrameRate(): number;
                isBigEndian(): boolean;
                properties(): JavaMap<string, any>;
                getProperty(arg0: string): any;
                matches(arg0: AudioFormat): boolean;

            }

            class AudioInputStream extends java.io.InputStream {
                static readonly class: JavaClass<AudioInputStream>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: java.io.InputStream, arg1: AudioFormat, arg2: long);
                constructor (arg0: TargetDataLine);

                getFormat(): AudioFormat;
                getFrameLength(): number;
                read(): number;
                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                available(): number;
                close(): void;
                mark(arg0: int): void;
                reset(): void;
                markSupported(): boolean;

            }

            abstract class Control extends java.lang.Object {
                static readonly class: JavaClass<Control>;
                /** @deprecated */ static prototype: undefined;

                getType(): Control$Type;

            }

            class Line$Info extends java.lang.Object {
                static readonly class: JavaClass<Line$Info>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: JavaClassArg<any>);

                getLineClass(): JavaClass<any>;
                matches(arg0: Line$Info): boolean;

            }

            class AudioFormat$Encoding extends java.lang.Object {
                static readonly class: JavaClass<AudioFormat$Encoding>;
                /** @deprecated */ static prototype: undefined;

                static readonly PCM_SIGNED: AudioFormat$Encoding;
                static readonly PCM_UNSIGNED: AudioFormat$Encoding;
                static readonly PCM_FLOAT: AudioFormat$Encoding;
                static readonly ULAW: AudioFormat$Encoding;
                static readonly ALAW: AudioFormat$Encoding;

                constructor (arg0: string);

            }

            abstract class TargetDataLine extends java.lang.Interface {
                static readonly class: JavaClass<TargetDataLine>;
                /** @deprecated */ static prototype: undefined;
            }
            interface TargetDataLine extends DataLine {

                open(arg0: AudioFormat, arg1: int): void;
                open(arg0: AudioFormat): void;
                open(): void;
                read(arg0: byte[], arg1: int, arg2: int): number;

            }

            abstract class LineListener extends java.lang.Interface {
                static readonly class: JavaClass<LineListener>;
                /** @deprecated */ static prototype: undefined;
            }
            interface LineListener extends java.util.EventListener {

                update(arg0: LineEvent): void;

            }

            abstract class Control$Type extends java.lang.Object {
                static readonly class: JavaClass<Control$Type>;
                /** @deprecated */ static prototype: undefined;
            }

            class LineEvent extends java.util.EventObject {
                static readonly class: JavaClass<LineEvent>;
                /** @deprecated */ static prototype: undefined;

                constructor (arg0: Line, arg1: LineEvent$Type, arg2: long);

                getLine(): Line;
                getType(): LineEvent$Type;
                getFramePosition(): number;

            }

            abstract class LineEvent$Type extends java.lang.Object {
                static readonly class: JavaClass<LineEvent$Type>;
                /** @deprecated */ static prototype: undefined;

                static readonly OPEN: LineEvent$Type;
                static readonly CLOSE: LineEvent$Type;
                static readonly START: LineEvent$Type;
                static readonly STOP: LineEvent$Type;
            }

            export {
                Clip,
                DataLine,
                Line,
                AudioFormat,
                AudioInputStream,
                Control,
                Line$Info,
                AudioFormat$Encoding,
                TargetDataLine,
                LineListener,
                Control$Type,
                LineEvent,
                LineEvent$Type
            }

        }

        namespace swing.text {

            abstract class AttributeSet extends java.lang.Interface {
                static readonly class: JavaClass<AttributeSet>;
                /** @deprecated */ static prototype: undefined;

                static readonly NameAttribute: any;
                static readonly ResolveAttribute: any;
            }
            interface AttributeSet {

                getAttributeCount(): number;
                isDefined(arg0: any): boolean;
                isEqual(arg0: AttributeSet): boolean;
                copyAttributes(): AttributeSet;
                getAttribute(arg0: any): any;
                getAttributeNames(): java.util.Enumeration<any>;
                containsAttribute(arg0: any, arg1: any): boolean;
                containsAttributes(arg0: AttributeSet): boolean;
                getResolveParent(): AttributeSet;

            }

            export { AttributeSet }

        }

        namespace tools {

            abstract class JavaFileObject extends java.lang.Interface {
                static readonly class: JavaClass<JavaFileObject>;
                /** @deprecated */ static prototype: undefined;
            }
            interface JavaFileObject extends FileObject {

                getKind(): JavaFileObject$Kind;
                isNameCompatible(arg0: string, arg1: JavaFileObject$Kind): boolean;
                getNestingKind(): javax.lang.model.element.NestingKind;
                getAccessLevel(): javax.lang.model.element.Modifier;

            }

            abstract class FileObject extends java.lang.Interface {
                static readonly class: JavaClass<FileObject>;
                /** @deprecated */ static prototype: undefined;
            }
            interface FileObject {

                toUri(): java.net.URI;
                getName(): string;
                openInputStream(): java.io.InputStream;
                openOutputStream(): java.io.OutputStream;
                openReader(arg0: boolean): java.io.Reader;
                getCharContent(arg0: boolean): java.lang.CharSequence;
                openWriter(): java.io.Writer;
                getLastModified(): number;
                delete(): boolean;

            }

            abstract class JavaFileManager$Location extends java.lang.Interface {
                static readonly class: JavaClass<JavaFileManager$Location>;
                /** @deprecated */ static prototype: undefined;
            }
            interface JavaFileManager$Location {

                getName(): string;
                isOutputLocation(): boolean;
                isModuleOrientedLocation(): boolean;

            }

            abstract class Diagnostic$Kind extends java.lang.Enum<Diagnostic$Kind> {
                static readonly class: JavaClass<Diagnostic$Kind>;
                /** @deprecated */ static prototype: undefined;

                static readonly ERROR: Diagnostic$Kind;
                static readonly WARNING: Diagnostic$Kind;
                static readonly MANDATORY_WARNING: Diagnostic$Kind;
                static readonly NOTE: Diagnostic$Kind;
                static readonly OTHER: Diagnostic$Kind;

                static values(): JavaArray<Diagnostic$Kind>;
                static valueOf(arg0: string): Diagnostic$Kind;

            }

            abstract class JavaFileObject$Kind extends java.lang.Enum<JavaFileObject$Kind> {
                static readonly class: JavaClass<JavaFileObject$Kind>;
                /** @deprecated */ static prototype: undefined;

                static readonly SOURCE: JavaFileObject$Kind;
                static readonly CLASS: JavaFileObject$Kind;
                static readonly HTML: JavaFileObject$Kind;
                static readonly OTHER: JavaFileObject$Kind;

                static values(): JavaArray<JavaFileObject$Kind>;
                static valueOf(arg0: string): JavaFileObject$Kind;

                readonly extension: string;
            }

            export {
                JavaFileObject,
                FileObject,
                JavaFileManager$Location,
                Diagnostic$Kind,
                JavaFileObject$Kind
            }

        }

    }

    namespace org {

        namespace joml {

            interface Vector3f extends java.lang.Cloneable, Vector3fc, java.io.Externalizable {}
            class Vector3f extends java.lang.Object {
                static readonly class: JavaClass<Vector3f>;
                /** @deprecated */ static prototype: undefined;

                static lengthSquared(arg0: float, arg1: float, arg2: float): number;
                static length(arg0: float, arg1: float, arg2: float): number;
                static distance(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): number;
                static distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): number;

                constructor ();
                constructor (arg0: float);
                constructor (arg0: float, arg1: float, arg2: float);
                constructor (arg0: Vector3fc);
                constructor (arg0: Vector3ic);
                constructor (arg0: Vector2fc, arg1: float);
                constructor (arg0: Vector2ic, arg1: float);
                constructor (arg0: float[]);
                constructor (arg0: java.nio.ByteBuffer);
                constructor (arg0: int, arg1: java.nio.ByteBuffer);
                constructor (arg0: java.nio.FloatBuffer);
                constructor (arg0: int, arg1: java.nio.FloatBuffer);

                x: number;
                y: number;
                z: number;

                x(): number;
                y(): number;
                z(): number;
                set(arg0: Vector3fc): Vector3f;
                set(arg0: Vector3dc): Vector3f;
                set(arg0: Vector3ic): Vector3f;
                set(arg0: Vector2fc, arg1: float): Vector3f;
                set(arg0: Vector2dc, arg1: float): Vector3f;
                set(arg0: Vector2ic, arg1: float): Vector3f;
                set(arg0: float): Vector3f;
                set(arg0: float, arg1: float, arg2: float): Vector3f;
                set(arg0: double): Vector3f;
                set(arg0: double, arg1: double, arg2: double): Vector3f;
                set(arg0: float[]): Vector3f;
                set(arg0: java.nio.ByteBuffer): Vector3f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector3f;
                set(arg0: java.nio.FloatBuffer): Vector3f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Vector3f;
                setFromAddress(arg0: long): Vector3f;
                setComponent(arg0: int, arg1: float): Vector3f;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3fc;
                sub(arg0: Vector3fc): Vector3f;
                sub(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                sub(arg0: float, arg1: float, arg2: float): Vector3f;
                sub(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                add(arg0: Vector3fc): Vector3f;
                add(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                add(arg0: float, arg1: float, arg2: float): Vector3f;
                add(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                fma(arg0: Vector3fc, arg1: Vector3fc): Vector3f;
                fma(arg0: float, arg1: Vector3fc): Vector3f;
                fma(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                fma(arg0: float, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mulAdd(arg0: Vector3fc, arg1: Vector3fc): Vector3f;
                mulAdd(arg0: float, arg1: Vector3fc): Vector3f;
                mulAdd(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mulAdd(arg0: float, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mul(arg0: Vector3fc): Vector3f;
                mul(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                div(arg0: Vector3fc): Vector3f;
                div(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc, arg1: float, arg2: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc): Vector3f;
                mul(arg0: Matrix3fc): Vector3f;
                mul(arg0: Matrix3fc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3dc): Vector3f;
                mul(arg0: Matrix3dc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3x2fc): Vector3f;
                mul(arg0: Matrix3x2fc, arg1: Vector3f): Vector3f;
                mulTranspose(arg0: Matrix3fc): Vector3f;
                mulTranspose(arg0: Matrix3fc, arg1: Vector3f): Vector3f;
                mulPosition(arg0: Matrix4fc): Vector3f;
                mulPosition(arg0: Matrix4x3fc): Vector3f;
                mulPosition(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulPosition(arg0: Matrix4x3fc, arg1: Vector3f): Vector3f;
                mulTransposePosition(arg0: Matrix4fc): Vector3f;
                mulTransposePosition(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulPositionW(arg0: Matrix4fc): number;
                mulPositionW(arg0: Matrix4fc, arg1: Vector3f): number;
                mulDirection(arg0: Matrix4dc): Vector3f;
                mulDirection(arg0: Matrix4fc): Vector3f;
                mulDirection(arg0: Matrix4x3fc): Vector3f;
                mulDirection(arg0: Matrix4dc, arg1: Vector3f): Vector3f;
                mulDirection(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulDirection(arg0: Matrix4x3fc, arg1: Vector3f): Vector3f;
                mulTransposeDirection(arg0: Matrix4fc): Vector3f;
                mulTransposeDirection(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mul(arg0: float): Vector3f;
                mul(arg0: float, arg1: Vector3f): Vector3f;
                mul(arg0: float, arg1: float, arg2: float): Vector3f;
                mul(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                div(arg0: float): Vector3f;
                div(arg0: float, arg1: Vector3f): Vector3f;
                div(arg0: float, arg1: float, arg2: float): Vector3f;
                div(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                rotate(arg0: Quaternionfc): Vector3f;
                rotate(arg0: Quaternionfc, arg1: Vector3f): Vector3f;
                rotationTo(arg0: Vector3fc, arg1: Quaternionf): Quaternionf;
                rotationTo(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float): Vector3f;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector3f): Vector3f;
                rotateX(arg0: float): Vector3f;
                rotateX(arg0: float, arg1: Vector3f): Vector3f;
                rotateY(arg0: float): Vector3f;
                rotateY(arg0: float, arg1: Vector3f): Vector3f;
                rotateZ(arg0: float): Vector3f;
                rotateZ(arg0: float, arg1: Vector3f): Vector3f;
                lengthSquared(): number;
                length(): number;
                normalize(): Vector3f;
                normalize(arg0: Vector3f): Vector3f;
                normalize(arg0: float): Vector3f;
                normalize(arg0: float, arg1: Vector3f): Vector3f;
                cross(arg0: Vector3fc): Vector3f;
                cross(arg0: float, arg1: float, arg2: float): Vector3f;
                cross(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                cross(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                distance(arg0: Vector3fc): number;
                distance(arg0: float, arg1: float, arg2: float): number;
                distanceSquared(arg0: Vector3fc): number;
                distanceSquared(arg0: float, arg1: float, arg2: float): number;
                dot(arg0: Vector3fc): number;
                dot(arg0: float, arg1: float, arg2: float): number;
                angleCos(arg0: Vector3fc): number;
                angle(arg0: Vector3fc): number;
                angleSigned(arg0: Vector3fc, arg1: Vector3fc): number;
                angleSigned(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): number;
                min(arg0: Vector3fc): Vector3f;
                min(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                max(arg0: Vector3fc): Vector3f;
                max(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                zero(): Vector3f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector3f;
                negate(arg0: Vector3f): Vector3f;
                absolute(): Vector3f;
                absolute(arg0: Vector3f): Vector3f;
                equals(arg0: Vector3fc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float): boolean;
                equals(arg0: any): boolean;
                reflect(arg0: Vector3fc): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float): Vector3f;
                reflect(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                half(arg0: Vector3fc): Vector3f;
                half(arg0: float, arg1: float, arg2: float): Vector3f;
                half(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                half(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                smoothStep(arg0: Vector3fc, arg1: float, arg2: Vector3f): Vector3f;
                hermite(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: float, arg4: Vector3f): Vector3f;
                lerp(arg0: Vector3fc, arg1: float): Vector3f;
                lerp(arg0: Vector3fc, arg1: float, arg2: Vector3f): Vector3f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector3i): Vector3i;
                get(arg0: Vector3f): Vector3f;
                get(arg0: Vector3d): Vector3d;
                maxComponent(): number;
                minComponent(): number;
                orthogonalize(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                orthogonalize(arg0: Vector3fc): Vector3f;
                orthogonalizeUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                orthogonalizeUnit(arg0: Vector3fc): Vector3f;
                floor(): Vector3f;
                floor(arg0: Vector3f): Vector3f;
                ceil(): Vector3f;
                ceil(arg0: Vector3f): Vector3f;
                round(): Vector3f;
                round(arg0: Vector3f): Vector3f;
                isFinite(): boolean;
                clone(): any;

            }

            abstract class Vector3fc extends java.lang.Interface {
                static readonly class: JavaClass<Vector3fc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Vector3fc {

                x(): number;
                y(): number;
                z(): number;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3fc;
                sub(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                sub(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                add(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                add(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                fma(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                fma(arg0: float, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mulAdd(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mulAdd(arg0: float, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mul(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                div(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc, arg1: float, arg2: Vector3f): Vector3f;
                mul(arg0: Matrix3fc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3dc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3x2fc, arg1: Vector3f): Vector3f;
                mulTranspose(arg0: Matrix3fc, arg1: Vector3f): Vector3f;
                mulPosition(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulPosition(arg0: Matrix4x3fc, arg1: Vector3f): Vector3f;
                mulTransposePosition(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulPositionW(arg0: Matrix4fc, arg1: Vector3f): number;
                mulDirection(arg0: Matrix4dc, arg1: Vector3f): Vector3f;
                mulDirection(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulDirection(arg0: Matrix4x3fc, arg1: Vector3f): Vector3f;
                mulTransposeDirection(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mul(arg0: float, arg1: Vector3f): Vector3f;
                mul(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                div(arg0: float, arg1: Vector3f): Vector3f;
                div(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                rotate(arg0: Quaternionfc, arg1: Vector3f): Vector3f;
                rotationTo(arg0: Vector3fc, arg1: Quaternionf): Quaternionf;
                rotationTo(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector3f): Vector3f;
                rotateX(arg0: float, arg1: Vector3f): Vector3f;
                rotateY(arg0: float, arg1: Vector3f): Vector3f;
                rotateZ(arg0: float, arg1: Vector3f): Vector3f;
                lengthSquared(): number;
                length(): number;
                normalize(arg0: Vector3f): Vector3f;
                normalize(arg0: float, arg1: Vector3f): Vector3f;
                cross(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                cross(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                distance(arg0: Vector3fc): number;
                distance(arg0: float, arg1: float, arg2: float): number;
                distanceSquared(arg0: Vector3fc): number;
                distanceSquared(arg0: float, arg1: float, arg2: float): number;
                dot(arg0: Vector3fc): number;
                dot(arg0: float, arg1: float, arg2: float): number;
                angleCos(arg0: Vector3fc): number;
                angle(arg0: Vector3fc): number;
                angleSigned(arg0: Vector3fc, arg1: Vector3fc): number;
                angleSigned(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): number;
                min(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                max(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                negate(arg0: Vector3f): Vector3f;
                absolute(arg0: Vector3f): Vector3f;
                reflect(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                half(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                half(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                smoothStep(arg0: Vector3fc, arg1: float, arg2: Vector3f): Vector3f;
                hermite(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: float, arg4: Vector3f): Vector3f;
                lerp(arg0: Vector3fc, arg1: float, arg2: Vector3f): Vector3f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector3i): Vector3i;
                get(arg0: Vector3f): Vector3f;
                get(arg0: Vector3d): Vector3d;
                maxComponent(): number;
                minComponent(): number;
                orthogonalize(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                orthogonalizeUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                floor(arg0: Vector3f): Vector3f;
                ceil(arg0: Vector3f): Vector3f;
                round(arg0: Vector3f): Vector3f;
                isFinite(): boolean;
                equals(arg0: Vector3fc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float): boolean;

            }

            abstract class Matrix3fc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix3fc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Matrix3fc {

                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                mul(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                mulLocal(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                determinant(): number;
                invert(arg0: Matrix3f): Matrix3f;
                transpose(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4f): Matrix4f;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                scale(arg0: Vector3fc, arg1: Matrix3f): Matrix3f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                scale(arg0: float, arg1: Matrix3f): Matrix3f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformTranspose(arg0: Vector3f): Vector3f;
                transformTranspose(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformTranspose(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                rotateX(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateY(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateZ(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3f): Matrix3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3f): Matrix3f;
                rotateLocalX(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalY(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalZ(arg0: float, arg1: Matrix3f): Matrix3f;
                rotate(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                rotate(arg0: AxisAngle4f, arg1: Matrix3f): Matrix3f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix3f): Matrix3f;
                getRow(arg0: int, arg1: Vector3f): Vector3f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                get(arg0: int, arg1: int): number;
                getRowColumn(arg0: int, arg1: int): number;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor(arg0: Matrix3f): Matrix3f;
                getScale(arg0: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                add(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                sub(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                mulComponentWise(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                lerp(arg0: Matrix3fc, arg1: float, arg2: Matrix3f): Matrix3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix3f): Matrix3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix3f): Matrix3f;
                equals(arg0: Matrix3fc, arg1: float): boolean;
                reflect(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                reflect(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                reflect(arg0: Vector3fc, arg1: Matrix3f): Matrix3f;
                isFinite(): boolean;
                quadraticFormProduct(arg0: float, arg1: float, arg2: float): number;
                quadraticFormProduct(arg0: Vector3fc): number;
                mapXZY(arg0: Matrix3f): Matrix3f;
                mapXZnY(arg0: Matrix3f): Matrix3f;
                mapXnYnZ(arg0: Matrix3f): Matrix3f;
                mapXnZY(arg0: Matrix3f): Matrix3f;
                mapXnZnY(arg0: Matrix3f): Matrix3f;
                mapYXZ(arg0: Matrix3f): Matrix3f;
                mapYXnZ(arg0: Matrix3f): Matrix3f;
                mapYZX(arg0: Matrix3f): Matrix3f;
                mapYZnX(arg0: Matrix3f): Matrix3f;
                mapYnXZ(arg0: Matrix3f): Matrix3f;
                mapYnXnZ(arg0: Matrix3f): Matrix3f;
                mapYnZX(arg0: Matrix3f): Matrix3f;
                mapYnZnX(arg0: Matrix3f): Matrix3f;
                mapZXY(arg0: Matrix3f): Matrix3f;
                mapZXnY(arg0: Matrix3f): Matrix3f;
                mapZYX(arg0: Matrix3f): Matrix3f;
                mapZYnX(arg0: Matrix3f): Matrix3f;
                mapZnXY(arg0: Matrix3f): Matrix3f;
                mapZnXnY(arg0: Matrix3f): Matrix3f;
                mapZnYX(arg0: Matrix3f): Matrix3f;
                mapZnYnX(arg0: Matrix3f): Matrix3f;
                mapnXYnZ(arg0: Matrix3f): Matrix3f;
                mapnXZY(arg0: Matrix3f): Matrix3f;
                mapnXZnY(arg0: Matrix3f): Matrix3f;
                mapnXnYZ(arg0: Matrix3f): Matrix3f;
                mapnXnYnZ(arg0: Matrix3f): Matrix3f;
                mapnXnZY(arg0: Matrix3f): Matrix3f;
                mapnXnZnY(arg0: Matrix3f): Matrix3f;
                mapnYXZ(arg0: Matrix3f): Matrix3f;
                mapnYXnZ(arg0: Matrix3f): Matrix3f;
                mapnYZX(arg0: Matrix3f): Matrix3f;
                mapnYZnX(arg0: Matrix3f): Matrix3f;
                mapnYnXZ(arg0: Matrix3f): Matrix3f;
                mapnYnXnZ(arg0: Matrix3f): Matrix3f;
                mapnYnZX(arg0: Matrix3f): Matrix3f;
                mapnYnZnX(arg0: Matrix3f): Matrix3f;
                mapnZXY(arg0: Matrix3f): Matrix3f;
                mapnZXnY(arg0: Matrix3f): Matrix3f;
                mapnZYX(arg0: Matrix3f): Matrix3f;
                mapnZYnX(arg0: Matrix3f): Matrix3f;
                mapnZnXY(arg0: Matrix3f): Matrix3f;
                mapnZnXnY(arg0: Matrix3f): Matrix3f;
                mapnZnYX(arg0: Matrix3f): Matrix3f;
                mapnZnYnX(arg0: Matrix3f): Matrix3f;
                negateX(arg0: Matrix3f): Matrix3f;
                negateY(arg0: Matrix3f): Matrix3f;
                negateZ(arg0: Matrix3f): Matrix3f;

            }

            abstract class Vector3dc extends java.lang.Interface {
                static readonly class: JavaClass<Vector3dc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Vector3dc {

                x(): number;
                y(): number;
                z(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getf(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getf(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3dc;
                sub(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                sub(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                sub(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                add(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                add(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                add(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                fma(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: double, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: Vector3fc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mul(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                mul(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                div(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                div(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc, arg1: double, arg2: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3dc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3dc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3fc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3x2dc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3x2fc, arg1: Vector3d): Vector3d;
                mulTranspose(arg0: Matrix3dc, arg1: Vector3d): Vector3d;
                mulTranspose(arg0: Matrix3fc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4x3dc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4x3fc, arg1: Vector3d): Vector3d;
                mulTransposePosition(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulTransposePosition(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulPositionW(arg0: Matrix4fc, arg1: Vector3d): number;
                mulPositionW(arg0: Matrix4dc, arg1: Vector3d): number;
                mulDirection(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4x3dc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4x3fc, arg1: Vector3d): Vector3d;
                mulTransposeDirection(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulTransposeDirection(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mul(arg0: double, arg1: Vector3d): Vector3d;
                mul(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                rotate(arg0: Quaterniondc, arg1: Vector3d): Vector3d;
                rotationTo(arg0: Vector3dc, arg1: Quaterniond): Quaterniond;
                rotationTo(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector3d): Vector3d;
                rotateX(arg0: double, arg1: Vector3d): Vector3d;
                rotateY(arg0: double, arg1: Vector3d): Vector3d;
                rotateZ(arg0: double, arg1: Vector3d): Vector3d;
                div(arg0: double, arg1: Vector3d): Vector3d;
                div(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                lengthSquared(): number;
                length(): number;
                normalize(arg0: Vector3d): Vector3d;
                normalize(arg0: double, arg1: Vector3d): Vector3d;
                cross(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                cross(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                distance(arg0: Vector3dc): number;
                distance(arg0: double, arg1: double, arg2: double): number;
                distanceSquared(arg0: Vector3dc): number;
                distanceSquared(arg0: double, arg1: double, arg2: double): number;
                dot(arg0: Vector3dc): number;
                dot(arg0: double, arg1: double, arg2: double): number;
                angleCos(arg0: Vector3dc): number;
                angle(arg0: Vector3dc): number;
                angleSigned(arg0: Vector3dc, arg1: Vector3dc): number;
                angleSigned(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                min(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                max(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                negate(arg0: Vector3d): Vector3d;
                absolute(arg0: Vector3d): Vector3d;
                reflect(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                half(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                half(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                smoothStep(arg0: Vector3dc, arg1: double, arg2: Vector3d): Vector3d;
                hermite(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: double, arg4: Vector3d): Vector3d;
                lerp(arg0: Vector3dc, arg1: double, arg2: Vector3d): Vector3d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector3i): Vector3i;
                get(arg0: Vector3f): Vector3f;
                get(arg0: Vector3d): Vector3d;
                maxComponent(): number;
                minComponent(): number;
                orthogonalize(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                orthogonalizeUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                floor(arg0: Vector3d): Vector3d;
                ceil(arg0: Vector3d): Vector3d;
                round(arg0: Vector3d): Vector3d;
                isFinite(): boolean;
                equals(arg0: Vector3dc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double): boolean;

            }

            abstract class Matrix4x3fc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix4x3fc>;
                /** @deprecated */ static prototype: undefined;

                static readonly PLANE_NX: number;
                static readonly PLANE_PX: number;
                static readonly PLANE_NY: number;
                static readonly PLANE_PY: number;
                static readonly PLANE_NZ: number;
                static readonly PLANE_PZ: number;
                static readonly PROPERTY_IDENTITY: number;
                static readonly PROPERTY_TRANSLATION: number;
                static readonly PROPERTY_ORTHONORMAL: number;
            }
            interface Matrix4x3fc {

                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulTranslation(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulOrtho(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                fma(arg0: Matrix4x3fc, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                add(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                sub(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulComponentWise(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                determinant(): number;
                invert(arg0: Matrix4x3f): Matrix4x3f;
                invert(arg0: Matrix4f): Matrix4f;
                invertOrtho(arg0: Matrix4x3f): Matrix4x3f;
                transpose3x3(arg0: Matrix4x3f): Matrix4x3f;
                transpose3x3(arg0: Matrix3f): Matrix3f;
                getTranslation(arg0: Vector3f): Vector3f;
                getScale(arg0: Vector3f): Vector3f;
                get(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4x3d): Matrix4x3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getRotation(arg0: AxisAngle4d): AxisAngle4d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4x3fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                get4x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: float[], arg1: int): JavaArray<number>;
                getTransposed(arg0: float[]): JavaArray<number>;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformPosition(arg0: Vector3f): Vector3f;
                transformPosition(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                scale(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                scale(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                scaleXY(arg0: float, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateX(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateY(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateZ(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateTranslation(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                translate(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                translate(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                translateLocal(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                translateLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4x3f): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4x3f): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4x3f): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4x3f): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                rotate(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotate(arg0: AxisAngle4f, arg1: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflect(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                getRow(arg0: int, arg1: Vector4f): Vector4f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                normal(arg0: Matrix4x3f): Matrix4x3f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix4x3f): Matrix4x3f;
                normalize3x3(arg0: Matrix4x3f): Matrix4x3f;
                normalize3x3(arg0: Matrix3f): Matrix3f;
                frustumPlane(arg0: int, arg1: Vector4f): Vector4f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                origin(arg0: Vector3f): Vector3f;
                shadow(arg0: Vector4fc, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Matrix4x3f): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: Matrix4x3f): Matrix4x3f;
                shadow(arg0: Vector4fc, arg1: Matrix4x3fc, arg2: Matrix4x3f): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3fc, arg5: Matrix4x3f): Matrix4x3f;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[], arg5: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                transformAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Vector3f, arg7: Vector3f): Matrix4x3f;
                transformAab(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f, arg3: Vector3f): Matrix4x3f;
                lerp(arg0: Matrix4x3fc, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                withLookAtUp(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                withLookAtUp(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                mapXZY(arg0: Matrix4x3f): Matrix4x3f;
                mapXZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapXnYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapXnZY(arg0: Matrix4x3f): Matrix4x3f;
                mapXnZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapYXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYZX(arg0: Matrix4x3f): Matrix4x3f;
                mapYZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapYnXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYnXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYnZX(arg0: Matrix4x3f): Matrix4x3f;
                mapYnZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapZXY(arg0: Matrix4x3f): Matrix4x3f;
                mapZXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapZYX(arg0: Matrix4x3f): Matrix4x3f;
                mapZYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapZnXY(arg0: Matrix4x3f): Matrix4x3f;
                mapZnXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapZnYX(arg0: Matrix4x3f): Matrix4x3f;
                mapZnYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnXYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXZY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnYZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnZY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnYXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYZX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnZX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZXY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZYX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnXY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnYX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnYnX(arg0: Matrix4x3f): Matrix4x3f;
                negateX(arg0: Matrix4x3f): Matrix4x3f;
                negateY(arg0: Matrix4x3f): Matrix4x3f;
                negateZ(arg0: Matrix4x3f): Matrix4x3f;
                equals(arg0: Matrix4x3fc, arg1: float): boolean;
                isFinite(): boolean;

            }

            interface Quaternionf extends java.lang.Cloneable, java.io.Externalizable, Quaternionfc {}
            class Quaternionf extends java.lang.Object {
                static readonly class: JavaClass<Quaternionf>;
                /** @deprecated */ static prototype: undefined;

                static slerp(arg0: Quaternionf[], arg1: float[], arg2: Quaternionf): Quaternionfc;
                static nlerp(arg0: Quaternionfc[], arg1: float[], arg2: Quaternionf): Quaternionfc;
                static nlerpIterative(arg0: Quaternionf[], arg1: float[], arg2: float, arg3: Quaternionf): Quaternionfc;

                constructor ();
                constructor (arg0: double, arg1: double, arg2: double, arg3: double);
                constructor (arg0: float, arg1: float, arg2: float, arg3: float);
                constructor (arg0: Quaternionfc);
                constructor (arg0: Quaterniondc);
                constructor (arg0: AxisAngle4f);
                constructor (arg0: AxisAngle4d);

                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                normalize(): Quaternionf;
                normalize(arg0: Quaternionf): Quaternionf;
                add(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                add(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                add(arg0: Quaternionfc): Quaternionf;
                add(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                dot(arg0: Quaternionf): number;
                angle(): number;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4x3d): Matrix4x3d;
                get(arg0: AxisAngle4f): AxisAngle4f;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Quaternionf): Quaternionf;
                getAsMatrix3f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix3f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getAsMatrix4f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix4f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getAsMatrix4x3f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix4x3f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                set(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                set(arg0: Quaternionfc): Quaternionf;
                set(arg0: Quaterniondc): Quaternionf;
                set(arg0: AxisAngle4f): Quaternionf;
                set(arg0: AxisAngle4d): Quaternionf;
                setAngleAxis(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                setAngleAxis(arg0: double, arg1: double, arg2: double, arg3: double): Quaternionf;
                rotationAxis(arg0: AxisAngle4f): Quaternionf;
                rotationAxis(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                rotationAxis(arg0: float, arg1: Vector3fc): Quaternionf;
                rotationX(arg0: float): Quaternionf;
                rotationY(arg0: float): Quaternionf;
                rotationZ(arg0: float): Quaternionf;
                setFromUnnormalized(arg0: Matrix4fc): Quaternionf;
                setFromUnnormalized(arg0: Matrix4x3fc): Quaternionf;
                setFromUnnormalized(arg0: Matrix4x3dc): Quaternionf;
                setFromNormalized(arg0: Matrix4fc): Quaternionf;
                setFromNormalized(arg0: Matrix4x3fc): Quaternionf;
                setFromNormalized(arg0: Matrix4x3dc): Quaternionf;
                setFromUnnormalized(arg0: Matrix4dc): Quaternionf;
                setFromNormalized(arg0: Matrix4dc): Quaternionf;
                setFromUnnormalized(arg0: Matrix3fc): Quaternionf;
                setFromNormalized(arg0: Matrix3fc): Quaternionf;
                setFromUnnormalized(arg0: Matrix3dc): Quaternionf;
                setFromNormalized(arg0: Matrix3dc): Quaternionf;
                fromAxisAngleRad(arg0: Vector3fc, arg1: float): Quaternionf;
                fromAxisAngleRad(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                fromAxisAngleDeg(arg0: Vector3fc, arg1: float): Quaternionf;
                fromAxisAngleDeg(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                mul(arg0: Quaternionfc): Quaternionf;
                mul(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                mul(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                mul(arg0: float): Quaternionf;
                mul(arg0: float, arg1: Quaternionf): Quaternionf;
                premul(arg0: Quaternionfc): Quaternionf;
                premul(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                premul(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                premul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                transform(arg0: Vector3f): Vector3f;
                transformInverse(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector4f): Vector4f;
                transformUnitPositiveX(arg0: Vector3f): Vector3f;
                transformUnitPositiveX(arg0: Vector4f): Vector4f;
                transformPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector3f): Vector3f;
                transform(arg0: Vector4f): Vector4f;
                transformInverse(arg0: Vector4f): Vector4f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverse(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformUnit(arg0: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverse(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transform(arg0: Vector3d): Vector3d;
                transformInverse(arg0: Vector3d): Vector3d;
                transformUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4f): Vector4f;
                transformUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformPositiveX(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector4d): Vector4d;
                transformUnitPositiveX(arg0: Vector3d): Vector3d;
                transformUnitPositiveX(arg0: Vector4d): Vector4d;
                transformPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector3d): Vector3d;
                transform(arg0: Vector4d): Vector4d;
                transformInverse(arg0: Vector4d): Vector4d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverse(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverse(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformUnit(arg0: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4d): Vector4d;
                transformUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                invert(arg0: Quaternionf): Quaternionf;
                invert(): Quaternionf;
                div(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                div(arg0: Quaternionfc): Quaternionf;
                conjugate(): Quaternionf;
                conjugate(arg0: Quaternionf): Quaternionf;
                identity(): Quaternionf;
                rotateXYZ(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateZYX(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateYXZ(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesZXY(arg0: Vector3f): Vector3f;
                getEulerAnglesYXZ(arg0: Vector3f): Vector3f;
                lengthSquared(): number;
                rotationXYZ(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotationZYX(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotationYXZ(arg0: float, arg1: float, arg2: float): Quaternionf;
                slerp(arg0: Quaternionfc, arg1: float): Quaternionf;
                slerp(arg0: Quaternionfc, arg1: float, arg2: Quaternionf): Quaternionf;
                scale(arg0: float): Quaternionf;
                scale(arg0: float, arg1: Quaternionf): Quaternionf;
                scaling(arg0: float): Quaternionf;
                integrate(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                integrate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                nlerp(arg0: Quaternionfc, arg1: float): Quaternionf;
                nlerp(arg0: Quaternionfc, arg1: float, arg2: Quaternionf): Quaternionf;
                nlerpIterative(arg0: Quaternionfc, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                nlerpIterative(arg0: Quaternionfc, arg1: float, arg2: float): Quaternionf;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc): Quaternionf;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Quaternionf;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Quaternionf): Quaternionf;
                rotationTo(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Quaternionf;
                rotationTo(arg0: Vector3fc, arg1: Vector3fc): Quaternionf;
                rotateTo(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Quaternionf): Quaternionf;
                rotateTo(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Quaternionf;
                rotateTo(arg0: Vector3fc, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                rotateTo(arg0: Vector3fc, arg1: Vector3fc): Quaternionf;
                rotateX(arg0: float): Quaternionf;
                rotateX(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateY(arg0: float): Quaternionf;
                rotateY(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateZ(arg0: float): Quaternionf;
                rotateZ(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalX(arg0: float): Quaternionf;
                rotateLocalX(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalY(arg0: float): Quaternionf;
                rotateLocalY(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalZ(arg0: float): Quaternionf;
                rotateLocalZ(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: Vector3fc): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                difference(arg0: Quaternionf): Quaternionf;
                difference(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                conjugateBy(arg0: Quaternionfc): Quaternionf;
                conjugateBy(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                isFinite(): boolean;
                equals(arg0: Quaternionfc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                equals(arg0: any): boolean;
                clone(): any;

            }

            abstract class Matrix4dc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix4dc>;
                /** @deprecated */ static prototype: undefined;

                static readonly PLANE_NX: number;
                static readonly PLANE_PX: number;
                static readonly PLANE_NY: number;
                static readonly PLANE_PY: number;
                static readonly PLANE_NZ: number;
                static readonly PLANE_PZ: number;
                static readonly CORNER_NXNYNZ: number;
                static readonly CORNER_PXNYNZ: number;
                static readonly CORNER_PXPYNZ: number;
                static readonly CORNER_NXPYNZ: number;
                static readonly CORNER_PXNYPZ: number;
                static readonly CORNER_NXNYPZ: number;
                static readonly CORNER_NXPYPZ: number;
                static readonly CORNER_PXPYPZ: number;
                static readonly PROPERTY_PERSPECTIVE: number;
                static readonly PROPERTY_AFFINE: number;
                static readonly PROPERTY_IDENTITY: number;
                static readonly PROPERTY_TRANSLATION: number;
                static readonly PROPERTY_ORTHONORMAL: number;
            }
            interface Matrix4dc {

                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m03(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m13(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m23(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m33(): number;
                mul(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul0(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double, arg16: Matrix4d): Matrix4d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                mulLocal(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulLocalAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix3x2dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix3x2fc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4fc, arg1: Matrix4d): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                mulAffineR(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulTranslationAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulOrthoAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                fma4x3(arg0: Matrix4dc, arg1: double, arg2: Matrix4d): Matrix4d;
                add(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                sub(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulComponentWise(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                add4x3(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                add4x3(arg0: Matrix4fc, arg1: Matrix4d): Matrix4d;
                sub4x3(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul4x3ComponentWise(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                determinant(): number;
                determinant3x3(): number;
                determinantAffine(): number;
                invert(arg0: Matrix4d): Matrix4d;
                invertPerspective(arg0: Matrix4d): Matrix4d;
                invertFrustum(arg0: Matrix4d): Matrix4d;
                invertOrtho(arg0: Matrix4d): Matrix4d;
                invertPerspectiveView(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                invertPerspectiveView(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                invertAffine(arg0: Matrix4d): Matrix4d;
                transpose(arg0: Matrix4d): Matrix4d;
                transpose3x3(arg0: Matrix4d): Matrix4d;
                transpose3x3(arg0: Matrix3d): Matrix3d;
                getTranslation(arg0: Vector3d): Vector3d;
                getScale(arg0: Vector3d): Vector3d;
                get(arg0: Matrix4d): Matrix4d;
                get4x3(arg0: Matrix4x3d): Matrix4x3d;
                get3x3(arg0: Matrix3d): Matrix3d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4dc;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x3Transposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformTranspose(arg0: Vector4d): Vector4d;
                transformTranspose(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformTranspose(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformProject(arg0: Vector4d): Vector4d;
                transformProject(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformProject(arg0: Vector4dc, arg1: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformProject(arg0: Vector3d): Vector3d;
                transformProject(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector3d): Vector3d;
                transformPosition(arg0: Vector3d): Vector3d;
                transformPosition(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformPosition(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformDirection(arg0: Vector3d): Vector3d;
                transformDirection(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformDirection(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformAffine(arg0: Vector4d): Vector4d;
                transformAffine(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                scale(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                scale(arg0: double, arg1: Matrix4d): Matrix4d;
                scaleXY(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                scaleLocal(arg0: double, arg1: Matrix4d): Matrix4d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateTranslation(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAroundAffine(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateLocalX(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalY(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalZ(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateAroundLocal(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                translate(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                translate(arg0: Vector3fc, arg1: Matrix4d): Matrix4d;
                translate(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                translateLocal(arg0: Vector3fc, arg1: Matrix4d): Matrix4d;
                translateLocal(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                translateLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateX(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateY(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateZ(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateTowardsXY(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotate(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotate(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateAffine(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateTranslation(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateAffine(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotate(arg0: AxisAngle4f, arg1: Matrix4d): Matrix4d;
                rotate(arg0: AxisAngle4d, arg1: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix4d): Matrix4d;
                getRow(arg0: int, arg1: Vector4d): Vector4d;
                getRow(arg0: int, arg1: Vector3d): Vector3d;
                getColumn(arg0: int, arg1: Vector4d): Vector4d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                get(arg0: int, arg1: int): number;
                getRowColumn(arg0: int, arg1: int): number;
                normal(arg0: Matrix4d): Matrix4d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix4d): Matrix4d;
                normalize3x3(arg0: Matrix4d): Matrix4d;
                normalize3x3(arg0: Matrix3d): Matrix3d;
                unproject(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                unproject(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                unproject(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                unproject(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                unprojectRay(arg0: double, arg1: double, arg2: int[], arg3: Vector3d, arg4: Vector3d): Matrix4d;
                unprojectRay(arg0: Vector2dc, arg1: int[], arg2: Vector3d, arg3: Vector3d): Matrix4d;
                unprojectInv(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                unprojectInv(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                unprojectInv(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                unprojectInv(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                unprojectInvRay(arg0: Vector2dc, arg1: int[], arg2: Vector3d, arg3: Vector3d): Matrix4d;
                unprojectInvRay(arg0: double, arg1: double, arg2: int[], arg3: Vector3d, arg4: Vector3d): Matrix4d;
                project(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                project(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                project(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                project(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                reflect(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4d): Matrix4d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAtPerspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4d): Matrix4d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAtPerspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                tile(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                frustumPlane(arg0: int, arg1: Vector4d): Vector4d;
                frustumCorner(arg0: int, arg1: Vector3d): Vector3d;
                perspectiveOrigin(arg0: Vector3d): Vector3d;
                perspectiveInvOrigin(arg0: Vector3d): Vector3d;
                perspectiveFov(): number;
                perspectiveNear(): number;
                perspectiveFar(): number;
                frustumRayDir(arg0: double, arg1: double, arg2: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                originAffine(arg0: Vector3d): Vector3d;
                origin(arg0: Vector3d): Vector3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double, arg5: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: Matrix4d): Matrix4d;
                shadow(arg0: Vector4dc, arg1: Matrix4dc, arg2: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4dc, arg5: Matrix4d): Matrix4d;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[], arg5: Matrix4d): Matrix4d;
                isAffine(): boolean;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                projectedGridRange(arg0: Matrix4dc, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                perspectiveFrustumSlice(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                orthoCrop(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                transformAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Vector3d, arg7: Vector3d): Matrix4d;
                transformAab(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d, arg3: Vector3d): Matrix4d;
                lerp(arg0: Matrix4dc, arg1: double, arg2: Matrix4d): Matrix4d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                testPoint(arg0: double, arg1: double, arg2: double): boolean;
                testSphere(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                testAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): boolean;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                withLookAtUp(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                withLookAtUp(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                mapXZY(arg0: Matrix4d): Matrix4d;
                mapXZnY(arg0: Matrix4d): Matrix4d;
                mapXnYnZ(arg0: Matrix4d): Matrix4d;
                mapXnZY(arg0: Matrix4d): Matrix4d;
                mapXnZnY(arg0: Matrix4d): Matrix4d;
                mapYXZ(arg0: Matrix4d): Matrix4d;
                mapYXnZ(arg0: Matrix4d): Matrix4d;
                mapYZX(arg0: Matrix4d): Matrix4d;
                mapYZnX(arg0: Matrix4d): Matrix4d;
                mapYnXZ(arg0: Matrix4d): Matrix4d;
                mapYnXnZ(arg0: Matrix4d): Matrix4d;
                mapYnZX(arg0: Matrix4d): Matrix4d;
                mapYnZnX(arg0: Matrix4d): Matrix4d;
                mapZXY(arg0: Matrix4d): Matrix4d;
                mapZXnY(arg0: Matrix4d): Matrix4d;
                mapZYX(arg0: Matrix4d): Matrix4d;
                mapZYnX(arg0: Matrix4d): Matrix4d;
                mapZnXY(arg0: Matrix4d): Matrix4d;
                mapZnXnY(arg0: Matrix4d): Matrix4d;
                mapZnYX(arg0: Matrix4d): Matrix4d;
                mapZnYnX(arg0: Matrix4d): Matrix4d;
                mapnXYnZ(arg0: Matrix4d): Matrix4d;
                mapnXZY(arg0: Matrix4d): Matrix4d;
                mapnXZnY(arg0: Matrix4d): Matrix4d;
                mapnXnYZ(arg0: Matrix4d): Matrix4d;
                mapnXnYnZ(arg0: Matrix4d): Matrix4d;
                mapnXnZY(arg0: Matrix4d): Matrix4d;
                mapnXnZnY(arg0: Matrix4d): Matrix4d;
                mapnYXZ(arg0: Matrix4d): Matrix4d;
                mapnYXnZ(arg0: Matrix4d): Matrix4d;
                mapnYZX(arg0: Matrix4d): Matrix4d;
                mapnYZnX(arg0: Matrix4d): Matrix4d;
                mapnYnXZ(arg0: Matrix4d): Matrix4d;
                mapnYnXnZ(arg0: Matrix4d): Matrix4d;
                mapnYnZX(arg0: Matrix4d): Matrix4d;
                mapnYnZnX(arg0: Matrix4d): Matrix4d;
                mapnZXY(arg0: Matrix4d): Matrix4d;
                mapnZXnY(arg0: Matrix4d): Matrix4d;
                mapnZYX(arg0: Matrix4d): Matrix4d;
                mapnZYnX(arg0: Matrix4d): Matrix4d;
                mapnZnXY(arg0: Matrix4d): Matrix4d;
                mapnZnXnY(arg0: Matrix4d): Matrix4d;
                mapnZnYX(arg0: Matrix4d): Matrix4d;
                mapnZnYnX(arg0: Matrix4d): Matrix4d;
                negateX(arg0: Matrix4d): Matrix4d;
                negateY(arg0: Matrix4d): Matrix4d;
                negateZ(arg0: Matrix4d): Matrix4d;
                equals(arg0: Matrix4dc, arg1: double): boolean;
                isFinite(): boolean;

            }

            interface Vector3d extends Vector3dc, java.lang.Cloneable, java.io.Externalizable {}
            class Vector3d extends java.lang.Object {
                static readonly class: JavaClass<Vector3d>;
                /** @deprecated */ static prototype: undefined;

                static lengthSquared(arg0: double, arg1: double, arg2: double): number;
                static length(arg0: double, arg1: double, arg2: double): number;
                static distance(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                static distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;

                constructor ();
                constructor (arg0: double);
                constructor (arg0: double, arg1: double, arg2: double);
                constructor (arg0: Vector3fc);
                constructor (arg0: Vector3ic);
                constructor (arg0: Vector2fc, arg1: double);
                constructor (arg0: Vector2ic, arg1: double);
                constructor (arg0: Vector3dc);
                constructor (arg0: Vector2dc, arg1: double);
                constructor (arg0: double[]);
                constructor (arg0: float[]);
                constructor (arg0: java.nio.ByteBuffer);
                constructor (arg0: int, arg1: java.nio.ByteBuffer);
                constructor (arg0: java.nio.DoubleBuffer);
                constructor (arg0: int, arg1: java.nio.DoubleBuffer);

                x: number;
                y: number;
                z: number;

                x(): number;
                y(): number;
                z(): number;
                set(arg0: Vector3dc): Vector3d;
                set(arg0: Vector3ic): Vector3d;
                set(arg0: Vector2dc, arg1: double): Vector3d;
                set(arg0: Vector2ic, arg1: double): Vector3d;
                set(arg0: Vector3fc): Vector3d;
                set(arg0: Vector2fc, arg1: double): Vector3d;
                set(arg0: double): Vector3d;
                set(arg0: double, arg1: double, arg2: double): Vector3d;
                set(arg0: double[]): Vector3d;
                set(arg0: float[]): Vector3d;
                set(arg0: java.nio.ByteBuffer): Vector3d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector3d;
                set(arg0: java.nio.DoubleBuffer): Vector3d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Vector3d;
                setFromAddress(arg0: long): Vector3d;
                setComponent(arg0: int, arg1: double): Vector3d;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getf(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getf(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getToAddress(arg0: long): Vector3dc;
                sub(arg0: Vector3dc): Vector3d;
                sub(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                sub(arg0: Vector3fc): Vector3d;
                sub(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                sub(arg0: double, arg1: double, arg2: double): Vector3d;
                sub(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                add(arg0: Vector3dc): Vector3d;
                add(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                add(arg0: Vector3fc): Vector3d;
                add(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                add(arg0: double, arg1: double, arg2: double): Vector3d;
                add(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3dc): Vector3d;
                fma(arg0: double, arg1: Vector3dc): Vector3d;
                fma(arg0: Vector3fc, arg1: Vector3fc): Vector3d;
                fma(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3fc): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: Vector3dc, arg1: Vector3dc): Vector3d;
                mulAdd(arg0: double, arg1: Vector3dc): Vector3d;
                mulAdd(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: double, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: Vector3fc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mul(arg0: Vector3dc): Vector3d;
                mul(arg0: Vector3fc): Vector3d;
                mul(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                mul(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                div(arg0: Vector3d): Vector3d;
                div(arg0: Vector3fc): Vector3d;
                div(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                div(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc, arg1: double, arg2: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc): Vector3d;
                mulProject(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4fc): Vector3d;
                mul(arg0: Matrix3fc): Vector3d;
                mul(arg0: Matrix3dc): Vector3d;
                mul(arg0: Matrix3dc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3dc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3fc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3x2dc): Vector3d;
                mul(arg0: Matrix3x2dc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3x2fc): Vector3d;
                mul(arg0: Matrix3x2fc, arg1: Vector3d): Vector3d;
                mulTranspose(arg0: Matrix3dc): Vector3d;
                mulTranspose(arg0: Matrix3dc, arg1: Vector3d): Vector3d;
                mulTranspose(arg0: Matrix3fc): Vector3d;
                mulTranspose(arg0: Matrix3fc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4fc): Vector3d;
                mulPosition(arg0: Matrix4dc): Vector3d;
                mulPosition(arg0: Matrix4x3dc): Vector3d;
                mulPosition(arg0: Matrix4x3fc): Vector3d;
                mulPosition(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4x3dc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4x3fc, arg1: Vector3d): Vector3d;
                mulTransposePosition(arg0: Matrix4dc): Vector3d;
                mulTransposePosition(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulTransposePosition(arg0: Matrix4fc): Vector3d;
                mulTransposePosition(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulPositionW(arg0: Matrix4fc): number;
                mulPositionW(arg0: Matrix4fc, arg1: Vector3d): number;
                mulPositionW(arg0: Matrix4dc): number;
                mulPositionW(arg0: Matrix4dc, arg1: Vector3d): number;
                mulDirection(arg0: Matrix4fc): Vector3d;
                mulDirection(arg0: Matrix4dc): Vector3d;
                mulDirection(arg0: Matrix4x3dc): Vector3d;
                mulDirection(arg0: Matrix4x3fc): Vector3d;
                mulDirection(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4x3dc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4x3fc, arg1: Vector3d): Vector3d;
                mulTransposeDirection(arg0: Matrix4dc): Vector3d;
                mulTransposeDirection(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulTransposeDirection(arg0: Matrix4fc): Vector3d;
                mulTransposeDirection(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mul(arg0: double): Vector3d;
                mul(arg0: double, arg1: Vector3d): Vector3d;
                mul(arg0: double, arg1: double, arg2: double): Vector3d;
                mul(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                rotate(arg0: Quaterniondc): Vector3d;
                rotate(arg0: Quaterniondc, arg1: Vector3d): Vector3d;
                rotationTo(arg0: Vector3dc, arg1: Quaterniond): Quaterniond;
                rotationTo(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double): Vector3d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector3d): Vector3d;
                rotateX(arg0: double): Vector3d;
                rotateX(arg0: double, arg1: Vector3d): Vector3d;
                rotateY(arg0: double): Vector3d;
                rotateY(arg0: double, arg1: Vector3d): Vector3d;
                rotateZ(arg0: double): Vector3d;
                rotateZ(arg0: double, arg1: Vector3d): Vector3d;
                div(arg0: double): Vector3d;
                div(arg0: double, arg1: Vector3d): Vector3d;
                div(arg0: double, arg1: double, arg2: double): Vector3d;
                div(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                lengthSquared(): number;
                length(): number;
                normalize(): Vector3d;
                normalize(arg0: Vector3d): Vector3d;
                normalize(arg0: double): Vector3d;
                normalize(arg0: double, arg1: Vector3d): Vector3d;
                cross(arg0: Vector3dc): Vector3d;
                cross(arg0: double, arg1: double, arg2: double): Vector3d;
                cross(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                cross(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                distance(arg0: Vector3dc): number;
                distance(arg0: double, arg1: double, arg2: double): number;
                distanceSquared(arg0: Vector3dc): number;
                distanceSquared(arg0: double, arg1: double, arg2: double): number;
                dot(arg0: Vector3dc): number;
                dot(arg0: double, arg1: double, arg2: double): number;
                angleCos(arg0: Vector3dc): number;
                angle(arg0: Vector3dc): number;
                angleSigned(arg0: Vector3dc, arg1: Vector3dc): number;
                angleSigned(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                min(arg0: Vector3dc): Vector3d;
                min(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                max(arg0: Vector3dc): Vector3d;
                max(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                zero(): Vector3d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector3d;
                negate(arg0: Vector3d): Vector3d;
                absolute(): Vector3d;
                absolute(arg0: Vector3d): Vector3d;
                equals(arg0: Vector3dc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double): boolean;
                equals(arg0: any): boolean;
                reflect(arg0: Vector3dc): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double): Vector3d;
                reflect(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                half(arg0: Vector3dc): Vector3d;
                half(arg0: double, arg1: double, arg2: double): Vector3d;
                half(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                half(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                smoothStep(arg0: Vector3dc, arg1: double, arg2: Vector3d): Vector3d;
                hermite(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: double, arg4: Vector3d): Vector3d;
                lerp(arg0: Vector3dc, arg1: double): Vector3d;
                lerp(arg0: Vector3dc, arg1: double, arg2: Vector3d): Vector3d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector3i): Vector3i;
                get(arg0: Vector3f): Vector3f;
                get(arg0: Vector3d): Vector3d;
                maxComponent(): number;
                minComponent(): number;
                orthogonalize(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                orthogonalize(arg0: Vector3dc): Vector3d;
                orthogonalizeUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                orthogonalizeUnit(arg0: Vector3dc): Vector3d;
                floor(): Vector3d;
                floor(arg0: Vector3d): Vector3d;
                ceil(): Vector3d;
                ceil(arg0: Vector3d): Vector3d;
                round(): Vector3d;
                round(arg0: Vector3d): Vector3d;
                isFinite(): boolean;
                clone(): any;

            }

            abstract class Matrix3x2fc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix3x2fc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Matrix3x2fc {

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m20(): number;
                m21(): number;
                mul(arg0: Matrix3x2fc, arg1: Matrix3x2f): Matrix3x2f;
                mulLocal(arg0: Matrix3x2fc, arg1: Matrix3x2f): Matrix3x2f;
                determinant(): number;
                invert(arg0: Matrix3x2f): Matrix3x2f;
                translate(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                translate(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                translateLocal(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                translateLocal(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                get(arg0: Matrix3x2f): Matrix3x2f;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x3(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3x2fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get3x3(arg0: float[], arg1: int): JavaArray<number>;
                get3x3(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                scale(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                scale(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                scale(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                scaleLocal(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                scaleLocal(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3f, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformPosition(arg0: Vector2f): Vector2f;
                transformPosition(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformPosition(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                transformDirection(arg0: Vector2f): Vector2f;
                transformDirection(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformDirection(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                rotate(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                rotateLocal(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                rotateAbout(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                rotateTo(arg0: Vector2fc, arg1: Vector2fc, arg2: Matrix3x2f): Matrix3x2f;
                view(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                origin(arg0: Vector2f): Vector2f;
                viewArea(arg0: float[]): JavaArray<number>;
                positiveX(arg0: Vector2f): Vector2f;
                normalizedPositiveX(arg0: Vector2f): Vector2f;
                positiveY(arg0: Vector2f): Vector2f;
                normalizedPositiveY(arg0: Vector2f): Vector2f;
                unproject(arg0: float, arg1: float, arg2: int[], arg3: Vector2f): Vector2f;
                unprojectInv(arg0: float, arg1: float, arg2: int[], arg3: Vector2f): Vector2f;
                testPoint(arg0: float, arg1: float): boolean;
                testCircle(arg0: float, arg1: float, arg2: float): boolean;
                testAar(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                equals(arg0: Matrix3x2fc, arg1: float): boolean;
                isFinite(): boolean;

            }

            abstract class Vector2ic extends java.lang.Interface {
                static readonly class: JavaClass<Vector2ic>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Vector2ic {

                x(): number;
                y(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                getToAddress(arg0: long): Vector2ic;
                sub(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                sub(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2ic): number;
                distance(arg0: int, arg1: int): number;
                distanceSquared(arg0: Vector2ic): number;
                distanceSquared(arg0: int, arg1: int): number;
                gridDistance(arg0: Vector2ic): number;
                gridDistance(arg0: int, arg1: int): number;
                add(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                add(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                mul(arg0: int, arg1: Vector2i): Vector2i;
                mul(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                mul(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                div(arg0: float, arg1: Vector2i): Vector2i;
                div(arg0: int, arg1: Vector2i): Vector2i;
                negate(arg0: Vector2i): Vector2i;
                min(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                max(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                maxComponent(): number;
                minComponent(): number;
                absolute(arg0: Vector2i): Vector2i;
                get(arg0: int): number;
                equals(arg0: int, arg1: int): boolean;

            }

            abstract class Vector2fc extends java.lang.Interface {
                static readonly class: JavaClass<Vector2fc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Vector2fc {

                x(): number;
                y(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getToAddress(arg0: long): Vector2fc;
                sub(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                sub(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                dot(arg0: Vector2fc): number;
                angle(arg0: Vector2fc): number;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2fc): number;
                distanceSquared(arg0: Vector2fc): number;
                distance(arg0: float, arg1: float): number;
                distanceSquared(arg0: float, arg1: float): number;
                normalize(arg0: Vector2f): Vector2f;
                normalize(arg0: float, arg1: Vector2f): Vector2f;
                add(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                add(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                negate(arg0: Vector2f): Vector2f;
                mul(arg0: float, arg1: Vector2f): Vector2f;
                mul(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                mul(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                div(arg0: float, arg1: Vector2f): Vector2f;
                div(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                div(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                mul(arg0: Matrix2fc, arg1: Vector2f): Vector2f;
                mul(arg0: Matrix2dc, arg1: Vector2f): Vector2f;
                mulTranspose(arg0: Matrix2fc, arg1: Vector2f): Vector2f;
                mulPosition(arg0: Matrix3x2fc, arg1: Vector2f): Vector2f;
                mulDirection(arg0: Matrix3x2fc, arg1: Vector2f): Vector2f;
                lerp(arg0: Vector2fc, arg1: float, arg2: Vector2f): Vector2f;
                fma(arg0: Vector2fc, arg1: Vector2fc, arg2: Vector2f): Vector2f;
                fma(arg0: float, arg1: Vector2fc, arg2: Vector2f): Vector2f;
                min(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                max(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                maxComponent(): number;
                minComponent(): number;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector2i): Vector2i;
                get(arg0: Vector2f): Vector2f;
                get(arg0: Vector2d): Vector2d;
                floor(arg0: Vector2f): Vector2f;
                ceil(arg0: Vector2f): Vector2f;
                round(arg0: Vector2f): Vector2f;
                isFinite(): boolean;
                absolute(arg0: Vector2f): Vector2f;
                equals(arg0: Vector2fc, arg1: float): boolean;
                equals(arg0: float, arg1: float): boolean;

            }

            abstract class Vector3ic extends java.lang.Interface {
                static readonly class: JavaClass<Vector3ic>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Vector3ic {

                x(): number;
                y(): number;
                z(): number;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3ic;
                sub(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                sub(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                add(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                add(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                mul(arg0: int, arg1: Vector3i): Vector3i;
                mul(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                mul(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                div(arg0: float, arg1: Vector3i): Vector3i;
                div(arg0: int, arg1: Vector3i): Vector3i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector3ic): number;
                distance(arg0: int, arg1: int, arg2: int): number;
                gridDistance(arg0: Vector3ic): number;
                gridDistance(arg0: int, arg1: int, arg2: int): number;
                distanceSquared(arg0: Vector3ic): number;
                distanceSquared(arg0: int, arg1: int, arg2: int): number;
                negate(arg0: Vector3i): Vector3i;
                min(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                max(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                get(arg0: int): number;
                maxComponent(): number;
                minComponent(): number;
                absolute(arg0: Vector3i): Vector3i;
                equals(arg0: int, arg1: int, arg2: int): boolean;

            }

            abstract class Quaternionfc extends java.lang.Interface {
                static readonly class: JavaClass<Quaternionfc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Quaternionfc {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                normalize(arg0: Quaternionf): Quaternionf;
                add(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                add(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                angle(): number;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4x3d): Matrix4x3d;
                get(arg0: AxisAngle4f): AxisAngle4f;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Quaternionf): Quaternionf;
                getAsMatrix3f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix3f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getAsMatrix4f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix4f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getAsMatrix4x3f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix4x3f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                mul(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                mul(arg0: float, arg1: Quaternionf): Quaternionf;
                premul(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                premul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                transform(arg0: Vector3f): Vector3f;
                transformInverse(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector4f): Vector4f;
                transformUnitPositiveX(arg0: Vector3f): Vector3f;
                transformUnitPositiveX(arg0: Vector4f): Vector4f;
                transformPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector3f): Vector3f;
                transformUnitPositiveY(arg0: Vector4f): Vector4f;
                transformPositiveZ(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector3f): Vector3f;
                transformUnitPositiveZ(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4f): Vector4f;
                transformInverse(arg0: Vector4f): Vector4f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverse(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverse(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transform(arg0: Vector3d): Vector3d;
                transformInverse(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector4d): Vector4d;
                transformUnitPositiveX(arg0: Vector3d): Vector3d;
                transformUnitPositiveX(arg0: Vector4d): Vector4d;
                transformPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector3d): Vector3d;
                transformUnitPositiveY(arg0: Vector4d): Vector4d;
                transformPositiveZ(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector3d): Vector3d;
                transformUnitPositiveZ(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4d): Vector4d;
                transformInverse(arg0: Vector4d): Vector4d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverse(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverse(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformUnit(arg0: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4d): Vector4d;
                transformUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                invert(arg0: Quaternionf): Quaternionf;
                div(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                conjugate(arg0: Quaternionf): Quaternionf;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesZXY(arg0: Vector3f): Vector3f;
                getEulerAnglesYXZ(arg0: Vector3f): Vector3f;
                lengthSquared(): number;
                slerp(arg0: Quaternionfc, arg1: float, arg2: Quaternionf): Quaternionf;
                scale(arg0: float, arg1: Quaternionf): Quaternionf;
                integrate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                nlerp(arg0: Quaternionfc, arg1: float, arg2: Quaternionf): Quaternionf;
                nlerpIterative(arg0: Quaternionfc, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Quaternionf): Quaternionf;
                rotateTo(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Quaternionf): Quaternionf;
                rotateTo(arg0: Vector3fc, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                rotateX(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateY(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateZ(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalX(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalY(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalZ(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                difference(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                conjugateBy(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                isFinite(): boolean;
                equals(arg0: Quaternionfc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float, arg3: float): boolean;

            }

            abstract class Matrix3dc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix3dc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Matrix3dc {

                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                mul(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mulLocal(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mul(arg0: Matrix3fc, arg1: Matrix3d): Matrix3d;
                determinant(): number;
                invert(arg0: Matrix3d): Matrix3d;
                transpose(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix3d): Matrix3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                scale(arg0: Vector3dc, arg1: Matrix3d): Matrix3d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                scale(arg0: double, arg1: Matrix3d): Matrix3d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformTranspose(arg0: Vector3d): Vector3d;
                transformTranspose(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformTranspose(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                rotateX(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateY(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateZ(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3d): Matrix3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3d): Matrix3d;
                rotateLocalX(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalY(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalZ(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: Quaternionfc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: AxisAngle4f, arg1: Matrix3d): Matrix3d;
                rotate(arg0: AxisAngle4d, arg1: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix3d): Matrix3d;
                getRow(arg0: int, arg1: Vector3d): Vector3d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                get(arg0: int, arg1: int): number;
                getRowColumn(arg0: int, arg1: int): number;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor(arg0: Matrix3d): Matrix3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix3d): Matrix3d;
                getScale(arg0: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                add(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                sub(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mulComponentWise(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                lerp(arg0: Matrix3dc, arg1: double, arg2: Matrix3d): Matrix3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix3d): Matrix3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix3d): Matrix3d;
                equals(arg0: Matrix3dc, arg1: double): boolean;
                reflect(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                reflect(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                reflect(arg0: Vector3dc, arg1: Matrix3d): Matrix3d;
                isFinite(): boolean;
                quadraticFormProduct(arg0: double, arg1: double, arg2: double): number;
                quadraticFormProduct(arg0: Vector3dc): number;
                quadraticFormProduct(arg0: Vector3fc): number;
                mapXZY(arg0: Matrix3d): Matrix3d;
                mapXZnY(arg0: Matrix3d): Matrix3d;
                mapXnYnZ(arg0: Matrix3d): Matrix3d;
                mapXnZY(arg0: Matrix3d): Matrix3d;
                mapXnZnY(arg0: Matrix3d): Matrix3d;
                mapYXZ(arg0: Matrix3d): Matrix3d;
                mapYXnZ(arg0: Matrix3d): Matrix3d;
                mapYZX(arg0: Matrix3d): Matrix3d;
                mapYZnX(arg0: Matrix3d): Matrix3d;
                mapYnXZ(arg0: Matrix3d): Matrix3d;
                mapYnXnZ(arg0: Matrix3d): Matrix3d;
                mapYnZX(arg0: Matrix3d): Matrix3d;
                mapYnZnX(arg0: Matrix3d): Matrix3d;
                mapZXY(arg0: Matrix3d): Matrix3d;
                mapZXnY(arg0: Matrix3d): Matrix3d;
                mapZYX(arg0: Matrix3d): Matrix3d;
                mapZYnX(arg0: Matrix3d): Matrix3d;
                mapZnXY(arg0: Matrix3d): Matrix3d;
                mapZnXnY(arg0: Matrix3d): Matrix3d;
                mapZnYX(arg0: Matrix3d): Matrix3d;
                mapZnYnX(arg0: Matrix3d): Matrix3d;
                mapnXYnZ(arg0: Matrix3d): Matrix3d;
                mapnXZY(arg0: Matrix3d): Matrix3d;
                mapnXZnY(arg0: Matrix3d): Matrix3d;
                mapnXnYZ(arg0: Matrix3d): Matrix3d;
                mapnXnYnZ(arg0: Matrix3d): Matrix3d;
                mapnXnZY(arg0: Matrix3d): Matrix3d;
                mapnXnZnY(arg0: Matrix3d): Matrix3d;
                mapnYXZ(arg0: Matrix3d): Matrix3d;
                mapnYXnZ(arg0: Matrix3d): Matrix3d;
                mapnYZX(arg0: Matrix3d): Matrix3d;
                mapnYZnX(arg0: Matrix3d): Matrix3d;
                mapnYnXZ(arg0: Matrix3d): Matrix3d;
                mapnYnXnZ(arg0: Matrix3d): Matrix3d;
                mapnYnZX(arg0: Matrix3d): Matrix3d;
                mapnYnZnX(arg0: Matrix3d): Matrix3d;
                mapnZXY(arg0: Matrix3d): Matrix3d;
                mapnZXnY(arg0: Matrix3d): Matrix3d;
                mapnZYX(arg0: Matrix3d): Matrix3d;
                mapnZYnX(arg0: Matrix3d): Matrix3d;
                mapnZnXY(arg0: Matrix3d): Matrix3d;
                mapnZnXnY(arg0: Matrix3d): Matrix3d;
                mapnZnYX(arg0: Matrix3d): Matrix3d;
                mapnZnYnX(arg0: Matrix3d): Matrix3d;
                negateX(arg0: Matrix3d): Matrix3d;
                negateY(arg0: Matrix3d): Matrix3d;
                negateZ(arg0: Matrix3d): Matrix3d;

            }

            abstract class Matrix4fc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix4fc>;
                /** @deprecated */ static prototype: undefined;

                static readonly PLANE_NX: number;
                static readonly PLANE_PX: number;
                static readonly PLANE_NY: number;
                static readonly PLANE_PY: number;
                static readonly PLANE_NZ: number;
                static readonly PLANE_PZ: number;
                static readonly CORNER_NXNYNZ: number;
                static readonly CORNER_PXNYNZ: number;
                static readonly CORNER_PXPYNZ: number;
                static readonly CORNER_NXPYNZ: number;
                static readonly CORNER_PXNYPZ: number;
                static readonly CORNER_NXNYPZ: number;
                static readonly CORNER_NXPYPZ: number;
                static readonly CORNER_PXPYPZ: number;
                static readonly PROPERTY_PERSPECTIVE: number;
                static readonly PROPERTY_AFFINE: number;
                static readonly PROPERTY_IDENTITY: number;
                static readonly PROPERTY_TRANSLATION: number;
                static readonly PROPERTY_ORTHONORMAL: number;
            }
            interface Matrix4fc {

                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m03(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m13(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m23(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m33(): number;
                mul(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul0(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float, arg16: Matrix4f): Matrix4f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                mulLocal(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulLocalAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: Matrix3x2fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                mulAffineR(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulTranslationAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulOrthoAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                fma4x3(arg0: Matrix4fc, arg1: float, arg2: Matrix4f): Matrix4f;
                add(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                sub(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulComponentWise(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                add4x3(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                sub4x3(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul4x3ComponentWise(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                determinant(): number;
                determinant3x3(): number;
                determinantAffine(): number;
                invert(arg0: Matrix4f): Matrix4f;
                invertPerspective(arg0: Matrix4f): Matrix4f;
                invertFrustum(arg0: Matrix4f): Matrix4f;
                invertOrtho(arg0: Matrix4f): Matrix4f;
                invertPerspectiveView(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                invertPerspectiveView(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                invertAffine(arg0: Matrix4f): Matrix4f;
                transpose(arg0: Matrix4f): Matrix4f;
                transpose3x3(arg0: Matrix4f): Matrix4f;
                transpose3x3(arg0: Matrix3f): Matrix3f;
                getTranslation(arg0: Vector3f): Vector3f;
                getScale(arg0: Vector3f): Vector3f;
                get(arg0: Matrix4f): Matrix4f;
                get4x3(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4d): Matrix4d;
                get3x3(arg0: Matrix3f): Matrix3f;
                get3x3(arg0: Matrix3d): Matrix3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getRotation(arg0: AxisAngle4d): AxisAngle4d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3Transposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformTranspose(arg0: Vector4f): Vector4f;
                transformTranspose(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformTranspose(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformProject(arg0: Vector4f): Vector4f;
                transformProject(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformProject(arg0: Vector3f): Vector3f;
                transformProject(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformProject(arg0: Vector4fc, arg1: Vector3f): Vector3f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector3f): Vector3f;
                transformPosition(arg0: Vector3f): Vector3f;
                transformPosition(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformPosition(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformAffine(arg0: Vector4f): Vector4f;
                transformAffine(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                scale(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                scale(arg0: float, arg1: Matrix4f): Matrix4f;
                scaleXY(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                scaleLocal(arg0: float, arg1: Matrix4f): Matrix4f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateX(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateY(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateZ(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateTowardsXY(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateTranslation(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateLocalX(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalY(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalZ(arg0: float, arg1: Matrix4f): Matrix4f;
                translate(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                translate(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                translateLocal(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                translateLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtPerspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtPerspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                tile(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                rotate(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAffine(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAroundAffine(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAroundLocal(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotate(arg0: AxisAngle4f, arg1: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                unproject(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                unproject(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                unproject(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                unproject(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                unprojectRay(arg0: float, arg1: float, arg2: int[], arg3: Vector3f, arg4: Vector3f): Matrix4f;
                unprojectRay(arg0: Vector2fc, arg1: int[], arg2: Vector3f, arg3: Vector3f): Matrix4f;
                unprojectInv(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                unprojectInv(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                unprojectInvRay(arg0: Vector2fc, arg1: int[], arg2: Vector3f, arg3: Vector3f): Matrix4f;
                unprojectInvRay(arg0: float, arg1: float, arg2: int[], arg3: Vector3f, arg4: Vector3f): Matrix4f;
                unprojectInv(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                unprojectInv(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                project(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                project(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                project(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                project(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                reflect(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                getRow(arg0: int, arg1: Vector4f): Vector4f;
                getRow(arg0: int, arg1: Vector3f): Vector3f;
                getColumn(arg0: int, arg1: Vector4f): Vector4f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                get(arg0: int, arg1: int): number;
                getRowColumn(arg0: int, arg1: int): number;
                normal(arg0: Matrix4f): Matrix4f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix4f): Matrix4f;
                normalize3x3(arg0: Matrix4f): Matrix4f;
                normalize3x3(arg0: Matrix3f): Matrix3f;
                frustumPlane(arg0: int, arg1: Vector4f): Vector4f;
                frustumCorner(arg0: int, arg1: Vector3f): Vector3f;
                perspectiveOrigin(arg0: Vector3f): Vector3f;
                perspectiveInvOrigin(arg0: Vector3f): Vector3f;
                perspectiveFov(): number;
                perspectiveNear(): number;
                perspectiveFar(): number;
                frustumRayDir(arg0: float, arg1: float, arg2: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                originAffine(arg0: Vector3f): Vector3f;
                origin(arg0: Vector3f): Vector3f;
                shadow(arg0: Vector4f, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: Matrix4f): Matrix4f;
                shadow(arg0: Vector4f, arg1: Matrix4fc, arg2: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4fc, arg5: Matrix4f): Matrix4f;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[], arg5: Matrix4f): Matrix4f;
                isAffine(): boolean;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                frustumAabb(arg0: Vector3f, arg1: Vector3f): Matrix4f;
                projectedGridRange(arg0: Matrix4fc, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                perspectiveFrustumSlice(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                orthoCrop(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                transformAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Vector3f, arg7: Vector3f): Matrix4f;
                transformAab(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f, arg3: Vector3f): Matrix4f;
                lerp(arg0: Matrix4fc, arg1: float, arg2: Matrix4f): Matrix4f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                testPoint(arg0: float, arg1: float, arg2: float): boolean;
                testSphere(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                testAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): boolean;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                withLookAtUp(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                withLookAtUp(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                mapXZY(arg0: Matrix4f): Matrix4f;
                mapXZnY(arg0: Matrix4f): Matrix4f;
                mapXnYnZ(arg0: Matrix4f): Matrix4f;
                mapXnZY(arg0: Matrix4f): Matrix4f;
                mapXnZnY(arg0: Matrix4f): Matrix4f;
                mapYXZ(arg0: Matrix4f): Matrix4f;
                mapYXnZ(arg0: Matrix4f): Matrix4f;
                mapYZX(arg0: Matrix4f): Matrix4f;
                mapYZnX(arg0: Matrix4f): Matrix4f;
                mapYnXZ(arg0: Matrix4f): Matrix4f;
                mapYnXnZ(arg0: Matrix4f): Matrix4f;
                mapYnZX(arg0: Matrix4f): Matrix4f;
                mapYnZnX(arg0: Matrix4f): Matrix4f;
                mapZXY(arg0: Matrix4f): Matrix4f;
                mapZXnY(arg0: Matrix4f): Matrix4f;
                mapZYX(arg0: Matrix4f): Matrix4f;
                mapZYnX(arg0: Matrix4f): Matrix4f;
                mapZnXY(arg0: Matrix4f): Matrix4f;
                mapZnXnY(arg0: Matrix4f): Matrix4f;
                mapZnYX(arg0: Matrix4f): Matrix4f;
                mapZnYnX(arg0: Matrix4f): Matrix4f;
                mapnXYnZ(arg0: Matrix4f): Matrix4f;
                mapnXZY(arg0: Matrix4f): Matrix4f;
                mapnXZnY(arg0: Matrix4f): Matrix4f;
                mapnXnYZ(arg0: Matrix4f): Matrix4f;
                mapnXnYnZ(arg0: Matrix4f): Matrix4f;
                mapnXnZY(arg0: Matrix4f): Matrix4f;
                mapnXnZnY(arg0: Matrix4f): Matrix4f;
                mapnYXZ(arg0: Matrix4f): Matrix4f;
                mapnYXnZ(arg0: Matrix4f): Matrix4f;
                mapnYZX(arg0: Matrix4f): Matrix4f;
                mapnYZnX(arg0: Matrix4f): Matrix4f;
                mapnYnXZ(arg0: Matrix4f): Matrix4f;
                mapnYnXnZ(arg0: Matrix4f): Matrix4f;
                mapnYnZX(arg0: Matrix4f): Matrix4f;
                mapnYnZnX(arg0: Matrix4f): Matrix4f;
                mapnZXY(arg0: Matrix4f): Matrix4f;
                mapnZXnY(arg0: Matrix4f): Matrix4f;
                mapnZYX(arg0: Matrix4f): Matrix4f;
                mapnZYnX(arg0: Matrix4f): Matrix4f;
                mapnZnXY(arg0: Matrix4f): Matrix4f;
                mapnZnXnY(arg0: Matrix4f): Matrix4f;
                mapnZnYX(arg0: Matrix4f): Matrix4f;
                mapnZnYnX(arg0: Matrix4f): Matrix4f;
                negateX(arg0: Matrix4f): Matrix4f;
                negateY(arg0: Matrix4f): Matrix4f;
                negateZ(arg0: Matrix4f): Matrix4f;
                equals(arg0: Matrix4fc, arg1: float): boolean;
                isFinite(): boolean;

            }

            interface Vector3i extends java.lang.Cloneable, Vector3ic, java.io.Externalizable {}
            class Vector3i extends java.lang.Object {
                static readonly class: JavaClass<Vector3i>;
                /** @deprecated */ static prototype: undefined;

                static lengthSquared(arg0: int, arg1: int, arg2: int): number;
                static length(arg0: int, arg1: int, arg2: int): number;
                static distance(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): number;
                static distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): number;

                constructor ();
                constructor (arg0: int);
                constructor (arg0: int, arg1: int, arg2: int);
                constructor (arg0: Vector3ic);
                constructor (arg0: Vector2ic, arg1: int);
                constructor (arg0: float, arg1: float, arg2: float, arg3: int);
                constructor (arg0: double, arg1: double, arg2: double, arg3: int);
                constructor (arg0: Vector2fc, arg1: float, arg2: int);
                constructor (arg0: Vector3fc, arg1: int);
                constructor (arg0: Vector2dc, arg1: float, arg2: int);
                constructor (arg0: Vector3dc, arg1: int);
                constructor (arg0: int[]);
                constructor (arg0: java.nio.ByteBuffer);
                constructor (arg0: int, arg1: java.nio.ByteBuffer);
                constructor (arg0: java.nio.IntBuffer);
                constructor (arg0: int, arg1: java.nio.IntBuffer);

                x: number;
                y: number;
                z: number;

                x(): number;
                y(): number;
                z(): number;
                set(arg0: Vector3ic): Vector3i;
                set(arg0: Vector3dc): Vector3i;
                set(arg0: Vector3dc, arg1: int): Vector3i;
                set(arg0: Vector3fc, arg1: int): Vector3i;
                set(arg0: Vector2ic, arg1: int): Vector3i;
                set(arg0: int): Vector3i;
                set(arg0: int, arg1: int, arg2: int): Vector3i;
                set(arg0: int[]): Vector3i;
                set(arg0: java.nio.ByteBuffer): Vector3i;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector3i;
                set(arg0: java.nio.IntBuffer): Vector3i;
                set(arg0: int, arg1: java.nio.IntBuffer): Vector3i;
                setFromAddress(arg0: long): Vector3i;
                get(arg0: int): number;
                setComponent(arg0: int, arg1: int): Vector3i;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3ic;
                sub(arg0: Vector3ic): Vector3i;
                sub(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                sub(arg0: int, arg1: int, arg2: int): Vector3i;
                sub(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                add(arg0: Vector3ic): Vector3i;
                add(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                add(arg0: int, arg1: int, arg2: int): Vector3i;
                add(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                mul(arg0: int): Vector3i;
                mul(arg0: int, arg1: Vector3i): Vector3i;
                mul(arg0: Vector3ic): Vector3i;
                mul(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                mul(arg0: int, arg1: int, arg2: int): Vector3i;
                mul(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                div(arg0: float): Vector3i;
                div(arg0: float, arg1: Vector3i): Vector3i;
                div(arg0: int): Vector3i;
                div(arg0: int, arg1: Vector3i): Vector3i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector3ic): number;
                distance(arg0: int, arg1: int, arg2: int): number;
                gridDistance(arg0: Vector3ic): number;
                gridDistance(arg0: int, arg1: int, arg2: int): number;
                distanceSquared(arg0: Vector3ic): number;
                distanceSquared(arg0: int, arg1: int, arg2: int): number;
                zero(): Vector3i;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector3i;
                negate(arg0: Vector3i): Vector3i;
                min(arg0: Vector3ic): Vector3i;
                min(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                max(arg0: Vector3ic): Vector3i;
                max(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                maxComponent(): number;
                minComponent(): number;
                absolute(): Vector3i;
                absolute(arg0: Vector3i): Vector3i;
                equals(arg0: int, arg1: int, arg2: int): boolean;
                equals(arg0: any): boolean;
                clone(): any;

            }

            abstract class Vector2dc extends java.lang.Interface {
                static readonly class: JavaClass<Vector2dc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Vector2dc {

                x(): number;
                y(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getToAddress(arg0: long): Vector2dc;
                sub(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                sub(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                sub(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                mul(arg0: double, arg1: Vector2d): Vector2d;
                mul(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                mul(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                div(arg0: double, arg1: Vector2d): Vector2d;
                div(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                div(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                div(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                mul(arg0: Matrix2dc, arg1: Vector2d): Vector2d;
                mul(arg0: Matrix2fc, arg1: Vector2d): Vector2d;
                mulTranspose(arg0: Matrix2dc, arg1: Vector2d): Vector2d;
                mulTranspose(arg0: Matrix2fc, arg1: Vector2d): Vector2d;
                mulPosition(arg0: Matrix3x2dc, arg1: Vector2d): Vector2d;
                mulDirection(arg0: Matrix3x2dc, arg1: Vector2d): Vector2d;
                dot(arg0: Vector2dc): number;
                angle(arg0: Vector2dc): number;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2dc): number;
                distanceSquared(arg0: Vector2dc): number;
                distance(arg0: Vector2fc): number;
                distanceSquared(arg0: Vector2fc): number;
                distance(arg0: double, arg1: double): number;
                distanceSquared(arg0: double, arg1: double): number;
                normalize(arg0: Vector2d): Vector2d;
                normalize(arg0: double, arg1: Vector2d): Vector2d;
                add(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                add(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                add(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                negate(arg0: Vector2d): Vector2d;
                lerp(arg0: Vector2dc, arg1: double, arg2: Vector2d): Vector2d;
                fma(arg0: Vector2dc, arg1: Vector2dc, arg2: Vector2d): Vector2d;
                fma(arg0: double, arg1: Vector2dc, arg2: Vector2d): Vector2d;
                min(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                max(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                maxComponent(): number;
                minComponent(): number;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector2i): Vector2i;
                get(arg0: Vector2f): Vector2f;
                get(arg0: Vector2d): Vector2d;
                floor(arg0: Vector2d): Vector2d;
                ceil(arg0: Vector2d): Vector2d;
                round(arg0: Vector2d): Vector2d;
                isFinite(): boolean;
                absolute(arg0: Vector2d): Vector2d;
                equals(arg0: Vector2dc, arg1: double): boolean;
                equals(arg0: double, arg1: double): boolean;

            }

            interface Matrix3d extends java.lang.Cloneable, java.io.Externalizable, Matrix3dc {}
            class Matrix3d extends java.lang.Object {
                static readonly class: JavaClass<Matrix3d>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Matrix2dc);
                constructor (arg0: Matrix2fc);
                constructor (arg0: Matrix3dc);
                constructor (arg0: Matrix3fc);
                constructor (arg0: Matrix4fc);
                constructor (arg0: Matrix4dc);
                constructor (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double);
                constructor (arg0: java.nio.DoubleBuffer);
                constructor (arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc);

                m00: number;
                m01: number;
                m02: number;
                m10: number;
                m11: number;
                m12: number;
                m20: number;
                m21: number;
                m22: number;

                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m00(arg0: double): Matrix3d;
                m01(arg0: double): Matrix3d;
                m02(arg0: double): Matrix3d;
                m10(arg0: double): Matrix3d;
                m11(arg0: double): Matrix3d;
                m12(arg0: double): Matrix3d;
                m20(arg0: double): Matrix3d;
                m21(arg0: double): Matrix3d;
                m22(arg0: double): Matrix3d;
                set(arg0: Matrix3dc): Matrix3d;
                setTransposed(arg0: Matrix3dc): Matrix3d;
                set(arg0: Matrix3fc): Matrix3d;
                setTransposed(arg0: Matrix3fc): Matrix3d;
                set(arg0: Matrix4x3dc): Matrix3d;
                set(arg0: Matrix4fc): Matrix3d;
                set(arg0: Matrix4dc): Matrix3d;
                set(arg0: Matrix2fc): Matrix3d;
                set(arg0: Matrix2dc): Matrix3d;
                set(arg0: AxisAngle4f): Matrix3d;
                set(arg0: AxisAngle4d): Matrix3d;
                set(arg0: Quaternionfc): Matrix3d;
                set(arg0: Quaterniondc): Matrix3d;
                mul(arg0: Matrix3dc): Matrix3d;
                mul(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mulLocal(arg0: Matrix3dc): Matrix3d;
                mulLocal(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mul(arg0: Matrix3fc): Matrix3d;
                mul(arg0: Matrix3fc, arg1: Matrix3d): Matrix3d;
                set(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix3d;
                set(arg0: double[]): Matrix3d;
                set(arg0: float[]): Matrix3d;
                determinant(): number;
                invert(): Matrix3d;
                invert(arg0: Matrix3d): Matrix3d;
                transpose(): Matrix3d;
                transpose(arg0: Matrix3d): Matrix3d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix3d): Matrix3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                set(arg0: java.nio.DoubleBuffer): Matrix3d;
                set(arg0: java.nio.FloatBuffer): Matrix3d;
                set(arg0: java.nio.ByteBuffer): Matrix3d;
                setFloats(arg0: java.nio.ByteBuffer): Matrix3d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix3d;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix3d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix3d;
                setFloats(arg0: int, arg1: java.nio.ByteBuffer): Matrix3d;
                setFromAddress(arg0: long): Matrix3d;
                set(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix3d;
                zero(): Matrix3d;
                identity(): Matrix3d;
                scaling(arg0: double): Matrix3d;
                scaling(arg0: double, arg1: double, arg2: double): Matrix3d;
                scaling(arg0: Vector3dc): Matrix3d;
                scale(arg0: Vector3dc, arg1: Matrix3d): Matrix3d;
                scale(arg0: Vector3dc): Matrix3d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                scale(arg0: double, arg1: double, arg2: double): Matrix3d;
                scale(arg0: double, arg1: Matrix3d): Matrix3d;
                scale(arg0: double): Matrix3d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                scaleLocal(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotation(arg0: double, arg1: Vector3dc): Matrix3d;
                rotation(arg0: double, arg1: Vector3fc): Matrix3d;
                rotation(arg0: AxisAngle4f): Matrix3d;
                rotation(arg0: AxisAngle4d): Matrix3d;
                rotation(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3d;
                rotationX(arg0: double): Matrix3d;
                rotationY(arg0: double): Matrix3d;
                rotationZ(arg0: double): Matrix3d;
                rotationXYZ(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotationZYX(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotationYXZ(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotation(arg0: Quaterniondc): Matrix3d;
                rotation(arg0: Quaternionfc): Matrix3d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformTranspose(arg0: Vector3d): Vector3d;
                transformTranspose(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformTranspose(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotateX(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateX(arg0: double): Matrix3d;
                rotateY(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateY(arg0: double): Matrix3d;
                rotateZ(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateZ(arg0: double): Matrix3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotateZYX(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotateYXZ(arg0: Vector3d): Matrix3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3d): Matrix3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3d): Matrix3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3d;
                rotateLocalX(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalX(arg0: double): Matrix3d;
                rotateLocalY(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalY(arg0: double): Matrix3d;
                rotateLocalZ(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalZ(arg0: double): Matrix3d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                rotateLocal(arg0: Quaterniondc): Matrix3d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix3d): Matrix3d;
                rotateLocal(arg0: Quaternionfc): Matrix3d;
                rotate(arg0: Quaterniondc): Matrix3d;
                rotate(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: Quaternionfc): Matrix3d;
                rotate(arg0: Quaternionfc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: AxisAngle4f): Matrix3d;
                rotate(arg0: AxisAngle4f, arg1: Matrix3d): Matrix3d;
                rotate(arg0: AxisAngle4d): Matrix3d;
                rotate(arg0: AxisAngle4d, arg1: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: Vector3dc): Matrix3d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: Vector3fc): Matrix3d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix3d): Matrix3d;
                getRow(arg0: int, arg1: Vector3d): Vector3d;
                setRow(arg0: int, arg1: Vector3dc): Matrix3d;
                setRow(arg0: int, arg1: double, arg2: double, arg3: double): Matrix3d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                setColumn(arg0: int, arg1: Vector3dc): Matrix3d;
                setColumn(arg0: int, arg1: double, arg2: double, arg3: double): Matrix3d;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: double): Matrix3d;
                getRowColumn(arg0: int, arg1: int): number;
                setRowColumn(arg0: int, arg1: int, arg2: double): Matrix3d;
                normal(): Matrix3d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor(): Matrix3d;
                cofactor(arg0: Matrix3d): Matrix3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix3d): Matrix3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3d;
                setLookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix3d;
                setLookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3d;
                getScale(arg0: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                equals(arg0: Matrix3dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                swap(arg0: Matrix3d): Matrix3d;
                add(arg0: Matrix3dc): Matrix3d;
                add(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                sub(arg0: Matrix3dc): Matrix3d;
                sub(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mulComponentWise(arg0: Matrix3dc): Matrix3d;
                mulComponentWise(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                setSkewSymmetric(arg0: double, arg1: double, arg2: double): Matrix3d;
                lerp(arg0: Matrix3dc, arg1: double): Matrix3d;
                lerp(arg0: Matrix3dc, arg1: double, arg2: Matrix3d): Matrix3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix3d): Matrix3d;
                rotationTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix3d;
                rotationTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                obliqueZ(arg0: double, arg1: double): Matrix3d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix3d): Matrix3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                reflect(arg0: double, arg1: double, arg2: double): Matrix3d;
                reflect(arg0: Vector3dc): Matrix3d;
                reflect(arg0: Quaterniondc): Matrix3d;
                reflect(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                reflect(arg0: Vector3dc, arg1: Matrix3d): Matrix3d;
                reflection(arg0: double, arg1: double, arg2: double): Matrix3d;
                reflection(arg0: Vector3dc): Matrix3d;
                reflection(arg0: Quaterniondc): Matrix3d;
                isFinite(): boolean;
                quadraticFormProduct(arg0: double, arg1: double, arg2: double): number;
                quadraticFormProduct(arg0: Vector3dc): number;
                quadraticFormProduct(arg0: Vector3fc): number;
                mapXZY(): Matrix3d;
                mapXZY(arg0: Matrix3d): Matrix3d;
                mapXZnY(): Matrix3d;
                mapXZnY(arg0: Matrix3d): Matrix3d;
                mapXnYnZ(): Matrix3d;
                mapXnYnZ(arg0: Matrix3d): Matrix3d;
                mapXnZY(): Matrix3d;
                mapXnZY(arg0: Matrix3d): Matrix3d;
                mapXnZnY(): Matrix3d;
                mapXnZnY(arg0: Matrix3d): Matrix3d;
                mapYXZ(): Matrix3d;
                mapYXZ(arg0: Matrix3d): Matrix3d;
                mapYXnZ(): Matrix3d;
                mapYXnZ(arg0: Matrix3d): Matrix3d;
                mapYZX(): Matrix3d;
                mapYZX(arg0: Matrix3d): Matrix3d;
                mapYZnX(): Matrix3d;
                mapYZnX(arg0: Matrix3d): Matrix3d;
                mapYnXZ(): Matrix3d;
                mapYnXZ(arg0: Matrix3d): Matrix3d;
                mapYnXnZ(): Matrix3d;
                mapYnXnZ(arg0: Matrix3d): Matrix3d;
                mapYnZX(): Matrix3d;
                mapYnZX(arg0: Matrix3d): Matrix3d;
                mapYnZnX(): Matrix3d;
                mapYnZnX(arg0: Matrix3d): Matrix3d;
                mapZXY(): Matrix3d;
                mapZXY(arg0: Matrix3d): Matrix3d;
                mapZXnY(): Matrix3d;
                mapZXnY(arg0: Matrix3d): Matrix3d;
                mapZYX(): Matrix3d;
                mapZYX(arg0: Matrix3d): Matrix3d;
                mapZYnX(): Matrix3d;
                mapZYnX(arg0: Matrix3d): Matrix3d;
                mapZnXY(): Matrix3d;
                mapZnXY(arg0: Matrix3d): Matrix3d;
                mapZnXnY(): Matrix3d;
                mapZnXnY(arg0: Matrix3d): Matrix3d;
                mapZnYX(): Matrix3d;
                mapZnYX(arg0: Matrix3d): Matrix3d;
                mapZnYnX(): Matrix3d;
                mapZnYnX(arg0: Matrix3d): Matrix3d;
                mapnXYnZ(): Matrix3d;
                mapnXYnZ(arg0: Matrix3d): Matrix3d;
                mapnXZY(): Matrix3d;
                mapnXZY(arg0: Matrix3d): Matrix3d;
                mapnXZnY(): Matrix3d;
                mapnXZnY(arg0: Matrix3d): Matrix3d;
                mapnXnYZ(): Matrix3d;
                mapnXnYZ(arg0: Matrix3d): Matrix3d;
                mapnXnYnZ(): Matrix3d;
                mapnXnYnZ(arg0: Matrix3d): Matrix3d;
                mapnXnZY(): Matrix3d;
                mapnXnZY(arg0: Matrix3d): Matrix3d;
                mapnXnZnY(): Matrix3d;
                mapnXnZnY(arg0: Matrix3d): Matrix3d;
                mapnYXZ(): Matrix3d;
                mapnYXZ(arg0: Matrix3d): Matrix3d;
                mapnYXnZ(): Matrix3d;
                mapnYXnZ(arg0: Matrix3d): Matrix3d;
                mapnYZX(): Matrix3d;
                mapnYZX(arg0: Matrix3d): Matrix3d;
                mapnYZnX(): Matrix3d;
                mapnYZnX(arg0: Matrix3d): Matrix3d;
                mapnYnXZ(): Matrix3d;
                mapnYnXZ(arg0: Matrix3d): Matrix3d;
                mapnYnXnZ(): Matrix3d;
                mapnYnXnZ(arg0: Matrix3d): Matrix3d;
                mapnYnZX(): Matrix3d;
                mapnYnZX(arg0: Matrix3d): Matrix3d;
                mapnYnZnX(): Matrix3d;
                mapnYnZnX(arg0: Matrix3d): Matrix3d;
                mapnZXY(): Matrix3d;
                mapnZXY(arg0: Matrix3d): Matrix3d;
                mapnZXnY(): Matrix3d;
                mapnZXnY(arg0: Matrix3d): Matrix3d;
                mapnZYX(): Matrix3d;
                mapnZYX(arg0: Matrix3d): Matrix3d;
                mapnZYnX(): Matrix3d;
                mapnZYnX(arg0: Matrix3d): Matrix3d;
                mapnZnXY(): Matrix3d;
                mapnZnXY(arg0: Matrix3d): Matrix3d;
                mapnZnXnY(): Matrix3d;
                mapnZnXnY(arg0: Matrix3d): Matrix3d;
                mapnZnYX(): Matrix3d;
                mapnZnYX(arg0: Matrix3d): Matrix3d;
                mapnZnYnX(): Matrix3d;
                mapnZnYnX(arg0: Matrix3d): Matrix3d;
                negateX(): Matrix3d;
                negateX(arg0: Matrix3d): Matrix3d;
                negateY(): Matrix3d;
                negateY(arg0: Matrix3d): Matrix3d;
                negateZ(): Matrix3d;
                negateZ(arg0: Matrix3d): Matrix3d;
                clone(): any;

            }

            interface Matrix4x3d extends java.lang.Cloneable, Matrix4x3dc, java.io.Externalizable {}
            class Matrix4x3d extends java.lang.Object {
                static readonly class: JavaClass<Matrix4x3d>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Matrix4x3dc);
                constructor (arg0: Matrix4x3fc);
                constructor (arg0: Matrix3dc);
                constructor (arg0: Matrix3fc);
                constructor (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double);
                constructor (arg0: java.nio.DoubleBuffer);

                assume(arg0: int): Matrix4x3d;
                determineProperties(): Matrix4x3d;
                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m00(arg0: double): Matrix4x3d;
                m01(arg0: double): Matrix4x3d;
                m02(arg0: double): Matrix4x3d;
                m10(arg0: double): Matrix4x3d;
                m11(arg0: double): Matrix4x3d;
                m12(arg0: double): Matrix4x3d;
                m20(arg0: double): Matrix4x3d;
                m21(arg0: double): Matrix4x3d;
                m22(arg0: double): Matrix4x3d;
                m30(arg0: double): Matrix4x3d;
                m31(arg0: double): Matrix4x3d;
                m32(arg0: double): Matrix4x3d;
                identity(): Matrix4x3d;
                set(arg0: Matrix4x3dc): Matrix4x3d;
                set(arg0: Matrix4x3fc): Matrix4x3d;
                set(arg0: Matrix4dc): Matrix4x3d;
                get(arg0: Matrix4d): Matrix4d;
                set(arg0: Matrix3dc): Matrix4x3d;
                set(arg0: Matrix3fc): Matrix4x3d;
                set(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Vector3dc): Matrix4x3d;
                set3x3(arg0: Matrix4x3dc): Matrix4x3d;
                set(arg0: AxisAngle4f): Matrix4x3d;
                set(arg0: AxisAngle4d): Matrix4x3d;
                set(arg0: Quaternionfc): Matrix4x3d;
                set(arg0: Quaterniondc): Matrix4x3d;
                mul(arg0: Matrix4x3dc): Matrix4x3d;
                mul(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mul(arg0: Matrix4x3fc): Matrix4x3d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulTranslation(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mulTranslation(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulOrtho(arg0: Matrix4x3dc): Matrix4x3d;
                mulOrtho(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                fma(arg0: Matrix4x3dc, arg1: double): Matrix4x3d;
                fma(arg0: Matrix4x3dc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                fma(arg0: Matrix4x3fc, arg1: double): Matrix4x3d;
                fma(arg0: Matrix4x3fc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                add(arg0: Matrix4x3dc): Matrix4x3d;
                add(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                add(arg0: Matrix4x3fc): Matrix4x3d;
                add(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                sub(arg0: Matrix4x3dc): Matrix4x3d;
                sub(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                sub(arg0: Matrix4x3fc): Matrix4x3d;
                sub(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulComponentWise(arg0: Matrix4x3dc): Matrix4x3d;
                mulComponentWise(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                set(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double): Matrix4x3d;
                set(arg0: double[], arg1: int): Matrix4x3d;
                set(arg0: double[]): Matrix4x3d;
                set(arg0: float[], arg1: int): Matrix4x3d;
                set(arg0: float[]): Matrix4x3d;
                set(arg0: java.nio.DoubleBuffer): Matrix4x3d;
                set(arg0: java.nio.FloatBuffer): Matrix4x3d;
                set(arg0: java.nio.ByteBuffer): Matrix4x3d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix4x3d;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix4x3d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix4x3d;
                setFloats(arg0: java.nio.ByteBuffer): Matrix4x3d;
                setFloats(arg0: int, arg1: java.nio.ByteBuffer): Matrix4x3d;
                setFromAddress(arg0: long): Matrix4x3d;
                determinant(): number;
                invert(): Matrix4x3d;
                invert(arg0: Matrix4x3d): Matrix4x3d;
                invertOrtho(arg0: Matrix4x3d): Matrix4x3d;
                invertOrtho(): Matrix4x3d;
                transpose3x3(): Matrix4x3d;
                transpose3x3(arg0: Matrix4x3d): Matrix4x3d;
                transpose3x3(arg0: Matrix3d): Matrix3d;
                translation(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                translation(arg0: Vector3fc): Matrix4x3d;
                translation(arg0: Vector3dc): Matrix4x3d;
                setTranslation(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                setTranslation(arg0: Vector3dc): Matrix4x3d;
                getTranslation(arg0: Vector3d): Vector3d;
                getScale(arg0: Vector3d): Vector3d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix4x3d): Matrix4x3d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4x3dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                get4x4(arg0: double[], arg1: int): JavaArray<number>;
                get4x4(arg0: double[]): JavaArray<number>;
                get4x4(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: double[], arg1: int): JavaArray<number>;
                getTransposed(arg0: double[]): JavaArray<number>;
                zero(): Matrix4x3d;
                scaling(arg0: double): Matrix4x3d;
                scaling(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                scaling(arg0: Vector3dc): Matrix4x3d;
                rotation(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotationX(arg0: double): Matrix4x3d;
                rotationY(arg0: double): Matrix4x3d;
                rotationZ(arg0: double): Matrix4x3d;
                rotationXYZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotationZYX(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotationYXZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                setRotationXYZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                setRotationZYX(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                setRotationYXZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotation(arg0: double, arg1: Vector3dc): Matrix4x3d;
                rotation(arg0: double, arg1: Vector3fc): Matrix4x3d;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformPosition(arg0: Vector3d): Vector3d;
                transformPosition(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformDirection(arg0: Vector3d): Vector3d;
                transformDirection(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                set3x3(arg0: Matrix3dc): Matrix4x3d;
                set3x3(arg0: Matrix3fc): Matrix4x3d;
                scale(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                scale(arg0: Vector3dc): Matrix4x3d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                scale(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                scale(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                scale(arg0: double): Matrix4x3d;
                scaleXY(arg0: double, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                scaleXY(arg0: double, arg1: double): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                scaleLocal(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotateTranslation(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotationAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotateLocalX(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocalX(arg0: double): Matrix4x3d;
                rotateLocalY(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocalY(arg0: double): Matrix4x3d;
                rotateLocalZ(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocalZ(arg0: double): Matrix4x3d;
                translate(arg0: Vector3dc): Matrix4x3d;
                translate(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                translate(arg0: Vector3fc): Matrix4x3d;
                translate(arg0: Vector3fc, arg1: Matrix4x3d): Matrix4x3d;
                translate(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                translate(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                translateLocal(arg0: Vector3fc): Matrix4x3d;
                translateLocal(arg0: Vector3fc, arg1: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: Vector3dc): Matrix4x3d;
                translateLocal(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotateX(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateX(arg0: double): Matrix4x3d;
                rotateY(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateY(arg0: double): Matrix4x3d;
                rotateZ(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateZ(arg0: double): Matrix4x3d;
                rotateXYZ(arg0: Vector3d): Matrix4x3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateZYX(arg0: Vector3d): Matrix4x3d;
                rotateZYX(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateYXZ(arg0: Vector3d): Matrix4x3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotation(arg0: AxisAngle4f): Matrix4x3d;
                rotation(arg0: AxisAngle4d): Matrix4x3d;
                rotation(arg0: Quaterniondc): Matrix4x3d;
                rotation(arg0: Quaternionfc): Matrix4x3d;
                translationRotateScale(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): Matrix4x3d;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4x3d;
                translationRotateScale(arg0: Vector3dc, arg1: Quaterniondc, arg2: Vector3dc): Matrix4x3d;
                translationRotateScaleMul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: Matrix4x3dc): Matrix4x3d;
                translationRotateScaleMul(arg0: Vector3dc, arg1: Quaterniondc, arg2: Vector3dc, arg3: Matrix4x3dc): Matrix4x3d;
                translationRotate(arg0: double, arg1: double, arg2: double, arg3: Quaterniondc): Matrix4x3d;
                translationRotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): Matrix4x3d;
                translationRotate(arg0: Vector3dc, arg1: Quaterniondc): Matrix4x3d;
                translationRotateMul(arg0: double, arg1: double, arg2: double, arg3: Quaternionfc, arg4: Matrix4x3dc): Matrix4x3d;
                translationRotateMul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: Matrix4x3dc): Matrix4x3d;
                translationRotateInvert(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): Matrix4x3d;
                translationRotateInvert(arg0: Vector3dc, arg1: Quaterniondc): Matrix4x3d;
                rotate(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: Quaterniondc): Matrix4x3d;
                rotate(arg0: Quaternionfc): Matrix4x3d;
                rotateTranslation(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaterniondc): Matrix4x3d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaternionfc): Matrix4x3d;
                rotate(arg0: AxisAngle4f): Matrix4x3d;
                rotate(arg0: AxisAngle4f, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: AxisAngle4d): Matrix4x3d;
                rotate(arg0: AxisAngle4d, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3dc): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3fc): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix4x3d): Matrix4x3d;
                getRow(arg0: int, arg1: Vector4d): Vector4d;
                setRow(arg0: int, arg1: Vector4dc): Matrix4x3d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                setColumn(arg0: int, arg1: Vector3dc): Matrix4x3d;
                normal(): Matrix4x3d;
                normal(arg0: Matrix4x3d): Matrix4x3d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor3x3(): Matrix4x3d;
                cofactor3x3(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix4x3d): Matrix4x3d;
                normalize3x3(): Matrix4x3d;
                normalize3x3(arg0: Matrix4x3d): Matrix4x3d;
                normalize3x3(arg0: Matrix3d): Matrix3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                reflect(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc): Matrix4x3d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                reflect(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                reflection(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                reflection(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                reflection(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                reflection(arg0: Quaterniondc, arg1: Vector3dc): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4x3d): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4x3d): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                setOrtho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4x3d;
                setOrtho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                setOrthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4x3d;
                setOrthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4x3d): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4x3d): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                setOrthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4x3d;
                setOrthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                setOrthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4x3d;
                setOrthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                setOrtho2D(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                setOrtho2DLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                setLookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                setLookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                setLookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                setLookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4x3d): Matrix4x3d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                setLookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                setLookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4x3d): Matrix4x3d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                frustumPlane(arg0: int, arg1: Vector4d): Vector4d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                origin(arg0: Vector3d): Vector3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double): Matrix4x3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double, arg5: Matrix4x3d): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: Matrix4x3d): Matrix4x3d;
                shadow(arg0: Vector4dc, arg1: Matrix4x3dc, arg2: Matrix4x3d): Matrix4x3d;
                shadow(arg0: Vector4dc, arg1: Matrix4x3dc): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3dc, arg5: Matrix4x3d): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3dc): Matrix4x3d;
                billboardCylindrical(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                billboardSpherical(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                billboardSpherical(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                equals(arg0: Matrix4x3dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[], arg5: Matrix4x3d): Matrix4x3d;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[]): Matrix4x3d;
                swap(arg0: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double): Matrix4x3d;
                transformAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Vector3d, arg7: Vector3d): Matrix4x3d;
                transformAab(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d, arg3: Vector3d): Matrix4x3d;
                lerp(arg0: Matrix4x3dc, arg1: double): Matrix4x3d;
                lerp(arg0: Matrix4x3dc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                rotationTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                rotationTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                translationRotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                translationRotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                obliqueZ(arg0: double, arg1: double): Matrix4x3d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                mapXZY(): Matrix4x3d;
                mapXZY(arg0: Matrix4x3d): Matrix4x3d;
                mapXZnY(): Matrix4x3d;
                mapXZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapXnYnZ(): Matrix4x3d;
                mapXnYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapXnZY(): Matrix4x3d;
                mapXnZY(arg0: Matrix4x3d): Matrix4x3d;
                mapXnZnY(): Matrix4x3d;
                mapXnZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapYXZ(): Matrix4x3d;
                mapYXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYXnZ(): Matrix4x3d;
                mapYXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYZX(): Matrix4x3d;
                mapYZX(arg0: Matrix4x3d): Matrix4x3d;
                mapYZnX(): Matrix4x3d;
                mapYZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapYnXZ(): Matrix4x3d;
                mapYnXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYnXnZ(): Matrix4x3d;
                mapYnXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYnZX(): Matrix4x3d;
                mapYnZX(arg0: Matrix4x3d): Matrix4x3d;
                mapYnZnX(): Matrix4x3d;
                mapYnZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapZXY(): Matrix4x3d;
                mapZXY(arg0: Matrix4x3d): Matrix4x3d;
                mapZXnY(): Matrix4x3d;
                mapZXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapZYX(): Matrix4x3d;
                mapZYX(arg0: Matrix4x3d): Matrix4x3d;
                mapZYnX(): Matrix4x3d;
                mapZYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapZnXY(): Matrix4x3d;
                mapZnXY(arg0: Matrix4x3d): Matrix4x3d;
                mapZnXnY(): Matrix4x3d;
                mapZnXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapZnYX(): Matrix4x3d;
                mapZnYX(arg0: Matrix4x3d): Matrix4x3d;
                mapZnYnX(): Matrix4x3d;
                mapZnYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnXYnZ(): Matrix4x3d;
                mapnXYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXZY(): Matrix4x3d;
                mapnXZY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXZnY(): Matrix4x3d;
                mapnXZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnYZ(): Matrix4x3d;
                mapnXnYZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnYnZ(): Matrix4x3d;
                mapnXnYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnZY(): Matrix4x3d;
                mapnXnZY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnZnY(): Matrix4x3d;
                mapnXnZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnYXZ(): Matrix4x3d;
                mapnYXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYXnZ(): Matrix4x3d;
                mapnYXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYZX(): Matrix4x3d;
                mapnYZX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYZnX(): Matrix4x3d;
                mapnYZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnXZ(): Matrix4x3d;
                mapnYnXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnXnZ(): Matrix4x3d;
                mapnYnXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnZX(): Matrix4x3d;
                mapnYnZX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnZnX(): Matrix4x3d;
                mapnYnZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZXY(): Matrix4x3d;
                mapnZXY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZXnY(): Matrix4x3d;
                mapnZXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZYX(): Matrix4x3d;
                mapnZYX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZYnX(): Matrix4x3d;
                mapnZYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnXY(): Matrix4x3d;
                mapnZnXY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnXnY(): Matrix4x3d;
                mapnZnXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnYX(): Matrix4x3d;
                mapnZnYX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnYnX(): Matrix4x3d;
                mapnZnYnX(arg0: Matrix4x3d): Matrix4x3d;
                negateX(): Matrix4x3d;
                negateX(arg0: Matrix4x3d): Matrix4x3d;
                negateY(): Matrix4x3d;
                negateY(arg0: Matrix4x3d): Matrix4x3d;
                negateZ(): Matrix4x3d;
                negateZ(arg0: Matrix4x3d): Matrix4x3d;
                isFinite(): boolean;
                clone(): any;

            }

            interface Quaterniond extends java.lang.Cloneable, Quaterniondc, java.io.Externalizable {}
            class Quaterniond extends java.lang.Object {
                static readonly class: JavaClass<Quaterniond>;
                /** @deprecated */ static prototype: undefined;

                static slerp(arg0: Quaterniond[], arg1: double[], arg2: Quaterniond): Quaterniondc;
                static nlerp(arg0: Quaterniond[], arg1: double[], arg2: Quaterniond): Quaterniondc;
                static nlerpIterative(arg0: Quaterniondc[], arg1: double[], arg2: double, arg3: Quaterniond): Quaterniond;

                constructor ();
                constructor (arg0: double, arg1: double, arg2: double, arg3: double);
                constructor (arg0: Quaterniondc);
                constructor (arg0: Quaternionfc);
                constructor (arg0: AxisAngle4f);
                constructor (arg0: AxisAngle4d);

                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                normalize(): Quaterniond;
                normalize(arg0: Quaterniond): Quaterniond;
                add(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                add(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                add(arg0: Quaterniondc): Quaterniond;
                add(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                dot(arg0: Quaterniondc): number;
                angle(): number;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: AxisAngle4f): AxisAngle4f;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Quaternionf): Quaternionf;
                set(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                set(arg0: Quaterniondc): Quaterniond;
                set(arg0: Quaternionfc): Quaterniond;
                set(arg0: AxisAngle4f): Quaterniond;
                set(arg0: AxisAngle4d): Quaterniond;
                setAngleAxis(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                setAngleAxis(arg0: double, arg1: Vector3dc): Quaterniond;
                setFromUnnormalized(arg0: Matrix4fc): Quaterniond;
                setFromUnnormalized(arg0: Matrix4x3fc): Quaterniond;
                setFromUnnormalized(arg0: Matrix4x3dc): Quaterniond;
                setFromNormalized(arg0: Matrix4fc): Quaterniond;
                setFromNormalized(arg0: Matrix4x3fc): Quaterniond;
                setFromNormalized(arg0: Matrix4x3dc): Quaterniond;
                setFromUnnormalized(arg0: Matrix4dc): Quaterniond;
                setFromNormalized(arg0: Matrix4dc): Quaterniond;
                setFromUnnormalized(arg0: Matrix3fc): Quaterniond;
                setFromNormalized(arg0: Matrix3fc): Quaterniond;
                setFromUnnormalized(arg0: Matrix3dc): Quaterniond;
                setFromNormalized(arg0: Matrix3dc): Quaterniond;
                fromAxisAngleRad(arg0: Vector3dc, arg1: double): Quaterniond;
                fromAxisAngleRad(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                fromAxisAngleDeg(arg0: Vector3dc, arg1: double): Quaterniond;
                fromAxisAngleDeg(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                mul(arg0: Quaterniondc): Quaterniond;
                mul(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                mul(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                mul(arg0: double): Quaterniond;
                mul(arg0: double, arg1: Quaterniond): Quaterniond;
                premul(arg0: Quaterniondc): Quaterniond;
                premul(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                premul(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                premul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                transform(arg0: Vector3d): Vector3d;
                transformInverse(arg0: Vector3d): Vector3d;
                transformUnit(arg0: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector4d): Vector4d;
                transformUnitPositiveX(arg0: Vector3d): Vector3d;
                transformUnitPositiveX(arg0: Vector4d): Vector4d;
                transformPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector3d): Vector3d;
                transform(arg0: Vector4d): Vector4d;
                transformInverse(arg0: Vector4d): Vector4d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverse(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverse(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transform(arg0: Vector3f): Vector3f;
                transformInverse(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4d): Vector4d;
                transformUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformUnit(arg0: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector4f): Vector4f;
                transformUnitPositiveX(arg0: Vector3f): Vector3f;
                transformUnitPositiveX(arg0: Vector4f): Vector4f;
                transformPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector3f): Vector3f;
                transform(arg0: Vector4f): Vector4f;
                transformInverse(arg0: Vector4f): Vector4f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverse(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverse(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4f): Vector4f;
                transformUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                invert(arg0: Quaterniond): Quaterniond;
                invert(): Quaterniond;
                div(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                div(arg0: Quaterniondc): Quaterniond;
                conjugate(): Quaterniond;
                conjugate(arg0: Quaterniond): Quaterniond;
                identity(): Quaterniond;
                lengthSquared(): number;
                rotationXYZ(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotationZYX(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotationYXZ(arg0: double, arg1: double, arg2: double): Quaterniond;
                slerp(arg0: Quaterniondc, arg1: double): Quaterniond;
                slerp(arg0: Quaterniondc, arg1: double, arg2: Quaterniond): Quaterniond;
                scale(arg0: double): Quaterniond;
                scale(arg0: double, arg1: Quaterniond): Quaterniond;
                scaling(arg0: double): Quaterniond;
                integrate(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                integrate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                nlerp(arg0: Quaterniondc, arg1: double): Quaterniond;
                nlerp(arg0: Quaterniondc, arg1: double, arg2: Quaterniond): Quaterniond;
                nlerpIterative(arg0: Quaterniondc, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                nlerpIterative(arg0: Quaterniondc, arg1: double, arg2: double): Quaterniond;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc): Quaterniond;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Quaterniond;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Quaterniond): Quaterniond;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                difference(arg0: Quaterniondc): Quaterniond;
                difference(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                rotationTo(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Quaterniond;
                rotationTo(arg0: Vector3dc, arg1: Vector3dc): Quaterniond;
                rotateTo(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Quaterniond): Quaterniond;
                rotationAxis(arg0: AxisAngle4f): Quaterniond;
                rotationAxis(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                rotationX(arg0: double): Quaterniond;
                rotationY(arg0: double): Quaterniond;
                rotationZ(arg0: double): Quaterniond;
                rotateTo(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Quaterniond;
                rotateTo(arg0: Vector3dc, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                rotateTo(arg0: Vector3dc, arg1: Vector3dc): Quaterniond;
                rotateX(arg0: double): Quaterniond;
                rotateX(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateY(arg0: double): Quaterniond;
                rotateY(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateZ(arg0: double): Quaterniond;
                rotateZ(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalX(arg0: double): Quaterniond;
                rotateLocalX(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalY(arg0: double): Quaterniond;
                rotateLocalY(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalZ(arg0: double): Quaterniond;
                rotateLocalZ(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateXYZ(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateZYX(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateYXZ(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesZXY(arg0: Vector3d): Vector3d;
                getEulerAnglesYXZ(arg0: Vector3d): Vector3d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: Vector3dc): Quaterniond;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                conjugateBy(arg0: Quaterniondc): Quaterniond;
                conjugateBy(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                isFinite(): boolean;
                equals(arg0: Quaterniondc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                equals(arg0: any): boolean;
                clone(): any;

            }

            abstract class Matrix3x2dc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix3x2dc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Matrix3x2dc {

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m20(): number;
                m21(): number;
                mul(arg0: Matrix3x2dc, arg1: Matrix3x2d): Matrix3x2d;
                mulLocal(arg0: Matrix3x2dc, arg1: Matrix3x2d): Matrix3x2d;
                determinant(): number;
                invert(arg0: Matrix3x2d): Matrix3x2d;
                translate(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                translate(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                translateLocal(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                translateLocal(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                get(arg0: Matrix3x2d): Matrix3x2d;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get3x3(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get3x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3x2dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get3x3(arg0: double[], arg1: int): JavaArray<number>;
                get3x3(arg0: double[]): JavaArray<number>;
                get4x4(arg0: double[], arg1: int): JavaArray<number>;
                get4x4(arg0: double[]): JavaArray<number>;
                scale(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                scale(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                scale(arg0: Vector2fc, arg1: Matrix3x2d): Matrix3x2d;
                scaleLocal(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                scaleLocal(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                scale(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformPosition(arg0: Vector2d): Vector2d;
                transformPosition(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformPosition(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                transformDirection(arg0: Vector2d): Vector2d;
                transformDirection(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformDirection(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                rotate(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                rotateLocal(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                rotateAbout(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                rotateTo(arg0: Vector2dc, arg1: Vector2dc, arg2: Matrix3x2d): Matrix3x2d;
                view(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                origin(arg0: Vector2d): Vector2d;
                viewArea(arg0: double[]): JavaArray<number>;
                positiveX(arg0: Vector2d): Vector2d;
                normalizedPositiveX(arg0: Vector2d): Vector2d;
                positiveY(arg0: Vector2d): Vector2d;
                normalizedPositiveY(arg0: Vector2d): Vector2d;
                unproject(arg0: double, arg1: double, arg2: int[], arg3: Vector2d): Vector2d;
                unprojectInv(arg0: double, arg1: double, arg2: int[], arg3: Vector2d): Vector2d;
                testPoint(arg0: double, arg1: double): boolean;
                testCircle(arg0: double, arg1: double, arg2: double): boolean;
                testAar(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                equals(arg0: Matrix3x2dc, arg1: double): boolean;
                isFinite(): boolean;

            }

            interface Matrix4x3f extends java.lang.Cloneable, Matrix4x3fc, java.io.Externalizable {}
            class Matrix4x3f extends java.lang.Object {
                static readonly class: JavaClass<Matrix4x3f>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Matrix3fc);
                constructor (arg0: Matrix4x3fc);
                constructor (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float);
                constructor (arg0: java.nio.FloatBuffer);
                constructor (arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Vector3fc);

                assume(arg0: int): Matrix4x3f;
                determineProperties(): Matrix4x3f;
                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m00(arg0: float): Matrix4x3f;
                m01(arg0: float): Matrix4x3f;
                m02(arg0: float): Matrix4x3f;
                m10(arg0: float): Matrix4x3f;
                m11(arg0: float): Matrix4x3f;
                m12(arg0: float): Matrix4x3f;
                m20(arg0: float): Matrix4x3f;
                m21(arg0: float): Matrix4x3f;
                m22(arg0: float): Matrix4x3f;
                m30(arg0: float): Matrix4x3f;
                m31(arg0: float): Matrix4x3f;
                m32(arg0: float): Matrix4x3f;
                identity(): Matrix4x3f;
                set(arg0: Matrix4x3fc): Matrix4x3f;
                set(arg0: Matrix4fc): Matrix4x3f;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix4d): Matrix4d;
                set(arg0: Matrix3fc): Matrix4x3f;
                set(arg0: AxisAngle4f): Matrix4x3f;
                set(arg0: AxisAngle4d): Matrix4x3f;
                set(arg0: Quaternionfc): Matrix4x3f;
                set(arg0: Quaterniondc): Matrix4x3f;
                set(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Vector3fc): Matrix4x3f;
                set3x3(arg0: Matrix4x3fc): Matrix4x3f;
                mul(arg0: Matrix4x3fc): Matrix4x3f;
                mul(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulTranslation(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulOrtho(arg0: Matrix4x3fc): Matrix4x3f;
                mulOrtho(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                fma(arg0: Matrix4x3fc, arg1: float): Matrix4x3f;
                fma(arg0: Matrix4x3fc, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                add(arg0: Matrix4x3fc): Matrix4x3f;
                add(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                sub(arg0: Matrix4x3fc): Matrix4x3f;
                sub(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulComponentWise(arg0: Matrix4x3fc): Matrix4x3f;
                mulComponentWise(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                set(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float): Matrix4x3f;
                set(arg0: float[], arg1: int): Matrix4x3f;
                set(arg0: float[]): Matrix4x3f;
                set(arg0: java.nio.FloatBuffer): Matrix4x3f;
                set(arg0: java.nio.ByteBuffer): Matrix4x3f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix4x3f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix4x3f;
                setFromAddress(arg0: long): Matrix4x3f;
                determinant(): number;
                invert(arg0: Matrix4x3f): Matrix4x3f;
                invert(arg0: Matrix4f): Matrix4f;
                invert(): Matrix4x3f;
                invertOrtho(arg0: Matrix4x3f): Matrix4x3f;
                invertOrtho(): Matrix4x3f;
                transpose3x3(): Matrix4x3f;
                transpose3x3(arg0: Matrix4x3f): Matrix4x3f;
                transpose3x3(arg0: Matrix3f): Matrix3f;
                translation(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                translation(arg0: Vector3fc): Matrix4x3f;
                setTranslation(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                setTranslation(arg0: Vector3fc): Matrix4x3f;
                getTranslation(arg0: Vector3f): Vector3f;
                getScale(arg0: Vector3f): Vector3f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4x3d): Matrix4x3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getRotation(arg0: AxisAngle4d): AxisAngle4d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4x3fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                get4x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: float[], arg1: int): JavaArray<number>;
                getTransposed(arg0: float[]): JavaArray<number>;
                zero(): Matrix4x3f;
                scaling(arg0: float): Matrix4x3f;
                scaling(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                scaling(arg0: Vector3fc): Matrix4x3f;
                rotation(arg0: float, arg1: Vector3fc): Matrix4x3f;
                rotation(arg0: AxisAngle4f): Matrix4x3f;
                rotation(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotationX(arg0: float): Matrix4x3f;
                rotationY(arg0: float): Matrix4x3f;
                rotationZ(arg0: float): Matrix4x3f;
                rotationXYZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotationZYX(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotationYXZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                setRotationXYZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                setRotationZYX(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                setRotationYXZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotation(arg0: Quaternionfc): Matrix4x3f;
                translationRotateScale(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): Matrix4x3f;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4x3f;
                translationRotateScaleMul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: Matrix4x3f): Matrix4x3f;
                translationRotateScaleMul(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                translationRotate(arg0: float, arg1: float, arg2: float, arg3: Quaternionfc): Matrix4x3f;
                translationRotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): Matrix4x3f;
                translationRotate(arg0: Vector3fc, arg1: Quaternionfc): Matrix4x3f;
                translationRotateMul(arg0: float, arg1: float, arg2: float, arg3: Quaternionfc, arg4: Matrix4x3fc): Matrix4x3f;
                translationRotateMul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: Matrix4x3fc): Matrix4x3f;
                translationRotateInvert(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): Matrix4x3f;
                translationRotateInvert(arg0: Vector3fc, arg1: Quaternionfc): Matrix4x3f;
                set3x3(arg0: Matrix3fc): Matrix4x3f;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformPosition(arg0: Vector3f): Vector3f;
                transformPosition(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                scale(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                scale(arg0: Vector3fc): Matrix4x3f;
                scale(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                scale(arg0: float): Matrix4x3f;
                scaleXY(arg0: float, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                scaleXY(arg0: float, arg1: float): Matrix4x3f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                scale(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                scaleLocal(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotateX(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateX(arg0: float): Matrix4x3f;
                rotateY(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateY(arg0: float): Matrix4x3f;
                rotateZ(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateZ(arg0: float): Matrix4x3f;
                rotateXYZ(arg0: Vector3f): Matrix4x3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateZYX(arg0: Vector3f): Matrix4x3f;
                rotateZYX(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateYXZ(arg0: Vector3f): Matrix4x3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotateTranslation(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotationAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotateLocalX(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocalX(arg0: float): Matrix4x3f;
                rotateLocalY(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocalY(arg0: float): Matrix4x3f;
                rotateLocalZ(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocalZ(arg0: float): Matrix4x3f;
                translate(arg0: Vector3fc): Matrix4x3f;
                translate(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                translate(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                translate(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                translateLocal(arg0: Vector3fc): Matrix4x3f;
                translateLocal(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                translateLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                translateLocal(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4x3f): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4x3f): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                setOrtho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4x3f;
                setOrtho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                setOrthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4x3f;
                setOrthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4x3f): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4x3f): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                setOrthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4x3f;
                setOrthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                setOrthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4x3f;
                setOrthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                setOrtho2D(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                setOrtho2DLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                setLookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                setLookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                setLookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                setLookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                setLookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                setLookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                rotate(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotate(arg0: Quaternionfc): Matrix4x3f;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: Quaternionfc): Matrix4x3f;
                rotate(arg0: AxisAngle4f): Matrix4x3f;
                rotate(arg0: AxisAngle4f, arg1: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: Vector3fc): Matrix4x3f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                reflect(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc): Matrix4x3f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflect(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflection(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                reflection(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                reflection(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                reflection(arg0: Quaternionfc, arg1: Vector3fc): Matrix4x3f;
                getRow(arg0: int, arg1: Vector4f): Vector4f;
                setRow(arg0: int, arg1: Vector4fc): Matrix4x3f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                setColumn(arg0: int, arg1: Vector3fc): Matrix4x3f;
                normal(): Matrix4x3f;
                normal(arg0: Matrix4x3f): Matrix4x3f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor3x3(): Matrix4x3f;
                cofactor3x3(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix4x3f): Matrix4x3f;
                normalize3x3(): Matrix4x3f;
                normalize3x3(arg0: Matrix4x3f): Matrix4x3f;
                normalize3x3(arg0: Matrix3f): Matrix3f;
                frustumPlane(arg0: int, arg1: Vector4f): Vector4f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                origin(arg0: Vector3f): Vector3f;
                shadow(arg0: Vector4fc, arg1: float, arg2: float, arg3: float, arg4: float): Matrix4x3f;
                shadow(arg0: Vector4fc, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Matrix4x3f): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: Matrix4x3f): Matrix4x3f;
                shadow(arg0: Vector4fc, arg1: Matrix4x3fc, arg2: Matrix4x3f): Matrix4x3f;
                shadow(arg0: Vector4fc, arg1: Matrix4x3fc): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3fc, arg5: Matrix4x3f): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                billboardCylindrical(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                billboardSpherical(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                billboardSpherical(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                equals(arg0: Matrix4x3fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[], arg5: Matrix4x3f): Matrix4x3f;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[]): Matrix4x3f;
                swap(arg0: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float): Matrix4x3f;
                transformAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Vector3f, arg7: Vector3f): Matrix4x3f;
                transformAab(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f, arg3: Vector3f): Matrix4x3f;
                lerp(arg0: Matrix4x3fc, arg1: float): Matrix4x3f;
                lerp(arg0: Matrix4x3fc, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                rotationTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                rotationTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                translationRotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                translationRotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                obliqueZ(arg0: float, arg1: float): Matrix4x3f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                withLookAtUp(arg0: Vector3fc): Matrix4x3f;
                withLookAtUp(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                withLookAtUp(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                withLookAtUp(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                mapXZY(): Matrix4x3f;
                mapXZY(arg0: Matrix4x3f): Matrix4x3f;
                mapXZnY(): Matrix4x3f;
                mapXZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapXnYnZ(): Matrix4x3f;
                mapXnYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapXnZY(): Matrix4x3f;
                mapXnZY(arg0: Matrix4x3f): Matrix4x3f;
                mapXnZnY(): Matrix4x3f;
                mapXnZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapYXZ(): Matrix4x3f;
                mapYXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYXnZ(): Matrix4x3f;
                mapYXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYZX(): Matrix4x3f;
                mapYZX(arg0: Matrix4x3f): Matrix4x3f;
                mapYZnX(): Matrix4x3f;
                mapYZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapYnXZ(): Matrix4x3f;
                mapYnXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYnXnZ(): Matrix4x3f;
                mapYnXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYnZX(): Matrix4x3f;
                mapYnZX(arg0: Matrix4x3f): Matrix4x3f;
                mapYnZnX(): Matrix4x3f;
                mapYnZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapZXY(): Matrix4x3f;
                mapZXY(arg0: Matrix4x3f): Matrix4x3f;
                mapZXnY(): Matrix4x3f;
                mapZXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapZYX(): Matrix4x3f;
                mapZYX(arg0: Matrix4x3f): Matrix4x3f;
                mapZYnX(): Matrix4x3f;
                mapZYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapZnXY(): Matrix4x3f;
                mapZnXY(arg0: Matrix4x3f): Matrix4x3f;
                mapZnXnY(): Matrix4x3f;
                mapZnXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapZnYX(): Matrix4x3f;
                mapZnYX(arg0: Matrix4x3f): Matrix4x3f;
                mapZnYnX(): Matrix4x3f;
                mapZnYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnXYnZ(): Matrix4x3f;
                mapnXYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXZY(): Matrix4x3f;
                mapnXZY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXZnY(): Matrix4x3f;
                mapnXZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnYZ(): Matrix4x3f;
                mapnXnYZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnYnZ(): Matrix4x3f;
                mapnXnYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnZY(): Matrix4x3f;
                mapnXnZY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnZnY(): Matrix4x3f;
                mapnXnZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnYXZ(): Matrix4x3f;
                mapnYXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYXnZ(): Matrix4x3f;
                mapnYXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYZX(): Matrix4x3f;
                mapnYZX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYZnX(): Matrix4x3f;
                mapnYZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnXZ(): Matrix4x3f;
                mapnYnXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnXnZ(): Matrix4x3f;
                mapnYnXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnZX(): Matrix4x3f;
                mapnYnZX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnZnX(): Matrix4x3f;
                mapnYnZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZXY(): Matrix4x3f;
                mapnZXY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZXnY(): Matrix4x3f;
                mapnZXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZYX(): Matrix4x3f;
                mapnZYX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZYnX(): Matrix4x3f;
                mapnZYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnXY(): Matrix4x3f;
                mapnZnXY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnXnY(): Matrix4x3f;
                mapnZnXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnYX(): Matrix4x3f;
                mapnZnYX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnYnX(): Matrix4x3f;
                mapnZnYnX(arg0: Matrix4x3f): Matrix4x3f;
                negateX(): Matrix4x3f;
                negateX(arg0: Matrix4x3f): Matrix4x3f;
                negateY(): Matrix4x3f;
                negateY(arg0: Matrix4x3f): Matrix4x3f;
                negateZ(): Matrix4x3f;
                negateZ(arg0: Matrix4x3f): Matrix4x3f;
                isFinite(): boolean;
                clone(): any;

            }

            abstract class Matrix2fc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix2fc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Matrix2fc {

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                mul(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                mulLocal(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                determinant(): number;
                invert(arg0: Matrix2f): Matrix2f;
                transpose(arg0: Matrix2f): Matrix2f;
                get(arg0: Matrix2f): Matrix2f;
                get(arg0: Matrix3x2f): Matrix3x2f;
                get(arg0: Matrix3f): Matrix3f;
                getRotation(): number;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix2fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                scale(arg0: Vector2fc, arg1: Matrix2f): Matrix2f;
                scale(arg0: float, arg1: float, arg2: Matrix2f): Matrix2f;
                scale(arg0: float, arg1: Matrix2f): Matrix2f;
                scaleLocal(arg0: float, arg1: float, arg2: Matrix2f): Matrix2f;
                transform(arg0: Vector2f): Vector2f;
                transform(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transform(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                transformTranspose(arg0: Vector2f): Vector2f;
                transformTranspose(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformTranspose(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                rotate(arg0: float, arg1: Matrix2f): Matrix2f;
                rotateLocal(arg0: float, arg1: Matrix2f): Matrix2f;
                getRow(arg0: int, arg1: Vector2f): Vector2f;
                getColumn(arg0: int, arg1: Vector2f): Vector2f;
                get(arg0: int, arg1: int): number;
                normal(arg0: Matrix2f): Matrix2f;
                getScale(arg0: Vector2f): Vector2f;
                positiveX(arg0: Vector2f): Vector2f;
                normalizedPositiveX(arg0: Vector2f): Vector2f;
                positiveY(arg0: Vector2f): Vector2f;
                normalizedPositiveY(arg0: Vector2f): Vector2f;
                add(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                sub(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                mulComponentWise(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                lerp(arg0: Matrix2fc, arg1: float, arg2: Matrix2f): Matrix2f;
                equals(arg0: Matrix2fc, arg1: float): boolean;
                isFinite(): boolean;

            }

            interface Matrix3x2f extends java.lang.Cloneable, Matrix3x2fc, java.io.Externalizable {}
            class Matrix3x2f extends java.lang.Object {
                static readonly class: JavaClass<Matrix3x2f>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Matrix3x2fc);
                constructor (arg0: Matrix2fc);
                constructor (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float);
                constructor (arg0: java.nio.FloatBuffer);

                m00: number;
                m01: number;
                m10: number;
                m11: number;
                m20: number;
                m21: number;

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m20(): number;
                m21(): number;
                set(arg0: Matrix3x2fc): Matrix3x2f;
                set(arg0: Matrix2fc): Matrix3x2f;
                mul(arg0: Matrix3x2fc): Matrix3x2f;
                mul(arg0: Matrix3x2fc, arg1: Matrix3x2f): Matrix3x2f;
                mulLocal(arg0: Matrix3x2fc): Matrix3x2f;
                mulLocal(arg0: Matrix3x2fc, arg1: Matrix3x2f): Matrix3x2f;
                set(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3x2f;
                set(arg0: float[]): Matrix3x2f;
                determinant(): number;
                invert(): Matrix3x2f;
                invert(arg0: Matrix3x2f): Matrix3x2f;
                translation(arg0: float, arg1: float): Matrix3x2f;
                translation(arg0: Vector2fc): Matrix3x2f;
                setTranslation(arg0: float, arg1: float): Matrix3x2f;
                setTranslation(arg0: Vector2f): Matrix3x2f;
                translate(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                translate(arg0: float, arg1: float): Matrix3x2f;
                translate(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                translate(arg0: Vector2fc): Matrix3x2f;
                translateLocal(arg0: Vector2fc): Matrix3x2f;
                translateLocal(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                translateLocal(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                translateLocal(arg0: float, arg1: float): Matrix3x2f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix3x2f): Matrix3x2f;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x3(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3x2fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get3x3(arg0: float[], arg1: int): JavaArray<number>;
                get3x3(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                set(arg0: java.nio.FloatBuffer): Matrix3x2f;
                set(arg0: java.nio.ByteBuffer): Matrix3x2f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix3x2f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix3x2f;
                setFromAddress(arg0: long): Matrix3x2f;
                zero(): Matrix3x2f;
                identity(): Matrix3x2f;
                scale(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                scale(arg0: float, arg1: float): Matrix3x2f;
                scale(arg0: Vector2fc): Matrix3x2f;
                scale(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                scale(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                scale(arg0: float): Matrix3x2f;
                scaleLocal(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                scaleLocal(arg0: float, arg1: float): Matrix3x2f;
                scaleLocal(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                scaleLocal(arg0: float): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float): Matrix3x2f;
                scaling(arg0: float): Matrix3x2f;
                scaling(arg0: float, arg1: float): Matrix3x2f;
                rotation(arg0: float): Matrix3x2f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3f, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformPosition(arg0: Vector2f): Vector2f;
                transformPosition(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformPosition(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                transformDirection(arg0: Vector2f): Vector2f;
                transformDirection(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformDirection(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotate(arg0: float): Matrix3x2f;
                rotate(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                rotateLocal(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                rotateLocal(arg0: float): Matrix3x2f;
                rotateAbout(arg0: float, arg1: float, arg2: float): Matrix3x2f;
                rotateAbout(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                rotateTo(arg0: Vector2fc, arg1: Vector2fc, arg2: Matrix3x2f): Matrix3x2f;
                rotateTo(arg0: Vector2fc, arg1: Vector2fc): Matrix3x2f;
                view(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                view(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3x2f;
                setView(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3x2f;
                origin(arg0: Vector2f): Vector2f;
                viewArea(arg0: float[]): JavaArray<number>;
                positiveX(arg0: Vector2f): Vector2f;
                normalizedPositiveX(arg0: Vector2f): Vector2f;
                positiveY(arg0: Vector2f): Vector2f;
                normalizedPositiveY(arg0: Vector2f): Vector2f;
                unproject(arg0: float, arg1: float, arg2: int[], arg3: Vector2f): Vector2f;
                unprojectInv(arg0: float, arg1: float, arg2: int[], arg3: Vector2f): Vector2f;
                shearX(arg0: float): Matrix3x2f;
                shearX(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                shearY(arg0: float): Matrix3x2f;
                shearY(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                span(arg0: Vector2f, arg1: Vector2f, arg2: Vector2f): Matrix3x2f;
                testPoint(arg0: float, arg1: float): boolean;
                testCircle(arg0: float, arg1: float, arg2: float): boolean;
                testAar(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                equals(arg0: Matrix3x2fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                isFinite(): boolean;
                clone(): any;

            }

            interface AxisAngle4d extends java.lang.Cloneable, java.io.Externalizable {}
            class AxisAngle4d extends java.lang.Object {
                static readonly class: JavaClass<AxisAngle4d>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: AxisAngle4d);
                constructor (arg0: AxisAngle4f);
                constructor (arg0: Quaternionfc);
                constructor (arg0: Quaterniondc);
                constructor (arg0: double, arg1: double, arg2: double, arg3: double);
                constructor (arg0: double, arg1: Vector3dc);
                constructor (arg0: double, arg1: Vector3f);

                angle: number;
                x: number;
                y: number;
                z: number;

                set(arg0: AxisAngle4d): AxisAngle4d;
                set(arg0: AxisAngle4f): AxisAngle4d;
                set(arg0: double, arg1: double, arg2: double, arg3: double): AxisAngle4d;
                set(arg0: double, arg1: Vector3dc): AxisAngle4d;
                set(arg0: double, arg1: Vector3f): AxisAngle4d;
                set(arg0: Quaternionfc): AxisAngle4d;
                set(arg0: Quaterniondc): AxisAngle4d;
                set(arg0: Matrix3fc): AxisAngle4d;
                set(arg0: Matrix3dc): AxisAngle4d;
                set(arg0: Matrix4fc): AxisAngle4d;
                set(arg0: Matrix4x3fc): AxisAngle4d;
                set(arg0: Matrix4dc): AxisAngle4d;
                get(arg0: Quaternionf): Quaternionf;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: AxisAngle4f): AxisAngle4f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                normalize(): AxisAngle4d;
                rotate(arg0: double): AxisAngle4d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                clone(): any;

            }

            abstract class Matrix4x3dc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix4x3dc>;
                /** @deprecated */ static prototype: undefined;

                static readonly PLANE_NX: number;
                static readonly PLANE_PX: number;
                static readonly PLANE_NY: number;
                static readonly PLANE_PY: number;
                static readonly PLANE_NZ: number;
                static readonly PLANE_PZ: number;
                static readonly PROPERTY_IDENTITY: number;
                static readonly PROPERTY_TRANSLATION: number;
                static readonly PROPERTY_ORTHONORMAL: number;
            }
            interface Matrix4x3dc {

                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                get(arg0: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulTranslation(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mulTranslation(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulOrtho(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                fma(arg0: Matrix4x3dc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                fma(arg0: Matrix4x3fc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                add(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                add(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                sub(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                sub(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulComponentWise(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                determinant(): number;
                invert(arg0: Matrix4x3d): Matrix4x3d;
                invertOrtho(arg0: Matrix4x3d): Matrix4x3d;
                transpose3x3(arg0: Matrix4x3d): Matrix4x3d;
                transpose3x3(arg0: Matrix3d): Matrix3d;
                getTranslation(arg0: Vector3d): Vector3d;
                getScale(arg0: Vector3d): Vector3d;
                get(arg0: Matrix4x3d): Matrix4x3d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4x3dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get4x4(arg0: double[], arg1: int): JavaArray<number>;
                get4x4(arg0: double[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                get4x4(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: double[], arg1: int): JavaArray<number>;
                getTransposed(arg0: double[]): JavaArray<number>;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformPosition(arg0: Vector3d): Vector3d;
                transformPosition(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformDirection(arg0: Vector3d): Vector3d;
                transformDirection(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                scale(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                scale(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                scaleXY(arg0: double, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateTranslation(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                translate(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                translate(arg0: Vector3fc, arg1: Matrix4x3d): Matrix4x3d;
                translate(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: Vector3fc, arg1: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateX(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateY(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateZ(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotate(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotateTranslation(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: AxisAngle4f, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: AxisAngle4d, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix4x3d): Matrix4x3d;
                getRow(arg0: int, arg1: Vector4d): Vector4d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                normal(arg0: Matrix4x3d): Matrix4x3d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix4x3d): Matrix4x3d;
                normalize3x3(arg0: Matrix4x3d): Matrix4x3d;
                normalize3x3(arg0: Matrix3d): Matrix3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                reflect(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4x3d): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4x3d): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4x3d): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4x3d): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4x3d): Matrix4x3d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4x3d): Matrix4x3d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                frustumPlane(arg0: int, arg1: Vector4d): Vector4d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                origin(arg0: Vector3d): Vector3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double, arg5: Matrix4x3d): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: Matrix4x3d): Matrix4x3d;
                shadow(arg0: Vector4dc, arg1: Matrix4x3dc, arg2: Matrix4x3d): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3dc, arg5: Matrix4x3d): Matrix4x3d;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[], arg5: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                transformAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Vector3d, arg7: Vector3d): Matrix4x3d;
                transformAab(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d, arg3: Vector3d): Matrix4x3d;
                lerp(arg0: Matrix4x3dc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                mapXZY(arg0: Matrix4x3d): Matrix4x3d;
                mapXZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapXnYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapXnZY(arg0: Matrix4x3d): Matrix4x3d;
                mapXnZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapYXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYZX(arg0: Matrix4x3d): Matrix4x3d;
                mapYZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapYnXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYnXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYnZX(arg0: Matrix4x3d): Matrix4x3d;
                mapYnZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapZXY(arg0: Matrix4x3d): Matrix4x3d;
                mapZXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapZYX(arg0: Matrix4x3d): Matrix4x3d;
                mapZYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapZnXY(arg0: Matrix4x3d): Matrix4x3d;
                mapZnXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapZnYX(arg0: Matrix4x3d): Matrix4x3d;
                mapZnYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnXYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXZY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnYZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnZY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnYXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYZX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnZX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZXY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZYX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnXY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnYX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnYnX(arg0: Matrix4x3d): Matrix4x3d;
                negateX(arg0: Matrix4x3d): Matrix4x3d;
                negateY(arg0: Matrix4x3d): Matrix4x3d;
                negateZ(arg0: Matrix4x3d): Matrix4x3d;
                equals(arg0: Matrix4x3dc, arg1: double): boolean;
                isFinite(): boolean;

            }

            abstract class Vector4fc extends java.lang.Interface {
                static readonly class: JavaClass<Vector4fc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Vector4fc {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4fc;
                sub(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                sub(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                add(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                add(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                fma(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                fma(arg0: float, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mulAdd(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mulAdd(arg0: float, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mul(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                div(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                mul(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulTranspose(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulAffine(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulAffineTranspose(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mul(arg0: Matrix4x3fc, arg1: Vector4f): Vector4f;
                mulProject(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulProject(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mul(arg0: float, arg1: Vector4f): Vector4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                div(arg0: float, arg1: Vector4f): Vector4f;
                div(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                rotate(arg0: Quaternionfc, arg1: Vector4f): Vector4f;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                rotateX(arg0: float, arg1: Vector4f): Vector4f;
                rotateY(arg0: float, arg1: Vector4f): Vector4f;
                rotateZ(arg0: float, arg1: Vector4f): Vector4f;
                lengthSquared(): number;
                length(): number;
                normalize(arg0: Vector4f): Vector4f;
                normalize(arg0: float, arg1: Vector4f): Vector4f;
                normalize3(arg0: Vector4f): Vector4f;
                distance(arg0: Vector4fc): number;
                distance(arg0: float, arg1: float, arg2: float, arg3: float): number;
                distanceSquared(arg0: Vector4fc): number;
                distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float): number;
                dot(arg0: Vector4fc): number;
                dot(arg0: float, arg1: float, arg2: float, arg3: float): number;
                angleCos(arg0: Vector4fc): number;
                angle(arg0: Vector4fc): number;
                negate(arg0: Vector4f): Vector4f;
                min(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                max(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                lerp(arg0: Vector4fc, arg1: float, arg2: Vector4f): Vector4f;
                smoothStep(arg0: Vector4fc, arg1: float, arg2: Vector4f): Vector4f;
                hermite(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4fc, arg3: float, arg4: Vector4f): Vector4f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector4i): Vector4i;
                get(arg0: Vector4f): Vector4f;
                get(arg0: Vector4d): Vector4d;
                maxComponent(): number;
                minComponent(): number;
                floor(arg0: Vector4f): Vector4f;
                ceil(arg0: Vector4f): Vector4f;
                round(arg0: Vector4f): Vector4f;
                isFinite(): boolean;
                absolute(arg0: Vector4f): Vector4f;
                equals(arg0: Vector4fc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float, arg3: float): boolean;

            }

            interface Matrix4f extends java.lang.Cloneable, java.io.Externalizable, Matrix4fc {}
            class Matrix4f extends java.lang.Object {
                static readonly class: JavaClass<Matrix4f>;
                /** @deprecated */ static prototype: undefined;

                static perspectiveOffCenterViewFromRectangle(arg0: Vector3f, arg1: Vector3f, arg2: Vector3f, arg3: Vector3f, arg4: float, arg5: boolean, arg6: Matrix4f, arg7: Matrix4f): void;

                constructor ();
                constructor (arg0: Matrix3fc);
                constructor (arg0: Matrix4fc);
                constructor (arg0: Matrix4x3fc);
                constructor (arg0: Matrix4dc);
                constructor (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float);
                constructor (arg0: java.nio.FloatBuffer);
                constructor (arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4fc, arg3: Vector4fc);

                assume(arg0: int): Matrix4f;
                determineProperties(): Matrix4f;
                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m03(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m13(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m23(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m33(): number;
                m00(arg0: float): Matrix4f;
                m01(arg0: float): Matrix4f;
                m02(arg0: float): Matrix4f;
                m03(arg0: float): Matrix4f;
                m10(arg0: float): Matrix4f;
                m11(arg0: float): Matrix4f;
                m12(arg0: float): Matrix4f;
                m13(arg0: float): Matrix4f;
                m20(arg0: float): Matrix4f;
                m21(arg0: float): Matrix4f;
                m22(arg0: float): Matrix4f;
                m23(arg0: float): Matrix4f;
                m30(arg0: float): Matrix4f;
                m31(arg0: float): Matrix4f;
                m32(arg0: float): Matrix4f;
                m33(arg0: float): Matrix4f;
                identity(): Matrix4f;
                set(arg0: Matrix4fc): Matrix4f;
                setTransposed(arg0: Matrix4fc): Matrix4f;
                set(arg0: Matrix4x3fc): Matrix4f;
                set(arg0: Matrix4dc): Matrix4f;
                set(arg0: Matrix3fc): Matrix4f;
                set(arg0: AxisAngle4f): Matrix4f;
                set(arg0: AxisAngle4d): Matrix4f;
                set(arg0: Quaternionfc): Matrix4f;
                set(arg0: Quaterniondc): Matrix4f;
                set3x3(arg0: Matrix4f): Matrix4f;
                set4x3(arg0: Matrix4x3fc): Matrix4f;
                set4x3(arg0: Matrix4f): Matrix4f;
                mul(arg0: Matrix4fc): Matrix4f;
                mul(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul0(arg0: Matrix4fc): Matrix4f;
                mul0(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float): Matrix4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float, arg16: Matrix4f): Matrix4f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                mulLocal(arg0: Matrix4fc): Matrix4f;
                mulLocal(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulLocalAffine(arg0: Matrix4fc): Matrix4f;
                mulLocalAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: Matrix4x3fc): Matrix4f;
                mul(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: Matrix3x2fc): Matrix4f;
                mul(arg0: Matrix3x2fc, arg1: Matrix4f): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4fc): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4x3fc): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                mulAffineR(arg0: Matrix4fc): Matrix4f;
                mulAffineR(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulAffine(arg0: Matrix4fc): Matrix4f;
                mulAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulTranslationAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulOrthoAffine(arg0: Matrix4fc): Matrix4f;
                mulOrthoAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                fma4x3(arg0: Matrix4fc, arg1: float): Matrix4f;
                fma4x3(arg0: Matrix4fc, arg1: float, arg2: Matrix4f): Matrix4f;
                add(arg0: Matrix4fc): Matrix4f;
                add(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                sub(arg0: Matrix4fc): Matrix4f;
                sub(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulComponentWise(arg0: Matrix4fc): Matrix4f;
                mulComponentWise(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                add4x3(arg0: Matrix4fc): Matrix4f;
                add4x3(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                sub4x3(arg0: Matrix4f): Matrix4f;
                sub4x3(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul4x3ComponentWise(arg0: Matrix4fc): Matrix4f;
                mul4x3ComponentWise(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                set(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float): Matrix4f;
                set(arg0: float[], arg1: int): Matrix4f;
                set(arg0: float[]): Matrix4f;
                setTransposed(arg0: float[], arg1: int): Matrix4f;
                setTransposed(arg0: float[]): Matrix4f;
                set(arg0: java.nio.FloatBuffer): Matrix4f;
                set(arg0: java.nio.ByteBuffer): Matrix4f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix4f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix4f;
                setTransposed(arg0: java.nio.FloatBuffer): Matrix4f;
                setTransposed(arg0: java.nio.ByteBuffer): Matrix4f;
                setFromAddress(arg0: long): Matrix4f;
                setTransposedFromAddress(arg0: long): Matrix4f;
                set(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4fc, arg3: Vector4fc): Matrix4f;
                determinant(): number;
                determinant3x3(): number;
                determinantAffine(): number;
                invert(arg0: Matrix4f): Matrix4f;
                invert(): Matrix4f;
                invertPerspective(arg0: Matrix4f): Matrix4f;
                invertPerspective(): Matrix4f;
                invertFrustum(arg0: Matrix4f): Matrix4f;
                invertFrustum(): Matrix4f;
                invertOrtho(arg0: Matrix4f): Matrix4f;
                invertOrtho(): Matrix4f;
                invertPerspectiveView(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                invertPerspectiveView(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                invertAffine(arg0: Matrix4f): Matrix4f;
                invertAffine(): Matrix4f;
                transpose(arg0: Matrix4f): Matrix4f;
                transpose3x3(): Matrix4f;
                transpose3x3(arg0: Matrix4f): Matrix4f;
                transpose3x3(arg0: Matrix3f): Matrix3f;
                transpose(): Matrix4f;
                translation(arg0: float, arg1: float, arg2: float): Matrix4f;
                translation(arg0: Vector3fc): Matrix4f;
                setTranslation(arg0: float, arg1: float, arg2: float): Matrix4f;
                setTranslation(arg0: Vector3fc): Matrix4f;
                getTranslation(arg0: Vector3f): Vector3f;
                getScale(arg0: Vector3f): Vector3f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix4f): Matrix4f;
                get4x3(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4d): Matrix4d;
                get3x3(arg0: Matrix3f): Matrix3f;
                get3x3(arg0: Matrix3d): Matrix3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getRotation(arg0: AxisAngle4d): AxisAngle4d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3Transposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                zero(): Matrix4f;
                scaling(arg0: float): Matrix4f;
                scaling(arg0: float, arg1: float, arg2: float): Matrix4f;
                scaling(arg0: Vector3fc): Matrix4f;
                rotation(arg0: float, arg1: Vector3fc): Matrix4f;
                rotation(arg0: AxisAngle4f): Matrix4f;
                rotation(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotationX(arg0: float): Matrix4f;
                rotationY(arg0: float): Matrix4f;
                rotationZ(arg0: float): Matrix4f;
                rotationTowardsXY(arg0: float, arg1: float): Matrix4f;
                rotationXYZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotationZYX(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotationYXZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                setRotationXYZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                setRotationZYX(arg0: float, arg1: float, arg2: float): Matrix4f;
                setRotationYXZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotation(arg0: Quaternionfc): Matrix4f;
                translationRotateScale(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): Matrix4f;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4f;
                translationRotateScale(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): Matrix4f;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: float): Matrix4f;
                translationRotateScaleInvert(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): Matrix4f;
                translationRotateScaleInvert(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4f;
                translationRotateScaleInvert(arg0: Vector3fc, arg1: Quaternionfc, arg2: float): Matrix4f;
                translationRotateScaleMulAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: Matrix4f): Matrix4f;
                translationRotateScaleMulAffine(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                translationRotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): Matrix4f;
                translationRotate(arg0: float, arg1: float, arg2: float, arg3: Quaternionfc): Matrix4f;
                translationRotate(arg0: Vector3fc, arg1: Quaternionfc): Matrix4f;
                translationRotateInvert(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): Matrix4f;
                translationRotateInvert(arg0: Vector3fc, arg1: Quaternionfc): Matrix4f;
                set3x3(arg0: Matrix3fc): Matrix4f;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformTranspose(arg0: Vector4f): Vector4f;
                transformTranspose(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformTranspose(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformProject(arg0: Vector4f): Vector4f;
                transformProject(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformProject(arg0: Vector4fc, arg1: Vector3f): Vector3f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector3f): Vector3f;
                transformProject(arg0: Vector3f): Vector3f;
                transformProject(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformPosition(arg0: Vector3f): Vector3f;
                transformPosition(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformPosition(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformAffine(arg0: Vector4f): Vector4f;
                transformAffine(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                scale(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                scale(arg0: Vector3fc): Matrix4f;
                scale(arg0: float, arg1: Matrix4f): Matrix4f;
                scale(arg0: float): Matrix4f;
                scaleXY(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                scaleXY(arg0: float, arg1: float): Matrix4f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                scale(arg0: float, arg1: float, arg2: float): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                scaleLocal(arg0: float, arg1: Matrix4f): Matrix4f;
                scaleLocal(arg0: float): Matrix4f;
                scaleLocal(arg0: float, arg1: float, arg2: float): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateX(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateX(arg0: float): Matrix4f;
                rotateY(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateY(arg0: float): Matrix4f;
                rotateZ(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateZ(arg0: float): Matrix4f;
                rotateTowardsXY(arg0: float, arg1: float): Matrix4f;
                rotateTowardsXY(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                rotateXYZ(arg0: Vector3fc): Matrix4f;
                rotateXYZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineXYZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateAffineXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateZYX(arg0: Vector3f): Matrix4f;
                rotateZYX(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineZYX(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateAffineZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateYXZ(arg0: Vector3f): Matrix4f;
                rotateYXZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineYXZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateAffineYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateTranslation(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAffine(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateLocalX(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalX(arg0: float): Matrix4f;
                rotateLocalY(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalY(arg0: float): Matrix4f;
                rotateLocalZ(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalZ(arg0: float): Matrix4f;
                translate(arg0: Vector3fc): Matrix4f;
                translate(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                translate(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                translate(arg0: float, arg1: float, arg2: float): Matrix4f;
                translateLocal(arg0: Vector3fc): Matrix4f;
                translateLocal(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                translateLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                translateLocal(arg0: float, arg1: float, arg2: float): Matrix4f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setOrtho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setOrtho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setOrthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setOrthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setOrthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setOrthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setOrthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setOrthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setOrtho2D(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setOrtho2DLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setLookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                setLookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setLookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                setLookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtPerspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                setLookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                setLookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                lookAtPerspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                tile(arg0: int, arg1: int, arg2: int, arg3: int): Matrix4f;
                tile(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                setPerspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setPerspective(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setPerspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setPerspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setPerspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setPerspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setPerspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setPerspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setPerspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setPerspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setPerspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setPerspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setFrustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setFrustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setFrustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setFrustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setFromIntrinsic(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: int, arg6: int, arg7: float, arg8: float): Matrix4f;
                rotate(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotate(arg0: Quaternionfc): Matrix4f;
                rotateAffine(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAffine(arg0: Quaternionfc): Matrix4f;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateAroundAffine(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotationAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateLocal(arg0: Quaternionfc): Matrix4f;
                rotateAroundLocal(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAroundLocal(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotate(arg0: AxisAngle4f): Matrix4f;
                rotate(arg0: AxisAngle4f, arg1: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: Vector3fc): Matrix4f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                unproject(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                unproject(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                unproject(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                unproject(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                unprojectRay(arg0: float, arg1: float, arg2: int[], arg3: Vector3f, arg4: Vector3f): Matrix4f;
                unprojectRay(arg0: Vector2fc, arg1: int[], arg2: Vector3f, arg3: Vector3f): Matrix4f;
                unprojectInv(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                unprojectInv(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                unprojectInvRay(arg0: Vector2fc, arg1: int[], arg2: Vector3f, arg3: Vector3f): Matrix4f;
                unprojectInvRay(arg0: float, arg1: float, arg2: int[], arg3: Vector3f, arg4: Vector3f): Matrix4f;
                unprojectInv(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                unprojectInv(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                project(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                project(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                project(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                project(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                reflect(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc): Matrix4f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                reflect(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                reflection(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                reflection(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                reflection(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                reflection(arg0: Quaternionfc, arg1: Vector3fc): Matrix4f;
                getRow(arg0: int, arg1: Vector4f): Vector4f;
                getRow(arg0: int, arg1: Vector3f): Vector3f;
                setRow(arg0: int, arg1: Vector4fc): Matrix4f;
                getColumn(arg0: int, arg1: Vector4f): Vector4f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                setColumn(arg0: int, arg1: Vector4fc): Matrix4f;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: float): Matrix4f;
                getRowColumn(arg0: int, arg1: int): number;
                setRowColumn(arg0: int, arg1: int, arg2: float): Matrix4f;
                normal(): Matrix4f;
                normal(arg0: Matrix4f): Matrix4f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor3x3(): Matrix4f;
                cofactor3x3(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix4f): Matrix4f;
                normalize3x3(): Matrix4f;
                normalize3x3(arg0: Matrix4f): Matrix4f;
                normalize3x3(arg0: Matrix3f): Matrix3f;
                frustumPlane(arg0: int, arg1: Vector4f): Vector4f;
                frustumCorner(arg0: int, arg1: Vector3f): Vector3f;
                perspectiveOrigin(arg0: Vector3f): Vector3f;
                perspectiveInvOrigin(arg0: Vector3f): Vector3f;
                perspectiveFov(): number;
                perspectiveNear(): number;
                perspectiveFar(): number;
                frustumRayDir(arg0: float, arg1: float, arg2: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                originAffine(arg0: Vector3f): Vector3f;
                origin(arg0: Vector3f): Vector3f;
                shadow(arg0: Vector4f, arg1: float, arg2: float, arg3: float, arg4: float): Matrix4f;
                shadow(arg0: Vector4f, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: Matrix4f): Matrix4f;
                shadow(arg0: Vector4f, arg1: Matrix4fc, arg2: Matrix4f): Matrix4f;
                shadow(arg0: Vector4f, arg1: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4fc, arg5: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                billboardCylindrical(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                billboardSpherical(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                billboardSpherical(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                equals(arg0: Matrix4fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[], arg5: Matrix4f): Matrix4f;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[]): Matrix4f;
                isAffine(): boolean;
                swap(arg0: Matrix4f): Matrix4f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float): Matrix4f;
                frustumAabb(arg0: Vector3f, arg1: Vector3f): Matrix4f;
                projectedGridRange(arg0: Matrix4fc, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                perspectiveFrustumSlice(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                orthoCrop(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                trapezoidCrop(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): Matrix4f;
                transformAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Vector3f, arg7: Vector3f): Matrix4f;
                transformAab(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f, arg3: Vector3f): Matrix4f;
                lerp(arg0: Matrix4fc, arg1: float): Matrix4f;
                lerp(arg0: Matrix4fc, arg1: float, arg2: Matrix4f): Matrix4f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                rotationTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                rotationTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                translationRotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                translationRotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                affineSpan(arg0: Vector3f, arg1: Vector3f, arg2: Vector3f, arg3: Vector3f): Matrix4f;
                testPoint(arg0: float, arg1: float, arg2: float): boolean;
                testSphere(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                testAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): boolean;
                obliqueZ(arg0: float, arg1: float): Matrix4f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                withLookAtUp(arg0: Vector3fc): Matrix4f;
                withLookAtUp(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                withLookAtUp(arg0: float, arg1: float, arg2: float): Matrix4f;
                withLookAtUp(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                mapXZY(): Matrix4f;
                mapXZY(arg0: Matrix4f): Matrix4f;
                mapXZnY(): Matrix4f;
                mapXZnY(arg0: Matrix4f): Matrix4f;
                mapXnYnZ(): Matrix4f;
                mapXnYnZ(arg0: Matrix4f): Matrix4f;
                mapXnZY(): Matrix4f;
                mapXnZY(arg0: Matrix4f): Matrix4f;
                mapXnZnY(): Matrix4f;
                mapXnZnY(arg0: Matrix4f): Matrix4f;
                mapYXZ(): Matrix4f;
                mapYXZ(arg0: Matrix4f): Matrix4f;
                mapYXnZ(): Matrix4f;
                mapYXnZ(arg0: Matrix4f): Matrix4f;
                mapYZX(): Matrix4f;
                mapYZX(arg0: Matrix4f): Matrix4f;
                mapYZnX(): Matrix4f;
                mapYZnX(arg0: Matrix4f): Matrix4f;
                mapYnXZ(): Matrix4f;
                mapYnXZ(arg0: Matrix4f): Matrix4f;
                mapYnXnZ(): Matrix4f;
                mapYnXnZ(arg0: Matrix4f): Matrix4f;
                mapYnZX(): Matrix4f;
                mapYnZX(arg0: Matrix4f): Matrix4f;
                mapYnZnX(): Matrix4f;
                mapYnZnX(arg0: Matrix4f): Matrix4f;
                mapZXY(): Matrix4f;
                mapZXY(arg0: Matrix4f): Matrix4f;
                mapZXnY(): Matrix4f;
                mapZXnY(arg0: Matrix4f): Matrix4f;
                mapZYX(): Matrix4f;
                mapZYX(arg0: Matrix4f): Matrix4f;
                mapZYnX(): Matrix4f;
                mapZYnX(arg0: Matrix4f): Matrix4f;
                mapZnXY(): Matrix4f;
                mapZnXY(arg0: Matrix4f): Matrix4f;
                mapZnXnY(): Matrix4f;
                mapZnXnY(arg0: Matrix4f): Matrix4f;
                mapZnYX(): Matrix4f;
                mapZnYX(arg0: Matrix4f): Matrix4f;
                mapZnYnX(): Matrix4f;
                mapZnYnX(arg0: Matrix4f): Matrix4f;
                mapnXYnZ(): Matrix4f;
                mapnXYnZ(arg0: Matrix4f): Matrix4f;
                mapnXZY(): Matrix4f;
                mapnXZY(arg0: Matrix4f): Matrix4f;
                mapnXZnY(): Matrix4f;
                mapnXZnY(arg0: Matrix4f): Matrix4f;
                mapnXnYZ(): Matrix4f;
                mapnXnYZ(arg0: Matrix4f): Matrix4f;
                mapnXnYnZ(): Matrix4f;
                mapnXnYnZ(arg0: Matrix4f): Matrix4f;
                mapnXnZY(): Matrix4f;
                mapnXnZY(arg0: Matrix4f): Matrix4f;
                mapnXnZnY(): Matrix4f;
                mapnXnZnY(arg0: Matrix4f): Matrix4f;
                mapnYXZ(): Matrix4f;
                mapnYXZ(arg0: Matrix4f): Matrix4f;
                mapnYXnZ(): Matrix4f;
                mapnYXnZ(arg0: Matrix4f): Matrix4f;
                mapnYZX(): Matrix4f;
                mapnYZX(arg0: Matrix4f): Matrix4f;
                mapnYZnX(): Matrix4f;
                mapnYZnX(arg0: Matrix4f): Matrix4f;
                mapnYnXZ(): Matrix4f;
                mapnYnXZ(arg0: Matrix4f): Matrix4f;
                mapnYnXnZ(): Matrix4f;
                mapnYnXnZ(arg0: Matrix4f): Matrix4f;
                mapnYnZX(): Matrix4f;
                mapnYnZX(arg0: Matrix4f): Matrix4f;
                mapnYnZnX(): Matrix4f;
                mapnYnZnX(arg0: Matrix4f): Matrix4f;
                mapnZXY(): Matrix4f;
                mapnZXY(arg0: Matrix4f): Matrix4f;
                mapnZXnY(): Matrix4f;
                mapnZXnY(arg0: Matrix4f): Matrix4f;
                mapnZYX(): Matrix4f;
                mapnZYX(arg0: Matrix4f): Matrix4f;
                mapnZYnX(): Matrix4f;
                mapnZYnX(arg0: Matrix4f): Matrix4f;
                mapnZnXY(): Matrix4f;
                mapnZnXY(arg0: Matrix4f): Matrix4f;
                mapnZnXnY(): Matrix4f;
                mapnZnXnY(arg0: Matrix4f): Matrix4f;
                mapnZnYX(): Matrix4f;
                mapnZnYX(arg0: Matrix4f): Matrix4f;
                mapnZnYnX(): Matrix4f;
                mapnZnYnX(arg0: Matrix4f): Matrix4f;
                negateX(): Matrix4f;
                negateX(arg0: Matrix4f): Matrix4f;
                negateY(): Matrix4f;
                negateY(arg0: Matrix4f): Matrix4f;
                negateZ(): Matrix4f;
                negateZ(arg0: Matrix4f): Matrix4f;
                isFinite(): boolean;
                clone(): any;

            }

            abstract class Matrix2dc extends java.lang.Interface {
                static readonly class: JavaClass<Matrix2dc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Matrix2dc {

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                mul(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                mul(arg0: Matrix2fc, arg1: Matrix2d): Matrix2d;
                mulLocal(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                determinant(): number;
                invert(arg0: Matrix2d): Matrix2d;
                transpose(arg0: Matrix2d): Matrix2d;
                get(arg0: Matrix2d): Matrix2d;
                get(arg0: Matrix3x2d): Matrix3x2d;
                get(arg0: Matrix3d): Matrix3d;
                getRotation(): number;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix2dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                scale(arg0: Vector2dc, arg1: Matrix2d): Matrix2d;
                scale(arg0: double, arg1: double, arg2: Matrix2d): Matrix2d;
                scale(arg0: double, arg1: Matrix2d): Matrix2d;
                scaleLocal(arg0: double, arg1: double, arg2: Matrix2d): Matrix2d;
                transform(arg0: Vector2d): Vector2d;
                transform(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transform(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                transformTranspose(arg0: Vector2d): Vector2d;
                transformTranspose(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformTranspose(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                rotate(arg0: double, arg1: Matrix2d): Matrix2d;
                rotateLocal(arg0: double, arg1: Matrix2d): Matrix2d;
                getRow(arg0: int, arg1: Vector2d): Vector2d;
                getColumn(arg0: int, arg1: Vector2d): Vector2d;
                get(arg0: int, arg1: int): number;
                normal(arg0: Matrix2d): Matrix2d;
                getScale(arg0: Vector2d): Vector2d;
                positiveX(arg0: Vector2d): Vector2d;
                normalizedPositiveX(arg0: Vector2d): Vector2d;
                positiveY(arg0: Vector2d): Vector2d;
                normalizedPositiveY(arg0: Vector2d): Vector2d;
                add(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                sub(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                mulComponentWise(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                lerp(arg0: Matrix2dc, arg1: double, arg2: Matrix2d): Matrix2d;
                equals(arg0: Matrix2dc, arg1: double): boolean;
                isFinite(): boolean;

            }

            interface Vector2i extends java.lang.Cloneable, Vector2ic, java.io.Externalizable {}
            class Vector2i extends java.lang.Object {
                static readonly class: JavaClass<Vector2i>;
                /** @deprecated */ static prototype: undefined;

                static lengthSquared(arg0: int, arg1: int): number;
                static length(arg0: int, arg1: int): number;
                static distance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                static distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;

                constructor ();
                constructor (arg0: int);
                constructor (arg0: int, arg1: int);
                constructor (arg0: float, arg1: float, arg2: int);
                constructor (arg0: double, arg1: double, arg2: int);
                constructor (arg0: Vector2ic);
                constructor (arg0: Vector2fc, arg1: int);
                constructor (arg0: Vector2dc, arg1: int);
                constructor (arg0: int[]);
                constructor (arg0: java.nio.ByteBuffer);
                constructor (arg0: int, arg1: java.nio.ByteBuffer);
                constructor (arg0: java.nio.IntBuffer);
                constructor (arg0: int, arg1: java.nio.IntBuffer);

                x: number;
                y: number;

                x(): number;
                y(): number;
                set(arg0: int): Vector2i;
                set(arg0: int, arg1: int): Vector2i;
                set(arg0: Vector2ic): Vector2i;
                set(arg0: Vector2dc): Vector2i;
                set(arg0: Vector2dc, arg1: int): Vector2i;
                set(arg0: Vector2fc, arg1: int): Vector2i;
                set(arg0: int[]): Vector2i;
                set(arg0: java.nio.ByteBuffer): Vector2i;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector2i;
                set(arg0: java.nio.IntBuffer): Vector2i;
                set(arg0: int, arg1: java.nio.IntBuffer): Vector2i;
                setFromAddress(arg0: long): Vector2i;
                get(arg0: int): number;
                setComponent(arg0: int, arg1: int): Vector2i;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                getToAddress(arg0: long): Vector2ic;
                sub(arg0: Vector2ic): Vector2i;
                sub(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                sub(arg0: int, arg1: int): Vector2i;
                sub(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2ic): number;
                distance(arg0: int, arg1: int): number;
                distanceSquared(arg0: Vector2ic): number;
                distanceSquared(arg0: int, arg1: int): number;
                gridDistance(arg0: Vector2ic): number;
                gridDistance(arg0: int, arg1: int): number;
                add(arg0: Vector2ic): Vector2i;
                add(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                add(arg0: int, arg1: int): Vector2i;
                add(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                mul(arg0: int): Vector2i;
                mul(arg0: int, arg1: Vector2i): Vector2i;
                mul(arg0: Vector2ic): Vector2i;
                mul(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                mul(arg0: int, arg1: int): Vector2i;
                mul(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                div(arg0: float): Vector2i;
                div(arg0: float, arg1: Vector2i): Vector2i;
                div(arg0: int): Vector2i;
                div(arg0: int, arg1: Vector2i): Vector2i;
                zero(): Vector2i;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector2i;
                negate(arg0: Vector2i): Vector2i;
                min(arg0: Vector2ic): Vector2i;
                min(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                max(arg0: Vector2ic): Vector2i;
                max(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                maxComponent(): number;
                minComponent(): number;
                absolute(): Vector2i;
                absolute(arg0: Vector2i): Vector2i;
                equals(arg0: int, arg1: int): boolean;
                equals(arg0: any): boolean;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                clone(): any;

            }

            interface Vector4f extends java.lang.Cloneable, Vector4fc, java.io.Externalizable {}
            class Vector4f extends java.lang.Object {
                static readonly class: JavaClass<Vector4f>;
                /** @deprecated */ static prototype: undefined;

                static lengthSquared(arg0: float, arg1: float, arg2: float, arg3: float): number;
                static lengthSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;
                static length(arg0: float, arg1: float, arg2: float, arg3: float): number;
                static distance(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): number;
                static distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): number;

                constructor ();
                constructor (arg0: Vector4fc);
                constructor (arg0: Vector4ic);
                constructor (arg0: Vector3fc, arg1: float);
                constructor (arg0: Vector3ic, arg1: float);
                constructor (arg0: Vector2fc, arg1: float, arg2: float);
                constructor (arg0: Vector2ic, arg1: float, arg2: float);
                constructor (arg0: float);
                constructor (arg0: float, arg1: float, arg2: float, arg3: float);
                constructor (arg0: float[]);
                constructor (arg0: java.nio.ByteBuffer);
                constructor (arg0: int, arg1: java.nio.ByteBuffer);
                constructor (arg0: java.nio.FloatBuffer);
                constructor (arg0: int, arg1: java.nio.FloatBuffer);

                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                set(arg0: Vector4fc): Vector4f;
                set(arg0: Vector4ic): Vector4f;
                set(arg0: Vector4dc): Vector4f;
                set(arg0: Vector3fc, arg1: float): Vector4f;
                set(arg0: Vector3ic, arg1: float): Vector4f;
                set(arg0: Vector2fc, arg1: float, arg2: float): Vector4f;
                set(arg0: Vector2ic, arg1: float, arg2: float): Vector4f;
                set(arg0: float): Vector4f;
                set(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                set(arg0: float, arg1: float, arg2: float): Vector4f;
                set(arg0: double): Vector4f;
                set(arg0: double, arg1: double, arg2: double, arg3: double): Vector4f;
                set(arg0: float[]): Vector4f;
                set(arg0: java.nio.ByteBuffer): Vector4f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector4f;
                set(arg0: java.nio.FloatBuffer): Vector4f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Vector4f;
                setFromAddress(arg0: long): Vector4f;
                setComponent(arg0: int, arg1: float): Vector4f;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4fc;
                sub(arg0: Vector4fc): Vector4f;
                sub(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                sub(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                sub(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                add(arg0: Vector4fc): Vector4f;
                add(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                add(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                add(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                fma(arg0: Vector4fc, arg1: Vector4fc): Vector4f;
                fma(arg0: float, arg1: Vector4fc): Vector4f;
                fma(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                fma(arg0: float, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mulAdd(arg0: Vector4fc, arg1: Vector4fc): Vector4f;
                mulAdd(arg0: float, arg1: Vector4fc): Vector4f;
                mulAdd(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mulAdd(arg0: float, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mul(arg0: Vector4fc): Vector4f;
                mul(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                div(arg0: Vector4fc): Vector4f;
                div(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                mul(arg0: Matrix4fc): Vector4f;
                mul(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulTranspose(arg0: Matrix4fc): Vector4f;
                mulTranspose(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulAffine(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulAffineTranspose(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mul(arg0: Matrix4x3fc): Vector4f;
                mul(arg0: Matrix4x3fc, arg1: Vector4f): Vector4f;
                mulProject(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulProject(arg0: Matrix4fc): Vector4f;
                mulProject(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mul(arg0: float): Vector4f;
                mul(arg0: float, arg1: Vector4f): Vector4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                div(arg0: float): Vector4f;
                div(arg0: float, arg1: Vector4f): Vector4f;
                div(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                div(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                rotate(arg0: Quaternionfc): Vector4f;
                rotate(arg0: Quaternionfc, arg1: Vector4f): Vector4f;
                rotateAbout(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                rotateX(arg0: float): Vector4f;
                rotateX(arg0: float, arg1: Vector4f): Vector4f;
                rotateY(arg0: float): Vector4f;
                rotateY(arg0: float, arg1: Vector4f): Vector4f;
                rotateZ(arg0: float): Vector4f;
                rotateZ(arg0: float, arg1: Vector4f): Vector4f;
                lengthSquared(): number;
                length(): number;
                normalize(): Vector4f;
                normalize(arg0: Vector4f): Vector4f;
                normalize(arg0: float): Vector4f;
                normalize(arg0: float, arg1: Vector4f): Vector4f;
                normalize3(): Vector4f;
                normalize3(arg0: Vector4f): Vector4f;
                distance(arg0: Vector4fc): number;
                distance(arg0: float, arg1: float, arg2: float, arg3: float): number;
                distanceSquared(arg0: Vector4fc): number;
                distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float): number;
                dot(arg0: Vector4fc): number;
                dot(arg0: float, arg1: float, arg2: float, arg3: float): number;
                angleCos(arg0: Vector4fc): number;
                angle(arg0: Vector4fc): number;
                zero(): Vector4f;
                negate(): Vector4f;
                negate(arg0: Vector4f): Vector4f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                min(arg0: Vector4fc): Vector4f;
                min(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                max(arg0: Vector4fc): Vector4f;
                max(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                equals(arg0: Vector4fc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                equals(arg0: any): boolean;
                smoothStep(arg0: Vector4fc, arg1: float, arg2: Vector4f): Vector4f;
                hermite(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4fc, arg3: float, arg4: Vector4f): Vector4f;
                lerp(arg0: Vector4fc, arg1: float): Vector4f;
                lerp(arg0: Vector4fc, arg1: float, arg2: Vector4f): Vector4f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector4i): Vector4i;
                get(arg0: Vector4f): Vector4f;
                get(arg0: Vector4d): Vector4d;
                maxComponent(): number;
                minComponent(): number;
                floor(): Vector4f;
                floor(arg0: Vector4f): Vector4f;
                ceil(): Vector4f;
                ceil(arg0: Vector4f): Vector4f;
                round(): Vector4f;
                round(arg0: Vector4f): Vector4f;
                isFinite(): boolean;
                absolute(): Vector4f;
                absolute(arg0: Vector4f): Vector4f;
                clone(): any;

            }

            interface Vector2f extends java.lang.Cloneable, java.io.Externalizable, Vector2fc {}
            class Vector2f extends java.lang.Object {
                static readonly class: JavaClass<Vector2f>;
                /** @deprecated */ static prototype: undefined;

                static lengthSquared(arg0: float, arg1: float): number;
                static length(arg0: float, arg1: float): number;
                static distance(arg0: float, arg1: float, arg2: float, arg3: float): number;
                static distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float): number;

                constructor ();
                constructor (arg0: float);
                constructor (arg0: float, arg1: float);
                constructor (arg0: Vector2fc);
                constructor (arg0: Vector2ic);
                constructor (arg0: float[]);
                constructor (arg0: java.nio.ByteBuffer);
                constructor (arg0: int, arg1: java.nio.ByteBuffer);
                constructor (arg0: java.nio.FloatBuffer);
                constructor (arg0: int, arg1: java.nio.FloatBuffer);

                x: number;
                y: number;

                x(): number;
                y(): number;
                set(arg0: float): Vector2f;
                set(arg0: float, arg1: float): Vector2f;
                set(arg0: double): Vector2f;
                set(arg0: double, arg1: double): Vector2f;
                set(arg0: Vector2fc): Vector2f;
                set(arg0: Vector2ic): Vector2f;
                set(arg0: Vector2dc): Vector2f;
                set(arg0: float[]): Vector2f;
                set(arg0: java.nio.ByteBuffer): Vector2f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector2f;
                set(arg0: java.nio.FloatBuffer): Vector2f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Vector2f;
                setFromAddress(arg0: long): Vector2f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector2i): Vector2i;
                get(arg0: Vector2f): Vector2f;
                get(arg0: Vector2d): Vector2d;
                setComponent(arg0: int, arg1: float): Vector2f;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getToAddress(arg0: long): Vector2fc;
                perpendicular(): Vector2f;
                sub(arg0: Vector2fc): Vector2f;
                sub(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                sub(arg0: float, arg1: float): Vector2f;
                sub(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                dot(arg0: Vector2fc): number;
                angle(arg0: Vector2fc): number;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2fc): number;
                distanceSquared(arg0: Vector2fc): number;
                distance(arg0: float, arg1: float): number;
                distanceSquared(arg0: float, arg1: float): number;
                normalize(): Vector2f;
                normalize(arg0: Vector2f): Vector2f;
                normalize(arg0: float): Vector2f;
                normalize(arg0: float, arg1: Vector2f): Vector2f;
                add(arg0: Vector2fc): Vector2f;
                add(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                add(arg0: float, arg1: float): Vector2f;
                add(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                zero(): Vector2f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector2f;
                negate(arg0: Vector2f): Vector2f;
                mul(arg0: float): Vector2f;
                mul(arg0: float, arg1: Vector2f): Vector2f;
                mul(arg0: float, arg1: float): Vector2f;
                mul(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                mul(arg0: Vector2fc): Vector2f;
                mul(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                div(arg0: Vector2fc): Vector2f;
                div(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                div(arg0: float): Vector2f;
                div(arg0: float, arg1: Vector2f): Vector2f;
                div(arg0: float, arg1: float): Vector2f;
                div(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                mul(arg0: Matrix2fc): Vector2f;
                mul(arg0: Matrix2fc, arg1: Vector2f): Vector2f;
                mul(arg0: Matrix2dc): Vector2f;
                mul(arg0: Matrix2dc, arg1: Vector2f): Vector2f;
                mulTranspose(arg0: Matrix2fc): Vector2f;
                mulTranspose(arg0: Matrix2fc, arg1: Vector2f): Vector2f;
                mulPosition(arg0: Matrix3x2fc): Vector2f;
                mulPosition(arg0: Matrix3x2fc, arg1: Vector2f): Vector2f;
                mulDirection(arg0: Matrix3x2fc): Vector2f;
                mulDirection(arg0: Matrix3x2fc, arg1: Vector2f): Vector2f;
                lerp(arg0: Vector2fc, arg1: float): Vector2f;
                lerp(arg0: Vector2fc, arg1: float, arg2: Vector2f): Vector2f;
                equals(arg0: Vector2fc, arg1: float): boolean;
                equals(arg0: float, arg1: float): boolean;
                equals(arg0: any): boolean;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                fma(arg0: Vector2fc, arg1: Vector2fc): Vector2f;
                fma(arg0: float, arg1: Vector2fc): Vector2f;
                fma(arg0: Vector2fc, arg1: Vector2fc, arg2: Vector2f): Vector2f;
                fma(arg0: float, arg1: Vector2fc, arg2: Vector2f): Vector2f;
                min(arg0: Vector2fc): Vector2f;
                min(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                max(arg0: Vector2fc): Vector2f;
                max(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                maxComponent(): number;
                minComponent(): number;
                floor(): Vector2f;
                floor(arg0: Vector2f): Vector2f;
                ceil(): Vector2f;
                ceil(arg0: Vector2f): Vector2f;
                round(): Vector2f;
                round(arg0: Vector2f): Vector2f;
                isFinite(): boolean;
                absolute(): Vector2f;
                absolute(arg0: Vector2f): Vector2f;
                clone(): any;

            }

            interface Matrix4d extends java.lang.Cloneable, java.io.Externalizable, Matrix4dc {}
            class Matrix4d extends java.lang.Object {
                static readonly class: JavaClass<Matrix4d>;
                /** @deprecated */ static prototype: undefined;

                static perspectiveOffCenterViewFromRectangle(arg0: Vector3d, arg1: Vector3d, arg2: Vector3d, arg3: Vector3d, arg4: double, arg5: boolean, arg6: Matrix4d, arg7: Matrix4d): void;

                constructor ();
                constructor (arg0: Matrix4dc);
                constructor (arg0: Matrix4fc);
                constructor (arg0: Matrix4x3dc);
                constructor (arg0: Matrix4x3fc);
                constructor (arg0: Matrix3dc);
                constructor (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double);
                constructor (arg0: java.nio.DoubleBuffer);
                constructor (arg0: Vector4d, arg1: Vector4d, arg2: Vector4d, arg3: Vector4d);

                assume(arg0: int): Matrix4d;
                determineProperties(): Matrix4d;
                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m03(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m13(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m23(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m33(): number;
                m00(arg0: double): Matrix4d;
                m01(arg0: double): Matrix4d;
                m02(arg0: double): Matrix4d;
                m03(arg0: double): Matrix4d;
                m10(arg0: double): Matrix4d;
                m11(arg0: double): Matrix4d;
                m12(arg0: double): Matrix4d;
                m13(arg0: double): Matrix4d;
                m20(arg0: double): Matrix4d;
                m21(arg0: double): Matrix4d;
                m22(arg0: double): Matrix4d;
                m23(arg0: double): Matrix4d;
                m30(arg0: double): Matrix4d;
                m31(arg0: double): Matrix4d;
                m32(arg0: double): Matrix4d;
                m33(arg0: double): Matrix4d;
                identity(): Matrix4d;
                set(arg0: Matrix4dc): Matrix4d;
                set(arg0: Matrix4fc): Matrix4d;
                setTransposed(arg0: Matrix4dc): Matrix4d;
                set(arg0: Matrix4x3dc): Matrix4d;
                set(arg0: Matrix4x3fc): Matrix4d;
                set(arg0: Matrix3dc): Matrix4d;
                set3x3(arg0: Matrix4dc): Matrix4d;
                set4x3(arg0: Matrix4x3dc): Matrix4d;
                set4x3(arg0: Matrix4x3fc): Matrix4d;
                set4x3(arg0: Matrix4dc): Matrix4d;
                set(arg0: AxisAngle4f): Matrix4d;
                set(arg0: AxisAngle4d): Matrix4d;
                set(arg0: Quaternionfc): Matrix4d;
                set(arg0: Quaterniondc): Matrix4d;
                mul(arg0: Matrix4dc): Matrix4d;
                mul(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul0(arg0: Matrix4dc): Matrix4d;
                mul0(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double): Matrix4d;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double, arg16: Matrix4d): Matrix4d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                mulLocal(arg0: Matrix4dc): Matrix4d;
                mulLocal(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulLocalAffine(arg0: Matrix4dc): Matrix4d;
                mulLocalAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3dc): Matrix4d;
                mul(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix3x2dc): Matrix4d;
                mul(arg0: Matrix3x2dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix3x2fc): Matrix4d;
                mul(arg0: Matrix3x2fc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4f): Matrix4d;
                mul(arg0: Matrix4fc, arg1: Matrix4d): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4dc): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulAffineR(arg0: Matrix4dc): Matrix4d;
                mulAffineR(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulAffine(arg0: Matrix4dc): Matrix4d;
                mulAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulTranslationAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulOrthoAffine(arg0: Matrix4dc): Matrix4d;
                mulOrthoAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                fma4x3(arg0: Matrix4dc, arg1: double): Matrix4d;
                fma4x3(arg0: Matrix4dc, arg1: double, arg2: Matrix4d): Matrix4d;
                add(arg0: Matrix4dc): Matrix4d;
                add(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                sub(arg0: Matrix4dc): Matrix4d;
                sub(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulComponentWise(arg0: Matrix4dc): Matrix4d;
                mulComponentWise(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                add4x3(arg0: Matrix4dc): Matrix4d;
                add4x3(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                add4x3(arg0: Matrix4fc): Matrix4d;
                add4x3(arg0: Matrix4fc, arg1: Matrix4d): Matrix4d;
                sub4x3(arg0: Matrix4dc): Matrix4d;
                sub4x3(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul4x3ComponentWise(arg0: Matrix4dc): Matrix4d;
                mul4x3ComponentWise(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                set(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double): Matrix4d;
                set(arg0: double[], arg1: int): Matrix4d;
                set(arg0: double[]): Matrix4d;
                set(arg0: float[], arg1: int): Matrix4d;
                set(arg0: float[]): Matrix4d;
                set(arg0: java.nio.DoubleBuffer): Matrix4d;
                set(arg0: java.nio.FloatBuffer): Matrix4d;
                set(arg0: java.nio.ByteBuffer): Matrix4d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix4d;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix4d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix4d;
                setFloats(arg0: java.nio.ByteBuffer): Matrix4d;
                setFloats(arg0: int, arg1: java.nio.ByteBuffer): Matrix4d;
                setFromAddress(arg0: long): Matrix4d;
                set(arg0: Vector4d, arg1: Vector4d, arg2: Vector4d, arg3: Vector4d): Matrix4d;
                determinant(): number;
                determinant3x3(): number;
                determinantAffine(): number;
                invert(): Matrix4d;
                invert(arg0: Matrix4d): Matrix4d;
                invertPerspective(arg0: Matrix4d): Matrix4d;
                invertPerspective(): Matrix4d;
                invertFrustum(arg0: Matrix4d): Matrix4d;
                invertFrustum(): Matrix4d;
                invertOrtho(arg0: Matrix4d): Matrix4d;
                invertOrtho(): Matrix4d;
                invertPerspectiveView(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                invertPerspectiveView(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                invertAffine(arg0: Matrix4d): Matrix4d;
                invertAffine(): Matrix4d;
                transpose(): Matrix4d;
                transpose(arg0: Matrix4d): Matrix4d;
                transpose3x3(): Matrix4d;
                transpose3x3(arg0: Matrix4d): Matrix4d;
                transpose3x3(arg0: Matrix3d): Matrix3d;
                translation(arg0: double, arg1: double, arg2: double): Matrix4d;
                translation(arg0: Vector3fc): Matrix4d;
                translation(arg0: Vector3dc): Matrix4d;
                setTranslation(arg0: double, arg1: double, arg2: double): Matrix4d;
                setTranslation(arg0: Vector3dc): Matrix4d;
                getTranslation(arg0: Vector3d): Vector3d;
                getScale(arg0: Vector3d): Vector3d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix4d): Matrix4d;
                get4x3(arg0: Matrix4x3d): Matrix4x3d;
                get3x3(arg0: Matrix3d): Matrix3d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x3Transposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                zero(): Matrix4d;
                scaling(arg0: double): Matrix4d;
                scaling(arg0: double, arg1: double, arg2: double): Matrix4d;
                scaling(arg0: Vector3dc): Matrix4d;
                rotation(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotationX(arg0: double): Matrix4d;
                rotationY(arg0: double): Matrix4d;
                rotationZ(arg0: double): Matrix4d;
                rotationTowardsXY(arg0: double, arg1: double): Matrix4d;
                rotationXYZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotationZYX(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotationYXZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                setRotationXYZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                setRotationZYX(arg0: double, arg1: double, arg2: double): Matrix4d;
                setRotationYXZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotation(arg0: double, arg1: Vector3dc): Matrix4d;
                rotation(arg0: double, arg1: Vector3fc): Matrix4d;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformTranspose(arg0: Vector4d): Vector4d;
                transformTranspose(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformTranspose(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformProject(arg0: Vector4d): Vector4d;
                transformProject(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformProject(arg0: Vector3d): Vector3d;
                transformProject(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformProject(arg0: Vector4dc, arg1: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector3d): Vector3d;
                transformPosition(arg0: Vector3d): Vector3d;
                transformPosition(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformPosition(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformDirection(arg0: Vector3d): Vector3d;
                transformDirection(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformDirection(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformAffine(arg0: Vector4d): Vector4d;
                transformAffine(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                set3x3(arg0: Matrix3dc): Matrix4d;
                scale(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                scale(arg0: Vector3dc): Matrix4d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                scale(arg0: double, arg1: double, arg2: double): Matrix4d;
                scale(arg0: double, arg1: Matrix4d): Matrix4d;
                scale(arg0: double): Matrix4d;
                scaleXY(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                scaleXY(arg0: double, arg1: double): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                scaleLocal(arg0: double, arg1: Matrix4d): Matrix4d;
                scaleLocal(arg0: double): Matrix4d;
                scaleLocal(arg0: double, arg1: double, arg2: double): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateTranslation(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAffine(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateAroundAffine(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotationAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateAroundLocal(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAroundLocal(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4d;
                translate(arg0: Vector3dc): Matrix4d;
                translate(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                translate(arg0: Vector3fc): Matrix4d;
                translate(arg0: Vector3fc, arg1: Matrix4d): Matrix4d;
                translate(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                translate(arg0: double, arg1: double, arg2: double): Matrix4d;
                translateLocal(arg0: Vector3fc): Matrix4d;
                translateLocal(arg0: Vector3fc, arg1: Matrix4d): Matrix4d;
                translateLocal(arg0: Vector3dc): Matrix4d;
                translateLocal(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                translateLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                translateLocal(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateLocalX(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalX(arg0: double): Matrix4d;
                rotateLocalY(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalY(arg0: double): Matrix4d;
                rotateLocalZ(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalZ(arg0: double): Matrix4d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotateX(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateX(arg0: double): Matrix4d;
                rotateY(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateY(arg0: double): Matrix4d;
                rotateZ(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateZ(arg0: double): Matrix4d;
                rotateTowardsXY(arg0: double, arg1: double): Matrix4d;
                rotateTowardsXY(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                rotateXYZ(arg0: Vector3d): Matrix4d;
                rotateXYZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineXYZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateAffineXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateZYX(arg0: Vector3d): Matrix4d;
                rotateZYX(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineZYX(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateAffineZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateYXZ(arg0: Vector3d): Matrix4d;
                rotateYXZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineYXZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateAffineYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotation(arg0: AxisAngle4f): Matrix4d;
                rotation(arg0: AxisAngle4d): Matrix4d;
                rotation(arg0: Quaterniondc): Matrix4d;
                rotation(arg0: Quaternionfc): Matrix4d;
                translationRotateScale(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): Matrix4d;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4d;
                translationRotateScale(arg0: Vector3dc, arg1: Quaterniondc, arg2: Vector3dc): Matrix4d;
                translationRotateScale(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): Matrix4d;
                translationRotateScale(arg0: Vector3dc, arg1: Quaterniondc, arg2: double): Matrix4d;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: double): Matrix4d;
                translationRotateScaleInvert(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): Matrix4d;
                translationRotateScaleInvert(arg0: Vector3dc, arg1: Quaterniondc, arg2: Vector3dc): Matrix4d;
                translationRotateScaleInvert(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4d;
                translationRotateScaleInvert(arg0: Vector3dc, arg1: Quaterniondc, arg2: double): Matrix4d;
                translationRotateScaleInvert(arg0: Vector3fc, arg1: Quaternionfc, arg2: double): Matrix4d;
                translationRotateScaleMulAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: Matrix4d): Matrix4d;
                translationRotateScaleMulAffine(arg0: Vector3fc, arg1: Quaterniondc, arg2: Vector3fc, arg3: Matrix4d): Matrix4d;
                translationRotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): Matrix4d;
                translationRotate(arg0: double, arg1: double, arg2: double, arg3: Quaterniondc): Matrix4d;
                translationRotate(arg0: Vector3dc, arg1: Quaterniondc): Matrix4d;
                translationRotateInvert(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): Matrix4d;
                translationRotateInvert(arg0: Vector3fc, arg1: Quaternionfc): Matrix4d;
                rotate(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotate(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotate(arg0: Quaterniondc): Matrix4d;
                rotate(arg0: Quaternionfc): Matrix4d;
                rotateAffine(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateAffine(arg0: Quaterniondc): Matrix4d;
                rotateTranslation(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaterniondc): Matrix4d;
                rotateAffine(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateAffine(arg0: Quaternionfc): Matrix4d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaternionfc): Matrix4d;
                rotate(arg0: AxisAngle4f): Matrix4d;
                rotate(arg0: AxisAngle4f, arg1: Matrix4d): Matrix4d;
                rotate(arg0: AxisAngle4d): Matrix4d;
                rotate(arg0: AxisAngle4d, arg1: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: Vector3dc): Matrix4d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: Vector3fc): Matrix4d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix4d): Matrix4d;
                getRow(arg0: int, arg1: Vector4d): Vector4d;
                getRow(arg0: int, arg1: Vector3d): Vector3d;
                setRow(arg0: int, arg1: Vector4dc): Matrix4d;
                getColumn(arg0: int, arg1: Vector4d): Vector4d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                setColumn(arg0: int, arg1: Vector4dc): Matrix4d;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: double): Matrix4d;
                getRowColumn(arg0: int, arg1: int): number;
                setRowColumn(arg0: int, arg1: int, arg2: double): Matrix4d;
                normal(): Matrix4d;
                normal(arg0: Matrix4d): Matrix4d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor3x3(): Matrix4d;
                cofactor3x3(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix4d): Matrix4d;
                normalize3x3(): Matrix4d;
                normalize3x3(arg0: Matrix4d): Matrix4d;
                normalize3x3(arg0: Matrix3d): Matrix3d;
                unproject(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                unproject(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                unproject(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                unproject(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                unprojectRay(arg0: double, arg1: double, arg2: int[], arg3: Vector3d, arg4: Vector3d): Matrix4d;
                unprojectRay(arg0: Vector2dc, arg1: int[], arg2: Vector3d, arg3: Vector3d): Matrix4d;
                unprojectInv(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                unprojectInv(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                unprojectInv(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                unprojectInv(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                unprojectInvRay(arg0: Vector2dc, arg1: int[], arg2: Vector3d, arg3: Vector3d): Matrix4d;
                unprojectInvRay(arg0: double, arg1: double, arg2: int[], arg3: Vector3d, arg4: Vector3d): Matrix4d;
                project(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                project(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                project(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                project(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                reflect(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc): Matrix4d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                reflect(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                reflection(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                reflection(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                reflection(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                reflection(arg0: Quaterniondc, arg1: Vector3dc): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setOrtho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setOrtho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setOrthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setOrthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setOrthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setOrthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setOrthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setOrthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setOrtho2D(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setOrtho2DLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setLookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                setLookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setLookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                setLookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4d): Matrix4d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                lookAtPerspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                setLookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                setLookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4d): Matrix4d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                lookAtPerspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                tile(arg0: int, arg1: int, arg2: int, arg3: int): Matrix4d;
                tile(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                setPerspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setPerspective(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setPerspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setPerspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setPerspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setPerspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setPerspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setPerspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setPerspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setPerspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setPerspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setPerspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setFrustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setFrustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setFrustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setFrustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setFromIntrinsic(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: int, arg6: int, arg7: double, arg8: double): Matrix4d;
                frustumPlane(arg0: int, arg1: Vector4d): Vector4d;
                frustumCorner(arg0: int, arg1: Vector3d): Vector3d;
                perspectiveOrigin(arg0: Vector3d): Vector3d;
                perspectiveInvOrigin(arg0: Vector3d): Vector3d;
                perspectiveFov(): number;
                perspectiveNear(): number;
                perspectiveFar(): number;
                frustumRayDir(arg0: double, arg1: double, arg2: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                originAffine(arg0: Vector3d): Vector3d;
                origin(arg0: Vector3d): Vector3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double): Matrix4d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double, arg5: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: Matrix4d): Matrix4d;
                shadow(arg0: Vector4dc, arg1: Matrix4dc, arg2: Matrix4d): Matrix4d;
                shadow(arg0: Vector4d, arg1: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4dc, arg5: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4dc): Matrix4d;
                billboardCylindrical(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                billboardSpherical(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                billboardSpherical(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                equals(arg0: Matrix4dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[], arg5: Matrix4d): Matrix4d;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[]): Matrix4d;
                isAffine(): boolean;
                swap(arg0: Matrix4d): Matrix4d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double): Matrix4d;
                frustumAabb(arg0: Vector3d, arg1: Vector3d): Matrix4d;
                projectedGridRange(arg0: Matrix4dc, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                perspectiveFrustumSlice(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                orthoCrop(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                trapezoidCrop(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): Matrix4d;
                transformAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Vector3d, arg7: Vector3d): Matrix4d;
                transformAab(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d, arg3: Vector3d): Matrix4d;
                lerp(arg0: Matrix4dc, arg1: double): Matrix4d;
                lerp(arg0: Matrix4dc, arg1: double, arg2: Matrix4d): Matrix4d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                rotationTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                rotationTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                translationRotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                translationRotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                affineSpan(arg0: Vector3d, arg1: Vector3d, arg2: Vector3d, arg3: Vector3d): Matrix4d;
                testPoint(arg0: double, arg1: double, arg2: double): boolean;
                testSphere(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                testAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): boolean;
                obliqueZ(arg0: double, arg1: double): Matrix4d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                withLookAtUp(arg0: Vector3dc): Matrix4d;
                withLookAtUp(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                withLookAtUp(arg0: double, arg1: double, arg2: double): Matrix4d;
                withLookAtUp(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                mapXZY(): Matrix4d;
                mapXZY(arg0: Matrix4d): Matrix4d;
                mapXZnY(): Matrix4d;
                mapXZnY(arg0: Matrix4d): Matrix4d;
                mapXnYnZ(): Matrix4d;
                mapXnYnZ(arg0: Matrix4d): Matrix4d;
                mapXnZY(): Matrix4d;
                mapXnZY(arg0: Matrix4d): Matrix4d;
                mapXnZnY(): Matrix4d;
                mapXnZnY(arg0: Matrix4d): Matrix4d;
                mapYXZ(): Matrix4d;
                mapYXZ(arg0: Matrix4d): Matrix4d;
                mapYXnZ(): Matrix4d;
                mapYXnZ(arg0: Matrix4d): Matrix4d;
                mapYZX(): Matrix4d;
                mapYZX(arg0: Matrix4d): Matrix4d;
                mapYZnX(): Matrix4d;
                mapYZnX(arg0: Matrix4d): Matrix4d;
                mapYnXZ(): Matrix4d;
                mapYnXZ(arg0: Matrix4d): Matrix4d;
                mapYnXnZ(): Matrix4d;
                mapYnXnZ(arg0: Matrix4d): Matrix4d;
                mapYnZX(): Matrix4d;
                mapYnZX(arg0: Matrix4d): Matrix4d;
                mapYnZnX(): Matrix4d;
                mapYnZnX(arg0: Matrix4d): Matrix4d;
                mapZXY(): Matrix4d;
                mapZXY(arg0: Matrix4d): Matrix4d;
                mapZXnY(): Matrix4d;
                mapZXnY(arg0: Matrix4d): Matrix4d;
                mapZYX(): Matrix4d;
                mapZYX(arg0: Matrix4d): Matrix4d;
                mapZYnX(): Matrix4d;
                mapZYnX(arg0: Matrix4d): Matrix4d;
                mapZnXY(): Matrix4d;
                mapZnXY(arg0: Matrix4d): Matrix4d;
                mapZnXnY(): Matrix4d;
                mapZnXnY(arg0: Matrix4d): Matrix4d;
                mapZnYX(): Matrix4d;
                mapZnYX(arg0: Matrix4d): Matrix4d;
                mapZnYnX(): Matrix4d;
                mapZnYnX(arg0: Matrix4d): Matrix4d;
                mapnXYnZ(): Matrix4d;
                mapnXYnZ(arg0: Matrix4d): Matrix4d;
                mapnXZY(): Matrix4d;
                mapnXZY(arg0: Matrix4d): Matrix4d;
                mapnXZnY(): Matrix4d;
                mapnXZnY(arg0: Matrix4d): Matrix4d;
                mapnXnYZ(): Matrix4d;
                mapnXnYZ(arg0: Matrix4d): Matrix4d;
                mapnXnYnZ(): Matrix4d;
                mapnXnYnZ(arg0: Matrix4d): Matrix4d;
                mapnXnZY(): Matrix4d;
                mapnXnZY(arg0: Matrix4d): Matrix4d;
                mapnXnZnY(): Matrix4d;
                mapnXnZnY(arg0: Matrix4d): Matrix4d;
                mapnYXZ(): Matrix4d;
                mapnYXZ(arg0: Matrix4d): Matrix4d;
                mapnYXnZ(): Matrix4d;
                mapnYXnZ(arg0: Matrix4d): Matrix4d;
                mapnYZX(): Matrix4d;
                mapnYZX(arg0: Matrix4d): Matrix4d;
                mapnYZnX(): Matrix4d;
                mapnYZnX(arg0: Matrix4d): Matrix4d;
                mapnYnXZ(): Matrix4d;
                mapnYnXZ(arg0: Matrix4d): Matrix4d;
                mapnYnXnZ(): Matrix4d;
                mapnYnXnZ(arg0: Matrix4d): Matrix4d;
                mapnYnZX(): Matrix4d;
                mapnYnZX(arg0: Matrix4d): Matrix4d;
                mapnYnZnX(): Matrix4d;
                mapnYnZnX(arg0: Matrix4d): Matrix4d;
                mapnZXY(): Matrix4d;
                mapnZXY(arg0: Matrix4d): Matrix4d;
                mapnZXnY(): Matrix4d;
                mapnZXnY(arg0: Matrix4d): Matrix4d;
                mapnZYX(): Matrix4d;
                mapnZYX(arg0: Matrix4d): Matrix4d;
                mapnZYnX(): Matrix4d;
                mapnZYnX(arg0: Matrix4d): Matrix4d;
                mapnZnXY(): Matrix4d;
                mapnZnXY(arg0: Matrix4d): Matrix4d;
                mapnZnXnY(): Matrix4d;
                mapnZnXnY(arg0: Matrix4d): Matrix4d;
                mapnZnYX(): Matrix4d;
                mapnZnYX(arg0: Matrix4d): Matrix4d;
                mapnZnYnX(): Matrix4d;
                mapnZnYnX(arg0: Matrix4d): Matrix4d;
                negateX(): Matrix4d;
                negateX(arg0: Matrix4d): Matrix4d;
                negateY(): Matrix4d;
                negateY(arg0: Matrix4d): Matrix4d;
                negateZ(): Matrix4d;
                negateZ(arg0: Matrix4d): Matrix4d;
                isFinite(): boolean;
                clone(): any;

            }

            interface AxisAngle4f extends java.lang.Cloneable, java.io.Externalizable {}
            class AxisAngle4f extends java.lang.Object {
                static readonly class: JavaClass<AxisAngle4f>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: AxisAngle4f);
                constructor (arg0: Quaternionfc);
                constructor (arg0: float, arg1: float, arg2: float, arg3: float);
                constructor (arg0: float, arg1: Vector3fc);

                angle: number;
                x: number;
                y: number;
                z: number;

                set(arg0: AxisAngle4f): AxisAngle4f;
                set(arg0: AxisAngle4d): AxisAngle4f;
                set(arg0: float, arg1: float, arg2: float, arg3: float): AxisAngle4f;
                set(arg0: float, arg1: Vector3fc): AxisAngle4f;
                set(arg0: Quaternionfc): AxisAngle4f;
                set(arg0: Quaterniondc): AxisAngle4f;
                set(arg0: Matrix3fc): AxisAngle4f;
                set(arg0: Matrix3dc): AxisAngle4f;
                set(arg0: Matrix4fc): AxisAngle4f;
                set(arg0: Matrix4x3fc): AxisAngle4f;
                set(arg0: Matrix4dc): AxisAngle4f;
                get(arg0: Quaternionf): Quaternionf;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: AxisAngle4f): AxisAngle4f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                normalize(): AxisAngle4f;
                rotate(arg0: float): AxisAngle4f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                clone(): any;

            }

            interface Matrix3f extends java.lang.Cloneable, Matrix3fc, java.io.Externalizable {}
            class Matrix3f extends java.lang.Object {
                static readonly class: JavaClass<Matrix3f>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Matrix2fc);
                constructor (arg0: Matrix3fc);
                constructor (arg0: Matrix4fc);
                constructor (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float);
                constructor (arg0: java.nio.FloatBuffer);
                constructor (arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc);

                m00: number;
                m01: number;
                m02: number;
                m10: number;
                m11: number;
                m12: number;
                m20: number;
                m21: number;
                m22: number;

                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m00(arg0: float): Matrix3f;
                m01(arg0: float): Matrix3f;
                m02(arg0: float): Matrix3f;
                m10(arg0: float): Matrix3f;
                m11(arg0: float): Matrix3f;
                m12(arg0: float): Matrix3f;
                m20(arg0: float): Matrix3f;
                m21(arg0: float): Matrix3f;
                m22(arg0: float): Matrix3f;
                set(arg0: Matrix3fc): Matrix3f;
                setTransposed(arg0: Matrix3fc): Matrix3f;
                set(arg0: Matrix4x3fc): Matrix3f;
                set(arg0: Matrix4fc): Matrix3f;
                set(arg0: Matrix2fc): Matrix3f;
                set(arg0: AxisAngle4f): Matrix3f;
                set(arg0: AxisAngle4d): Matrix3f;
                set(arg0: Quaternionfc): Matrix3f;
                set(arg0: Quaterniondc): Matrix3f;
                mul(arg0: Matrix3fc): Matrix3f;
                mul(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                mulLocal(arg0: Matrix3fc): Matrix3f;
                mulLocal(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                set(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix3f;
                set(arg0: float[]): Matrix3f;
                set(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix3f;
                determinant(): number;
                invert(): Matrix3f;
                invert(arg0: Matrix3f): Matrix3f;
                transpose(): Matrix3f;
                transpose(arg0: Matrix3f): Matrix3f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4f): Matrix4f;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                set(arg0: java.nio.FloatBuffer): Matrix3f;
                set(arg0: java.nio.ByteBuffer): Matrix3f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix3f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix3f;
                setFromAddress(arg0: long): Matrix3f;
                zero(): Matrix3f;
                identity(): Matrix3f;
                scale(arg0: Vector3fc, arg1: Matrix3f): Matrix3f;
                scale(arg0: Vector3fc): Matrix3f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                scale(arg0: float, arg1: float, arg2: float): Matrix3f;
                scale(arg0: float, arg1: Matrix3f): Matrix3f;
                scale(arg0: float): Matrix3f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                scaleLocal(arg0: float, arg1: float, arg2: float): Matrix3f;
                scaling(arg0: float): Matrix3f;
                scaling(arg0: float, arg1: float, arg2: float): Matrix3f;
                scaling(arg0: Vector3fc): Matrix3f;
                rotation(arg0: float, arg1: Vector3fc): Matrix3f;
                rotation(arg0: AxisAngle4f): Matrix3f;
                rotation(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3f;
                rotationX(arg0: float): Matrix3f;
                rotationY(arg0: float): Matrix3f;
                rotationZ(arg0: float): Matrix3f;
                rotationXYZ(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotationZYX(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotationYXZ(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotation(arg0: Quaternionfc): Matrix3f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformTranspose(arg0: Vector3f): Vector3f;
                transformTranspose(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformTranspose(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotateX(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateX(arg0: float): Matrix3f;
                rotateY(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateY(arg0: float): Matrix3f;
                rotateZ(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateZ(arg0: float): Matrix3f;
                rotateXYZ(arg0: Vector3f): Matrix3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotateZYX(arg0: Vector3f): Matrix3f;
                rotateZYX(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotateYXZ(arg0: Vector3f): Matrix3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3f): Matrix3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3f): Matrix3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3f;
                rotateLocalX(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalX(arg0: float): Matrix3f;
                rotateLocalY(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalY(arg0: float): Matrix3f;
                rotateLocalZ(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalZ(arg0: float): Matrix3f;
                rotate(arg0: Quaternionfc): Matrix3f;
                rotate(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                rotateLocal(arg0: Quaternionfc): Matrix3f;
                rotate(arg0: AxisAngle4f): Matrix3f;
                rotate(arg0: AxisAngle4f, arg1: Matrix3f): Matrix3f;
                rotate(arg0: float, arg1: Vector3fc): Matrix3f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix3f): Matrix3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3f;
                setLookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix3f;
                setLookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3f;
                getRow(arg0: int, arg1: Vector3f): Vector3f;
                setRow(arg0: int, arg1: Vector3fc): Matrix3f;
                setRow(arg0: int, arg1: float, arg2: float, arg3: float): Matrix3f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                setColumn(arg0: int, arg1: Vector3fc): Matrix3f;
                setColumn(arg0: int, arg1: float, arg2: float, arg3: float): Matrix3f;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: float): Matrix3f;
                getRowColumn(arg0: int, arg1: int): number;
                setRowColumn(arg0: int, arg1: int, arg2: float): Matrix3f;
                normal(): Matrix3f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor(): Matrix3f;
                cofactor(arg0: Matrix3f): Matrix3f;
                getScale(arg0: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                equals(arg0: Matrix3fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                swap(arg0: Matrix3f): Matrix3f;
                add(arg0: Matrix3fc): Matrix3f;
                add(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                sub(arg0: Matrix3fc): Matrix3f;
                sub(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                mulComponentWise(arg0: Matrix3fc): Matrix3f;
                mulComponentWise(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                setSkewSymmetric(arg0: float, arg1: float, arg2: float): Matrix3f;
                lerp(arg0: Matrix3fc, arg1: float): Matrix3f;
                lerp(arg0: Matrix3fc, arg1: float, arg2: Matrix3f): Matrix3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix3f): Matrix3f;
                rotationTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix3f;
                rotationTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                obliqueZ(arg0: float, arg1: float): Matrix3f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix3f): Matrix3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                reflect(arg0: float, arg1: float, arg2: float): Matrix3f;
                reflect(arg0: Vector3fc): Matrix3f;
                reflect(arg0: Quaternionfc): Matrix3f;
                reflect(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                reflect(arg0: Vector3fc, arg1: Matrix3f): Matrix3f;
                reflection(arg0: float, arg1: float, arg2: float): Matrix3f;
                reflection(arg0: Vector3fc): Matrix3f;
                reflection(arg0: Quaternionfc): Matrix3f;
                isFinite(): boolean;
                quadraticFormProduct(arg0: float, arg1: float, arg2: float): number;
                quadraticFormProduct(arg0: Vector3fc): number;
                mapXZY(): Matrix3f;
                mapXZY(arg0: Matrix3f): Matrix3f;
                mapXZnY(): Matrix3f;
                mapXZnY(arg0: Matrix3f): Matrix3f;
                mapXnYnZ(): Matrix3f;
                mapXnYnZ(arg0: Matrix3f): Matrix3f;
                mapXnZY(): Matrix3f;
                mapXnZY(arg0: Matrix3f): Matrix3f;
                mapXnZnY(): Matrix3f;
                mapXnZnY(arg0: Matrix3f): Matrix3f;
                mapYXZ(): Matrix3f;
                mapYXZ(arg0: Matrix3f): Matrix3f;
                mapYXnZ(): Matrix3f;
                mapYXnZ(arg0: Matrix3f): Matrix3f;
                mapYZX(): Matrix3f;
                mapYZX(arg0: Matrix3f): Matrix3f;
                mapYZnX(): Matrix3f;
                mapYZnX(arg0: Matrix3f): Matrix3f;
                mapYnXZ(): Matrix3f;
                mapYnXZ(arg0: Matrix3f): Matrix3f;
                mapYnXnZ(): Matrix3f;
                mapYnXnZ(arg0: Matrix3f): Matrix3f;
                mapYnZX(): Matrix3f;
                mapYnZX(arg0: Matrix3f): Matrix3f;
                mapYnZnX(): Matrix3f;
                mapYnZnX(arg0: Matrix3f): Matrix3f;
                mapZXY(): Matrix3f;
                mapZXY(arg0: Matrix3f): Matrix3f;
                mapZXnY(): Matrix3f;
                mapZXnY(arg0: Matrix3f): Matrix3f;
                mapZYX(): Matrix3f;
                mapZYX(arg0: Matrix3f): Matrix3f;
                mapZYnX(): Matrix3f;
                mapZYnX(arg0: Matrix3f): Matrix3f;
                mapZnXY(): Matrix3f;
                mapZnXY(arg0: Matrix3f): Matrix3f;
                mapZnXnY(): Matrix3f;
                mapZnXnY(arg0: Matrix3f): Matrix3f;
                mapZnYX(): Matrix3f;
                mapZnYX(arg0: Matrix3f): Matrix3f;
                mapZnYnX(): Matrix3f;
                mapZnYnX(arg0: Matrix3f): Matrix3f;
                mapnXYnZ(): Matrix3f;
                mapnXYnZ(arg0: Matrix3f): Matrix3f;
                mapnXZY(): Matrix3f;
                mapnXZY(arg0: Matrix3f): Matrix3f;
                mapnXZnY(): Matrix3f;
                mapnXZnY(arg0: Matrix3f): Matrix3f;
                mapnXnYZ(): Matrix3f;
                mapnXnYZ(arg0: Matrix3f): Matrix3f;
                mapnXnYnZ(): Matrix3f;
                mapnXnYnZ(arg0: Matrix3f): Matrix3f;
                mapnXnZY(): Matrix3f;
                mapnXnZY(arg0: Matrix3f): Matrix3f;
                mapnXnZnY(): Matrix3f;
                mapnXnZnY(arg0: Matrix3f): Matrix3f;
                mapnYXZ(): Matrix3f;
                mapnYXZ(arg0: Matrix3f): Matrix3f;
                mapnYXnZ(): Matrix3f;
                mapnYXnZ(arg0: Matrix3f): Matrix3f;
                mapnYZX(): Matrix3f;
                mapnYZX(arg0: Matrix3f): Matrix3f;
                mapnYZnX(): Matrix3f;
                mapnYZnX(arg0: Matrix3f): Matrix3f;
                mapnYnXZ(): Matrix3f;
                mapnYnXZ(arg0: Matrix3f): Matrix3f;
                mapnYnXnZ(): Matrix3f;
                mapnYnXnZ(arg0: Matrix3f): Matrix3f;
                mapnYnZX(): Matrix3f;
                mapnYnZX(arg0: Matrix3f): Matrix3f;
                mapnYnZnX(): Matrix3f;
                mapnYnZnX(arg0: Matrix3f): Matrix3f;
                mapnZXY(): Matrix3f;
                mapnZXY(arg0: Matrix3f): Matrix3f;
                mapnZXnY(): Matrix3f;
                mapnZXnY(arg0: Matrix3f): Matrix3f;
                mapnZYX(): Matrix3f;
                mapnZYX(arg0: Matrix3f): Matrix3f;
                mapnZYnX(): Matrix3f;
                mapnZYnX(arg0: Matrix3f): Matrix3f;
                mapnZnXY(): Matrix3f;
                mapnZnXY(arg0: Matrix3f): Matrix3f;
                mapnZnXnY(): Matrix3f;
                mapnZnXnY(arg0: Matrix3f): Matrix3f;
                mapnZnYX(): Matrix3f;
                mapnZnYX(arg0: Matrix3f): Matrix3f;
                mapnZnYnX(): Matrix3f;
                mapnZnYnX(arg0: Matrix3f): Matrix3f;
                negateX(): Matrix3f;
                negateX(arg0: Matrix3f): Matrix3f;
                negateY(): Matrix3f;
                negateY(arg0: Matrix3f): Matrix3f;
                negateZ(): Matrix3f;
                negateZ(arg0: Matrix3f): Matrix3f;
                clone(): any;

            }

            abstract class Vector4dc extends java.lang.Interface {
                static readonly class: JavaClass<Vector4dc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Vector4dc {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getf(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getf(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4dc;
                sub(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                sub(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                sub(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                add(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                add(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                add(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                fma(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                fma(arg0: double, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mul(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                div(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4x3dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4x3fc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4fc, arg1: Vector4d): Vector4d;
                mulTranspose(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulAffine(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulAffineTranspose(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulProject(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulProject(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulAdd(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mulAdd(arg0: double, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mul(arg0: double, arg1: Vector4d): Vector4d;
                div(arg0: double, arg1: Vector4d): Vector4d;
                rotate(arg0: Quaterniondc, arg1: Vector4d): Vector4d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                rotateX(arg0: double, arg1: Vector4d): Vector4d;
                rotateY(arg0: double, arg1: Vector4d): Vector4d;
                rotateZ(arg0: double, arg1: Vector4d): Vector4d;
                lengthSquared(): number;
                length(): number;
                normalize(arg0: Vector4d): Vector4d;
                normalize(arg0: double, arg1: Vector4d): Vector4d;
                normalize3(arg0: Vector4d): Vector4d;
                distance(arg0: Vector4dc): number;
                distance(arg0: double, arg1: double, arg2: double, arg3: double): number;
                distanceSquared(arg0: Vector4dc): number;
                distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double): number;
                dot(arg0: Vector4dc): number;
                dot(arg0: double, arg1: double, arg2: double, arg3: double): number;
                angleCos(arg0: Vector4dc): number;
                angle(arg0: Vector4dc): number;
                negate(arg0: Vector4d): Vector4d;
                min(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                max(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                smoothStep(arg0: Vector4dc, arg1: double, arg2: Vector4d): Vector4d;
                hermite(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4dc, arg3: double, arg4: Vector4d): Vector4d;
                lerp(arg0: Vector4dc, arg1: double, arg2: Vector4d): Vector4d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector4i): Vector4i;
                get(arg0: Vector4f): Vector4f;
                get(arg0: Vector4d): Vector4d;
                maxComponent(): number;
                minComponent(): number;
                floor(arg0: Vector4d): Vector4d;
                ceil(arg0: Vector4d): Vector4d;
                round(arg0: Vector4d): Vector4d;
                isFinite(): boolean;
                absolute(arg0: Vector4d): Vector4d;
                equals(arg0: Vector4dc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double, arg3: double): boolean;

            }

            interface Vector4d extends java.lang.Cloneable, java.io.Externalizable, Vector4dc {}
            class Vector4d extends java.lang.Object {
                static readonly class: JavaClass<Vector4d>;
                /** @deprecated */ static prototype: undefined;

                static lengthSquared(arg0: double, arg1: double, arg2: double, arg3: double): number;
                static length(arg0: double, arg1: double, arg2: double, arg3: double): number;
                static distance(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): number;
                static distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): number;

                constructor ();
                constructor (arg0: Vector4dc);
                constructor (arg0: Vector4ic);
                constructor (arg0: Vector3dc, arg1: double);
                constructor (arg0: Vector3ic, arg1: double);
                constructor (arg0: Vector2dc, arg1: double, arg2: double);
                constructor (arg0: Vector2ic, arg1: double, arg2: double);
                constructor (arg0: double);
                constructor (arg0: Vector4fc);
                constructor (arg0: Vector3fc, arg1: double);
                constructor (arg0: Vector2fc, arg1: double, arg2: double);
                constructor (arg0: double, arg1: double, arg2: double, arg3: double);
                constructor (arg0: float[]);
                constructor (arg0: double[]);
                constructor (arg0: java.nio.ByteBuffer);
                constructor (arg0: int, arg1: java.nio.ByteBuffer);
                constructor (arg0: java.nio.DoubleBuffer);
                constructor (arg0: int, arg1: java.nio.DoubleBuffer);

                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                set(arg0: Vector4dc): Vector4d;
                set(arg0: Vector4fc): Vector4d;
                set(arg0: Vector4ic): Vector4d;
                set(arg0: Vector3dc, arg1: double): Vector4d;
                set(arg0: Vector3ic, arg1: double): Vector4d;
                set(arg0: Vector3fc, arg1: double): Vector4d;
                set(arg0: Vector2dc, arg1: double, arg2: double): Vector4d;
                set(arg0: Vector2ic, arg1: double, arg2: double): Vector4d;
                set(arg0: double): Vector4d;
                set(arg0: Vector2fc, arg1: double, arg2: double): Vector4d;
                set(arg0: double, arg1: double, arg2: double, arg3: double): Vector4d;
                set(arg0: double, arg1: double, arg2: double): Vector4d;
                set(arg0: double[]): Vector4d;
                set(arg0: float[]): Vector4d;
                set(arg0: java.nio.ByteBuffer): Vector4d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector4d;
                set(arg0: java.nio.DoubleBuffer): Vector4d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Vector4d;
                setFromAddress(arg0: long): Vector4d;
                setComponent(arg0: int, arg1: double): Vector4d;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getf(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getf(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getToAddress(arg0: long): Vector4dc;
                sub(arg0: Vector4dc): Vector4d;
                sub(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                sub(arg0: Vector4fc): Vector4d;
                sub(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                sub(arg0: double, arg1: double, arg2: double, arg3: double): Vector4d;
                sub(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                add(arg0: Vector4dc): Vector4d;
                add(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                add(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                add(arg0: double, arg1: double, arg2: double, arg3: double): Vector4d;
                add(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                add(arg0: Vector4fc): Vector4d;
                fma(arg0: Vector4dc, arg1: Vector4dc): Vector4d;
                fma(arg0: double, arg1: Vector4dc): Vector4d;
                fma(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                fma(arg0: double, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mulAdd(arg0: Vector4dc, arg1: Vector4dc): Vector4d;
                mulAdd(arg0: double, arg1: Vector4dc): Vector4d;
                mulAdd(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mulAdd(arg0: double, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mul(arg0: Vector4dc): Vector4d;
                mul(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                div(arg0: Vector4dc): Vector4d;
                div(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Vector4fc): Vector4d;
                mul(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4dc): Vector4d;
                mul(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulTranspose(arg0: Matrix4dc): Vector4d;
                mulTranspose(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulAffine(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulAffineTranspose(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4x3dc): Vector4d;
                mul(arg0: Matrix4x3dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4x3fc): Vector4d;
                mul(arg0: Matrix4x3fc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4fc): Vector4d;
                mul(arg0: Matrix4fc, arg1: Vector4d): Vector4d;
                mulProject(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulProject(arg0: Matrix4dc): Vector4d;
                mulProject(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mul(arg0: double): Vector4d;
                mul(arg0: double, arg1: Vector4d): Vector4d;
                div(arg0: double): Vector4d;
                div(arg0: double, arg1: Vector4d): Vector4d;
                rotate(arg0: Quaterniondc): Vector4d;
                rotate(arg0: Quaterniondc, arg1: Vector4d): Vector4d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double): Vector4d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                rotateX(arg0: double): Vector4d;
                rotateX(arg0: double, arg1: Vector4d): Vector4d;
                rotateY(arg0: double): Vector4d;
                rotateY(arg0: double, arg1: Vector4d): Vector4d;
                rotateZ(arg0: double): Vector4d;
                rotateZ(arg0: double, arg1: Vector4d): Vector4d;
                lengthSquared(): number;
                length(): number;
                normalize(): Vector4d;
                normalize(arg0: Vector4d): Vector4d;
                normalize(arg0: double): Vector4d;
                normalize(arg0: double, arg1: Vector4d): Vector4d;
                normalize3(): Vector4d;
                normalize3(arg0: Vector4d): Vector4d;
                distance(arg0: Vector4dc): number;
                distance(arg0: double, arg1: double, arg2: double, arg3: double): number;
                distanceSquared(arg0: Vector4dc): number;
                distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double): number;
                dot(arg0: Vector4dc): number;
                dot(arg0: double, arg1: double, arg2: double, arg3: double): number;
                angleCos(arg0: Vector4dc): number;
                angle(arg0: Vector4dc): number;
                zero(): Vector4d;
                negate(): Vector4d;
                negate(arg0: Vector4d): Vector4d;
                min(arg0: Vector4dc): Vector4d;
                min(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                max(arg0: Vector4dc): Vector4d;
                max(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                equals(arg0: Vector4dc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                equals(arg0: any): boolean;
                smoothStep(arg0: Vector4dc, arg1: double, arg2: Vector4d): Vector4d;
                hermite(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4dc, arg3: double, arg4: Vector4d): Vector4d;
                lerp(arg0: Vector4dc, arg1: double): Vector4d;
                lerp(arg0: Vector4dc, arg1: double, arg2: Vector4d): Vector4d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector4i): Vector4i;
                get(arg0: Vector4f): Vector4f;
                get(arg0: Vector4d): Vector4d;
                maxComponent(): number;
                minComponent(): number;
                floor(): Vector4d;
                floor(arg0: Vector4d): Vector4d;
                ceil(): Vector4d;
                ceil(arg0: Vector4d): Vector4d;
                round(): Vector4d;
                round(arg0: Vector4d): Vector4d;
                isFinite(): boolean;
                absolute(): Vector4d;
                absolute(arg0: Vector4d): Vector4d;
                clone(): any;

            }

            abstract class Quaterniondc extends java.lang.Interface {
                static readonly class: JavaClass<Quaterniondc>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Quaterniondc {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                normalize(arg0: Quaterniond): Quaterniond;
                add(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                add(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                dot(arg0: Quaterniondc): number;
                angle(): number;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: AxisAngle4f): AxisAngle4f;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Quaternionf): Quaternionf;
                mul(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                mul(arg0: double, arg1: Quaterniond): Quaterniond;
                premul(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                premul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                transform(arg0: Vector3d): Vector3d;
                transformInverse(arg0: Vector3d): Vector3d;
                transformUnit(arg0: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector4d): Vector4d;
                transformUnitPositiveX(arg0: Vector3d): Vector3d;
                transformUnitPositiveX(arg0: Vector4d): Vector4d;
                transformPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector3d): Vector3d;
                transformUnitPositiveY(arg0: Vector4d): Vector4d;
                transformPositiveZ(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector3d): Vector3d;
                transformUnitPositiveZ(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4d): Vector4d;
                transformInverse(arg0: Vector4d): Vector4d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverse(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverse(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transform(arg0: Vector3f): Vector3f;
                transformInverse(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4d): Vector4d;
                transformUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformUnit(arg0: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector4f): Vector4f;
                transformUnitPositiveX(arg0: Vector3f): Vector3f;
                transformUnitPositiveX(arg0: Vector4f): Vector4f;
                transformPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector3f): Vector3f;
                transformUnitPositiveY(arg0: Vector4f): Vector4f;
                transformPositiveZ(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector3f): Vector3f;
                transformUnitPositiveZ(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4f): Vector4f;
                transformInverse(arg0: Vector4f): Vector4f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverse(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverse(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4f): Vector4f;
                transformUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                invert(arg0: Quaterniond): Quaterniond;
                div(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                conjugate(arg0: Quaterniond): Quaterniond;
                lengthSquared(): number;
                slerp(arg0: Quaterniondc, arg1: double, arg2: Quaterniond): Quaterniond;
                scale(arg0: double, arg1: Quaterniond): Quaterniond;
                integrate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                nlerp(arg0: Quaterniondc, arg1: double, arg2: Quaterniond): Quaterniond;
                nlerpIterative(arg0: Quaterniondc, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Quaterniond): Quaterniond;
                difference(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                rotateTo(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Quaterniond): Quaterniond;
                rotateTo(arg0: Vector3dc, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                rotateX(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateY(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateZ(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalX(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalY(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalZ(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesZXY(arg0: Vector3d): Vector3d;
                getEulerAnglesYXZ(arg0: Vector3d): Vector3d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                conjugateBy(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                isFinite(): boolean;
                equals(arg0: Quaterniondc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double, arg3: double): boolean;

            }

            interface Vector2d extends java.lang.Cloneable, Vector2dc, java.io.Externalizable {}
            class Vector2d extends java.lang.Object {
                static readonly class: JavaClass<Vector2d>;
                /** @deprecated */ static prototype: undefined;

                static lengthSquared(arg0: double, arg1: double): number;
                static length(arg0: double, arg1: double): number;
                static distance(arg0: double, arg1: double, arg2: double, arg3: double): number;
                static distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double): number;

                constructor ();
                constructor (arg0: double);
                constructor (arg0: double, arg1: double);
                constructor (arg0: Vector2dc);
                constructor (arg0: Vector2fc);
                constructor (arg0: Vector2ic);
                constructor (arg0: double[]);
                constructor (arg0: float[]);
                constructor (arg0: java.nio.ByteBuffer);
                constructor (arg0: int, arg1: java.nio.ByteBuffer);
                constructor (arg0: java.nio.DoubleBuffer);
                constructor (arg0: int, arg1: java.nio.DoubleBuffer);

                x: number;
                y: number;

                x(): number;
                y(): number;
                set(arg0: double): Vector2d;
                set(arg0: double, arg1: double): Vector2d;
                set(arg0: Vector2dc): Vector2d;
                set(arg0: Vector2fc): Vector2d;
                set(arg0: Vector2ic): Vector2d;
                set(arg0: double[]): Vector2d;
                set(arg0: float[]): Vector2d;
                set(arg0: java.nio.ByteBuffer): Vector2d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector2d;
                set(arg0: java.nio.DoubleBuffer): Vector2d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Vector2d;
                setFromAddress(arg0: long): Vector2d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector2i): Vector2i;
                get(arg0: Vector2f): Vector2f;
                get(arg0: Vector2d): Vector2d;
                setComponent(arg0: int, arg1: double): Vector2d;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getToAddress(arg0: long): Vector2dc;
                perpendicular(): Vector2d;
                sub(arg0: Vector2dc): Vector2d;
                sub(arg0: double, arg1: double): Vector2d;
                sub(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                sub(arg0: Vector2fc): Vector2d;
                sub(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                sub(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                mul(arg0: double): Vector2d;
                mul(arg0: double, arg1: Vector2d): Vector2d;
                mul(arg0: double, arg1: double): Vector2d;
                mul(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                mul(arg0: Vector2dc): Vector2d;
                mul(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                div(arg0: double): Vector2d;
                div(arg0: double, arg1: Vector2d): Vector2d;
                div(arg0: double, arg1: double): Vector2d;
                div(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                div(arg0: Vector2d): Vector2d;
                div(arg0: Vector2fc): Vector2d;
                div(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                div(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                mul(arg0: Matrix2fc): Vector2d;
                mul(arg0: Matrix2dc): Vector2d;
                mul(arg0: Matrix2dc, arg1: Vector2d): Vector2d;
                mul(arg0: Matrix2fc, arg1: Vector2d): Vector2d;
                mulTranspose(arg0: Matrix2dc): Vector2d;
                mulTranspose(arg0: Matrix2dc, arg1: Vector2d): Vector2d;
                mulTranspose(arg0: Matrix2fc): Vector2d;
                mulTranspose(arg0: Matrix2fc, arg1: Vector2d): Vector2d;
                mulPosition(arg0: Matrix3x2dc): Vector2d;
                mulPosition(arg0: Matrix3x2dc, arg1: Vector2d): Vector2d;
                mulDirection(arg0: Matrix3x2dc): Vector2d;
                mulDirection(arg0: Matrix3x2dc, arg1: Vector2d): Vector2d;
                dot(arg0: Vector2dc): number;
                angle(arg0: Vector2dc): number;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2dc): number;
                distanceSquared(arg0: Vector2dc): number;
                distance(arg0: Vector2fc): number;
                distanceSquared(arg0: Vector2fc): number;
                distance(arg0: double, arg1: double): number;
                distanceSquared(arg0: double, arg1: double): number;
                normalize(): Vector2d;
                normalize(arg0: Vector2d): Vector2d;
                normalize(arg0: double): Vector2d;
                normalize(arg0: double, arg1: Vector2d): Vector2d;
                add(arg0: Vector2dc): Vector2d;
                add(arg0: double, arg1: double): Vector2d;
                add(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                add(arg0: Vector2fc): Vector2d;
                add(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                add(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                zero(): Vector2d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector2d;
                negate(arg0: Vector2d): Vector2d;
                lerp(arg0: Vector2dc, arg1: double): Vector2d;
                lerp(arg0: Vector2dc, arg1: double, arg2: Vector2d): Vector2d;
                equals(arg0: Vector2dc, arg1: double): boolean;
                equals(arg0: double, arg1: double): boolean;
                equals(arg0: any): boolean;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                fma(arg0: Vector2dc, arg1: Vector2dc): Vector2d;
                fma(arg0: double, arg1: Vector2dc): Vector2d;
                fma(arg0: Vector2dc, arg1: Vector2dc, arg2: Vector2d): Vector2d;
                fma(arg0: double, arg1: Vector2dc, arg2: Vector2d): Vector2d;
                min(arg0: Vector2dc): Vector2d;
                min(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                max(arg0: Vector2dc): Vector2d;
                max(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                maxComponent(): number;
                minComponent(): number;
                floor(): Vector2d;
                floor(arg0: Vector2d): Vector2d;
                ceil(): Vector2d;
                ceil(arg0: Vector2d): Vector2d;
                round(): Vector2d;
                round(arg0: Vector2d): Vector2d;
                isFinite(): boolean;
                absolute(): Vector2d;
                absolute(arg0: Vector2d): Vector2d;
                clone(): any;

            }

            abstract class Vector4ic extends java.lang.Interface {
                static readonly class: JavaClass<Vector4ic>;
                /** @deprecated */ static prototype: undefined;
            }
            interface Vector4ic {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4ic;
                sub(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                sub(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Vector4i): Vector4i;
                add(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                add(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Vector4i): Vector4i;
                mul(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                div(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                mul(arg0: int, arg1: Vector4i): Vector4i;
                div(arg0: float, arg1: Vector4i): Vector4i;
                div(arg0: int, arg1: Vector4i): Vector4i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector4ic): number;
                distance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                gridDistance(arg0: Vector4ic): number;
                gridDistance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                distanceSquared(arg0: Vector4ic): number;
                distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;
                dot(arg0: Vector4ic): number;
                negate(arg0: Vector4i): Vector4i;
                min(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                max(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                get(arg0: int): number;
                maxComponent(): number;
                minComponent(): number;
                absolute(arg0: Vector4i): Vector4i;
                equals(arg0: int, arg1: int, arg2: int, arg3: int): boolean;

            }

            interface Matrix3x2d extends Matrix3x2dc, java.lang.Cloneable, java.io.Externalizable {}
            class Matrix3x2d extends java.lang.Object {
                static readonly class: JavaClass<Matrix3x2d>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Matrix2dc);
                constructor (arg0: Matrix2fc);
                constructor (arg0: Matrix3x2dc);
                constructor (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double);
                constructor (arg0: java.nio.DoubleBuffer);

                m00: number;
                m01: number;
                m10: number;
                m11: number;
                m20: number;
                m21: number;

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m20(): number;
                m21(): number;
                set(arg0: Matrix3x2dc): Matrix3x2d;
                set(arg0: Matrix2dc): Matrix3x2d;
                set(arg0: Matrix2fc): Matrix3x2d;
                mul(arg0: Matrix3x2dc): Matrix3x2d;
                mul(arg0: Matrix3x2dc, arg1: Matrix3x2d): Matrix3x2d;
                mulLocal(arg0: Matrix3x2dc): Matrix3x2d;
                mulLocal(arg0: Matrix3x2dc, arg1: Matrix3x2d): Matrix3x2d;
                set(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3x2d;
                set(arg0: double[]): Matrix3x2d;
                determinant(): number;
                invert(): Matrix3x2d;
                invert(arg0: Matrix3x2d): Matrix3x2d;
                translation(arg0: double, arg1: double): Matrix3x2d;
                translation(arg0: Vector2dc): Matrix3x2d;
                setTranslation(arg0: double, arg1: double): Matrix3x2d;
                setTranslation(arg0: Vector2dc): Matrix3x2d;
                translate(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                translate(arg0: double, arg1: double): Matrix3x2d;
                translate(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                translate(arg0: Vector2dc): Matrix3x2d;
                translateLocal(arg0: Vector2dc): Matrix3x2d;
                translateLocal(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                translateLocal(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                translateLocal(arg0: double, arg1: double): Matrix3x2d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix3x2d): Matrix3x2d;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get3x3(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get3x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3x2dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get3x3(arg0: double[], arg1: int): JavaArray<number>;
                get3x3(arg0: double[]): JavaArray<number>;
                get4x4(arg0: double[], arg1: int): JavaArray<number>;
                get4x4(arg0: double[]): JavaArray<number>;
                set(arg0: java.nio.DoubleBuffer): Matrix3x2d;
                set(arg0: java.nio.ByteBuffer): Matrix3x2d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix3x2d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix3x2d;
                setFromAddress(arg0: long): Matrix3x2d;
                zero(): Matrix3x2d;
                identity(): Matrix3x2d;
                scale(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                scale(arg0: double, arg1: double): Matrix3x2d;
                scale(arg0: Vector2dc): Matrix3x2d;
                scale(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                scale(arg0: Vector2fc): Matrix3x2d;
                scale(arg0: Vector2fc, arg1: Matrix3x2d): Matrix3x2d;
                scale(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                scale(arg0: double): Matrix3x2d;
                scaleLocal(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                scaleLocal(arg0: double, arg1: double): Matrix3x2d;
                scaleLocal(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                scaleLocal(arg0: double): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double): Matrix3x2d;
                scaling(arg0: double): Matrix3x2d;
                scaling(arg0: double, arg1: double): Matrix3x2d;
                rotation(arg0: double): Matrix3x2d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformPosition(arg0: Vector2d): Vector2d;
                transformPosition(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformPosition(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                transformDirection(arg0: Vector2d): Vector2d;
                transformDirection(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformDirection(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotate(arg0: double): Matrix3x2d;
                rotate(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                rotateLocal(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                rotateLocal(arg0: double): Matrix3x2d;
                rotateAbout(arg0: double, arg1: double, arg2: double): Matrix3x2d;
                rotateAbout(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                rotateTo(arg0: Vector2dc, arg1: Vector2dc, arg2: Matrix3x2d): Matrix3x2d;
                rotateTo(arg0: Vector2dc, arg1: Vector2dc): Matrix3x2d;
                view(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                view(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3x2d;
                setView(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3x2d;
                origin(arg0: Vector2d): Vector2d;
                viewArea(arg0: double[]): JavaArray<number>;
                positiveX(arg0: Vector2d): Vector2d;
                normalizedPositiveX(arg0: Vector2d): Vector2d;
                positiveY(arg0: Vector2d): Vector2d;
                normalizedPositiveY(arg0: Vector2d): Vector2d;
                unproject(arg0: double, arg1: double, arg2: int[], arg3: Vector2d): Vector2d;
                unprojectInv(arg0: double, arg1: double, arg2: int[], arg3: Vector2d): Vector2d;
                span(arg0: Vector2d, arg1: Vector2d, arg2: Vector2d): Matrix3x2d;
                testPoint(arg0: double, arg1: double): boolean;
                testCircle(arg0: double, arg1: double, arg2: double): boolean;
                testAar(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                equals(arg0: Matrix3x2dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                isFinite(): boolean;
                clone(): any;

            }

            interface Vector4i extends java.lang.Cloneable, Vector4ic, java.io.Externalizable {}
            class Vector4i extends java.lang.Object {
                static readonly class: JavaClass<Vector4i>;
                /** @deprecated */ static prototype: undefined;

                static lengthSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;
                static length(arg0: int, arg1: int, arg2: int, arg3: int): number;
                static distance(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int): number;
                static distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int): number;

                constructor ();
                constructor (arg0: Vector4ic);
                constructor (arg0: Vector3ic, arg1: int);
                constructor (arg0: Vector2ic, arg1: int, arg2: int);
                constructor (arg0: Vector3fc, arg1: float, arg2: int);
                constructor (arg0: Vector4fc, arg1: int);
                constructor (arg0: Vector4dc, arg1: int);
                constructor (arg0: int);
                constructor (arg0: int, arg1: int, arg2: int, arg3: int);
                constructor (arg0: int[]);
                constructor (arg0: java.nio.ByteBuffer);
                constructor (arg0: int, arg1: java.nio.ByteBuffer);
                constructor (arg0: java.nio.IntBuffer);
                constructor (arg0: int, arg1: java.nio.IntBuffer);

                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                set(arg0: Vector4ic): Vector4i;
                set(arg0: Vector4dc): Vector4i;
                set(arg0: Vector4dc, arg1: int): Vector4i;
                set(arg0: Vector4fc, arg1: int): Vector4i;
                set(arg0: Vector3ic, arg1: int): Vector4i;
                set(arg0: Vector2ic, arg1: int, arg2: int): Vector4i;
                set(arg0: int): Vector4i;
                set(arg0: int, arg1: int, arg2: int, arg3: int): Vector4i;
                set(arg0: int[]): Vector4i;
                set(arg0: java.nio.ByteBuffer): Vector4i;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector4i;
                set(arg0: java.nio.IntBuffer): Vector4i;
                set(arg0: int, arg1: java.nio.IntBuffer): Vector4i;
                setFromAddress(arg0: long): Vector4i;
                get(arg0: int): number;
                maxComponent(): number;
                minComponent(): number;
                setComponent(arg0: int, arg1: int): Vector4i;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4ic;
                sub(arg0: Vector4ic): Vector4i;
                sub(arg0: int, arg1: int, arg2: int, arg3: int): Vector4i;
                sub(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                sub(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Vector4i): Vector4i;
                add(arg0: Vector4ic): Vector4i;
                add(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                add(arg0: int, arg1: int, arg2: int, arg3: int): Vector4i;
                add(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Vector4i): Vector4i;
                mul(arg0: Vector4ic): Vector4i;
                mul(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                div(arg0: Vector4ic): Vector4i;
                div(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                mul(arg0: int): Vector4i;
                mul(arg0: int, arg1: Vector4i): Vector4i;
                div(arg0: float): Vector4i;
                div(arg0: float, arg1: Vector4i): Vector4i;
                div(arg0: int): Vector4i;
                div(arg0: int, arg1: Vector4i): Vector4i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector4ic): number;
                distance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                gridDistance(arg0: Vector4ic): number;
                gridDistance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                distanceSquared(arg0: Vector4ic): number;
                distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;
                dot(arg0: Vector4ic): number;
                zero(): Vector4i;
                negate(): Vector4i;
                negate(arg0: Vector4i): Vector4i;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                min(arg0: Vector4ic): Vector4i;
                min(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                max(arg0: Vector4ic): Vector4i;
                max(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                absolute(): Vector4i;
                absolute(arg0: Vector4i): Vector4i;
                equals(arg0: int, arg1: int, arg2: int, arg3: int): boolean;
                equals(arg0: any): boolean;
                clone(): any;

            }

            interface Matrix2d extends java.lang.Cloneable, Matrix2dc, java.io.Externalizable {}
            class Matrix2d extends java.lang.Object {
                static readonly class: JavaClass<Matrix2d>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Matrix2dc);
                constructor (arg0: Matrix2fc);
                constructor (arg0: Matrix3dc);
                constructor (arg0: Matrix3fc);
                constructor (arg0: double, arg1: double, arg2: double, arg3: double);
                constructor (arg0: java.nio.DoubleBuffer);
                constructor (arg0: Vector2dc, arg1: Vector2dc);

                m00: number;
                m01: number;
                m10: number;
                m11: number;

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m00(arg0: double): Matrix2d;
                m01(arg0: double): Matrix2d;
                m10(arg0: double): Matrix2d;
                m11(arg0: double): Matrix2d;
                set(arg0: Matrix2dc): Matrix2d;
                set(arg0: Matrix2fc): Matrix2d;
                set(arg0: Matrix3x2dc): Matrix2d;
                set(arg0: Matrix3x2fc): Matrix2d;
                set(arg0: Matrix3dc): Matrix2d;
                set(arg0: Matrix3fc): Matrix2d;
                mul(arg0: Matrix2dc): Matrix2d;
                mul(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                mul(arg0: Matrix2fc): Matrix2d;
                mul(arg0: Matrix2fc, arg1: Matrix2d): Matrix2d;
                mulLocal(arg0: Matrix2dc): Matrix2d;
                mulLocal(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                set(arg0: double, arg1: double, arg2: double, arg3: double): Matrix2d;
                set(arg0: double[]): Matrix2d;
                set(arg0: Vector2dc, arg1: Vector2dc): Matrix2d;
                determinant(): number;
                invert(): Matrix2d;
                invert(arg0: Matrix2d): Matrix2d;
                transpose(): Matrix2d;
                transpose(arg0: Matrix2d): Matrix2d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix2d): Matrix2d;
                get(arg0: Matrix3x2d): Matrix3x2d;
                get(arg0: Matrix3d): Matrix3d;
                getRotation(): number;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix2dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                set(arg0: java.nio.DoubleBuffer): Matrix2d;
                set(arg0: java.nio.ByteBuffer): Matrix2d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix2d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix2d;
                setFromAddress(arg0: long): Matrix2d;
                zero(): Matrix2d;
                identity(): Matrix2d;
                scale(arg0: Vector2dc, arg1: Matrix2d): Matrix2d;
                scale(arg0: Vector2dc): Matrix2d;
                scale(arg0: double, arg1: double, arg2: Matrix2d): Matrix2d;
                scale(arg0: double, arg1: double): Matrix2d;
                scale(arg0: double, arg1: Matrix2d): Matrix2d;
                scale(arg0: double): Matrix2d;
                scaleLocal(arg0: double, arg1: double, arg2: Matrix2d): Matrix2d;
                scaleLocal(arg0: double, arg1: double): Matrix2d;
                scaling(arg0: double): Matrix2d;
                scaling(arg0: double, arg1: double): Matrix2d;
                scaling(arg0: Vector2dc): Matrix2d;
                rotation(arg0: double): Matrix2d;
                transform(arg0: Vector2d): Vector2d;
                transform(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transform(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                transformTranspose(arg0: Vector2d): Vector2d;
                transformTranspose(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformTranspose(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotate(arg0: double): Matrix2d;
                rotate(arg0: double, arg1: Matrix2d): Matrix2d;
                rotateLocal(arg0: double): Matrix2d;
                rotateLocal(arg0: double, arg1: Matrix2d): Matrix2d;
                getRow(arg0: int, arg1: Vector2d): Vector2d;
                setRow(arg0: int, arg1: Vector2dc): Matrix2d;
                setRow(arg0: int, arg1: double, arg2: double): Matrix2d;
                getColumn(arg0: int, arg1: Vector2d): Vector2d;
                setColumn(arg0: int, arg1: Vector2dc): Matrix2d;
                setColumn(arg0: int, arg1: double, arg2: double): Matrix2d;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: double): Matrix2d;
                normal(): Matrix2d;
                normal(arg0: Matrix2d): Matrix2d;
                getScale(arg0: Vector2d): Vector2d;
                positiveX(arg0: Vector2d): Vector2d;
                normalizedPositiveX(arg0: Vector2d): Vector2d;
                positiveY(arg0: Vector2d): Vector2d;
                normalizedPositiveY(arg0: Vector2d): Vector2d;
                equals(arg0: Matrix2dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                swap(arg0: Matrix2d): Matrix2d;
                add(arg0: Matrix2dc): Matrix2d;
                add(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                sub(arg0: Matrix2dc): Matrix2d;
                sub(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                mulComponentWise(arg0: Matrix2dc): Matrix2d;
                mulComponentWise(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                lerp(arg0: Matrix2dc, arg1: double): Matrix2d;
                lerp(arg0: Matrix2dc, arg1: double, arg2: Matrix2d): Matrix2d;
                isFinite(): boolean;
                clone(): any;

            }

            interface Matrix2f extends Matrix2fc, java.lang.Cloneable, java.io.Externalizable {}
            class Matrix2f extends java.lang.Object {
                static readonly class: JavaClass<Matrix2f>;
                /** @deprecated */ static prototype: undefined;

                constructor ();
                constructor (arg0: Matrix2fc);
                constructor (arg0: Matrix3fc);
                constructor (arg0: float, arg1: float, arg2: float, arg3: float);
                constructor (arg0: java.nio.FloatBuffer);
                constructor (arg0: Vector2fc, arg1: Vector2fc);

                m00: number;
                m01: number;
                m10: number;
                m11: number;

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m00(arg0: float): Matrix2f;
                m01(arg0: float): Matrix2f;
                m10(arg0: float): Matrix2f;
                m11(arg0: float): Matrix2f;
                set(arg0: Matrix2fc): Matrix2f;
                set(arg0: Matrix3x2fc): Matrix2f;
                set(arg0: Matrix3fc): Matrix2f;
                mul(arg0: Matrix2fc): Matrix2f;
                mul(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                mulLocal(arg0: Matrix2fc): Matrix2f;
                mulLocal(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                set(arg0: float, arg1: float, arg2: float, arg3: float): Matrix2f;
                set(arg0: float[]): Matrix2f;
                set(arg0: Vector2fc, arg1: Vector2fc): Matrix2f;
                determinant(): number;
                invert(): Matrix2f;
                invert(arg0: Matrix2f): Matrix2f;
                transpose(): Matrix2f;
                transpose(arg0: Matrix2f): Matrix2f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix2f): Matrix2f;
                get(arg0: Matrix3x2f): Matrix3x2f;
                get(arg0: Matrix3f): Matrix3f;
                getRotation(): number;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix2fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                set(arg0: java.nio.FloatBuffer): Matrix2f;
                set(arg0: java.nio.ByteBuffer): Matrix2f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix2f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix2f;
                setFromAddress(arg0: long): Matrix2f;
                zero(): Matrix2f;
                identity(): Matrix2f;
                scale(arg0: Vector2fc, arg1: Matrix2f): Matrix2f;
                scale(arg0: Vector2fc): Matrix2f;
                scale(arg0: float, arg1: float, arg2: Matrix2f): Matrix2f;
                scale(arg0: float, arg1: float): Matrix2f;
                scale(arg0: float, arg1: Matrix2f): Matrix2f;
                scale(arg0: float): Matrix2f;
                scaleLocal(arg0: float, arg1: float, arg2: Matrix2f): Matrix2f;
                scaleLocal(arg0: float, arg1: float): Matrix2f;
                scaling(arg0: float): Matrix2f;
                scaling(arg0: float, arg1: float): Matrix2f;
                scaling(arg0: Vector2fc): Matrix2f;
                rotation(arg0: float): Matrix2f;
                transform(arg0: Vector2f): Vector2f;
                transform(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transform(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                transformTranspose(arg0: Vector2f): Vector2f;
                transformTranspose(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformTranspose(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotate(arg0: float): Matrix2f;
                rotate(arg0: float, arg1: Matrix2f): Matrix2f;
                rotateLocal(arg0: float): Matrix2f;
                rotateLocal(arg0: float, arg1: Matrix2f): Matrix2f;
                getRow(arg0: int, arg1: Vector2f): Vector2f;
                setRow(arg0: int, arg1: Vector2fc): Matrix2f;
                setRow(arg0: int, arg1: float, arg2: float): Matrix2f;
                getColumn(arg0: int, arg1: Vector2f): Vector2f;
                setColumn(arg0: int, arg1: Vector2fc): Matrix2f;
                setColumn(arg0: int, arg1: float, arg2: float): Matrix2f;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: float): Matrix2f;
                normal(): Matrix2f;
                normal(arg0: Matrix2f): Matrix2f;
                getScale(arg0: Vector2f): Vector2f;
                positiveX(arg0: Vector2f): Vector2f;
                normalizedPositiveX(arg0: Vector2f): Vector2f;
                positiveY(arg0: Vector2f): Vector2f;
                normalizedPositiveY(arg0: Vector2f): Vector2f;
                equals(arg0: Matrix2fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                swap(arg0: Matrix2f): Matrix2f;
                add(arg0: Matrix2fc): Matrix2f;
                add(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                sub(arg0: Matrix2fc): Matrix2f;
                sub(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                mulComponentWise(arg0: Matrix2fc): Matrix2f;
                mulComponentWise(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                lerp(arg0: Matrix2fc, arg1: float): Matrix2f;
                lerp(arg0: Matrix2fc, arg1: float, arg2: Matrix2f): Matrix2f;
                isFinite(): boolean;
                clone(): any;

            }

            export {
                Vector3f,
                Vector3fc,
                Matrix3fc,
                Vector3dc,
                Matrix4x3fc,
                Quaternionf,
                Matrix4dc,
                Vector3d,
                Matrix3x2fc,
                Vector2ic,
                Vector2fc,
                Vector3ic,
                Quaternionfc,
                Matrix3dc,
                Matrix4fc,
                Vector3i,
                Vector2dc,
                Matrix3d,
                Matrix4x3d,
                Quaterniond,
                Matrix3x2dc,
                Matrix4x3f,
                Matrix2fc,
                Matrix3x2f,
                AxisAngle4d,
                Matrix4x3dc,
                Vector4fc,
                Matrix4f,
                Matrix2dc,
                Vector2i,
                Vector4f,
                Vector2f,
                Matrix4d,
                AxisAngle4f,
                Matrix3f,
                Vector4dc,
                Vector4d,
                Quaterniondc,
                Vector2d,
                Vector4ic,
                Matrix3x2d,
                Vector4i,
                Matrix2d,
                Matrix2f
            }

        }

        namespace joor {

            abstract class Reflect extends java.lang.Object {
                static readonly class: JavaClass<Reflect>;
                /** @deprecated */ static prototype: undefined;

                static compile(arg0: string, arg1: string): Reflect;
                static compile(arg0: string, arg1: string, arg2: CompileOptions): Reflect;
                /** @deprecated */
                static on(arg0: string): Reflect;
                /** @deprecated */
                static on(arg0: string, arg1: java.lang.ClassLoader): Reflect;
                /** @deprecated */
                static on(arg0: JavaClassArg<any>): Reflect;
                static onClass(arg0: string): Reflect;
                static onClass(arg0: string, arg1: java.lang.ClassLoader): Reflect;
                static onClass(arg0: JavaClassArg<any>): Reflect;
                static on(arg0: any): Reflect;
                static initValue<T>(arg0: JavaClassArg<T>): T;
                static accessible<T extends java.lang.reflect.AccessibleObject>(arg0: T): T;
                static wrapper<T>(arg0: JavaClassArg<T>): JavaClass<T>;

                get<T>(): T;
                set(arg0: string, arg1: any): Reflect;
                get<T>(arg0: string): T;
                field(arg0: string): Reflect;
                fields(): JavaMap<string, Reflect>;
                call(arg0: string): Reflect;
                call(arg0: string, ...arg1: JavaVarArgs<any>): Reflect;
                create(): Reflect;
                create(...arg0: JavaVarArgs<any>): Reflect;
                as<P>(arg0: JavaClassArg<P>): P;
                as<P>(arg0: JavaClassArg<P>, ...arg1: JavaVarArgs<JavaClassArg<any>>): P;
                type(): JavaClass<any>;

            }

            class CompileOptions extends java.lang.Object {
                static readonly class: JavaClass<CompileOptions>;
                /** @deprecated */ static prototype: undefined;

                constructor ();

                processors(...arg0: JavaVarArgs<javax.annotation.processing.Processor>): CompileOptions;
                processors(arg0: JavaList<javax.annotation.processing.Processor>): CompileOptions;
                options(...arg0: JavaVarArgs<string>): CompileOptions;
                options(arg0: JavaList<string>): CompileOptions;

            }

            export { Reflect, CompileOptions }

        }

        namespace slf4j {

            abstract class Logger extends java.lang.Interface {
                static readonly class: JavaClass<Logger>;
                /** @deprecated */ static prototype: undefined;

                static readonly ROOT_LOGGER_NAME: string;
            }
            interface Logger {

                getName(): string;
                makeLoggingEventBuilder(arg0: org.slf4j.event.Level): org.slf4j.spi.LoggingEventBuilder;
                atLevel(arg0: org.slf4j.event.Level): org.slf4j.spi.LoggingEventBuilder;
                isEnabledForLevel(arg0: org.slf4j.event.Level): boolean;
                isTraceEnabled(): boolean;
                trace(arg0: string): void;
                trace(arg0: string, arg1: any): void;
                trace(arg0: string, arg1: any, arg2: any): void;
                trace(arg0: string, ...arg1: JavaVarArgs<any>): void;
                trace(arg0: string, arg1: java.lang.Throwable): void;
                isTraceEnabled(arg0: Marker): boolean;
                atTrace(): org.slf4j.spi.LoggingEventBuilder;
                trace(arg0: Marker, arg1: string): void;
                trace(arg0: Marker, arg1: string, arg2: any): void;
                trace(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                trace(arg0: Marker, arg1: string, ...arg2: JavaVarArgs<any>): void;
                trace(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                isDebugEnabled(): boolean;
                debug(arg0: string): void;
                debug(arg0: string, arg1: any): void;
                debug(arg0: string, arg1: any, arg2: any): void;
                debug(arg0: string, ...arg1: JavaVarArgs<any>): void;
                debug(arg0: string, arg1: java.lang.Throwable): void;
                isDebugEnabled(arg0: Marker): boolean;
                debug(arg0: Marker, arg1: string): void;
                debug(arg0: Marker, arg1: string, arg2: any): void;
                debug(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                debug(arg0: Marker, arg1: string, ...arg2: JavaVarArgs<any>): void;
                debug(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                atDebug(): org.slf4j.spi.LoggingEventBuilder;
                isInfoEnabled(): boolean;
                info(arg0: string): void;
                info(arg0: string, arg1: any): void;
                info(arg0: string, arg1: any, arg2: any): void;
                info(arg0: string, ...arg1: JavaVarArgs<any>): void;
                info(arg0: string, arg1: java.lang.Throwable): void;
                isInfoEnabled(arg0: Marker): boolean;
                info(arg0: Marker, arg1: string): void;
                info(arg0: Marker, arg1: string, arg2: any): void;
                info(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                info(arg0: Marker, arg1: string, ...arg2: JavaVarArgs<any>): void;
                info(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                atInfo(): org.slf4j.spi.LoggingEventBuilder;
                isWarnEnabled(): boolean;
                warn(arg0: string): void;
                warn(arg0: string, arg1: any): void;
                warn(arg0: string, ...arg1: JavaVarArgs<any>): void;
                warn(arg0: string, arg1: any, arg2: any): void;
                warn(arg0: string, arg1: java.lang.Throwable): void;
                isWarnEnabled(arg0: Marker): boolean;
                warn(arg0: Marker, arg1: string): void;
                warn(arg0: Marker, arg1: string, arg2: any): void;
                warn(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                warn(arg0: Marker, arg1: string, ...arg2: JavaVarArgs<any>): void;
                warn(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                atWarn(): org.slf4j.spi.LoggingEventBuilder;
                isErrorEnabled(): boolean;
                error(arg0: string): void;
                error(arg0: string, arg1: any): void;
                error(arg0: string, arg1: any, arg2: any): void;
                error(arg0: string, ...arg1: JavaVarArgs<any>): void;
                error(arg0: string, arg1: java.lang.Throwable): void;
                isErrorEnabled(arg0: Marker): boolean;
                error(arg0: Marker, arg1: string): void;
                error(arg0: Marker, arg1: string, arg2: any): void;
                error(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                error(arg0: Marker, arg1: string, ...arg2: JavaVarArgs<any>): void;
                error(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                atError(): org.slf4j.spi.LoggingEventBuilder;

            }

            abstract class Marker extends java.lang.Interface {
                static readonly class: JavaClass<Marker>;
                /** @deprecated */ static prototype: undefined;

                static readonly ANY_MARKER: string;
                static readonly ANY_NON_NULL_MARKER: string;
            }
            interface Marker extends java.io.Serializable {

                getName(): string;
                add(arg0: Marker): void;
                remove(arg0: Marker): boolean;
                /** @deprecated */
                hasChildren(): boolean;
                hasReferences(): boolean;
                iterator(): java.util.Iterator<Marker>;
                contains(arg0: Marker): boolean;
                contains(arg0: string): boolean;

            }

            export { Logger, Marker }

        }
        namespace slf4j {

            namespace event {

                abstract class Level extends java.lang.Enum<Level> {
                    static readonly class: JavaClass<Level>;
                    /** @deprecated */ static prototype: undefined;

                    static readonly ERROR: Level;
                    static readonly WARN: Level;
                    static readonly INFO: Level;
                    static readonly DEBUG: Level;
                    static readonly TRACE: Level;

                    static values(): JavaArray<Level>;
                    static valueOf(arg0: string): Level;
                    static intToLevel(arg0: int): Level;

                    toInt(): number;

                }

                export { Level }

            }

            namespace spi {

                abstract class LoggingEventBuilder extends java.lang.Interface {
                    static readonly class: JavaClass<LoggingEventBuilder>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface LoggingEventBuilder {

                    setCause(arg0: java.lang.Throwable): LoggingEventBuilder;
                    addMarker(arg0: org.slf4j.Marker): LoggingEventBuilder;
                    addArgument(arg0: any): LoggingEventBuilder;
                    addArgument(arg0: MethodWrapper<any, any, any>): LoggingEventBuilder;
                    addKeyValue(arg0: string, arg1: any): LoggingEventBuilder;
                    addKeyValue(arg0: string, arg1: MethodWrapper<any, any, any>): LoggingEventBuilder;
                    setMessage(arg0: string): LoggingEventBuilder;
                    setMessage(arg0: MethodWrapper<any, any, string>): LoggingEventBuilder;
                    log(): void;
                    log(arg0: string): void;
                    log(arg0: string, arg1: any): void;
                    log(arg0: string, arg1: any, arg2: any): void;
                    log(arg0: string, ...arg1: JavaVarArgs<any>): void;
                    log(arg0: MethodWrapper<any, any, string>): void;

                }

                export { LoggingEventBuilder }

            }

        }

    }

    namespace xyz.wagyourtail {


        /**
         * Is this even faster than just iterating through a LinkedHashSet / HashSet at this point?
         *  also should the node-length just always be 1?
         * @author Wagyourtail
         */
        interface StringHashTrie extends JavaCollection<java.lang.String> {}
        class StringHashTrie extends java.lang.Object {
            static readonly class: JavaClass<StringHashTrie>;
            /** @deprecated */ static prototype: undefined;

            constructor ();

            size(): number;
            isEmpty(): boolean;
            contains(o: any): boolean;
            iterator(): java.util.Iterator<string>;
            toArray(): JavaArray<string>;
            toArray<T>(a: T[]): JavaArray<T>;
            toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
            add(s: string): boolean;

            /**
             * this can make the StringHashTrie sparse, this can cause extra steps in lookup that are no longer needed,  
             *  at some point it would be best to rebase the StringHashTrie with `new StringHashTrie().addAll(current.getAll())`
             */
            remove(o: any): boolean;
            containsAll(c: JavaCollection<any>): boolean;
            containsAll(...o: JavaVarArgs<string>): boolean;
            addAll(c: JavaCollection<string>): boolean;
            addAll(...o: JavaVarArgs<string>): boolean;
            removeAll(c: JavaCollection<any>): boolean;
            removeAll(...o: JavaVarArgs<string>): boolean;
            retainAll(c: JavaCollection<any>): boolean;
            retainAll(...o: JavaVarArgs<string>): boolean;
            clear(): void;

            /**
             * @param prefix prefix to search with
             * @return all elements that start with the given prefix
             */
            getAllWithPrefix(prefix: string): JavaSet<string>;

            /**
             * @param prefix prefix to search with
             * @return all elements that start with the given prefix (case insensitive)
             */
            getAllWithPrefixCaseInsensitive(prefix: string): JavaSet<string>;

            /**
             * all contained elements as a {@link Set}
             */
            getAll(): JavaSet<string>;

            /**
             * @return json representation, mainly for debugging.
             */
            toString(): string;

        }

        class Pair<T, U> extends java.lang.Object {
            static readonly class: JavaClass<Pair<any, any>>;
            /** @deprecated */ static prototype: undefined;

            constructor <T, U>(t: T, u: U);

            setU(u: U): void;
            setT(t: T): void;
            getU(): U;
            getT(): T;

        }

        export { StringHashTrie, Pair }

    }
    namespace xyz.wagyourtail {

        namespace jsmacros {

            namespace client {

                namespace api {

                    namespace classes {


                        /**
                         * An object, that combines all possible player inputs
                         * @author NotSomeBot
                         * @since 1.4.0
                         */
                        class PlayerInput extends java.lang.Object {
                            static readonly class: JavaClass<PlayerInput>;
                            /** @deprecated */ static prototype: undefined;

                            /**
                             * Parses each row of CSV string into a `PlayerInput`.  
                             *  The capitalization of the header matters.<br>  
                             *  About the columns:  
                             *  <ul>  
                             *    <li> `movementForward` and `movementSideways` as a number</li>  
                             *    <li>`yaw` and `pitch` as an absolute number</li>  
                             *    <li>`jumping`, `sneaking` and `sprinting` have to be boolean</li>  
                             *  </ul>  
                             *
                             *  The separation must be a "," it's a csv...(but spaces don't matter)<br>  
                             *  Quoted values don't work
                             * @param csv CSV string to be parsed
                             * @return `List<PlayerInput>` Each row parsed as a `PlayerInput`
                             * @see PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            static fromCsv(csv: string): JavaList<PlayerInput>;

                            /**
                             * Parses a JSON string into a `PlayerInput` Object<br>  
                             *  Capitalization of the keys matters.
                             * @param json JSON string to be parsed
                             * @return The JSON parsed into a `PlayerInput`
                             * @see fromCsv(String)
                             * @since 1.4.0
                             */
                            static fromJson(json: string): PlayerInput;

                            /**
                             * Creates a new `PlayerInput` Object with all values set either to 0 or false
                             * @see PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            constructor ();

                            /**
                             * Creates a new `PlayerInput` Object with all other values set either to 0 or false
                             * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
                             * @param movementSideways 1 = left input (A); 0 = no input; -1 = right input (D)
                             * @param yaw yaw of the player
                             * @see PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            constructor (movementForward: float, movementSideways: float, yaw: float);

                            /**
                             * Creates a new `PlayerInput` Object with all other values set either to 0 or false
                             * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
                             * @param yaw yaw of the player
                             * @param jumping jump input
                             * @param sprinting sprint input
                             * @see PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            constructor (movementForward: float, yaw: float, jumping: boolean, sprinting: boolean);

                            /**
                             * Creates a new `PlayerInput` Object from a minecraft input with the missing values extra
                             * @param input Minecraft Input to be converted.
                             * @param yaw yaw of the player
                             * @param pitch pitch of the player
                             * @param sprinting sprint input
                             * @see PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            constructor (input: /* net.minecraft.client.input.Input */ any, yaw: float, pitch: float, sprinting: boolean);

                            /**
                             * Creates a new `PlayerInput` Object with all double values converted to floats
                             * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
                             * @param movementSideways 1 = left input (A); 0 = no input; -1 = right input (D)
                             * @param yaw yaw of the player
                             * @param pitch pitch of the player
                             * @param jumping jump input
                             * @param sneaking sneak input
                             * @param sprinting sprint input
                             * @see PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            constructor (movementForward: double, movementSideways: double, yaw: double, pitch: double, jumping: boolean, sneaking: boolean, sprinting: boolean);

                            /**
                             * Creates a new `PlayerInput` Object
                             * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
                             * @param movementSideways 1 = left input (A); 0 = no input; -1 = right input (D)
                             * @param yaw yaw of the player
                             * @param pitch pitch of the player
                             * @param jumping jump input
                             * @param sneaking sneak input
                             * @param sprinting sprint input
                             * @since 1.4.0
                             */
                            constructor (movementForward: float, movementSideways: float, yaw: float, pitch: float, jumping: boolean, sneaking: boolean, sprinting: boolean);

                            /**
                             * Creates a clone `PlayerInput` Object
                             * @param input the `PlayerInput` object to be cloned
                             * @since 1.4.0
                             */
                            constructor (input: PlayerInput);

                            movementForward: number;
                            movementSideways: number;
                            yaw: number;
                            pitch: number;
                            jumping: boolean;
                            sneaking: boolean;
                            sprinting: boolean;

                            /**
                             * Converts the current object into a string.  
                             *  This can be used to convert current inputs created using `Player.getCurrentPlayerInput()`
                             *  to either JSON or CSV.  
                             *
                             *  The output can be converted into a PlayerInput object again by using either
                             *  `fromCsv(String, String)` or `fromJson(String)`.
                             * @param varNames whether to include variable Names(=JSON) or not(=CSV)
                             * @return The `PlayerInput` object as a string
                             * @since 1.4.0
                             */
                            toString(varNames: boolean): string;
                            toString(): string;
                            clone(): PlayerInput;

                        }


                        /**
                         * usage: `builder.append("hello,").withColor(0xc).append(" World!").withColor(0x6)`
                         * @author Wagyourtail
                         * @since 1.3.0
                         */
                        class TextBuilder extends java.lang.Object {
                            static readonly class: JavaClass<TextBuilder>;
                            /** @deprecated */ static prototype: undefined;

                            constructor ();

                            /**
                             * move on to next section and set it's text.
                             * @param text a {@link String}, {@link TextHelper} or {@link TextBuilder}
                             * @since 1.3.0
                             */
                            append(text: any): TextBuilder;

                            /**
                             * set current section's color by color code as hex, like `0x6` for gold
                             *  and `0xc` for red.
                             * @since 1.3.0
                             */
                            withColor(color: int): TextBuilder;

                            /**
                             * Add text with custom colors.
                             * @param r red `0-255`
                             * @param g green `0-255`
                             * @param b blue `0-255`
                             * @since 1.3.1
                             */
                            withColor(r: int, g: int, b: int): TextBuilder;

                            /**
                             * set other formatting options for the current section
                             * @since 1.3.0
                             */
                            withFormatting(underline: boolean, bold: boolean, italic: boolean, strikethrough: boolean, magic: boolean): TextBuilder;

                            /**
                             * @param formattings the formattings to apply
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            withFormatting(...formattings: JavaVarArgs<xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper>): this;

                            /**
                             * set current section's hover event to show text
                             * @since 1.3.0
                             */
                            withShowTextHover(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): TextBuilder;

                            /**
                             * set current section's hover event to show an item
                             * @since 1.3.0
                             */
                            withShowItemHover(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): TextBuilder;

                            /**
                             * set current section's hover event to show an entity
                             * @since 1.3.0
                             */
                            withShowEntityHover(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.Entity */ any>): TextBuilder;

                            /**
                             * custom click event.
                             * @since 1.3.0
                             */
                            withCustomClickEvent(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): TextBuilder;

                            /**
                             * normal click events like: `open_url`, `open_file`, `run_command`, `suggest_command`, `change_page`, and `copy_to_clipboard`
                             * @since 1.3.0
                             */
                            withClickEvent(action: TextClickAction, value: string): TextBuilder;
                            withStyle(style: xyz.wagyourtail.jsmacros.client.api.helpers.StyleHelper): TextBuilder;

                            /**
                             * @return the width of this text.
                             * @since 1.8.4
                             */
                            getWidth(): number;

                            /**
                             * Build to a {@link TextHelper}
                             * @since 1.3.0
                             */
                            build(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                        }


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        class CustomImage extends java.lang.Object {
                            static readonly class: JavaClass<CustomImage>;
                            /** @deprecated */ static prototype: undefined;

                            static readonly IMAGES: JavaMap<string, CustomImage>;

                            static createWidget(width: int, height: int, name: string): CustomImage;
                            static createWidget(path: string, name: string): CustomImage | null;

                            /**
                             * Minecraft textures use an ABGR format for some reason.
                             * @param argb the argb color to transform
                             * @return the abgr argb for the given argb color.
                             * @since 1.8.4
                             */
                            static nativeARGBFlip(argb: int): number;

                            constructor (image: java.awt.image.BufferedImage);
                            constructor (image: java.awt.image.BufferedImage, name: string);

                            /**
                             * @return the name of this image.
                             * @since 1.8.4
                             */
                            getName(): string;

                            /**
                             * The image can be used with the drawImage methods to draw it onto this image.
                             * @param path the path to the image, relative to the jsMacros config folder
                             * @return an image from the given path.
                             * @see drawImage(Image, int, int, int, int)
                             * @see drawImage(Image, int, int, int, int, int, int, int, int)
                             * @since 1.8.4
                             */
                            loadImage(path: string): java.awt.image.BufferedImage | null;

                            /**
                             * Loads the image from the given path and returns a subimage of it from the given positions.  
                             *  The image can be used with the drawImage methods to draw it onto this image.
                             * @param path the path to the image, relative to the jsMacros config folder
                             * @param x the x position to get the subimage from
                             * @param y the y position to get the subimage from
                             * @param width the width of the subimage
                             * @param height the height of the subimage
                             * @return the cropped image from the given path.
                             * @see drawImage(Image, int, int, int, int)
                             * @see drawImage(Image, int, int, int, int, int, int, int, int)
                             * @since 1.8.4
                             */
                            loadImage(path: string, x: int, y: int, width: int, height: int): java.awt.image.BufferedImage;

                            /**
                             * Updates the texture to be drawn with the contents of this image. Any changes made to this
                             *  image will only be displayed after calling this method. The method must not be called after
                             *  each change, but rather when the image is finished being changed.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            update(): this;

                            /**
                             * Saves this image to the given path. The file will be saved as a png.
                             * @param path the path to the image, relative to the jsMacros config folder
                             * @param fileName the file name of the image, without the extension
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            saveImage(path: string, fileName: string): this;

                            /**
                             * The identifier should be used with any buttons and textures in the draw2D and other classes,  
                             *  which require an identifier.
                             * @return the identifier of this image.
                             * @since 1.8.4
                             */
                            getIdentifier(): string;

                            /**
                             * The width is a constant and will not change.
                             * @return the width of this image.
                             * @since 1.8.4
                             */
                            getWidth(): number;

                            /**
                             * The height is a constant and will not change.
                             * @return the height of this image.
                             * @since 1.8.4
                             */
                            getHeight(): number;

                            /**
                             * @return the internal BufferedImage of this image, which all updates are made to.
                             * @since 1.8.4
                             */
                            getImage(): java.awt.image.BufferedImage;

                            /**
                             * The color is in the ARGB format.
                             * @param x the x position to get the color from
                             * @param y the y position to get the color from
                             * @return the color at the given position.
                             * @since 1.8.4
                             */
                            getPixel(x: int, y: int): number;

                            /**
                             * The color is in the ARGB format.
                             * @param x the x position to set the color at
                             * @param y the y position to set the color at
                             * @param argb the ARGB value to set the pixel to
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setPixel(x: int, y: int, argb: int): this;

                            /**
                             * @param img the image to draw onto this image
                             * @param x the x position to draw the image at
                             * @param y the y position to draw the image at
                             * @param width the width of the image to draw
                             * @param height the height of the image to draw
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawImage(img: java.awt.Image, x: int, y: int, width: int, height: int): this;

                            /**
                             * @param img the image to draw onto this image
                             * @param x the x position to draw the image at
                             * @param y the y position to draw the image at
                             * @param width the width of the image to draw
                             * @param height the height of the image to draw
                             * @param sourceX the x position of the subimage to draw
                             * @param sourceY the y position of the subimage to draw
                             * @param sourceWidth the width of the subimage to draw
                             * @param sourceHeight the height of the subimage to draw
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawImage(img: java.awt.Image, x: int, y: int, width: int, height: int, sourceX: int, sourceY: int, sourceWidth: int, sourceHeight: int): this;

                            /**
                             * The color is a rgb value which is used for draw and fill operations.
                             * @return the graphics current rgb color.
                             * @since 1.8.4
                             */
                            getGraphicsColor(): number;

                            /**
                             * The color is a rgb value which is used for draw and fill operations.
                             * @param color the rgb color to use for graphics operations
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setGraphicsColor(color: int): this;

                            /**
                             * @param x the x position of the origin point
                             * @param y the y position of the origin point
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            translate(x: int, y: int): this;

                            /**
                             * @param x the x coordinate of the rectangle to intersect the clip with
                             * @param y the y coordinate of the rectangle to intersect the clip with
                             * @param width the width of the rectangle to intersect the clip with
                             * @param height the height of the rectangle to intersect the clip with
                             * @return self for chaining.
                             */
                            clipRect(x: int, y: int, width: int, height: int): this;

                            /**
                             * @param x the x coordinate of the new clip rectangle
                             * @param y the y coordinate of the new clip rectangle
                             * @param width the width of the new clip rectangle
                             * @param height the height of the new clip rectangle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setClip(x: int, y: int, width: int, height: int): this;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setPaintMode(): this;

                            /**
                             * @param color the color to use for the xor operation
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setXorMode(color: int): this;

                            /**
                             * @return an array with the bounds of the current clip.
                             * @since 1.8.4
                             */
                            getClipBounds(): java.awt.Rectangle;

                            /**
                             * @param x the x position to copy from
                             * @param y the y position to copy from
                             * @param width the width of the area to copy
                             * @param height the height of the area to copy
                             * @param dx the offset to the x position to copy to
                             * @param dy the offset to the y position to copy to
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            copyArea(x: int, y: int, width: int, height: int, dx: int, dy: int): this;

                            /**
                             * @param x1 the first x position of the line
                             * @param y1 the first y position of the line
                             * @param x2 the second x position of the line
                             * @param y2 the second y position of the line
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawLine(x1: int, y1: int, x2: int, y2: int): this;

                            /**
                             * @param x the x position of the rectangle
                             * @param y the y position of the rectangle
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawRect(x: int, y: int, width: int, height: int): this;

                            /**
                             * @param x the x position of the rectangle
                             * @param y the y position of the rectangle
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillRect(x: int, y: int, width: int, height: int): this;

                            /**
                             * @param x the x position of the rectangle
                             * @param y the y position of the rectangle
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            clearRect(x: int, y: int, width: int, height: int): this;

                            /**
                             * @param x the x position of the rectangle
                             * @param y the y position of the rectangle
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @param color the rgb color to fill the rectangle with
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            clearRect(x: int, y: int, width: int, height: int, color: int): this;

                            /**
                             * @param x the x position to draw the rectangle at
                             * @param y the y position to draw the rectangle at
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @param arcWidth the horizontal diameter of the arc at the four corners
                             * @param arcHeight the vertical diameter of the arc at the four corners
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawRoundRect(x: int, y: int, width: int, height: int, arcWidth: int, arcHeight: int): this;

                            /**
                             * @param x the x position to draw the rectangle at
                             * @param y the y position to draw the rectangle at
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @param arcWidth the horizontal diameter of the arc at the four corners
                             * @param arcHeight the vertical diameter of the arc at the four corners
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillRoundRect(x: int, y: int, width: int, height: int, arcWidth: int, arcHeight: int): this;

                            /**
                             * @param x the x position to draw the 3D rectangle at
                             * @param y the y position to draw the 3D rectangle at
                             * @param width the width of the 3D rectangle
                             * @param height the height of the 3D rectangle
                             * @param raised whether the rectangle should be raised above the surface or etched into the
                             *                surface
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            draw3DRect(x: int, y: int, width: int, height: int, raised: boolean): this;

                            /**
                             * @param x the x position to draw the 3D rectangle at
                             * @param y the y position to draw the 3D rectangle at
                             * @param width the width of the 3D rectangle
                             * @param height the height of the 3D rectangle
                             * @param raised whether the rectangle should be raised above the surface or etched into the
                             *                surface
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fill3DRect(x: int, y: int, width: int, height: int, raised: boolean): this;

                            /**
                             * @param x the x position to draw the oval at
                             * @param y the y position to draw the oval at
                             * @param width the width of the oval
                             * @param height the height of the oval
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawOval(x: int, y: int, width: int, height: int): this;

                            /**
                             * @param x the x position to draw the oval at
                             * @param y the y position to draw the oval at
                             * @param width the width of the oval
                             * @param height the height of the oval
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillOval(x: int, y: int, width: int, height: int): this;

                            /**
                             * @param x the x position to draw the arc at
                             * @param y the y position to draw the arc at
                             * @param width the width of the arc
                             * @param height the height of the arc
                             * @param startAngle the beginning angle
                             * @param arcAngle the angular extent of the arc, relative to the start angle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawArc(x: int, y: int, width: int, height: int, startAngle: int, arcAngle: int): this;

                            /**
                             * @param x the x position to draw the arc at
                             * @param y the y position to draw the arc at
                             * @param width the width of the arc
                             * @param height the height of the arc
                             * @param startAngle the beginning angle
                             * @param arcAngle the angular extent of the arc, relative to the start angle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillArc(x: int, y: int, width: int, height: int, startAngle: int, arcAngle: int): this;

                            /**
                             * The x and y array must have the same length and order for the points.
                             * @param pointsX an array of all x positions of the points in the polygon
                             * @param pointsY an array of all y positions of the points in the polygon
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawPolygonLine(pointsX: int[], pointsY: int[]): this;

                            /**
                             * The x and y array must have the same length and order for the points.
                             * @param pointsX an array of all x positions of the points in the polygon
                             * @param pointsY an array of all y positions of the points in the polygon
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawPolygon(pointsX: int[], pointsY: int[]): this;

                            /**
                             * The x and y array must have the same length and order for the points.
                             * @param pointsX an array of all x positions of the points in the polygon
                             * @param pointsY an array of all y positions of the points in the polygon
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillPolygon(pointsX: int[], pointsY: int[]): this;

                            /**
                             * @param x the x position to draw the string at
                             * @param y the y position to draw the string at
                             * @param text the text to draw
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawString(x: int, y: int, text: string): this;

                            /**
                             * @param toAnalyze the string to analyze
                             * @return the width of the string for the current font in pixels
                             * @since 1.8.4
                             */
                            getStringWidth(toAnalyze: string): number;

                        }


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        class RegistryHelper extends java.lang.Object {
                            static readonly class: JavaClass<RegistryHelper>;
                            /** @deprecated */ static prototype: undefined;

                            static parseIdentifier(id: string): /* net.minecraft.util.Identifier */ any;
                            static parseNameSpace(id: string): string;

                            constructor ();

                            /**
                             * @param id the item's id
                             * @return an {@link ItemHelper} for the given item.
                             * @since 1.8.4
                             */
                            getItem(id: CanOmitNamespace<ItemId>): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemHelper;

                            /**
                             * @param id the item's id
                             * @return an {@link ItemStackHelper} for the given item.
                             * @since 1.8.4
                             */
                            getItemStack(id: CanOmitNamespace<ItemId>): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            /**
                             * @param id the item's id
                             * @param nbt the item's nbt
                             * @return an {@link ItemStackHelper} for the given item and nbt data.
                             * @throws CommandSyntaxException if the nbt data is invalid.
                             * @since 1.8.4
                             */
                            getItemStack(id: CanOmitNamespace<ItemId>, nbt: string): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            /**
                             * @return a list of all registered item ids.
                             * @since 1.8.4
                             */
                            getItemIds(): JavaList<ItemId>;

                            /**
                             * @return a list of all registered items.
                             * @since 1.8.4
                             */
                            getItems(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemHelper>;

                            /**
                             * @param id the block's id
                             * @return an {@link BlockHelper} for the given block.
                             * @since 1.8.4
                             */
                            getBlock(id: CanOmitNamespace<BlockId>): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper;

                            /**
                             * @param id the block's id
                             * @return an {@link BlockStateHelper} for the given block.
                             * @since 1.8.4
                             */
                            getBlockState(id: CanOmitNamespace<BlockId>): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper;

                            /**
                             * @param id the status effect's id
                             * @return an {@link StatusEffectHelper} for the given status effect with 0 ticks duration.
                             */
                            getStatusEffect(id: CanOmitNamespace<StatusEffectId>): xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper;

                            /**
                             * @return a list of all registered status effects as {@link StatusEffectHelper}s with 0 ticks duration.
                             * @since 1.8.4
                             */
                            getStatusEffects(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper>;

                            /**
                             * @param id the block's id
                             * @param nbt the block's nbt
                             * @return an {@link BlockStateHelper} for the given block with the specified nbt.
                             * @throws CommandSyntaxException if the nbt data is invalid.
                             * @since 1.8.4
                             */
                            getBlockState(id: CanOmitNamespace<BlockId>, nbt: string): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper;

                            /**
                             * @return a list of all registered block ids.
                             * @since 1.8.4
                             */
                            getBlockIds(): JavaList<BlockId>;

                            /**
                             * @return a list of all registered blocks.
                             * @since 1.8.4
                             */
                            getBlocks(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper>;

                            /**
                             * @param id the enchantment's id
                             * @return an {@link EnchantmentHelper} for the given enchantment.
                             * @since 1.8.4
                             */
                            getEnchantment(id: EnchantmentId): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.EnchantmentHelper;

                            /**
                             * @param id the enchantment's id
                             * @param level the level of the enchantment
                             * @return an {@link EnchantmentHelper} for the given enchantment with the specified level.
                             * @since 1.8.4
                             */
                            getEnchantment(id: CanOmitNamespace<EnchantmentId>, level: int): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.EnchantmentHelper;

                            /**
                             * @return a list of all registered enchantment ids.
                             * @since 1.8.4
                             */
                            getEnchantmentIds(): JavaList<EnchantmentId>;

                            /**
                             * @return a list of all registered enchantments.
                             * @since 1.8.4
                             */
                            getEnchantments(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.EnchantmentHelper>;

                            /**
                             * @param type the id of the entity's type
                             * @return an {@link EntityHelper} for the given entity.
                             * @since 1.8.4
                             */
                            getEntity<E extends CanOmitNamespace<EntityId>>(type: E): EntityTypeFromId<E>;

                            /**
                             * @param type the id of the entity's type
                             * @return an {@link EntityType} for the given entity.
                             * @since 1.8.4
                             */
                            getRawEntityType(type: CanOmitNamespace<EntityId>): /* net.minecraft.entity.EntityType<any> */ any;

                            /**
                             * @return a list of all entity type ids.
                             * @since 1.8.4
                             */
                            getEntityTypeIds(): JavaList<EntityId>;

                            /**
                             * @param id the fluid's id
                             * @return an {@link FluidStateHelper} for the given fluid.
                             * @since 1.8.4
                             */
                            getFluidState(id: CanOmitNamespace<FluidId>): xyz.wagyourtail.jsmacros.client.api.helpers.world.FluidStateHelper;

                            /**
                             * @return a list of all feature ids.
                             * @since 1.8.4
                             */
                            getFeatureIds(): JavaList<FeatureId>;

                            /**
                             * @return a list of all structure feature ids.
                             * @since 1.8.4
                             */
                            getStructureFeatureIds(): JavaList<StructureFeatureId>;

                            /**
                             * @return a list of all painting motive ids.
                             * @since 1.8.4
                             */
                            getPaintingIds(): JavaList<PaintingId>;

                            /**
                             * @return a list of all particle type ids.
                             * @since 1.8.4
                             */
                            getParticleTypeIds(): JavaList<ParticleTypeId>;

                            /**
                             * @return a list of all game event names.
                             * @since 1.8.4
                             */
                            getGameEventNames(): JavaList<GameEventName>;

                            /**
                             * @return a list of all status effect ids.
                             * @since 1.8.4
                             */
                            getStatusEffectIds(): JavaList<StatusEffectId>;

                            /**
                             * @return a list of all block entity type ids.
                             * @since 1.8.4
                             */
                            getBlockEntityTypeIds(): JavaList<BlockEntityTypeId>;

                            /**
                             * @return a list of all screen handler ids.
                             * @since 1.8.4
                             */
                            getScreenHandlerIds(): JavaList<ScreenHandlerId>;

                            /**
                             * @return a list of all recipe type ids.
                             * @since 1.8.4
                             */
                            getRecipeTypeIds(): JavaList<RecipeTypeId>;

                            /**
                             * @return a list of all villager type ids.
                             * @since 1.8.4
                             */
                            getVillagerTypeIds(): JavaList<VillagerTypeId>;

                            /**
                             * @return a list of all villager profession ids.
                             * @since 1.8.4
                             */
                            getVillagerProfessionIds(): JavaList<VillagerProfession>;

                            /**
                             * @return a list of all point of interest type ids.
                             * @since 1.8.4
                             */
                            getPointOfInterestTypeIds(): JavaList<PointOfInterestTypeId>;

                            /**
                             * @return a list of all memory module type ids.
                             * @since 1.8.4
                             */
                            getMemoryModuleTypeIds(): JavaList<MemoryModuleTypeId>;

                            /**
                             * @return a list of all villager sensor type ids.
                             * @since 1.8.4
                             */
                            getSensorTypeIds(): JavaList<SensorTypeId>;

                            /**
                             * @return a list of all villager activity type ids.
                             * @since 1.8.4
                             */
                            getActivityTypeIds(): JavaList<ActivityTypeId>;

                            /**
                             * @return a list of all stat type ids.
                             * @since 1.8.4
                             */
                            getStatTypeIds(): JavaList<StatTypeId>;

                            /**
                             * @return a list of all entity attribute ids.
                             * @since 1.8.4
                             */
                            getEntityAttributeIds(): JavaList<EntityAttributeId>;

                            /**
                             * @return a list of all potion type ids.
                             * @since 1.8.4
                             */
                            getPotionTypeIds(): JavaList<PotionTypeId>;

                            /**
                             * @param identifier the String representation of the identifier, with the namespace and path
                             * @return the raw minecraft Identifier.
                             * @since 1.8.4
                             */
                            getIdentifier(identifier: string): /* net.minecraft.util.Identifier */ any;

                        }

                        class InteractionProxy$Break$BreakBlockResult extends java.lang.Object {
                            static readonly class: JavaClass<InteractionProxy$Break$BreakBlockResult>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (reason: string | null, pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper | null);

                            readonly reason: BreakBlockResult$Reason | null;
                            readonly pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper | null;
                        }

                        export {
                            PlayerInput,
                            TextBuilder,
                            CustomImage,
                            RegistryHelper,
                            InteractionProxy$Break$BreakBlockResult
                        }

                    }
                    namespace classes {

                        namespace inventory {


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class SmithingInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.SmithingScreen */ any> {
                                static readonly class: JavaClass<SmithingInventory>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (inventory: /* net.minecraft.client.gui.screen.ingame.SmithingScreen */ any);

                                /**
                                 * @return the left input item.
                                 * @since 1.8.4
                                 */
                                getLeftInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the right input item.
                                 * @since 1.8.4
                                 */
                                getRightInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the expected output item.
                                 * @since 1.8.4
                                 */
                                getOutput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            }

                            /** @since 1.5.1 */
                            abstract class BeaconInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.BeaconScreen */ any> {
                                static readonly class: JavaClass<BeaconInventory>;
                                /** @deprecated */ static prototype: undefined;

                                /** @since 1.5.1 */
                                getLevel(): number;
                                /** @since 1.5.1 */
                                getFirstEffect(): BeaconStatusEffect | null;
                                /** @since 1.5.1 */
                                getSecondEffect(): BeaconStatusEffect | null;
                                /** @since 1.5.1 */
                                selectFirstEffect(id: BeaconStatusEffect): boolean;
                                /** @since 1.5.1 */
                                selectSecondEffect(id: BeaconStatusEffect): boolean;
                                /** @since 1.5.1 */
                                applyEffects(): boolean;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            abstract class PlayerInventory extends RecipeInventory</* net.minecraft.client.gui.screen.ingame.InventoryScreen */ any> {
                                static readonly class: JavaClass<PlayerInventory>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * @param x the x position of the input from 0 to 1, going left to right
                                 * @param y the y position of the input from 0 to 1, going top to bottom
                                 * @return the input item at the given position of the crafting grid.
                                 * @since 1.8.4
                                 */
                                getInput(x: int, y: int): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the input items of the crafting grid, in a 2d array.
                                 * @since 1.8.4
                                 */
                                getInput(): JavaArray<JavaArray<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>>;

                                /**
                                 * @param slot the slot to check
                                 * @return `true` if the slot is in the hotbar or the offhand slot, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                isInHotbar(slot: int): boolean;

                                /**
                                 * @return the item in the offhand.
                                 * @since 1.8.4
                                 */
                                getOffhand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the equipped helmet item.
                                 * @since 1.8.4
                                 */
                                getHelmet(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the equipped chestplate item.
                                 * @since 1.8.4
                                 */
                                getChestplate(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the equipped leggings item.
                                 * @since 1.8.4
                                 */
                                getLeggings(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the equipped boots item.
                                 * @since 1.8.4
                                 */
                                getBoots(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class GrindStoneInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.GrindstoneScreen */ any> {
                                static readonly class: JavaClass<GrindStoneInventory>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (inventory: /* net.minecraft.client.gui.screen.ingame.GrindstoneScreen */ any);

                                /**
                                 * @return the upper item to disenchant.
                                 * @since 1.8.4
                                 */
                                getTopInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the bottom item to disenchant.
                                 * @since 1.8.4
                                 */
                                getBottomInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the expected output item.
                                 * @since 1.8.4
                                 */
                                getOutput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * Returns the minimum amount of xp dropped when disenchanting the input items. To calculate the
                                 *  maximum amount of xp, just multiply the return value by 2.
                                 * @return the minimum amount of xp the grindstone should return.
                                 * @since 1.8.4
                                 */
                                simulateXp(): number;

                            }

                            /** @since 1.7.0 */
                            class CommandManager extends java.lang.Object {
                                static readonly class: JavaClass<CommandManager>;
                                /** @deprecated */ static prototype: undefined;

                                static instance: CommandManager;

                                constructor ();

                                /**
                                 * @return list of commands
                                 * @since 1.7.0
                                 */
                                getValidCommands(): JavaList<string>;
                                /** @since 1.7.0 */
                                createCommandBuilder(name: string): CommandBuilder;

                                /**
                                 * @throws IllegalAccessException
                                 * @since 1.7.0
                                 */
                                unregisterCommand(command: string): xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper;

                                /**
                                 * warning: this method is hacky
                                 * @since 1.7.0
                                 */
                                reRegisterCommand(node: xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper): void;
                                /** @since 1.8.2 */
                                getArgumentAutocompleteOptions(commandPart: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<JavaList<string>, any, any, any>): void;

                            }

                            /** @since 1.3.1 */
                            abstract class VillagerInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.MerchantScreen */ any> {
                                static readonly class: JavaClass<VillagerInventory>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * select the trade by its index
                                 * @return self for chaining
                                 * @since 1.3.1
                                 */
                                selectTrade(index: int): this;
                                /** @since 1.3.1 */
                                getExperience(): number;
                                /** @since 1.3.1 */
                                getLevelProgress(): number;
                                /** @since 1.3.1 */
                                getMerchantRewardedExperience(): number;
                                /** @since 1.3.1 */
                                canRefreshTrades(): boolean;
                                /** @since 1.3.1 */
                                isLeveled(): boolean;

                                /**
                                 * @return list of trade offers
                                 * @since 1.3.1
                                 */
                                getTrades(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.TradeOfferHelper>;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            abstract class HorseInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.HorseScreen */ any> {
                                static readonly class: JavaClass<HorseInventory>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * @return `true` if the horse can be saddled, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                canBeSaddled(): boolean;

                                /**
                                 * @return `true` if the horse is saddled, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isSaddled(): boolean;

                                /**
                                 * @return the saddle item.
                                 * @since 1.8.4
                                 */
                                getSaddle(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return `true` if the horse can eqiup armor, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                hasArmorSlot(): boolean;

                                /**
                                 * @return the armor item.
                                 * @since 1.8.4
                                 */
                                getArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return `true` if the horse has equipped a chest, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                hasChest(): boolean;

                                /**
                                 * @return the horse's inventory size.
                                 * @since 1.8.4
                                 */
                                getInventorySize(): number;

                                /**
                                 * @return a list of items in the horse's inventory.
                                 * @since 1.8.4
                                 */
                                getHorseInventory(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                /**
                                 * @return the horse this inventory belongs to.
                                 * @since 1.8.4
                                 */
                                getHorse(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.AbstractHorseEntityHelper<any>;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class FurnaceInventory extends RecipeInventory</* net.minecraft.client.gui.screen.ingame.AbstractFurnaceScreen<any> */ any> {
                                static readonly class: JavaClass<FurnaceInventory>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (inventory: /* net.minecraft.client.gui.screen.ingame.AbstractFurnaceScreen<any> */ any);

                                /**
                                 * @param x the x position of the input, will always be 0
                                 * @param y the y position of the input, will always be 0
                                 * @return the currently smelting item.
                                 * @since 1.8.4
                                 */
                                getInput(x: int, y: int): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the input items of the crafting grid, in a 2d array.
                                 * @since 1.8.4
                                 */
                                getInput(): JavaArray<JavaArray<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>>;

                                /**
                                 * @return the currently smelting item.
                                 * @since 1.8.4
                                 */
                                getSmeltedItem(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the fuel item.
                                 * @since 1.8.4
                                 */
                                getFuel(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @param stack the item to check
                                 * @return `true` if the item is a valid fuel, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                canUseAsFuel(stack: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): boolean;

                                /**
                                 * @param stack the item to check
                                 * @return `true` if the item can be smelted, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isSmeltable(stack: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): boolean;

                                /**
                                 * @return a map of all valid fuels and their burn times in ticks.
                                 * @since 1.8.4
                                 */
                                getFuelValues(): JavaMap<string, number>;

                                /**
                                 * If the returned value equals {@link getTotalSmeltingTime}() then the item is done smelting.
                                 * @return the current Smelting progress in ticks.
                                 * @since 1.8.4
                                 */
                                getSmeltingProgress(): number;

                                /**
                                 * @return the total smelting time of a single input item in ticks.
                                 * @since 1.8.4
                                 */
                                getTotalSmeltingTime(): number;

                                /**
                                 * @return the remaining time of the smelting progress in ticks.
                                 * @since 1.8.4
                                 */
                                getRemainingSmeltingTime(): number;

                                /**
                                 * @return the remaining fuel time in ticks.
                                 * @since 1.8.4
                                 */
                                getRemainingFuelTime(): number;

                                /**
                                 * @return the total fuel time of the current fuel item in ticks.
                                 * @since 1.8.4
                                 */
                                getTotalFuelTime(): number;

                                /**
                                 * @return `true` if the furnace is currently smelting an item, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isBurning(): boolean;

                            }

                            /** @since 1.4.2 */
                            class CommandBuilder extends java.lang.Object {
                                static readonly class: JavaClass<CommandBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor ();

                                literalArg(name: string): CommandBuilder;
                                booleanArg(name: string): CommandBuilder;
                                intArg(name: string): CommandBuilder;
                                intArg(name: string, min: int, max: int): CommandBuilder;
                                intRangeArg(name: string): CommandBuilder;
                                longArg(name: string): CommandBuilder;
                                longArg(name: string, min: long, max: long): CommandBuilder;
                                floatRangeArg(name: string): CommandBuilder;
                                doubleArg(name: string): CommandBuilder;
                                doubleArg(name: string, min: double, max: double): CommandBuilder;
                                uuidArgType(name: string): CommandBuilder;
                                greedyStringArg(name: string): CommandBuilder;
                                quotedStringArg(name: string): CommandBuilder;
                                wordArg(name: string): CommandBuilder;
                                regexArgType(name: string, regex: string, flags: string): CommandBuilder;
                                textArgType(name: string): CommandBuilder;
                                timeArg(name: string): CommandBuilder;
                                identifierArg(name: string): CommandBuilder;
                                nbtArg(name: string): CommandBuilder;
                                nbtElementArg(name: string): CommandBuilder;
                                nbtCompoundArg(name: string): CommandBuilder;
                                colorArg(name: string): CommandBuilder;
                                angleArg(name: string): CommandBuilder;
                                itemArg(name: string): CommandBuilder;
                                itemStackArg(name: string): CommandBuilder;
                                itemPredicateArg(name: string): CommandBuilder;
                                blockArg(name: string): CommandBuilder;
                                blockStateArg(name: string): CommandBuilder;
                                blockPredicateArg(name: string): CommandBuilder;
                                blockPosArg(name: string): CommandBuilder;
                                columnPosArg(name: string): CommandBuilder;
                                dimensionArg(name: string): CommandBuilder;
                                itemSlotArg(name: string): CommandBuilder;
                                particleArg(name: string): CommandBuilder;

                                /**
                                 * it is recommended to use {@link JsMacros.runScript}(String, BaseEvent)
                                 *  in the callback if you expect to actually do anything complicated with waits.  
                                 *
                                 *  the {@link CommandContextHelper} arg is an {@link BaseEvent}
                                 *  so you can pass it directly to {@link JsMacros.runScript}(String, BaseEvent).  
                                 *
                                 *  make sure your callback returns a boolean success = true.
                                 */
                                executes(callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.CommandContextHelper, any, any, any>): CommandBuilder;
                                /** @since 1.6.5 */
                                suggestMatching(...suggestions: JavaVarArgs<string>): CommandBuilder;

                                /**
                                 * @param suggestions the strings to match
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestMatching(suggestions: JavaCollection<string>): this;
                                /** @since 1.6.5 */
                                suggestIdentifier(...suggestions: JavaVarArgs<string>): CommandBuilder;

                                /**
                                 * @param suggestions the identifiers to match
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestIdentifier(suggestions: JavaCollection<string>): this;

                                /**
                                 * @param positions the positions to suggest
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestBlockPositions(...positions: JavaVarArgs<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper>): this;

                                /**
                                 * @param positions the positions to suggest
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestBlockPositions(positions: JavaCollection<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper>): this;

                                /**
                                 * Positions are strings of the form "x y z" where x, y, and z are numbers or the default
                                 *  minecraft selectors "~" and "^" followed by a number.
                                 * @param positions the positions to suggest
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestPositions(...positions: JavaVarArgs<string>): this;

                                /**
                                 * Positions are strings of the form "x y z" where x, y, and z are numbers or the default
                                 *  minecraft selectors "~" and "^" followed by a number.
                                 * @param positions the positions to match
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestPositions(positions: JavaCollection<string>): this;
                                /** @since 1.6.5 */
                                suggest(callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.CommandContextHelper, xyz.wagyourtail.jsmacros.client.api.helpers.SuggestionsBuilderHelper, any, any>): CommandBuilder;
                                or(): CommandBuilder;

                                /**
                                 * name overload for {@link or}() to work around language keyword restrictions
                                 * @since 1.5.2
                                 */
                                otherwise(): CommandBuilder;
                                or(argumentLevel: int): CommandBuilder;

                                /**
                                 * name overload for {@link or}(int) to work around language keyword restrictions
                                 * @since 1.5.2
                                 */
                                otherwise(argLevel: int): CommandBuilder;
                                register(): void;

                                /**
                                 * @since 1.6.5
                                 *  removes this command
                                 */
                                unregister(): void;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class ContainerInventory<T = /* net.minecraft.client.gui.screen.ingame.HandledScreen<any> */ any> extends Inventory<T> {
                                static readonly class: JavaClass<ContainerInventory<any>>;
                                /** @deprecated */ static prototype: undefined;

                                constructor <T extends /* net.minecraft.client.gui.screen.ingame.HandledScreen<any> */ any>(inventory: T);

                                /**
                                 * @return the first free slot in this container.
                                 * @since 1.8.4
                                 */
                                findFreeContainerSlot(): number;

                            }

                            /** @since 1.3.1 */
                            abstract class EnchantInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.EnchantmentScreen */ any> {
                                static readonly class: JavaClass<EnchantInventory>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * @return xp level required to do enchantments
                                 * @since 1.3.1
                                 */
                                getRequiredLevels(): JavaArray<number>;

                                /**
                                 * @return list of enchantments text.
                                 * @since 1.3.1
                                 */
                                getEnchantments(): JavaArray<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

                                /**
                                 * @return the visible enchantment for each level.
                                 * @since 1.8.4
                                 */
                                getEnchantmentHelpers(): JavaArray<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.EnchantmentHelper>;

                                /**
                                 * @return id for enchantments
                                 * @since 1.3.1
                                 */
                                getEnchantmentIds(): JavaArray<string>;

                                /**
                                 * @return level of enchantments
                                 * @since 1.3.1
                                 */
                                getEnchantmentLevels(): JavaArray<number>;

                                /**
                                 * clicks the button to enchant.
                                 * @return success
                                 * @since 1.3.1
                                 */
                                doEnchant(index: int): boolean;

                                /**
                                 * @return the item to be enchanted.
                                 * @since 1.8.4
                                 */
                                getItemToEnchant(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the slot containing the lapis lazuli.
                                 * @since 1.8.4
                                 */
                                getLapis(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.0.8
                             */
                            abstract class Inventory<T = /* net.minecraft.client.gui.screen.ingame.HandledScreen<any> */ IScreen> extends java.lang.Object {
                                static readonly class: JavaClass<Inventory<any>>;
                                /** @deprecated */ static prototype: undefined;

                                static create(): Inventory<any>;
                                static create(s: /* net.minecraft.client.gui.screen.Screen */ any | null): Inventory<any> | null;

                                /** @since 1.5.0 */
                                click(slot: int): Inventory<T>;

                                /**
                                 * Clicks a slot with a mouse button.~~if the slot is a container, it will click the first slot in the container
                                 * @since 1.0.8
                                 */
                                click(slot: int, mousebutton: Trit): Inventory<T>;

                                /**
                                 * Does a drag-click with a mouse button. (the slots don't have to be in order or even adjacent, but when vanilla minecraft calls the underlying function they're always sorted...)
                                 */
                                dragClick(slots: int[], mousebutton: Bit): Inventory<T>;
                                /** @since 1.5.0 */
                                dropSlot(slot: int): Inventory<T>;

                                /**
                                 * @param slot the slot to drop
                                 * @param stack decide whether to drop the whole stack or just a single item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                dropSlot(slot: int, stack: boolean): Inventory<T>;

                                /**
                                 * @param item the item to check for
                                 * @return `true` if the item is contined anywhere in the inventory, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                contains(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): boolean;

                                /**
                                 * @param item the item to check for
                                 * @return `true` if the item is contined anywhere in the inventory, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                contains(item: ItemId): boolean;

                                /**
                                 * @return the first empty slot in the main inventory or `-1` if there are no empty
                                 *  slots.
                                 * @since 1.8.4
                                 */
                                findFreeInventorySlot(): number;

                                /**
                                 * @return the first empty hotbar slot or `-1` if there are no empty slots.
                                 * @since 1.8.4
                                 */
                                findFreeHotbarSlot(): number;

                                /**
                                 * @param mapIdentifiers the identifier of the inventory sections to check
                                 * @return the first empty slot in the given inventory sections, or `-1` if there are no
                                 *  empty slots.
                                 * @since 1.8.4
                                 */
                                findFreeSlot(...mapIdentifiers: InvMapId[]): number;

                                /**
                                 * @return a map of all item ids and their total count inside the inventory.
                                 * @since 1.8.4
                                 */
                                getItemCount(): JavaMap<ItemId, number>;

                                /**
                                 * @return a list of all items in the inventory.
                                 * @since 1.8.4
                                 */
                                getItems(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                /**
                                 * @param mapIdentifiers the inventory sections
                                 * @return a list of all items in the given inventory sections.
                                 * @since 1.8.4
                                 */
                                getItems(...mapIdentifiers: InvMapId[]): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                /**
                                 * @param item the item to search for
                                 * @return all slots containing the given item.
                                 * @since 1.8.4
                                 */
                                findItem(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): JavaArray<number>;

                                /**
                                 * @param item the item to search for
                                 * @return all slots containing the given item.
                                 * @since 1.8.4
                                 */
                                findItem(item: ItemId): JavaArray<number>;

                                /**
                                 * @param mapIdentifiers the inventory sections
                                 * @return all slots indexes in the given inventory sections.
                                 * @since 1.8.4
                                 */
                                getSlots(...mapIdentifiers: InvMapId[]): JavaArray<number>;

                                /**
                                 * @return the index of the selected hotbar slot.
                                 * @since 1.2.5
                                 */
                                getSelectedHotbarSlotIndex(): number;
                                /** @since 1.2.5 */
                                setSelectedHotbarSlotIndex(index: int): void;

                                /**
                                 * closes the inventory, (if the inventory/container is visible it will close the gui). also drops any "held on mouse" items.
                                 */
                                closeAndDrop(): Inventory<T>;

                                /**
                                 * Closes the inventory, and open gui if applicable.
                                 */
                                close(): void;

                                /**
                                 * simulates a shift-click on a slot.  
                                 *  It should be safe to chain these without {@link Client.waitTick}() at least for a bunch of the same item.
                                 */
                                quick(slot: int): Inventory<T>;
                                /** @since 1.7.0 */
                                quickAll(slot: int): number;

                                /**
                                 * quicks all that match the slot
                                 * @param slot a slot from the section you want to move items from
                                 * @return number of items that matched
                                 * @since 1.7.0
                                 */
                                quickAll(slot: int, button: Bit): number;

                                /**
                                 * @return the held (by the mouse) item.
                                 */
                                getHeld(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the item in the slot.
                                 */
                                getSlot(slot: int): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the size of the container/inventory.
                                 */
                                getTotalSlots(): number;

                                /**
                                 * Splits the held stack into two slots. can be alternatively done with {@link Inventory.dragClick}(int[], int) if this one has issues on some servers.
                                 * @throws Exception
                                 */
                                split(slot1: int, slot2: int): Inventory<T>;

                                /**
                                 * Does that double click thingy to turn a incomplete stack pickup into a complete stack pickup if you have more in your inventory.
                                 */
                                grabAll(slot: int): Inventory<T>;

                                /**
                                 * swaps the items in two slots.
                                 */
                                swap(slot1: int, slot2: int): Inventory<T>;

                                /**
                                 * equivalent to hitting the numbers or f for swapping slots to hotbar
                                 * @param hotbarSlot 0-8 or 40 for offhand
                                 * @since 1.6.5 [citation needed]
                                 */
                                swapHotbar(slot: int, hotbarSlot: HotbarSwapSlot): Inventory<T>;
                                /** @since 1.2.8 */
                                openGui(): void;

                                /**
                                 * @return the id of the slot under the mouse.
                                 * @since 1.1.3
                                 */
                                getSlotUnderMouse(): number;

                                /**
                                 * @return the part of the mapping the slot is in.
                                 * @since 1.1.3
                                 */
                                getType(): ScreenName;

                                /**
                                 * checks if this inventory type equals to any of the specified types<br>
                                 * @since 1.9.0
                                 */
                                is<T extends ScreenName>(...types: T[]): this is T extends keyof InvNameToTypeMap ? InvNameToTypeMap[keyof InvNameToTypeMap] extends InvNameToTypeMap[T] ? Inventory : InvNameToTypeMap[T] : this;

                                /**
                                 * @return the inventory mappings different depending on the type of open container/inventory.
                                 * @since 1.1.3
                                 */
                                getMap(): JavaMap<InvMapId, JavaArray<number>>;

                                /**
                                 * @return returns the part of the mapping the slot is in.
                                 * @since 1.1.3
                                 */
                                getLocation(slotNum: int): InvMapId | null;

                                /**
                                 * @return the x/y position of the specified slot index
                                 * @since 1.8.4
                                 */
                                getSlotPos(slot: int): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;

                                /**
                                 * @return `true` if the inventory is a container, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isContainer(): boolean;
                                /** @since 1.2.3 */
                                getContainerTitle(): string;
                                getRawContainer(): T;
                                /** @since 1.6.0 */
                                getCurrentSyncId(): number;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class AnvilInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.AnvilScreen */ any> {
                                static readonly class: JavaClass<AnvilInventory>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (inventory: /* net.minecraft.client.gui.screen.ingame.AnvilScreen */ any);

                                /**
                                 * @return the currently set name to be applied.
                                 * @since 1.8.4
                                 */
                                getName(): string;

                                /**
                                 * The change will be applied once the item is taken out of the anvil.
                                 * @param name the new item name
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                seName(name: string): this;

                                /**
                                 * @return the level cost to apply the changes.
                                 * @since 1.8.4
                                 */
                                getLevelCost(): number;

                                /**
                                 * @return the amount of item needed to fully repair the item.
                                 * @since 1.8.4
                                 */
                                getItemRepairCost(): number;

                                /**
                                 * @return the maximum default level cost.
                                 * @since 1.8.4
                                 */
                                getMaximumLevelCost(): number;

                                /**
                                 * @return the first input item.
                                 * @since 1.8.4
                                 */
                                getLeftInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the second input item.
                                 * @since 1.8.4
                                 */
                                getRightInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the expected output item.
                                 * @since 1.8.4
                                 */
                                getOutput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class StoneCutterInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.StonecutterScreen */ any> {
                                static readonly class: JavaClass<StoneCutterInventory>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (inventory: /* net.minecraft.client.gui.screen.ingame.StonecutterScreen */ any);

                                /**
                                 * @return the selected recipe index.
                                 * @since 1.8.4
                                 */
                                getSelectedRecipeIndex(): number;

                                /**
                                 * @return the output item for the selected recipe.
                                 * @since 1.8.4
                                 */
                                getOutput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @param idx the index to select
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                selectRecipe(idx: int): this;

                                /**
                                 * @return the amount of available recipes.
                                 * @since 1.8.4
                                 */
                                getAvailableRecipeCount(): number;

                                /**
                                 * @return a list of all available recipe results in the form of item stacks.
                                 * @since 1.8.4
                                 */
                                getRecipes(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                /**
                                 * @return `true` if there is a selected recipe, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                canCraft(): boolean;

                            }

                            /** @since 1.6.0 */
                            class ChatHistoryManager extends java.lang.Object {
                                static readonly class: JavaClass<ChatHistoryManager>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (hud: /* net.minecraft.client.gui.hud.ChatHud */ any);

                                /** @since 1.6.0 */
                                getRecvLine(index: int): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper;

                                /**
                                 * @return the amount of messages in the chat history.
                                 * @throws InterruptedException
                                 * @since 1.8.4
                                 */
                                getRecvCount(): number;

                                /**
                                 * @return all received messages in the chat history.
                                 * @throws InterruptedException
                                 * @since 1.8.4
                                 */
                                getRecvLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper>;
                                /** @since 1.6.0 */
                                insertRecvText(index: int, line: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): void;

                                /**
                                 * you should probably run {@link refreshVisible}() after...
                                 * @since 1.6.0
                                 */
                                insertRecvText(index: int, line: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, timeTicks: int): void;

                                /**
                                 * @throws InterruptedException
                                 * @since 1.6.0
                                 */
                                insertRecvText(index: int, line: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, timeTicks: int, await: boolean): void;
                                /** @since 1.6.0 */
                                removeRecvText(index: int): void;

                                /**
                                 * @throws InterruptedException
                                 * @since 1.6.0
                                 */
                                removeRecvText(index: int, await: boolean): void;
                                /** @since 1.6.0 */
                                removeRecvTextMatching(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): void;

                                /**
                                 * @throws InterruptedException
                                 * @since 1.6.0
                                 */
                                removeRecvTextMatching(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, await: boolean): void;
                                /** @since 1.6.0 */
                                removeRecvTextMatchingFilter(filter: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper, any, boolean, any>): void;

                                /**
                                 * @throws InterruptedException
                                 * @since 1.6.0
                                 */
                                removeRecvTextMatchingFilter(filter: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper, any, boolean, any>, await: boolean): void;

                                /**
                                 * this will reset the view of visible messages
                                 * @since 1.6.0
                                 */
                                refreshVisible(): void;

                                /**
                                 * @throws InterruptedException
                                 * @since 1.6.0
                                 */
                                refreshVisible(await: boolean): void;
                                /** @since 1.6.0 */
                                clearRecv(): void;

                                /**
                                 * @throws InterruptedException
                                 * @since 1.6.0
                                 */
                                clearRecv(await: boolean): void;

                                /**
                                 * @return direct reference to sent message history list. modifications will affect the list.
                                 * @since 1.6.0
                                 */
                                getSent(): JavaList<string>;
                                /** @since 1.6.0 */
                                clearSent(): void;

                                /**
                                 * @throws InterruptedException
                                 * @since 1.6.0
                                 */
                                clearSent(await: boolean): void;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class CartographyInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.CartographyTableScreen */ any> {
                                static readonly class: JavaClass<CartographyInventory>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (inventory: /* net.minecraft.client.gui.screen.ingame.CartographyTableScreen */ any);

                                /**
                                 * @return the map item.
                                 * @since 1.8.4
                                 */
                                getMapItem(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the paper item.
                                 * @since 1.8.4
                                 */
                                getMaterial(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the output item.
                                 * @since 1.8.4
                                 */
                                getOutput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            abstract class RecipeInventory<T = /* net.minecraft.client.gui.screen.ingame.HandledScreen<net.minecraft.screen.AbstractRecipeScreenHandler<any>> */ any> extends Inventory<T> {
                                static readonly class: JavaClass<RecipeInventory<any>>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * @return the output item.
                                 * @since 1.8.4
                                 */
                                getOutput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the maximum input size for all recipes in this inventory.
                                 * @since 1.8.4
                                 */
                                getInputSize(): number;

                                /**
                                 * @param x the x position of the input slot, starting at 0, left to right. Must be less than
                                 *           {@link getCraftingWidth}()
                                 * @param z the z position of the input slot, starting at 0, top to bottom. Must be less than
                                 *           {@link getCraftingHeight}()
                                 * @return the input item at the given position.
                                 * @since 1.8.4
                                 */
                                getInput(x: int, z: int): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the input items of the crafting grid, in a 2d array.
                                 * @since 1.8.4
                                 */
                                getInput(): JavaArray<JavaArray<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>>;

                                /**
                                 * @return the width of the crafting grid.
                                 * @since 1.8.4
                                 */
                                getCraftingWidth(): number;

                                /**
                                 * @return the height of the crafting grid.
                                 * @since 1.8.4
                                 */
                                getCraftingHeight(): number;

                                /**
                                 * @return the amount of slots used for crafting.
                                 * @since 1.8.4
                                 */
                                getCraftingSlotCount(): number;

                                /**
                                 * @return the recipe category of recipes that can be crafted in this inventory.
                                 * @since 1.8.4
                                 */
                                getCategory(): RecipeBookCategory;

                                /**
                                 * @throws InterruptedException
                                 * @since 1.3.1
                                 */
                                getCraftableRecipes(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.RecipeHelper>;

                                /**
                                 * @param craftable whether only to list craftable recipes
                                 * @return a list of recipes that can be crafted in this inventory.
                                 * @throws InterruptedException
                                 * @since 1.8.4
                                 */
                                getRecipes(craftable: boolean): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.RecipeHelper> | null;

                                /**
                                 * @return `true` if the recipe book is visible, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isRecipeBookOpened(): boolean;
                                /** @since 1.8.4 */
                                toggleRecipeBook(): void;

                                /**
                                 * @param open whether to open or close the recipe book
                                 * @since 1.8.4
                                 */
                                setRecipeBook(open: boolean): void;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            abstract class CreativeInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen */ any> {
                                static readonly class: JavaClass<CreativeInventory>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * The total scroll value is always clamp between 0 and 1.
                                 * @param amount the amount to scroll by, between -1 and 1
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                scroll(amount: double): this;

                                /**
                                 * The total scroll value is always clamp between 0 and 1.
                                 * @param position the position to scroll to, between 0 and 1
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                scrollTo(position: double): this;

                                /**
                                 * @return a list of all shown items.
                                 * @since 1.8.4
                                 */
                                getShownItems(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                /**
                                 * @param search the string to search for
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                search(search: string): this;

                                /**
                                 * Select the search tab.
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                selectSearch(): this;

                                /**
                                 * Select the inventory tab.
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                selectInventory(): this;

                                /**
                                 * Select the tab where the hotbars are stored.
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                selectHotbar(): this;

                                /**
                                 * @param tabName the name of the tab to select
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                selectTab(tabName: string): this;
                                getTabNames(): JavaList<string>;
                                getTabTexts(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

                                /**
                                 * Destroys the currently held item.
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                destroyHeldItem(): this;

                                /**
                                 * Destroys all items in the player's inventory.
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                destroyAllItems(): this;

                                /**
                                 * @param stack the item stack to drag
                                 * @return self for chaining.
                                 * @see RegistryHelper.getItemStack(String, String)
                                 * @since 1.8.4
                                 */
                                setCursorStack(stack: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): this;

                                /**
                                 * @param slot the slot to insert the item into
                                 * @param stack the item stack to insert
                                 * @return self for chaining.
                                 * @see RegistryHelper.getItemStack(String, String)
                                 * @since 1.8.4
                                 */
                                setStack(slot: int, stack: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): this;

                                /**
                                 * @param index the index to save the hotbar to, from 0 to 8
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                saveHotbar(index: int): this;

                                /**
                                 * @param index the index to save the hotbar to, from 0 to 8
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                restoreHotbar(index: int): this;

                                /**
                                 * @param index the index to save the hotbar to, from 0 to 8
                                 * @return a list of all items in the saved hotbar.
                                 * @since 1.8.4
                                 */
                                getSavedHotbar(index: int): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                /**
                                 * @param slot the slot to check
                                 * @return `true` if the slot is in the hotbar or the offhand slot, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                isInHotbar(slot: int): boolean;

                                /**
                                 * @return the item in the offhand.
                                 * @since 1.8.4
                                 */
                                getOffhand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the equipped helmet item.
                                 * @since 1.8.4
                                 */
                                getHelmet(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the equipped chestplate item.
                                 * @since 1.8.4
                                 */
                                getChestplate(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the equipped leggings item.
                                 * @since 1.8.4
                                 */
                                getLeggings(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the equipped boots item.
                                 * @since 1.8.4
                                 */
                                getBoots(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            }

                            /** @since 1.5.1 */
                            abstract class LoomInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.LoomScreen */ any> {
                                static readonly class: JavaClass<LoomInventory>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * @return success
                                 * @since 1.5.1
                                 * @deprecated
                                 */
                                selectPatternName(name: string): boolean;

                                /**
                                 * @return available pattern ids
                                 * @since 1.7.0
                                 */
                                listAvailablePatterns(): JavaList<string>;

                                /**
                                 * @return success
                                 * @since 1.5.1
                                 */
                                selectPatternId(id: string): boolean;

                                /**
                                 * @return success
                                 * @since 1.5.1
                                 */
                                selectPattern(index: int): boolean;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class BrewingStandInventory extends Inventory</* net.minecraft.client.gui.screen.ingame.BrewingStandScreen */ any> {
                                static readonly class: JavaClass<BrewingStandInventory>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (inventory: /* net.minecraft.client.gui.screen.ingame.BrewingStandScreen */ any);

                                /**
                                 * @param potion the potion to check
                                 * @return `true` if the given potion is can be brewed, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isBrewablePotion(potion: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): boolean;

                                /**
                                 * @param ingredient the item to check
                                 * @return `true` if the given item is a valid ingredient, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isValidIngredient(ingredient: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): boolean;

                                /**
                                 * @param potion the potion to check
                                 * @param ingredient the ingredient to check
                                 * @return `true` if the given potion and ingredient can be brewed together, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                isValidRecipe(potion: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, ingredient: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): boolean;

                                /**
                                 * @return the left fuel.
                                 * @since 1.8.4
                                 */
                                getFuelCount(): number;

                                /**
                                 * The maximum fuel count is a constant with the value 20.
                                 * @return the maximum fuel.
                                 * @since 1.8.4
                                 */
                                getMaxFuelUses(): number;

                                /**
                                 * @return `true` if the brewing stand can brew any of the held potions with the current
                                 *  ingredient, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                canBrewCurrentInput(): boolean;

                                /**
                                 * @return the time the potions have been brewing.
                                 * @since 1.8.4
                                 */
                                getBrewTime(): number;

                                /**
                                 * @return the remaining time the potions have to brew.
                                 * @since 1.8.4
                                 */
                                getRemainingTicks(): number;

                                /**
                                 * @param potion the potion
                                 * @param ingredient the ingredient
                                 * @return the resulting potion of the given potion and ingredient if it exists and the potion
                                 *  itself otherwise.
                                 * @since 1.8.4
                                 */
                                previewPotion(potion: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, ingredient: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return a list of all resulting potions of the current input.
                                 * @since 1.8.4
                                 */
                                previewPotions(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                /**
                                 * @return the ingredient.
                                 * @since 1.8.4
                                 */
                                getIngredient(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the fuel item.
                                 * @since 1.8.4
                                 */
                                getFuel(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the first potion.
                                 * @since 1.8.4
                                 */
                                getFirstPotion(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the second potion.
                                 * @since 1.8.4
                                 */
                                getSecondPotion(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the third potion.
                                 * @since 1.8.4
                                 */
                                getThirdPotion(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return a list of the potions inside the brewing stand.
                                 * @since 1.8.4
                                 */
                                getPotions(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            abstract class CraftingInventory extends RecipeInventory</* net.minecraft.client.gui.screen.ingame.CraftingScreen */ any> {
                                static readonly class: JavaClass<CraftingInventory>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * @param x the x position of the input from 0 to 2, going left to right
                                 * @param y the y position of the input from 0 to 2, going top to bottom
                                 * @return the input item at the given position.
                                 * @since 1.8.4
                                 */
                                getInput(x: int, y: int): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the input items of the crafting grid, in a 2d array.
                                 * @since 1.8.4
                                 */
                                getInput(): JavaArray<JavaArray<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>>;

                            }

                            export {
                                SmithingInventory,
                                BeaconInventory,
                                PlayerInventory,
                                GrindStoneInventory,
                                CommandManager,
                                VillagerInventory,
                                HorseInventory,
                                FurnaceInventory,
                                CommandBuilder,
                                ContainerInventory,
                                EnchantInventory,
                                Inventory,
                                AnvilInventory,
                                StoneCutterInventory,
                                ChatHistoryManager,
                                CartographyInventory,
                                RecipeInventory,
                                CreativeInventory,
                                LoomInventory,
                                BrewingStandInventory,
                                CraftingInventory
                            }

                        }

                        namespace math {


                            /**
                             * @author Wagyourtail
                             * @since 1.2.6 [citation needed]
                             */
                            class Pos3D extends Pos2D {
                                static readonly class: JavaClass<Pos3D>;
                                /** @deprecated */ static prototype: undefined;

                                static readonly ZERO: Pos3D;

                                constructor (vec: /* net.minecraft.util.math.Vec3d */ any);
                                constructor (x: double, y: double, z: double);

                                z: number;

                                getZ(): number;
                                add(pos: Pos3D): Pos3D;
                                /** @since 1.6.3 */
                                add(x: double, y: double, z: double): Pos3D;
                                add(pos: Pos2D): Pos2D;
                                /** @since 1.6.3 */
                                add(x: double, y: double): Pos2D;

                                /**
                                 * @param pos the position to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(pos: Pos3D): Pos3D;

                                /**
                                 * @param x the x coordinate to subtract
                                 * @param y the y coordinate to subtract
                                 * @param z the z coordinate to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(x: double, y: double, z: double): Pos3D;

                                /**
                                 * @param pos the position to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(pos: Pos2D): Pos2D;

                                /**
                                 * @param x the x coordinate to subtract
                                 * @param y the y coordinate to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(x: double, y: double): Pos2D;
                                multiply(pos: Pos3D): Pos3D;
                                /** @since 1.6.3 */
                                multiply(x: double, y: double, z: double): Pos3D;
                                multiply(pos: Pos2D): Pos2D;
                                /** @since 1.6.3 */
                                multiply(x: double, y: double): Pos2D;

                                /**
                                 * @param pos the position to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(pos: Pos3D): Pos3D;

                                /**
                                 * @param x the x coordinate to divide by
                                 * @param y the y coordinate to divide by
                                 * @param z the z coordinate to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(x: double, y: double, z: double): Pos3D;

                                /**
                                 * @param pos the position to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(pos: Pos2D): Pos2D;

                                /**
                                 * @param x the x coordinate to divide by
                                 * @param y the y coordinate to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(x: double, y: double): Pos2D;
                                /** @since 1.6.3 */
                                scale(scale: double): Pos3D;
                                toVector(): Vec3D;
                                /** @since 1.6.4 */
                                toVector(start_pos: Pos2D): Vec3D;
                                /** @since 1.6.4 */
                                toVector(start_pos: Pos3D): Vec3D;
                                /** @since 1.6.4 */
                                toVector(start_x: double, start_y: double, start_z: double): Vec3D;
                                /** @since 1.6.4 */
                                toVector(start_x: double, start_y: double): Vec2D;
                                /** @since 1.6.4 */
                                toReverseVector(): Vec3D;
                                toReverseVector(end_pos: Pos2D): Vec3D;
                                /** @since 1.6.4 */
                                toReverseVector(end_pos: Pos3D): Vec3D;
                                /** @since 1.6.4 */
                                toReverseVector(end_x: double, end_y: double, end_z: double): Vec3D;
                                /** @since 1.6.4 */
                                toReverseVector(end_x: double, end_y: double): Vec2D;
                                /** @since 1.8.0 */
                                toBlockPos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;
                                /** @since 1.8.0 */
                                toRawBlockPos(): /* net.minecraft.util.math.BlockPos */ any;

                                /**
                                 * @return the raw minecraft double vector with the same coordinates as this position.
                                 * @since 1.8.4
                                 */
                                toMojangDoubleVector(): /* net.minecraft.util.math.Vec3d */ any;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.2.6 [citation needed]
                             */
                            class Vec2D extends java.lang.Object {
                                static readonly class: JavaClass<Vec2D>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (x1: double, y1: double, x2: double, y2: double);
                                constructor (start: Pos2D, end: Pos2D);

                                x1: number;
                                y1: number;
                                x2: number;
                                y2: number;

                                getX1(): number;
                                getY1(): number;
                                getX2(): number;
                                getY2(): number;
                                getDeltaX(): number;
                                getDeltaY(): number;
                                getStart(): Pos2D;
                                getEnd(): Pos2D;
                                getMagnitude(): number;

                                /**
                                 * @return magnitude squared
                                 * @since 1.6.5
                                 */
                                getMagnitudeSq(): number;
                                add(vec: Vec2D): Vec2D;
                                /** @since 1.6.3 */
                                add(x1: double, y1: double, x2: double, y2: double): Vec2D;
                                multiply(vec: Vec2D): Vec2D;
                                /** @since 1.6.3 */
                                multiply(x1: double, y1: double, x2: double, y2: double): Vec2D;
                                /** @since 1.6.3 */
                                scale(scale: double): Vec2D;
                                dotProduct(vec: Vec2D): number;
                                reverse(): Vec2D;

                                /**
                                 * @return a new Vec2D with the same direction but a magnitude of 1
                                 * @since 1.6.5
                                 */
                                normalize(): Vec2D;
                                to3D(): Vec3D;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.2.6 [citation needed]
                             */
                            class Vec3D extends Vec2D {
                                static readonly class: JavaClass<Vec3D>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double);
                                constructor (start: Pos3D, end: Pos3D);

                                z1: number;
                                z2: number;

                                getZ1(): number;
                                getZ2(): number;
                                getDeltaZ(): number;
                                getStart(): Pos3D;
                                getEnd(): Pos3D;
                                getMagnitude(): number;
                                getMagnitudeSq(): number;
                                add(vec: Vec3D): Vec3D;
                                add(vec: Vec2D): Vec2D;
                                /** @since 1.6.3 */
                                add(x1: double, y1: double, x2: double, y2: double): Vec2D;
                                /** @since 1.6.4 */
                                addStart(pos: Pos3D): Vec3D;
                                /** @since 1.6.4 */
                                addEnd(pos: Pos3D): Vec3D;
                                /** @since 1.6.4 */
                                addStart(x: double, y: double, z: double): Vec3D;
                                /** @since 1.6.4 */
                                addEnd(x: double, y: double, z: double): Vec3D;
                                /** @since 1.6.3 */
                                add(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): Vec3D;
                                multiply(vec: Vec3D): Vec3D;
                                /** @since 1.6.3 */
                                multiply(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): Vec3D;
                                multiply(vec: Vec2D): Vec2D;
                                /** @since 1.6.3 */
                                multiply(x1: double, y1: double, x2: double, y2: double): Vec2D;
                                /** @since 1.6.3 */
                                scale(scale: double): Vec3D;
                                /** @since 1.6.5 */
                                normalize(): Vec3D;
                                getPitch(): number;
                                getYaw(): number;
                                dotProduct(vec: Vec3D): number;
                                dotProduct(vec: Vec2D): number;
                                crossProduct(vec: Vec3D): Vec3D;
                                reverse(): Vec3D;
                                /** @since 1.6.5 */
                                toMojangFloatVector(): org.joml.Vector3f;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.2.6 [citation needed]
                             */
                            class Pos2D extends java.lang.Object {
                                static readonly class: JavaClass<Pos2D>;
                                /** @deprecated */ static prototype: undefined;

                                static readonly ZERO: Pos2D;

                                constructor (x: double, y: double);

                                x: number;
                                y: number;

                                getX(): number;
                                getY(): number;
                                add(pos: Pos2D): Pos2D;
                                /** @since 1.6.3 */
                                add(x: double, y: double): Pos2D;

                                /**
                                 * @param pos the position to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(pos: Pos2D): Pos2D;

                                /**
                                 * @param x the x coordinate to subtract
                                 * @param y the y coordinate to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(x: double, y: double): Pos2D;
                                multiply(pos: Pos2D): Pos2D;
                                /** @since 1.6.3 */
                                multiply(x: double, y: double): Pos2D;

                                /**
                                 * @param pos the position to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(pos: Pos2D): Pos2D;

                                /**
                                 * @param x the x coordinate to divide by
                                 * @param y the y coordinate to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(x: double, y: double): Pos2D;
                                /** @since 1.6.3 */
                                scale(scale: double): Pos2D;
                                to3D(): Pos3D;
                                toVector(): Vec2D;
                                /** @since 1.6.4 */
                                toVector(start_pos: Pos2D): Vec2D;
                                /** @since 1.6.4 */
                                toVector(start_x: double, start_y: double): Vec2D;
                                /** @since 1.6.4 */
                                toReverseVector(): Vec2D;
                                /** @since 1.6.4 */
                                toReverseVector(end_pos: Pos2D): Vec2D;
                                /** @since 1.6.4 */
                                toReverseVector(end_x: double, end_y: double): Vec2D;

                            }

                            export { Pos3D, Vec2D, Vec3D, Pos2D }

                        }

                        namespace render {


                            /**
                             * @author Wagyourtail
                             * @since 1.2.7
                             */
                            abstract class IScreen extends java.lang.Interface {
                                static readonly class: JavaClass<IScreen>;
                                /** @deprecated */ static prototype: undefined;
                            }
                            interface IScreen extends IDraw2D<IScreen> {

                                /** @since 1.2.7 */
                                getScreenClassName(): string;
                                /** @since 1.0.5 */
                                getTitleText(): string;

                                /**
                                 * in `1.3.1` updated to work with all button widgets not just ones added by scripts.
                                 * @since 1.0.5
                                 */
                                getButtonWidgets(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>>;

                                /**
                                 * in `1.3.1` updated to work with all text fields not just ones added by scripts.
                                 * @since 1.0.5
                                 */
                                getTextFields(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper>;

                                /**
                                 * @param callback calls your method as a {@link Consumer}<{@link ClickableWidgetHelper}>
                                 * @since 1.0.5
                                 */
                                addButton(x: int, y: int, width: int, height: int, text: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>;

                                /**
                                 * @param callback calls your method as a {@link Consumer}<{@link ClickableWidgetHelper}>
                                 * @since 1.4.0
                                 */
                                addButton(x: int, y: int, width: int, height: int, zIndex: int, text: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>;

                                /**
                                 * @param x the x position of the checkbox
                                 * @param y the y position of the checkbox
                                 * @param width the width of the checkbox
                                 * @param height the height of the checkbox
                                 * @param text the text to display next to the checkbox
                                 * @param checked whether the checkbox is checked or not
                                 * @param showMessage whether to show the message or not
                                 * @param callback calls your method as a
                                 *                     {@link Consumer}<{@link CheckBoxWidgetHelper}>
                                 * @return a {@link CheckBoxWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCheckbox(x: int, y: int, width: int, height: int, text: string, checked: boolean, showMessage: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;

                                /**
                                 * @param x the x position of the checkbox
                                 * @param y the y position of the checkbox
                                 * @param width the width of the checkbox
                                 * @param height the height of the checkbox
                                 * @param text the text to display next to the checkbox
                                 * @param checked whether the checkbox is checked or not
                                 * @param callback calls your method as a {@link Consumer}<{@link CheckBoxWidgetHelper}>
                                 * @return a {@link CheckBoxWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCheckbox(x: int, y: int, width: int, height: int, text: string, checked: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;

                                /**
                                 * @param x the x position of the checkbox
                                 * @param y the y position of the checkbox
                                 * @param width the width of the checkbox
                                 * @param height the height of the checkbox
                                 * @param zIndex the z-index of the checkbox
                                 * @param text the text to display next to the checkbox
                                 * @param checked whether the checkbox is checked or not
                                 * @param callback calls your method as a {@link Consumer}<{@link CheckBoxWidgetHelper}>
                                 * @return a {@link CheckBoxWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCheckbox(x: int, y: int, width: int, height: int, zIndex: int, text: string, checked: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;

                                /**
                                 * @param x the x position of the checkbox
                                 * @param y the y position of the checkbox
                                 * @param width the width of the checkbox
                                 * @param height the height of the checkbox
                                 * @param zIndex the z-index of the checkbox
                                 * @param text the text to display next to the checkbox
                                 * @param checked whether the checkbox is checked or not
                                 * @param showMessage whether to show the message or not
                                 * @param callback calls your method as a
                                 *                     {@link Consumer}<{@link CheckBoxWidgetHelper}>
                                 * @return a {@link CheckBoxWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCheckbox(x: int, y: int, width: int, height: int, zIndex: int, text: string, checked: boolean, showMessage: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;

                                /**
                                 * @param x the x position of the slider
                                 * @param y the y position of the slider
                                 * @param width the width of the slider
                                 * @param height the height of the slider
                                 * @param text the text to be displayed inside the slider
                                 * @param value the initial value of the slider
                                 * @param callback calls your method as a {@link Consumer}<{@link SliderWidgetHelper}>
                                 * @param steps the number of steps the slider should have
                                 * @return a {@link SliderWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addSlider(x: int, y: int, width: int, height: int, text: string, value: double, steps: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;

                                /**
                                 * @param x the x position of the slider
                                 * @param y the y position of the slider
                                 * @param width the width of the slider
                                 * @param height the height of the slider
                                 * @param zIndex the z-index of the slider
                                 * @param text the text to be displayed inside the slider
                                 * @param value the initial value of the slider
                                 * @param callback calls your method as a {@link Consumer}<{@link SliderWidgetHelper}>
                                 * @param steps the number of steps the slider should have
                                 * @return a {@link SliderWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addSlider(x: int, y: int, width: int, height: int, zIndex: int, text: string, value: double, steps: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;

                                /**
                                 * @param x the x position of the slider
                                 * @param y the y position of the slider
                                 * @param width the width of the slider
                                 * @param height the height of the slider
                                 * @param text the text to be displayed inside the slider
                                 * @param value the initial value of the slider
                                 * @param callback calls your method as a {@link Consumer}<{@link SliderWidgetHelper}>
                                 * @return a {@link SliderWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addSlider(x: int, y: int, width: int, height: int, text: string, value: double, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;

                                /**
                                 * @param x the x position of the slider
                                 * @param y the y position of the slider
                                 * @param width the width of the slider
                                 * @param height the height of the slider
                                 * @param zIndex the z-index of the slider
                                 * @param text the text to be displayed inside the slider
                                 * @param value the initial value of the slider
                                 * @param callback calls your method as a {@link Consumer}<{@link SliderWidgetHelper}>
                                 * @return a {@link SliderWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addSlider(x: int, y: int, width: int, height: int, zIndex: int, text: string, value: double, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;

                                /**
                                 * @param x the x position of the lock button
                                 * @param y the y position of the lock button
                                 * @param callback calls your method as a
                                 *                  {@link Consumer}<{@link LockButtonWidgetHelper}>
                                 * @return {*} {@link LockButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addLockButton(x: int, y: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper;

                                /**
                                 * @param x the x position of the lock button
                                 * @param y the y position of the lock button
                                 * @param zIndex the z-index of the lock button
                                 * @param callback calls your method as a
                                 *                  {@link Consumer}<{@link LockButtonWidgetHelper}>
                                 * @return {*} {@link LockButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addLockButton(x: int, y: int, zIndex: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper;

                                /**
                                 * @param x the x position of the cylcing button
                                 * @param y the y position of the cylcing button
                                 * @param width the width of the cylcing button
                                 * @param height the height of the cycling button
                                 * @param callback calls your method as a
                                 *                  {@link Consumer}<{@link CyclingButtonWidgetHelper}>
                                 * @param values the values to cycle through
                                 * @param initial the initial value of the cycling button
                                 * @return {*} {@link CyclingButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCyclingButton(x: int, y: int, width: int, height: int, values: string[], initial: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>;

                                /**
                                 * @param x the x position of the cylcing button
                                 * @param y the y position of the cylcing button
                                 * @param width the width of the cylcing button
                                 * @param height the height of the cycling button
                                 * @param zIndex the z-index of the cycling button
                                 * @param callback calls your method as a
                                 *                  {@link Consumer}<{@link CyclingButtonWidgetHelper}>
                                 * @param values the values to cycle through
                                 * @param initial the initial value of the cycling button
                                 * @return {*} {@link CyclingButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCyclingButton(x: int, y: int, width: int, height: int, zIndex: int, values: string[], initial: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>;

                                /**
                                 * @param x the x position of the cylcing button
                                 * @param y the y position of the cylcing button
                                 * @param width the width of the cylcing button
                                 * @param height the height of the cycling button
                                 * @param zIndex the z-index of the cycling button
                                 * @param callback calls your method as a
                                 *                      {@link Consumer}<{@link CyclingButtonWidgetHelper}>
                                 * @param values the values to cycle through
                                 * @param alternatives the alternative values to cycle through
                                 * @param prefix the prefix of the values
                                 * @param initial the initial value of the cycling button
                                 * @return {*} {@link CyclingButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCyclingButton(x: int, y: int, width: int, height: int, zIndex: int, values: string[], alternatives: string[], initial: string, prefix: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>;

                                /**
                                 * @param x the x position of the cylcing button
                                 * @param y the y position of the cylcing button
                                 * @param width the width of the cylcing button
                                 * @param height the height of the cycling button
                                 * @param zIndex the z-index of the cycling button
                                 * @param callback calls your method as a
                                 *                         {@link Consumer}<{@link CyclingButtonWidgetHelper}>
                                 * @param values the values to cycle through
                                 * @param alternatives the alternative values to cycle through
                                 * @param prefix the prefix of the values
                                 * @param initial the initial value of the cycling button
                                 * @param alternateToggle the method to determine if the cycling button should use the
                                 *                         alternative values
                                 * @return {*} {@link CyclingButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCyclingButton(x: int, y: int, width: int, height: int, zIndex: int, values: string[], alternatives: string[], initial: string, prefix: string, alternateToggle: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, boolean, any>, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>;

                                /**
                                 * @since 1.0.5
                                 * @deprecated
                                 */
                                removeButton(btn: xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>): IScreen;

                                /**
                                 * @param onChange calls your method as a {@link Consumer}<{@link String}>
                                 * @since 1.0.5
                                 */
                                addTextInput(x: int, y: int, width: int, height: int, message: string, onChange: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper;

                                /**
                                 * @param onChange calls your method as a {@link Consumer}<{@link String}>
                                 * @since 1.0.5
                                 */
                                addTextInput(x: int, y: int, width: int, height: int, zIndex: int, message: string, onChange: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper;

                                /**
                                 * @since 1.0.5
                                 * @deprecated
                                 */
                                removeTextInput(inp: xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper): IScreen;

                                /**
                                 * @param onMouseDown calls your method as a {@link BiConsumer}<{@link Pos2D}, {@link Integer}>
                                 * @since 1.2.7
                                 */
                                setOnMouseDown(onMouseDown: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D, int, any, any>): IScreen;

                                /**
                                 * @param onMouseDrag calls your method as a {@link BiConsumer}<{@link Vec2D}, {@link Integer}>
                                 * @since 1.2.7
                                 */
                                setOnMouseDrag(onMouseDrag: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Vec2D, int, any, any>): IScreen;

                                /**
                                 * @param onMouseUp calls your method as a {@link BiConsumer}<{@link Pos2D}, {@link Integer}>
                                 * @since 1.2.7
                                 */
                                setOnMouseUp(onMouseUp: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D, int, any, any>): IScreen;

                                /**
                                 * @param onScroll calls your method as a {@link BiConsumer}<{@link Pos2D}, {@link Double}>
                                 * @since 1.2.7
                                 */
                                setOnScroll(onScroll: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D, xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D, any, any>): IScreen;

                                /**
                                 * @param onKeyPressed calls your method as a {@link BiConsumer}<{@link Integer}, {@link Integer}>
                                 * @since 1.2.7
                                 */
                                setOnKeyPressed(onKeyPressed: xyz.wagyourtail.jsmacros.core.MethodWrapper<int, int, any, any>): IScreen;

                                /**
                                 * @param onCharTyped calls your method as a {@link BiConsumer}<{@link Character}, {@link Integer}>
                                 * @since 1.8.4
                                 */
                                setOnCharTyped(onCharTyped: xyz.wagyourtail.jsmacros.core.MethodWrapper<char, int, any, any>): IScreen;

                                /**
                                 * @param onClose calls your method as a {@link Consumer}<{@link IScreen}>
                                 * @since 1.2.7
                                 */
                                setOnClose(onClose: xyz.wagyourtail.jsmacros.core.MethodWrapper<IScreen, any, any, any>): IScreen;
                                /** @since 1.1.9 */
                                close(): void;

                                /**
                                 * calls the screen's init function re-loading it.
                                 * @since 1.2.7
                                 */
                                reloadScreen(): IScreen;

                                /**
                                 * @return a new builder for buttons.
                                 * @since 1.8.4
                                 */
                                buttonBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper$ButtonBuilder;

                                /**
                                 * @return a new builder for checkboxes.
                                 * @since 1.8.4
                                 */
                                checkBoxBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper$CheckBoxBuilder;

                                /**
                                 * @param checked whether the checkbox should be checked by default
                                 * @return a new builder for checkboxes.
                                 * @since 1.8.4
                                 */
                                checkBoxBuilder(checked: boolean): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper$CheckBoxBuilder;

                                /**
                                 * @return a new builder for cycling buttons.
                                 * @since 1.8.4
                                 */
                                cyclicButtonBuilder(valueToText: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper$CyclicButtonBuilder<any>;

                                /**
                                 * @return a new builder for lock buttons.
                                 * @since 1.8.4
                                 */
                                lockButtonBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper$LockButtonBuilder;

                                /**
                                 * @param locked whether the lock button should be locked by default
                                 * @return a new builder for lock buttons.
                                 * @since 1.8.4
                                 */
                                lockButtonBuilder(locked: boolean): xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper$LockButtonBuilder;

                                /**
                                 * @return a new builder for sliders.
                                 * @since 1.8.4
                                 */
                                sliderBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper$SliderBuilder;

                                /**
                                 * @return a new builder for text fields.
                                 * @since 1.8.4
                                 */
                                textFieldBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper$TextFieldBuilder;

                                /**
                                 * @return a new builder for textured buttons.
                                 * @since 1.8.4
                                 */
                                texturedButtonBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @return `true` if the shift key is pressed, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isShiftDown(): boolean;

                                /**
                                 * @return `true` if the ctrl key is pressed, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isCtrlDown(): boolean;

                                /**
                                 * @return `true` if the alt key is pressed, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isAltDown(): boolean;
                                getOnClose(): xyz.wagyourtail.jsmacros.core.MethodWrapper<IScreen, any, any, any> | null;

                            }


                            /**
                             * @author Wagyourtail
                             * @see IDraw2D
                             * @since 1.0.5
                             */
                            interface Draw2D extends IDraw2D<Draw2D> {}
                            class Draw2D extends java.lang.Object {
                                static readonly class: JavaClass<Draw2D>;
                                /** @deprecated */ static prototype: undefined;

                                constructor ();

                                widthSupplier: java.util.function.IntSupplier;
                                heightSupplier: java.util.function.IntSupplier;
                                zIndex: number;
                                visible: boolean;

                                /**
                                 * @since 1.0.5
                                 * @deprecated please use {@link Draw2D.setOnInit}(MethodWrapper)
                                 */
                                onInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<Draw2D, any, any, any> | null;

                                /**
                                 * @since 1.1.9 [citation needed]
                                 * @deprecated please use {@link Draw2D.setOnFailInit}(MethodWrapper)
                                 */
                                catchInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, any, any, any> | null;

                                /**
                                 * @see IDraw2D.getWidth()
                                 * @since 1.0.5
                                 */
                                getWidth(): number;

                                /**
                                 * @see IDraw2D.getHeight()
                                 * @since 1.0.5
                                 */
                                getHeight(): number;

                                /**
                                 * @see IDraw2D.getTexts()
                                 * @since 1.0.5
                                 */
                                getTexts(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text>;

                                /**
                                 * @see IDraw2D.getRects()
                                 * @since 1.0.5
                                 */
                                getRects(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect>;
                                getLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line>;

                                /**
                                 * @see IDraw2D.getItems()
                                 * @since 1.0.5
                                 */
                                getItems(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item>;

                                /**
                                 * @see IDraw2D.getImages()
                                 * @since 1.2.3
                                 */
                                getImages(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image>;
                                getDraw2Ds(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement>;
                                getElements(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>;
                                removeElement(e: xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement): Draw2D;
                                reAddElement<T extends xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>(e: T): T;

                                /**
                                 * @param visible whether to render this element.
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setVisible(visible: boolean): this;

                                /**
                                 * @return `true` if this draw2d is visible, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isVisible(): boolean;
                                addDraw2D(draw2D: Draw2D, x: int, y: int, width: int, height: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;
                                addDraw2D(draw2D: Draw2D, x: int, y: int, width: int, height: int, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;
                                removeDraw2D(draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement): Draw2D;

                                /**
                                 * @see IDraw2D.addText(String, int, int, int, boolean)
                                 * @since 1.0.5
                                 */
                                addText(text: string, x: int, y: int, color: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @see IDraw2D.addText(String, int, int, int, boolean, double, double)
                                 * @since 1.2.6
                                 */
                                addText(text: string, x: int, y: int, color: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @see IDraw2D.removeText(Text)
                                 * @since 1.0.5
                                 */
                                removeText(t: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text): Draw2D;

                                /**
                                 * @see IDraw2D.addImage(int, int, int, int, String, int, int, int, int, int, int)
                                 * @since 1.2.3
                                 */
                                addImage(x: int, y: int, width: int, height: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @see IDraw2D.addImage(int, int, int, int, String, int, int, int, int, int, int, double)
                                 * @since 1.2.6
                                 */
                                addImage(x: int, y: int, width: int, height: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @see IDraw2D.addImage(int, int, int, int, int, String, int, int, int, int, int, int, double)
                                 * @since 1.4.0
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @see IDraw2D.addImage(int, int, int, int, int, int, String, int, int, int, int, int, int, double)
                                 * @since 1.6.5
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @see IDraw2D.addImage(int, int, int, int, int, int, int, String, int, int, int, int, int, int, double)
                                 * @since 1.6.5
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, alpha: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @see IDraw2D.removeImage(Image)
                                 * @since 1.2.3
                                 */
                                removeImage(i: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image): Draw2D;

                                /**
                                 * @see IDraw2D.addRect(int, int, int, int, int)
                                 * @since 1.0.5
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @see IDraw2D.addRect(int, int, int, int, int, int)
                                 * @since 1.1.8
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @see IDraw2D.addRect(int, int, int, int, int, int, double)
                                 * @since 1.2.6
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: double, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @see IDraw2D.removeRect(Rect)
                                 * @since 1.0.5
                                 */
                                removeRect(r: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect): Draw2D;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, width: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int, width: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, width: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int, width: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                removeLine(l: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line): Draw2D;

                                /**
                                 * @see IDraw2D.addItem(int, int, String)
                                 * @since 1.0.5
                                 */
                                addItem(x: int, y: int, id: string): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, id: string): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @see IDraw2D.addItem(int, int, String, boolean)
                                 * @since 1.2.0
                                 */
                                addItem(x: int, y: int, id: string, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, id: string, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @see IDraw2D.addItem(int, int, String, boolean, double, double)
                                 * @since 1.2.0
                                 */
                                addItem(x: int, y: int, id: string, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, id: string, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @see IDraw2D.addItem(int, int, ItemStackHelper)
                                 * @since 1.0.5
                                 */
                                addItem(x: int, y: int, Item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @see IDraw2D.addItem(int, int, ItemStackHelper, boolean)
                                 * @since 1.2.0
                                 */
                                addItem(x: int, y: int, Item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @see IDraw2D.addItem(int, int, ItemStackHelper, boolean, double, double)
                                 * @since 1.2.6
                                 */
                                addItem(x: int, y: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @see IDraw2D.removeItem(Item)
                                 * @since 1.0.5
                                 */
                                removeItem(i: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item): Draw2D;
                                init(): void;
                                getElementsByZIndex(): java.util.Iterator<xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>;

                                /**
                                 * init function, called when window is resized or screen/draw2d is registered.  
                                 *  clears all previous elements when called.
                                 * @param onInit calls your method as a {@link java.util.function.Consumer}<{@link Draw2D}>
                                 * @see IDraw2D.setOnInit(MethodWrapper)
                                 * @since 1.2.7
                                 */
                                setOnInit(onInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<Draw2D, any, any, any> | null): Draw2D;

                                /**
                                 * @param catchInit calls your method as a {@link java.util.function.Consumer}<string>
                                 * @see IDraw2D.setOnFailInit(MethodWrapper)
                                 * @since 1.2.7
                                 */
                                setOnFailInit(catchInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, any, any, any> | null): Draw2D;

                                /**
                                 * register so the overlay actually renders
                                 * @return self for chaining
                                 * @since 1.6.5
                                 */
                                register(): this;

                                /**
                                 * unregister so the overlay stops rendering
                                 * @return self for chaining
                                 * @since 1.6.5
                                 */
                                unregister(): this;
                                setZIndex(zIndex: int): void;
                                getZIndex(): number;

                            }


                            /**
                             * just go look at {@link IScreen}
                             *  since all the methods are done through a mixin...
                             * @author Wagyourtail
                             * @see IScreen
                             * @since 1.0.5
                             */
                            class ScriptScreen extends xyz.wagyourtail.wagyourgui.BaseScreen {
                                static readonly class: JavaClass<ScriptScreen>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (title: string, dirt: boolean);

                                drawTitle: boolean;

                                /**
                                 * @since 1.8.4
                                 *  WARNING: this can break the game if you set it false and don't have a way to close the screen.
                                 */
                                shouldCloseOnEsc: boolean;
                                /** @since 1.8.4 */
                                shouldPause: boolean;

                                /**
                                 * @param parent parent screen to go to when this one exits.
                                 * @since 1.4.0
                                 */
                                setParent(parent: IScreen): void;
                                setParent(parent: /* net.minecraft.client.gui.screen.Screen */ any): void;

                                /**
                                 * add custom stuff to the render function on the main thread.
                                 * @param onRender pos3d elements are mousex, mousey, tickDelta
                                 * @since 1.4.0
                                 */
                                setOnRender(onRender: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, /* net.minecraft.client.gui.DrawContext */ any, any, any> | null): void;

                            }


                            /**
                             * {@link Draw2D} is cool
                             * @author Wagyourtail
                             * @since 1.0.6
                             */
                            class Draw3D extends java.lang.Object {
                                static readonly class: JavaClass<Draw3D>;
                                /** @deprecated */ static prototype: undefined;

                                constructor ();

                                /** @since 1.0.6 */
                                getBoxes(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box>;
                                /** @since 1.0.6 */
                                getLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D>;
                                /** @since 1.9.0 */
                                getTraceLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine>;
                                /** @since 1.9.0 */
                                getEntityTraceLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.EntityTraceLine>;
                                /** @since 1.6.5 */
                                getDraw2Ds(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface>;
                                /** @since 1.8.4 */
                                clear(): void;
                                /** @since 1.8.4 */
                                reAddElement(element: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.RenderElement3D): void;
                                /** @since 1.8.4 */
                                addBox(box: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box): void;
                                /** @since 1.8.4 */
                                addLine(line: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D): void;
                                /** @since 1.9.0 */
                                addTraceLine(line: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine): void;
                                /** @since 1.8.4 */
                                addSurface(surface: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface): void;

                                /**
                                 * @return The {@link Box} you added.
                                 * @since 1.0.6
                                 */
                                addBox(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, fillColor: int, fill: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;
                                /** @since 1.3.1 */
                                addBox(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, fillColor: int, fill: boolean, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * @return the {@link Box} you added.
                                 * @since 1.1.8
                                 */
                                addBox(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, fillColor: int, fillAlpha: int, fill: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;
                                addBox(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, fillColor: int, fillAlpha: int, fill: boolean, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;
                                /** @since 1.0.6 */
                                removeBox(b: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box): Draw3D;

                                /**
                                 * @return the {@link Line3D} you added.
                                 * @since 1.0.6
                                 */
                                addLine(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;
                                /** @since 1.3.1 */
                                addLine(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;

                                /**
                                 * @return the {@link Line3D} you added.
                                 * @since 1.1.8
                                 */
                                addLine(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;
                                /** @since 1.3.1 */
                                addLine(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;
                                /** @since 1.0.6 */
                                removeLine(l: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D): Draw3D;
                                /** @since 1.9.0 */
                                addTraceLine(x: double, y: double, z: double, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine;
                                /** @since 1.9.0 */
                                addTraceLine(x: double, y: double, z: double, color: int, alpha: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine;
                                /** @since 1.9.0 */
                                addTraceLine(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine;
                                /** @since 1.9.0 */
                                addTraceLine(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, color: int, alpha: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine;
                                /** @since 1.9.0 */
                                addEntityTraceLine(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.EntityTraceLine;
                                /** @since 1.9.0 */
                                addEntityTraceLine(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>, color: int, alpha: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.EntityTraceLine;
                                /** @since 1.9.0 */
                                addEntityTraceLine(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>, color: int, alpha: int, yOffset: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.EntityTraceLine;

                                /**
                                 * @return self for chaining
                                 * @since 1.9.0
                                 */
                                removeTraceLine(traceLine: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine): this;

                                /**
                                 * Draws a cube({@link Box}) with a specific radius(`side length = 2*radius`)
                                 * @param point the center point
                                 * @param radius 1/2 of the side length of the cube
                                 * @param color point color
                                 * @return the {@link Box} generated, and visualized
                                 * @see Box
                                 * @since 1.4.0
                                 */
                                addPoint(point: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, radius: double, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * Draws a cube({@link Box}) with a specific radius(`side length = 2*radius`)
                                 * @param x x value of the center point
                                 * @param y y value of the center point
                                 * @param z z value of the center point
                                 * @param radius 1/2 of the side length of the cube
                                 * @param color point color
                                 * @return the {@link Box} generated, and visualized
                                 * @see Box
                                 * @since 1.4.0
                                 */
                                addPoint(x: double, y: double, z: double, radius: double, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * Draws a cube({@link Box}) with a specific radius(`side length = 2*radius`)
                                 * @param x x value of the center point
                                 * @param y y value of the center point
                                 * @param z z value of the center point
                                 * @param radius 1/2 of the side length of the cube
                                 * @param color point color
                                 * @param alpha alpha of the point
                                 * @param cull whether to cull the point or not
                                 * @return the {@link Box} generated, and visualized
                                 * @see Box
                                 * @since 1.4.0
                                 */
                                addPoint(x: double, y: double, z: double, radius: double, color: int, alpha: int, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * @param x top left
                                 * @since 1.6.5
                                 */
                                addDraw2D(x: double, y: double, z: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;
                                /** @since 1.6.5 */
                                addDraw2D(x: double, y: double, z: double, width: double, height: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;
                                /** @since 1.6.5 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;
                                /** @since 1.6.5 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double, width: double, height: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;
                                /** @since 1.6.5 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double, width: double, height: double, minSubdivisions: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;
                                /** @since 1.6.5 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double, width: double, height: double, minSubdivisions: int, renderBack: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;

                                /**
                                 * @param x top left
                                 * @since 1.6.5
                                 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double, width: double, height: double, minSubdivisions: int, renderBack: boolean, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;
                                /** @since 1.6.5 */
                                removeDraw2D(surface: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface): void;

                                /**
                                 * @return a new {@link Box.Builder} instance.
                                 * @since 1.8.4
                                 */
                                boxBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box$Builder;

                                /**
                                 * @param pos the block position of the box
                                 * @return a new {@link Box.Builder} instance.
                                 * @since 1.8.4
                                 */
                                boxBuilder(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box$Builder;

                                /**
                                 * @param x the x coordinate of the box
                                 * @param y the y coordinate of the box
                                 * @param z the z coordinate of the box
                                 * @return a new {@link Box.Builder} instance.
                                 * @since 1.8.4
                                 */
                                boxBuilder(x: int, y: int, z: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box$Builder;

                                /**
                                 * @return a new {@link Line3D.Builder} instance.
                                 * @since 1.8.4
                                 */
                                lineBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D$Builder;

                                /**
                                 * @return a new {@link TraceLine.Builder} instance.
                                 * @since 1.9.0
                                 */
                                traceLineBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine$Builder;

                                /**
                                 * @return a new {@link EntityTraceLine.Builder} instance.
                                 * @since 1.9.0
                                 */
                                entityTraceLineBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.EntityTraceLine$Builder;

                                /**
                                 * @return a new {@link Surface.Builder} instance.
                                 * @since 1.8.4
                                 */
                                surfaceBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface$Builder;

                                /**
                                 * register so it actually shows up
                                 * @return self for chaining
                                 * @since 1.6.5
                                 */
                                register(): this;

                                /**
                                 * @return self for chaining
                                 * @since 1.6.5
                                 */
                                unregister(): this;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.2.7
                             */
                            abstract class IDraw2D<T> extends java.lang.Interface {
                                static readonly class: JavaClass<IDraw2D<any>>;
                                /** @deprecated */ static prototype: undefined;
                            }
                            interface IDraw2D<T> {

                                /**
                                 * @return screen width
                                 * @since 1.2.7
                                 */
                                getWidth(): number;

                                /**
                                 * @return screen height
                                 * @since 1.2.7
                                 */
                                getHeight(): number;

                                /**
                                 * @return text elements
                                 * @since 1.2.7
                                 * @deprecated
                                 */
                                getTexts(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text>;

                                /**
                                 * @return rect elements
                                 * @since 1.2.7
                                 * @deprecated
                                 */
                                getRects(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect>;

                                /**
                                 * @return all registered line elements.
                                 * @since 1.8.4
                                 */
                                getLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line>;

                                /**
                                 * @return item elements
                                 * @since 1.2.7
                                 * @deprecated
                                 */
                                getItems(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item>;

                                /**
                                 * @return image elements
                                 * @since 1.2.7
                                 * @deprecated
                                 */
                                getImages(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image>;

                                /**
                                 * @return all registered draw2d elements.
                                 * @since 1.8.4
                                 */
                                getDraw2Ds(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement>;

                                /**
                                 * @return a read only copy of the list of all elements added by scripts.
                                 * @since 1.2.9
                                 */
                                getElements(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>;

                                /**
                                 * removes any element regardless of type.
                                 * @return self for chaining
                                 * @since 1.2.9
                                 */
                                removeElement(e: xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement): T;

                                /**
                                 * re-add an element you removed with {@link removeElement}(RenderElement)
                                 * @return self for chaining
                                 * @since 1.2.9
                                 */
                                reAddElement<T extends xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>(e: T): T;

                                /**
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param shadow include shadow layer
                                 * @return added text
                                 * @since 1.2.7
                                 */
                                addText(text: string, x: int, y: int, color: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param zIndex z-index
                                 * @param shadow include shadow layer
                                 * @return added text
                                 * @since 1.4.0
                                 */
                                addText(text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param shadow include shadow layer
                                 * @param scale text scale (as double)
                                 * @param rotation text rotation (as degrees)
                                 * @return added text
                                 * @since 1.2.7
                                 */
                                addText(text: string, x: int, y: int, color: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param zIndex z-index
                                 * @param shadow include shadow layer
                                 * @param scale text scale (as double)
                                 * @param rotation text rotation (as degrees)
                                 * @return added text
                                 * @since 1.4.0
                                 */
                                addText(text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param shadow include shadow layer
                                 * @return added text
                                 * @since 1.2.7
                                 */
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param zIndex z-index
                                 * @param shadow include shadow layer
                                 * @return added text
                                 * @since 1.4.0
                                 */
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param shadow include shadow layer
                                 * @param scale text scale (as double)
                                 * @param rotation text rotation (as degrees)
                                 * @return added text
                                 * @since 1.2.7
                                 */
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param zIndex z-index
                                 * @param shadow include shadow layer
                                 * @param scale text scale (as double)
                                 * @param rotation text rotation (as degrees)
                                 * @return added text
                                 * @since 1.4.0
                                 */
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @return self for chaining
                                 * @since 1.2.7
                                 * @deprecated
                                 */
                                removeText(t: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text): T;

                                /**
                                 * @param x screen x, top left corner
                                 * @param y screen y, top left corner
                                 * @param width width on screen
                                 * @param height height on screen
                                 * @param id image id, in the form `minecraft:textures` path'd as found in texture packs, ie `assets/minecraft/textures/gui/recipe_book.png` becomes `minecraft:textures/gui/recipe_book.png`
                                 * @param imageX the left-most coordinate of the texture region
                                 * @param imageY the top-most coordinate of the texture region
                                 * @param regionWidth the width the texture region
                                 * @param regionHeight the height the texture region
                                 * @param textureWidth the width of the entire texture
                                 * @param textureHeight the height of the entire texture
                                 * @return added image
                                 * @since 1.2.7
                                 */
                                addImage(x: int, y: int, width: int, height: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @param x screen x, top left corner
                                 * @param y screen y, top left corner
                                 * @param width width on screen
                                 * @param height height on screen
                                 * @param zIndex z-index
                                 * @param id image id, in the form `minecraft:textures` path'd as found in texture packs, ie `assets/minecraft/textures/gui/recipe_book.png` becomes `minecraft:textures/gui/recipe_book.png`
                                 * @param imageX the left-most coordinate of the texture region
                                 * @param imageY the top-most coordinate of the texture region
                                 * @param regionWidth the width the texture region
                                 * @param regionHeight the height the texture region
                                 * @param textureWidth the width of the entire texture
                                 * @param textureHeight the height of the entire texture
                                 * @return added image
                                 * @since 1.4.0
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @param x screen x, top left corner
                                 * @param y screen y, top left corner
                                 * @param width width on screen
                                 * @param height height on screen
                                 * @param id image id, in the form `minecraft:textures` path'd as found in texture packs, ie `assets/minecraft/textures/gui/recipe_book.png` becomes `minecraft:textures/gui/recipe_book.png`
                                 * @param imageX the left-most coordinate of the texture region
                                 * @param imageY the top-most coordinate of the texture region
                                 * @param regionWidth the width the texture region
                                 * @param regionHeight the height the texture region
                                 * @param textureWidth the width of the entire texture
                                 * @param textureHeight the height of the entire texture
                                 * @param rotation the rotation (clockwise) of the texture (as degrees)
                                 * @return added image
                                 * @since 1.2.7
                                 */
                                addImage(x: int, y: int, width: int, height: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @param x screen x, top left corner
                                 * @param y screen y, top left corner
                                 * @param width width on screen
                                 * @param height height on screen
                                 * @param zIndex z-index
                                 * @param id image id, in the form `minecraft:textures` path'd as found in texture packs, ie `assets/minecraft/textures/gui/recipe_book.png` becomes `minecraft:textures/gui/recipe_book.png`
                                 * @param imageX the left-most coordinate of the texture region
                                 * @param imageY the top-most coordinate of the texture region
                                 * @param regionWidth the width the texture region
                                 * @param regionHeight the height the texture region
                                 * @param textureWidth the width of the entire texture
                                 * @param textureHeight the height of the entire texture
                                 * @param rotation the rotation (clockwise) of the texture (as degrees)
                                 * @return added image
                                 * @since 1.4.0
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;
                                /** @since 1.6.5 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;
                                /** @since 1.6.5 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, alpha: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @return self for chaining
                                 * @since 1.2.7
                                 * @deprecated
                                 */
                                removeImage(i: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image): T;

                                /**
                                 * @param color as hex, with alpha channel
                                 * @return added rect
                                 * @since 1.2.7
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @param color as hex
                                 * @param alpha alpha channel 0-255
                                 * @return added rect
                                 * @since 1.2.7
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @param color as hex
                                 * @param alpha alpha channel 0-255
                                 * @param rotation as degrees
                                 * @return added rect
                                 * @since 1.2.7
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @param color as hex
                                 * @param alpha alpha channel 0-255
                                 * @param rotation as degrees
                                 * @param zIndex z-index
                                 * @return added rect
                                 * @since 1.4.0
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: double, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @return self for chaining
                                 * @since 1.2.7
                                 * @deprecated
                                 */
                                removeRect(r: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect): T;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param zIndex the z-index of the line
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param width the width of the line
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, width: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param zIndex the z-index of the line
                                 * @param width the width of the line
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int, width: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param width the width of the line
                                 * @param rotation the rotation (clockwise) of the line (as degrees)
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, width: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param zIndex the z-index of the line
                                 * @param width the width of the line
                                 * @param rotation the rotation (clockwise) of the line (as degrees)
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int, width: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param l the line to remove
                                 * @return self chaining.
                                 * @since 1.8.4
                                 */
                                removeLine(l: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line): T;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param id item id
                                 * @return added item
                                 * @since 1.2.7
                                 */
                                addItem(x: int, y: int, id: ItemId): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param id item id
                                 * @return added item
                                 * @since 1.4.0
                                 */
                                addItem(x: int, y: int, zIndex: int, id: ItemId): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param id item id
                                 * @param overlay should include overlay health and count
                                 * @return added item
                                 * @since 1.2.7
                                 */
                                addItem(x: int, y: int, id: ItemId, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param id item id
                                 * @param overlay should include overlay health and count
                                 * @return added item
                                 * @since 1.4.0
                                 */
                                addItem(x: int, y: int, zIndex: int, id: ItemId, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param id item id
                                 * @param overlay should include overlay health and count
                                 * @param scale scale of item
                                 * @param rotation rotation of item
                                 * @return added item
                                 * @since 1.2.7
                                 */
                                addItem(x: int, y: int, id: ItemId, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param id item id
                                 * @param overlay should include overlay health and count
                                 * @param scale scale of item
                                 * @param rotation rotation of item
                                 * @return added item
                                 * @since 1.4.0
                                 */
                                addItem(x: int, y: int, zIndex: int, id: ItemId, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param item from inventory as helper
                                 * @return added item
                                 * @since 1.2.7
                                 */
                                addItem(x: int, y: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param item from inventory as helper
                                 * @return added item
                                 * @since 1.4.0
                                 */
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param item from inventory as helper
                                 * @param overlay should include overlay health and count
                                 * @return added item
                                 * @since 1.2.7
                                 */
                                addItem(x: int, y: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param item from inventory as helper
                                 * @param overlay should include overlay health and count
                                 * @return added item
                                 * @since 1.4.0
                                 */
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param item from inventory as helper
                                 * @param overlay should include overlay health and count
                                 * @param scale scale of item
                                 * @param rotation rotation of item
                                 * @return added item
                                 * @since 1.2.7
                                 */
                                addItem(x: int, y: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param item from inventory as helper
                                 * @param overlay should include overlay health and count
                                 * @param scale scale of item
                                 * @param rotation rotation of item
                                 * @return added item
                                 * @since 1.4.0
                                 */
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @return self for chaining
                                 * @since 1.2.7
                                 * @deprecated
                                 */
                                removeItem(i: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item): T;

                                /**
                                 * Tries to add the given draw2d as a child. Fails if cyclic dependencies are detected.
                                 * @param draw2D the draw2d to add
                                 * @param x the x position on this draw2d
                                 * @param y the y position on this draw2d
                                 * @param width the width of the given draw2d
                                 * @param height the height of the given draw2d
                                 * @return a wrapper for the draw2d.
                                 * @since 1.8.4
                                 */
                                addDraw2D(draw2D: Draw2D, x: int, y: int, width: int, height: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;

                                /**
                                 * Tries to add the given draw2d as a child. Fails if cyclic dependencies are detected.
                                 * @param draw2D the draw2d to add
                                 * @param x the x position on this draw2d
                                 * @param y the y position on this draw2d
                                 * @param width the width of the given draw2d
                                 * @param height the height of the given draw2d
                                 * @param zIndex the z-index for the draw2d
                                 * @return a wrapper for the draw2d.
                                 * @since 1.8.4
                                 */
                                addDraw2D(draw2D: Draw2D, x: int, y: int, width: int, height: int, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;

                                /**
                                 * @param draw2D the draw2d to remove
                                 * @return self chaining.
                                 * @since 1.8.4
                                 */
                                removeDraw2D(draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement): T;

                                /**
                                 * @return a builder for an {@link Item}.
                                 * @since 1.8.4
                                 */
                                itemBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item$Builder;

                                /**
                                 * @param item the item to use
                                 * @return a builder for an {@link Item}.
                                 * @since 1.8.4
                                 */
                                itemBuilder(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item$Builder;

                                /**
                                 * @return a builder for an {@link Image}.
                                 * @since 1.8.4
                                 */
                                imageBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image$Builder;

                                /**
                                 * @param id the id of the image
                                 * @return a builder for an {@link Image}.
                                 * @since 1.8.4
                                 */
                                imageBuilder(id: string): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image$Builder;

                                /**
                                 * @return a builder for a {@link Rect}.
                                 * @since 1.8.4
                                 */
                                rectBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect$Builder;

                                /**
                                 * @param x the x position of the rectangle
                                 * @param y the y position of the rectangle
                                 * @param width the width of the rectangle
                                 * @param height the height of the rectangle
                                 * @return a builder for a {@link Rect}.
                                 * @since 1.8.4
                                 */
                                rectBuilder(x: int, y: int, width: int, height: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect$Builder;

                                /**
                                 * @return a builder for a {@link Line}.
                                 * @since 1.8.4
                                 */
                                lineBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line$Builder;

                                /**
                                 * @param x1 the x position of the first point
                                 * @param y1 the y position of the first point
                                 * @param x2 the x position of the second point
                                 * @param y2 the y position of the second point
                                 * @return a builder for a {@link Line}.
                                 * @since 1.8.4
                                 */
                                lineBuilder(x1: int, y1: int, x2: int, y2: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line$Builder;

                                /**
                                 * @return a builder for a {@link Text}.
                                 * @since 1.8.4
                                 */
                                textBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text$Builder;

                                /**
                                 * @param text the text to display
                                 * @return a builder for a {@link Text}.
                                 * @since 1.8.4
                                 */
                                textBuilder(text: string): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text$Builder;

                                /**
                                 * @param text the text to display
                                 * @return a builder for a {@link Text}.
                                 * @since 1.8.4
                                 */
                                textBuilder(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text$Builder;

                                /**
                                 * @param draw2D the draw2d to add
                                 * @return a builder for a {@link Draw2D}.
                                 * @since 1.8.4
                                 */
                                draw2DBuilder(draw2D: Draw2D): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement$Builder;

                                /**
                                 * @param onInit calls your method as a {@link Consumer}<{@link T}>
                                 * @return self for chaining
                                 * @since 1.2.7
                                 */
                                setOnInit(onInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<T, any, any, any>): T;

                                /**
                                 * @param catchInit calls your method as a {@link Consumer}<{@link String}>
                                 * @return self for chaining
                                 * @since 1.2.7
                                 */
                                setOnFailInit(catchInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, any, any, any>): T;
                                /** @since 1.8.4 */
                                setZIndex(zIndex: int): void;
                                /** @since 1.8.4 */
                                getZIndex(): number;

                            }

                            export { IScreen, Draw2D, ScriptScreen, Draw3D, IDraw2D }

                        }
                        namespace render {

                            namespace components {


                                /**
                                 * @author Wagyourtail
                                 * @since 1.0.5
                                 */
                                interface Rect extends RenderElement, Alignable<Rect> {}
                                class Rect extends java.lang.Object {
                                    static readonly class: JavaClass<Rect>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (x1: int, y1: int, x2: int, y2: int, color: int, rotation: float, zIndex: int);
                                    constructor (x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: float, zIndex: int);

                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any> | null;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    x1: number;
                                    y1: number;
                                    x2: number;
                                    y2: number;
                                    color: number;
                                    zIndex: number;

                                    /**
                                     * @param x1 the first x position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX1(x1: int): this;

                                    /**
                                     * @return the first x position of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getX1(): number;

                                    /**
                                     * @param y1 the first y position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY1(y1: int): this;

                                    /**
                                     * @return the first y position of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getY1(): number;

                                    /**
                                     * @param x1 the first x position of this rectangle
                                     * @param y1 the first y position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos1(x1: int, y1: int): this;

                                    /**
                                     * @param x2 the second x position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX2(x2: int): this;

                                    /**
                                     * @return the second x position of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getX2(): number;

                                    /**
                                     * @param y2 the second y position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY2(y2: int): this;

                                    /**
                                     * @return the second y position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getY2(): number;

                                    /**
                                     * @param x2 the second x position of this rectangle
                                     * @param y2 the second y position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos2(x2: int, y2: int): this;
                                    /** @since 1.1.8 */
                                    setPos(x1: int, y1: int, x2: int, y2: int): Rect;

                                    /**
                                     * @param width the new width of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWidth(width: int): this;

                                    /**
                                     * @return the width of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the new height of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setHeight(height: int): this;

                                    /**
                                     * @return the height of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the new width of this rectangle
                                     * @param height the new height of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setSize(width: int, height: int): this;
                                    /** @since 1.0.5 */
                                    setColor(color: int): Rect;
                                    /** @since 1.1.8 */
                                    setColor(color: int, alpha: int): Rect;
                                    /** @since 1.1.8 */
                                    setAlpha(alpha: int): Rect;

                                    /**
                                     * @return the color value of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @return the alpha value of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;
                                    /** @since 1.2.6 */
                                    setRotation(rotation: double): Rect;

                                    /**
                                     * @return the rotation of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this rectangle should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this rectangle should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the new z-index for this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): this;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Rect;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Rect;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                interface Item$Builder extends Alignable<Item$Builder> {}
                                class Item$Builder extends RenderElementBuilder<Item> {
                                    static readonly class: JavaClass<Item$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>);

                                    /**
                                     * @param x the x position of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x(x: int): this;

                                    /**
                                     * @return the x position of the item.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y(y: int): this;

                                    /**
                                     * @return the y position of the item.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position of the item
                                     * @param y the y position of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: int, y: int): this;

                                    /**
                                     * @param item the item to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    item(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): this;

                                    /**
                                     * @param id the id of the item to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    item(id: CanOmitNamespace<ItemId>): this;

                                    /**
                                     * @param id the id of the item to draw
                                     * @param count the stack size
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    item(id: ItemId, count: int): this;

                                    /**
                                     * @return the item to be drawn.
                                     * @since 1.8.4
                                     */
                                    getItem(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * This also sets the overlay to be shown.
                                     * @param overlayText the overlay text
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    overlayText(overlayText: string): this;

                                    /**
                                     * @return the overlay text.
                                     * @since 1.8.4
                                     */
                                    getOverlayText(): string;

                                    /**
                                     * @param visible whether the overlay should be visible or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    overlayVisible(visible: boolean): this;

                                    /**
                                     * @return `true` if the overlay should be visible, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isOverlayVisible(): boolean;

                                    /**
                                     * @param scale the scale of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    scale(scale: double): this;

                                    /**
                                     * @return the scale of the item.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the item in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): this;

                                    /**
                                     * @return the rotation (clockwise) of the item in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether the item should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this item should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the z-index of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): this;

                                    /**
                                     * @return the z-index of the item.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Item$Builder;

                                }


                                /**
                                 * @author Wagyourtail
                                 */
                                abstract class RenderElement extends java.lang.Interface {
                                    static readonly class: JavaClass<RenderElement>;
                                    /** @deprecated */ static prototype: undefined;

                                    static readonly mc: /* net.minecraft.client.MinecraftClient */ any;
                                }
                                interface RenderElement extends /* net.minecraft.client.gui.Drawable */ JavaObject {

                                    getZIndex(): number;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                interface Text$Builder extends Alignable<Text$Builder> {}
                                class Text$Builder extends RenderElementBuilder<Text> {
                                    static readonly class: JavaClass<Text$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>);

                                    /**
                                     * @param text the content of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    text(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): this;

                                    /**
                                     * @param text the content of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    text(text: xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder): this;

                                    /**
                                     * @param text the content of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    text(text: string): this;

                                    /**
                                     * @return the content of the text element.
                                     * @since 1.8.4
                                     */
                                    getText(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                    /**
                                     * @param x the x position of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x(x: int): this;

                                    /**
                                     * @return the x position of the text element.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y(y: int): this;

                                    /**
                                     * @return the y position of the text element.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position of the text element
                                     * @param y the y position of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: int, y: int): this;

                                    /**
                                     * @return the width of the string.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @return the height of the string.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param color the color of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): this;

                                    /**
                                     * @return the color of the text element.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param scale the scale of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    scale(scale: double): this;

                                    /**
                                     * @return the scale of the text element.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the text element in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): this;

                                    /**
                                     * @return the rotation (clockwise) of the text element in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this text should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this text should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param shadow whether the text should have a shadow or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    shadow(shadow: boolean): this;

                                    /**
                                     * @return `true` if the text element has a shadow, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    hasShadow(): boolean;

                                    /**
                                     * @param zIndex the z-index of the text element
                                     * @return self for chaining.
                                     */
                                    zIndex(zIndex: int): this;

                                    /**
                                     * @return the z-index of the text element.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    createElement(): Text;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Text$Builder;

                                }


                                /**
                                 * @author Wagyourtail
                                 * @since 1.0.5
                                 */
                                interface Item extends RenderElement, Alignable<Item> {}
                                class Item extends java.lang.Object {
                                    static readonly class: JavaClass<Item>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (x: int, y: int, zIndex: int, id: ItemId, overlay: boolean, scale: double, rotation: float);
                                    constructor (x: int, y: int, zIndex: int, i: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: float);
                                    constructor (x: int, y: int, zIndex: int, itemStack: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: float, ovText: string);

                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any> | null;
                                    item: /* net.minecraft.item.ItemStack */ any;
                                    ovText: string;
                                    overlay: boolean;
                                    scale: number;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    x: number;
                                    y: number;
                                    zIndex: number;

                                    /** @since 1.0.5 [citation needed] */
                                    setItem(i: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): Item;
                                    /** @since 1.0.5 [citation needed] */
                                    setItem(id: CanOmitNamespace<ItemId>, count: int): Item;
                                    /** @since 1.0.5 [citation needed] */
                                    getItem(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @param x the new x position of this element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX(x: int): this;

                                    /**
                                     * @return the x position of this element.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the new y position of this element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY(y: int): this;

                                    /**
                                     * @return the y position of this element.
                                     * @since 1.8.4
                                     */
                                    getY(): number;
                                    /** @since 1.0.5 */
                                    setPos(x: int, y: int): Item;

                                    /**
                                     * @throws IllegalArgumentException
                                     * @since 1.2.6
                                     */
                                    setScale(scale: double): Item;

                                    /**
                                     * @return the scale of this item.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;
                                    /** @since 1.2.6 */
                                    setRotation(rotation: double): Item;

                                    /**
                                     * @return the rotation of this item.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether the item should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this item should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;
                                    /** @since 1.2.0 */
                                    setOverlay(overlay: boolean): Item;

                                    /**
                                     * @return `true`, if the overlay, i.e. the durability bar, and the overlay text or
                                     *  item count should be shown, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    shouldShowOverlay(): boolean;
                                    /** @since 1.2.0 */
                                    setOverlayText(ovText: string): Item;

                                    /**
                                     * @return the overlay text of this item.
                                     * @since 1.8.4
                                     */
                                    getOverlayText(): string;

                                    /**
                                     * @param zIndex the new z-index of this item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): this;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Item;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Item;

                                }


                                /**
                                 * @author Wagyourtail
                                 * @since 1.2.3
                                 */
                                interface Image extends Alignable<Image>, RenderElement {}
                                class Image extends java.lang.Object {
                                    static readonly class: JavaClass<Image>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (x: int, y: int, width: int, height: int, zIndex: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: float);
                                    constructor (x: int, y: int, width: int, height: int, zIndex: int, alpha: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: float);

                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any> | null;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    x: number;
                                    y: number;
                                    width: number;
                                    height: number;
                                    imageX: number;
                                    imageY: number;
                                    regionWidth: number;
                                    regionHeight: number;
                                    textureWidth: number;
                                    textureHeight: number;
                                    color: number;
                                    zIndex: number;

                                    /**
                                     * @return self for chaining.
                                     * @since 1.2.3
                                     */
                                    setImage(id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): this;
                                    /** @since 1.2.3 */
                                    getImage(): string;

                                    /**
                                     * @param x the new x position of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX(x: int): this;

                                    /**
                                     * @return the x position of this image.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the new y position of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY(y: int): this;

                                    /**
                                     * @return the y position of this image.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the new x position of this image
                                     * @param y the new y position of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(x: int, y: int): this;
                                    /** @since 1.2.3 */
                                    setPos(x: int, y: int, width: int, height: int): Image;

                                    /**
                                     * @param width the new width of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWidth(width: int): this;

                                    /**
                                     * @return the width of this image.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the new height of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setHeight(height: int): this;

                                    /**
                                     * @return the height of this image.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the new width of this image
                                     * @param height the new height of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setSize(width: int, height: int): this;
                                    /** @since 1.6.5 */
                                    setColor(color: int): Image;
                                    /** @since 1.6.5 */
                                    setColor(color: int, alpha: int): Image;

                                    /**
                                     * @return the color of this image.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @return the alpha value of this image.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;
                                    /** @since 1.2.6 */
                                    setRotation(rotation: double): Image;

                                    /**
                                     * @return the rotation of this image.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether the image should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this image should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the new z-index of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): this;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Image;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Image;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                interface Line extends Alignable<Line>, RenderElement {}
                                class Line extends java.lang.Object {
                                    static readonly class: JavaClass<Line>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (x1: int, y1: int, x2: int, y2: int, color: int, rotation: float, width: float, zIndex: int);

                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any> | null;
                                    x1: number;
                                    y1: number;
                                    x2: number;
                                    y2: number;
                                    color: number;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    width: number;
                                    zIndex: number;

                                    /**
                                     * @param x1 the x position of the start of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX1(x1: int): this;

                                    /**
                                     * @return the x position of the start of the line.
                                     * @since 1.8.4
                                     */
                                    getX1(): number;

                                    /**
                                     * @param y1 the y position of the start of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY1(y1: int): this;

                                    /**
                                     * @return the y position of the start of the line.
                                     * @since 1.8.4
                                     */
                                    getY1(): number;

                                    /**
                                     * @param x1 the x position of the start of the line
                                     * @param y1 the y position of the start of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos1(x1: int, y1: int): this;

                                    /**
                                     * @param x2 the x position of the end of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX2(x2: int): this;

                                    /**
                                     * @return the x position of the end of the line.
                                     * @since 1.8.4
                                     */
                                    getX2(): number;

                                    /**
                                     * @param y2 the y position of the end of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY2(y2: int): this;

                                    /**
                                     * @return the y position of the end of the line.
                                     * @since 1.8.4
                                     */
                                    getY2(): number;

                                    /**
                                     * @param x2 the x position of the end of the line
                                     * @param y2 the y position of the end of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos2(x2: int, y2: int): this;

                                    /**
                                     * @param x1 the x position of the start of the line
                                     * @param y1 the y position of the start of the line
                                     * @param x2 the x position of the end of the line
                                     * @param y2 the y position of the end of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(x1: int, y1: int, x2: int, y2: int): this;

                                    /**
                                     * @param color the color of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setColor(color: int): this;

                                    /**
                                     * @param color the color of the line
                                     * @param alpha the alpha of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setColor(color: int, alpha: int): this;

                                    /**
                                     * @return the color of the line.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value of the line's color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setAlpha(alpha: int): this;

                                    /**
                                     * @return the alpha value of the line's color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotation(rotation: double): this;

                                    /**
                                     * @return the rotation (clockwise) of the line.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this line should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this line should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param width the width of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWidth(width: double): this;

                                    /**
                                     * @return the width of the line.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param zIndex the z-index of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): this;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Line;
                                    moveTo(x: int, y: int): Line;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                interface Image$Builder extends Alignable<Image$Builder> {}
                                class Image$Builder extends RenderElementBuilder<Image> {
                                    static readonly class: JavaClass<Image$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>);

                                    /**
                                     * Will automatically set all attributes to the default values of the custom image.  
                                     *  Values set before the call of this method will be overwritten.
                                     * @param customImage the custom image to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fromCustomImage(customImage: xyz.wagyourtail.jsmacros.client.api.classes.CustomImage): this;

                                    /**
                                     * @param identifier the identifier of the image to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    identifier(identifier: string): this;

                                    /**
                                     * @return the identifier of the used image or `null` if no image is used.
                                     * @since 1.8.4
                                     */
                                    getIdentifier(): string;

                                    /**
                                     * @param x the x position of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x(x: int): this;

                                    /**
                                     * @return the x position of the image.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y(y: int): this;

                                    /**
                                     * @return the y position of the image.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position of the image
                                     * @param y the y position of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: int, y: int): this;

                                    /**
                                     * @param width the width of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: int): this;

                                    /**
                                     * @return the width of the image.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the height of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    height(height: int): this;

                                    /**
                                     * @return the height of the image.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width of the image
                                     * @param height the height of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    size(width: int, height: int): this;

                                    /**
                                     * @param imageX the x position in the image texture to start drawing from
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    imageX(imageX: int): this;

                                    /**
                                     * @return the x position in the image texture to start drawing from.
                                     * @since 1.8.4
                                     */
                                    getImageX(): number;

                                    /**
                                     * @param imageY the y position in the image texture to start drawing from
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    imageY(imageY: int): this;

                                    /**
                                     * @return the y position in the image texture to start drawing from.
                                     * @since 1.8.4
                                     */
                                    getImageY(): number;

                                    /**
                                     * @param imageX the x position in the image texture to start drawing from
                                     * @param imageY the y position in the image texture to start drawing from
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    imagePos(imageX: int, imageY: int): this;

                                    /**
                                     * @param regionWidth the width of the region to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    regionWidth(regionWidth: int): this;

                                    /**
                                     * @return the width of the region to draw.
                                     * @since 1.8.4
                                     */
                                    getRegionWidth(): number;

                                    /**
                                     * @param regionHeight the height of the region to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    regionHeight(regionHeight: int): this;

                                    /**
                                     * @return the height of the region to draw.
                                     * @since 1.8.4
                                     */
                                    getRegionHeight(): number;

                                    /**
                                     * @param regionWidth the width of the region to draw
                                     * @param regionHeight the height of the region to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    regionSize(regionWidth: int, regionHeight: int): this;

                                    /**
                                     * @param x the x position in the image texture to start drawing from
                                     * @param y the y position in the image texture to start drawing from
                                     * @param width the width of the region to draw
                                     * @param height the height of the region to draw
                                     * @since 1.8.4
                                     */
                                    regions(x: int, y: int, width: int, height: int): Image$Builder;

                                    /**
                                     * @param x the x position in the image texture to start drawing from
                                     * @param y the y position in the image texture to start drawing from
                                     * @param width the width of the region to draw
                                     * @param height the height of the region to draw
                                     * @param textureWidth the width of the used texture
                                     * @param textureHeight the height of the used texture
                                     * @since 1.8.4
                                     */
                                    regions(x: int, y: int, width: int, height: int, textureWidth: int, textureHeight: int): Image$Builder;

                                    /**
                                     * @param textureWidth the width of the used texture
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    textureWidth(textureWidth: int): this;

                                    /**
                                     * @return the width of the used texture.
                                     * @since 1.8.4
                                     */
                                    getTextureWidth(): number;

                                    /**
                                     * @param textureHeight the height of the used texture
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    textureHeight(textureHeight: int): this;

                                    /**
                                     * @return the height of the used texture.
                                     * @since 1.8.4
                                     */
                                    getTextureHeight(): number;

                                    /**
                                     * @param textureWidth the width of the used texture
                                     * @param textureHeight the height of the used texture
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    textureSize(textureWidth: int, textureHeight: int): this;

                                    /**
                                     * @param color the color of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): this;

                                    /**
                                     * @param color the color of the image
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): this;

                                    /**
                                     * @return the color of the image.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): this;

                                    /**
                                     * @return the alpha value of the color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the image in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): this;

                                    /**
                                     * @return the rotation (clockwise) of the image in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether the image should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this image should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the z-index of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): this;

                                    /**
                                     * @return the z-index of the image.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    createElement(): Image;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Image$Builder;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                interface Rect$Builder extends Alignable<Rect$Builder> {}
                                class Rect$Builder extends RenderElementBuilder<Rect> {
                                    static readonly class: JavaClass<Rect$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>);

                                    /**
                                     * @param x1 the first x position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x1(x1: int): this;

                                    /**
                                     * @return the first x position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getX1(): number;

                                    /**
                                     * @param y1 the first y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y1(y1: int): this;

                                    /**
                                     * @return the first y position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getY1(): number;

                                    /**
                                     * @param x1 the first x position of the rectangle
                                     * @param y1 the first y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(x1: int, y1: int): this;

                                    /**
                                     * @param x2 the second x position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x2(x2: int): this;

                                    /**
                                     * @return the second x position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getX2(): number;

                                    /**
                                     * @param y2 the second y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y2(y2: int): this;

                                    /**
                                     * @return the second y position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getY2(): number;

                                    /**
                                     * @param x2 the second x position of the rectangle
                                     * @param y2 the second y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(x2: int, y2: int): this;

                                    /**
                                     * @param x1 the first x position of the rectangle
                                     * @param y1 the first y position of the rectangle
                                     * @param x2 the second x position of the rectangle
                                     * @param y2 the second y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x1: int, y1: int, x2: int, y2: int): this;

                                    /**
                                     * The width will just set the x2 position to `x1 + width`.
                                     * @param width the width of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: int): this;

                                    /**
                                     * @return the width of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * The width will just set the y2 position to `y1 + height`.
                                     * @param height the height of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    height(height: int): this;

                                    /**
                                     * @return the height of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width of the rectangle
                                     * @param height the height of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    size(width: int, height: int): this;

                                    /**
                                     * @param color the color of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): this;

                                    /**
                                     * @param color the color of the rectangle
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): this;

                                    /**
                                     * @return the color of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): this;

                                    /**
                                     * @return the alpha value of the color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the rectangle in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): this;

                                    /**
                                     * @return the rotation (clockwise) of the rectangle in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this rectangle should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this rectangle should be rotated around its center,
                                     *  `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the z-index of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): this;

                                    /**
                                     * @return the z-index of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    createElement(): Rect;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Rect$Builder;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                interface Line$Builder extends Alignable<Line$Builder> {}
                                class Line$Builder extends RenderElementBuilder<Line> {
                                    static readonly class: JavaClass<Line$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>);

                                    /**
                                     * @param x1 the x position of the first point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x1(x1: int): this;

                                    /**
                                     * @return the x position of the first point.
                                     * @since 1.8.4
                                     */
                                    getX1(): number;

                                    /**
                                     * @param y1 the y position of the first point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y1(y1: int): this;

                                    /**
                                     * @return the y position of the first point.
                                     * @since 1.8.4
                                     */
                                    getY1(): number;

                                    /**
                                     * @param x1 the x position of the first point
                                     * @param y1 the y position of the first point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(x1: int, y1: int): this;

                                    /**
                                     * @param x2 the x position of the second point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x2(x2: int): this;

                                    /**
                                     * @return the x position of the second point.
                                     * @since 1.8.4
                                     */
                                    getX2(): number;

                                    /**
                                     * @param y2 the y position of the second point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y2(y2: int): this;

                                    /**
                                     * @return the y position of the second point.
                                     * @since 1.8.4
                                     */
                                    getY2(): number;

                                    /**
                                     * @param x2 the x position of the second point
                                     * @param y2 the y position of the second point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(x2: int, y2: int): this;

                                    /**
                                     * @param x1 the x position of the first point
                                     * @param y1 the y position of the first point
                                     * @param x2 the x position of the second point
                                     * @param y2 the y position of the second point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x1: int, y1: int, x2: int, y2: int): this;

                                    /**
                                     * @param rotation the rotation (clockwise) of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): this;

                                    /**
                                     * @return the rotation (clockwise) of the line.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this line should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this line should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param width the width of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: double): this;

                                    /**
                                     * @return the width of the line.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param color the color of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): this;

                                    /**
                                     * @param color the color of the line
                                     * @param alpha the alpha component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): this;

                                    /**
                                     * @return the color of the line.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): this;

                                    /**
                                     * @return the alpha value of the color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param zIndex the z-index of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): this;

                                    /**
                                     * @return the z-index of the line.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    moveTo(x: int, y: int): Line$Builder;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;

                                }


                                /**
                                 * @author Wagyourtail
                                 * @since 1.0.5
                                 */
                                interface Text extends RenderElement, Alignable<Text> {}
                                class Text extends java.lang.Object {
                                    static readonly class: JavaClass<Text>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: float);
                                    constructor (text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: float);

                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any> | null;
                                    text: /* net.minecraft.text.Text */ any;
                                    scale: number;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    x: number;
                                    y: number;
                                    color: number;
                                    width: number;
                                    shadow: boolean;
                                    zIndex: number;

                                    /**
                                     * @param x the new x position for this text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX(x: int): this;

                                    /**
                                     * @return the x position of this element.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the new y position for this text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY(y: int): this;

                                    /**
                                     * @return the y position of this element.
                                     * @since 1.8.4
                                     */
                                    getY(): number;
                                    /** @since 1.0.5 */
                                    setPos(x: int, y: int): Text;
                                    /** @since 1.0.5 */
                                    setText(text: string): Text;
                                    /** @since 1.2.7 */
                                    setText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): Text;
                                    /** @since 1.2.7 */
                                    getText(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                    /** @since 1.0.5 */
                                    getWidth(): number;

                                    /**
                                     * @return the height of this text.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param shadow whether the text should be rendered with a shadow
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setShadow(shadow: boolean): this;

                                    /**
                                     * @return `true` if this text element is rendered with a shadow, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    hasShadow(): boolean;

                                    /**
                                     * @throws IllegalArgumentException
                                     * @since 1.0.5
                                     */
                                    setScale(scale: double): Text;

                                    /**
                                     * @return the scale of this text.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;
                                    /** @since 1.0.5 */
                                    setRotation(rotation: double): Text;

                                    /**
                                     * @return the rotation of this text.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this text should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this text should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param color the new color for this text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setColor(color: int): this;

                                    /**
                                     * @return the color of this text.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param zIndex the new z-index for this text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): this;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Text;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Text;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                interface Draw2DElement$Builder extends Alignable<Draw2DElement$Builder> {}
                                class Draw2DElement$Builder extends RenderElementBuilder<Draw2DElement> {
                                    static readonly class: JavaClass<Draw2DElement$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>, draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D);

                                    /**
                                     * @param x the x position of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x(x: int): this;

                                    /**
                                     * @return the x position of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y(y: int): this;

                                    /**
                                     * @return the y position of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position of the draw2D
                                     * @param y the y position of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: int, y: int): this;

                                    /**
                                     * @param width the width of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: int): this;

                                    /**
                                     * @return the width of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the height of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    height(height: int): this;

                                    /**
                                     * @return the height of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width of the draw2D
                                     * @param height the height of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    size(width: int, height: int): this;

                                    /**
                                     * @param scale the scale of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    scale(scale: double): this;

                                    /**
                                     * @return the scale of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the draw2D in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): this;

                                    /**
                                     * @return the rotation (clockwise) of the draw2D in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this draw2D should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this draw2D should be rotated around its center,
                                     *  `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @return the z-index of the draw2D.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): Draw2DElement$Builder;

                                    /**
                                     * @return the z-index of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Draw2DElement$Builder;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                interface Draw2DElement extends RenderElement, Alignable<Draw2DElement> {}
                                class Draw2DElement extends java.lang.Object {
                                    static readonly class: JavaClass<Draw2DElement>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D, x: int, y: int, width: java.util.function.IntSupplier, height: java.util.function.IntSupplier, zIndex: int, scale: float, rotation: float);

                                    readonly draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D;
                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any> | null;
                                    x: number;
                                    y: number;
                                    width: java.util.function.IntSupplier;
                                    height: java.util.function.IntSupplier;
                                    scale: number;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    zIndex: number;

                                    /**
                                     * @return the internal draw2D this draw2D element is wrapping.
                                     * @since 1.8.4
                                     */
                                    getDraw2D(): xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D;

                                    /**
                                     * @param x the x position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX(x: int): this;

                                    /**
                                     * @return the x position of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY(y: int): this;

                                    /**
                                     * @return the y position of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position
                                     * @param y the y position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(x: int, y: int): this;

                                    /**
                                     * @param width the width
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWidth(width: int): this;

                                    /**
                                     * @return the width of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the height
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setHeight(height: int): this;

                                    /**
                                     * @return the height of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width
                                     * @param height the height
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setSize(width: int, height: int): this;

                                    /**
                                     * @param scale the scale
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setScale(scale: double): this;

                                    /**
                                     * @return the scale of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation the rotation
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotation(rotation: double): this;

                                    /**
                                     * @return the rotation of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this draw2D should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this draw2D should be rotated around its center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the z-index of this draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): this;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Draw2DElement;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Draw2DElement;

                                }


                                /**
                                 * @template T the type of the render element for this builder
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                abstract class RenderElementBuilder<T extends RenderElement> extends java.lang.Object {
                                    static readonly class: JavaClass<RenderElementBuilder<any>>;
                                    /** @deprecated */ static prototype: undefined;

                                    /**
                                     * @return the newly created element.
                                     * @since 1.8.4
                                     */
                                    build(): T;

                                    /**
                                     * Builds and adds the element to the draw2D the builder was created from.
                                     * @return the newly created element.
                                     * @since 1.8.4
                                     */
                                    buildAndAdd(): T;

                                }


                                /**
                                 * @template B the builder class
                                 * @since 1.8.4
                                 */
                                abstract class Alignable<B extends Alignable<B>> extends java.lang.Interface {
                                    static readonly class: JavaClass<Alignable<any>>;
                                    /** @deprecated */ static prototype: undefined;

                                    /**
                                     * Parse the string containing a percentage of the form `x%` and return its value.
                                     * @param string the string to parse
                                     * @return the percentage or `-1` if the string is not a valid percentage.
                                     * @since 1.8.4
                                     */
                                    static parsePercentage(string: string): number;

                                }
                                interface Alignable<B extends Alignable<B>> {

                                    /**
                                     * @param other the element to align to
                                     * @param alignment the alignment to use
                                     * @return self for chaining.
                                     * @see alignHorizontally(Alignable, String, int)
                                     * @since 1.8.4
                                     */
                                    alignHorizontally(other: Alignable<any>, alignment: string): B;

                                    /**
                                     * The alignment must be of the format
                                     *  `[left|center|right|x%]On[left|center|right|x%]`. The input is case-insensitive.  
                                     *  The first alignment is for the element this method is called on and the second is for the
                                     *  other element. As an example, `LeftOnCenter` would align the left side of this
                                     *  element to the center of the other element.
                                     * @param other the element to align to
                                     * @param alignment the alignment to use
                                     * @param offset the offset to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alignHorizontally(other: Alignable<any>, alignment: string, offset: int): B;

                                    /**
                                     * @param alignment the alignment to use
                                     * @return self for chaining.
                                     * @see alignHorizontally(String, int)
                                     * @since 1.8.4
                                     */
                                    alignHorizontally(alignment: string): B;

                                    /**
                                     * Possible alignments are `left`, `center`, `right` or `y%` where y
                                     *  is a number between 0 and 100.
                                     * @param alignment the alignment to use
                                     * @param offset the offset to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alignHorizontally(alignment: string, offset: int): B;

                                    /**
                                     * @param other the element to align to
                                     * @param alignment the alignment to use
                                     * @return self for chaining.
                                     * @see alignVertically(Alignable, String, int)
                                     * @since 1.8.4
                                     */
                                    alignVertically(other: Alignable<any>, alignment: string): B;

                                    /**
                                     * The alignment must be of the format
                                     *  `[top|center|bottom|y%]On[top|center|bottom|y%]`. The input is case-insensitive.  
                                     *  The first alignment is for the element this method is called on and the second is for the
                                     *  other element. As an example, `BottomOnTop` would align the bottom side of this
                                     *  element to the top of the other element. Thus, the element would be placed above the
                                     *  other one.
                                     * @param other the element to align to
                                     * @param alignment the alignment to use
                                     * @param offset the offset to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alignVertically(other: Alignable<any>, alignment: string, offset: int): B;

                                    /**
                                     * @param alignment the alignment to use
                                     * @return self for chaining.
                                     * @see alignVertically(String, int)
                                     * @since 1.8.4
                                     */
                                    alignVertically(alignment: string): B;

                                    /**
                                     * Possible alignments are `top`, `center`, `bottom` or `x%` where x
                                     *  is a number between 0 and 100.
                                     * @param alignment the alignment to use
                                     * @param offset the offset to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alignVertically(alignment: string, offset: int): B;

                                    /**
                                     * @param horizontal the horizontal alignment to use
                                     * @param vertical the vertical alignment to use
                                     * @return self for chaining.
                                     * @see align(String, int, String, int)
                                     * @since 1.8.4
                                     */
                                    align(horizontal: string, vertical: string): B;

                                    /**
                                     * @param horizontal the horizontal alignment to use
                                     * @param horizontalOffset the horizontal offset to use
                                     * @param vertical the vertical alignment to use
                                     * @param verticalOffset the vertical offset to use
                                     * @return self for chaining.
                                     * @see alignHorizontally(String, int)
                                     * @see alignVertically(String, int)
                                     * @since 1.8.4
                                     */
                                    align(horizontal: string, horizontalOffset: int, vertical: string, verticalOffset: int): B;

                                    /**
                                     * @param other the element to align to
                                     * @param horizontal the horizontal alignment to use
                                     * @param vertical the vertical alignment to use
                                     * @return self for chaining.
                                     * @see align(Alignable, String, int, String, int)
                                     * @since 1.8.4
                                     */
                                    align(other: Alignable<any>, horizontal: string, vertical: string): B;

                                    /**
                                     * @param other the element to align to
                                     * @param horizontal the horizontal alignment to use
                                     * @param horizontalOffset the horizontal offset to use
                                     * @param vertical the vertical alignment to use
                                     * @param verticalOffset the vertical offset to use
                                     * @return self for chaining.
                                     * @see alignHorizontally(Alignable, String, int)
                                     * @see alignVertically(Alignable, String, int)
                                     * @since 1.8.4
                                     */
                                    align(other: Alignable<any>, horizontal: string, horizontalOffset: int, vertical: string, verticalOffset: int): B;

                                    /**
                                     * @param x the new x position
                                     * @param y the new y position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    moveTo(x: int, y: int): B;

                                    /**
                                     * @param x the new x position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    moveToX(x: int): B;

                                    /**
                                     * @param y the new y position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    moveToY(y: int): B;

                                    /**
                                     * @return the scaled width of the element.
                                     * @since 1.8.4
                                     */
                                    getScaledWidth(): number;

                                    /**
                                     * @return the width of the parent element.
                                     * @since 1.8.4
                                     */
                                    getParentWidth(): number;

                                    /**
                                     * @return the scaled height of the element.
                                     * @since 1.8.4
                                     */
                                    getScaledHeight(): number;

                                    /**
                                     * @return the height of the parent element.
                                     * @since 1.8.4
                                     */
                                    getParentHeight(): number;

                                    /**
                                     * @return the position of the scaled element's left side.
                                     * @since 1.8.4
                                     */
                                    getScaledLeft(): number;

                                    /**
                                     * @return the position of the scaled element's top side.
                                     * @since 1.8.4
                                     */
                                    getScaledTop(): number;

                                    /**
                                     * @return the position of the scaled element's right side.
                                     * @since 1.8.4
                                     */
                                    getScaledRight(): number;

                                    /**
                                     * @return the position of the scaled element's bottom side.
                                     * @since 1.8.4
                                     */
                                    getScaledBottom(): number;

                                }

                                export {
                                    Rect,
                                    Item$Builder,
                                    RenderElement,
                                    Text$Builder,
                                    Item,
                                    Image,
                                    Line,
                                    Image$Builder,
                                    Rect$Builder,
                                    Line$Builder,
                                    Text,
                                    Draw2DElement$Builder,
                                    Draw2DElement,
                                    RenderElementBuilder,
                                    Alignable
                                }

                            }

                            namespace components3d {

                                class EntityTraceLine$Builder extends java.lang.Object {
                                    static readonly class: JavaClass<EntityTraceLine$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D);

                                    screenPos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;

                                    /**
                                     * @param entity the target entity
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    entity(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null): this;

                                    /**
                                     * @return the target entity
                                     * @since 1.9.0
                                     */
                                    getEntity(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

                                    /**
                                     * @param yOffset the offset of y-axis
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    yOffset(yOffset: double): this;

                                    /**
                                     * @return the offset of y-axis
                                     * @since 1.9.0
                                     */
                                    getYOffset(): number;

                                    /**
                                     * @param color the color of the line
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    color(color: int): this;

                                    /**
                                     * @param color the color of the line
                                     * @param alpha the alpha value of the line's color
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    color(color: int, alpha: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    color(r: int, g: int, b: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha value of the color
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    color(r: int, g: int, b: int, a: int): this;

                                    /**
                                     * @return the color of the line
                                     * @since 1.9.0
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value for the line's color
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    alpha(alpha: int): this;

                                    /**
                                     * @return the alpha value of the line's color
                                     * @since 1.9.0
                                     */
                                    getAlpha(): number;

                                    /**
                                     * Creates the trace line for the given values and adds it to the draw3D
                                     * @param entity the target entity
                                     * @return the build line
                                     * @since 1.9.0
                                     */
                                    buildAndAdd(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null): EntityTraceLine;

                                    /**
                                     * Creates the trace line for the given values and adds it to the draw3D
                                     * @return the build line
                                     * @since 1.9.0
                                     */
                                    buildAndAdd(): EntityTraceLine;

                                    /**
                                     * Builds the line from the given values
                                     * @param entity the target entity
                                     * @return the build line
                                     * @since 1.9.0
                                     */
                                    build(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null): EntityTraceLine;

                                    /**
                                     * Builds the line from the given values
                                     * @return the build line
                                     * @since 1.9.0
                                     */
                                    build(): EntityTraceLine;

                                }


                                /**
                                 * @author Wagyourtail
                                 */
                                interface Line3D extends RenderElement3D {}
                                class Line3D extends java.lang.Object {
                                    static readonly class: JavaClass<Line3D>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, cull: boolean);
                                    constructor (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, cull: boolean);

                                    pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;
                                    color: number;
                                    cull: boolean;

                                    /** @since 1.0.6 */
                                    setPos(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): void;
                                    /** @since 1.0.6 */
                                    setColor(color: int): void;
                                    /** @since 1.1.8 */
                                    setColor(color: int, alpha: int): void;
                                    /** @since 1.1.8 */
                                    setAlpha(alpha: int): void;

                                }

                                abstract class RenderElement3D extends java.lang.Interface {
                                    static readonly class: JavaClass<RenderElement3D>;
                                    /** @deprecated */ static prototype: undefined;
                                }
                                interface RenderElement3D extends java.lang.Comparable<RenderElement3D> {

                                    compareTo(o: RenderElement3D): number;

                                }


                                /**
                                 * @author Wagyourtail
                                 * @since 1.6.5
                                 */
                                interface Surface extends xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement, RenderElement3D {}
                                class Surface extends xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D {
                                    static readonly class: JavaClass<Surface>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, rotations: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, sizes: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D, minSubdivisions: int, renderBack: boolean, cull: boolean);

                                    rotateToPlayer: boolean;
                                    rotateCenter: boolean;
                                    boundEntity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;
                                    boundOffset: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
                                    readonly pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
                                    readonly rotations: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * scale that zIndex is multiplied by to get the actual offset (in blocks) for rendering
                                     *  default: `1/1000` if there is still z-fighting, increase this value
                                     * @since 1.6.5
                                     */
                                    zIndexScale: number;
                                    renderBack: boolean;
                                    cull: boolean;

                                    /**
                                     * @param pos the position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param pos the position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;
                                    setPos(x: double, y: double, z: double): Surface;

                                    /**
                                     * The surface will move with the entity at the offset location.
                                     * @param boundEntity the entity to bind the surface to
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    bindToEntity(boundEntity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null): this;

                                    /**
                                     * @return the entity the surface is bound to, or `null` if it is not bound to an
                                     *  entity.
                                     * @since 1.8.4
                                     */
                                    getBoundEntity(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

                                    /**
                                     * @param boundOffset the offset from the entity's position to render the surface at
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setBoundOffset(boundOffset: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param x the x offset from the entity's position to render the surface at
                                     * @param y the y offset from the entity's position to render the surface at
                                     * @param z the z offset from the entity's position to render the surface at
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setBoundOffset(x: double, y: double, z: double): this;

                                    /**
                                     * @return the offset from the entity's position to render the surface at.
                                     * @since 1.8.4
                                     */
                                    getBoundOffset(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param rotateToPlayer whether to rotate the surface to face the player or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateToPlayer(rotateToPlayer: boolean): this;

                                    /**
                                     * @return `true` if the surface should be rotated to face the player, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    doesRotateToPlayer(): boolean;
                                    setRotations(x: double, y: double, z: double): void;
                                    setSizes(x: double, y: double): void;
                                    getSizes(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;
                                    setMinSubdivisions(minSubdivisions: int): void;
                                    getMinSubdivisions(): number;
                                    getHeight(): number;
                                    getWidth(): number;

                                    /**
                                     * @param rotateCenter whether to rotate the surface around its center or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this surface is rotated around it's center, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;
                                    init(): void;
                                    getZIndex(): number;

                                }


                                /**
                                 * @author Wagyourtail
                                 */
                                interface Box extends RenderElement3D {}
                                class Box extends java.lang.Object {
                                    static readonly class: JavaClass<Box>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, fillColor: int, fill: boolean, cull: boolean);
                                    constructor (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, fillColor: int, fillAlpha: int, fill: boolean, cull: boolean);

                                    pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;
                                    color: number;
                                    fillColor: number;
                                    fill: boolean;
                                    cull: boolean;

                                    /** @since 1.0.6 */
                                    setPos(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): void;

                                    /**
                                     * set this component's pos to a block
                                     * @since 1.9.0
                                     */
                                    setPosToBlock(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): void;

                                    /**
                                     * set this component's pos to a block
                                     * @since 1.9.0
                                     */
                                    setPosToBlock(x: int, y: int, z: int): void;

                                    /**
                                     * set this component's pos to a point
                                     * @since 1.9.0
                                     */
                                    setPosToPoint(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, radius: double): void;

                                    /**
                                     * set this component's pos to a point
                                     * @since 1.9.0
                                     */
                                    setPosToPoint(x: double, y: double, z: double, radius: double): void;
                                    /** @since 1.0.6 */
                                    setColor(color: int): void;
                                    /** @since 1.0.6 */
                                    setFillColor(fillColor: int): void;
                                    /** @since 1.1.8 */
                                    setColor(color: int, alpha: int): void;
                                    /** @since 1.1.8 */
                                    setAlpha(alpha: int): void;
                                    /** @since 1.1.8 */
                                    setFillColor(fillColor: int, alpha: int): void;
                                    /** @since 1.1.8 */
                                    setFillAlpha(alpha: int): void;
                                    /** @since 1.0.6 */
                                    setFill(fill: boolean): void;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                class Line3D$Builder extends java.lang.Object {
                                    static readonly class: JavaClass<Line3D$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D);

                                    /**
                                     * @param pos1 the first position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(pos1: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param pos1 the first position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                                    /**
                                     * @param x1 the x coordinate of the first position of the line
                                     * @param y1 the y coordinate of the first position of the line
                                     * @param z1 the z coordinate of the first position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(x1: double, y1: double, z1: double): this;

                                    /**
                                     * @return the first position of the line.
                                     * @since 1.8.4
                                     */
                                    getPos1(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param pos2 the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(pos2: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param pos2 the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                                    /**
                                     * @param x2 the x coordinate of the second position of the line
                                     * @param y2 the y coordinate of the second position of the line
                                     * @param z2 the z coordinate of the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(x2: int, y2: int, z2: int): this;

                                    /**
                                     * @return the second position of the line.
                                     * @since 1.8.4
                                     */
                                    getPos2(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param x1 the x coordinate of the first position of the line
                                     * @param y1 the y coordinate of the first position of the line
                                     * @param z1 the z coordinate of the first position of the line
                                     * @param x2 the x coordinate of the second position of the line
                                     * @param y2 the x coordinate of the second position of the line
                                     * @param z2 the z coordinate of the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x1: int, y1: int, z1: int, x2: int, y2: int, z2: int): this;

                                    /**
                                     * @param pos1 the first position of the line
                                     * @param pos2 the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                                    /**
                                     * @param pos1 the first position of the line
                                     * @param pos2 the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos1: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, pos2: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param color the color of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): this;

                                    /**
                                     * @param color the color of the line
                                     * @param alpha the alpha value of the line's color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): this;

                                    /**
                                     * @return the color of the line.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value for the line's color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): this;

                                    /**
                                     * @return the alpha value of the line's color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param cull whether to cull the line or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    cull(cull: boolean): this;

                                    /**
                                     * @return `true` if the line should be culled, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isCulled(): boolean;

                                    /**
                                     * Creates the line for the given values and adds it to the draw3D.
                                     * @return the build line.
                                     * @since 1.8.4
                                     */
                                    buildAndAdd(): Line3D;

                                    /**
                                     * Builds the line from the given values.
                                     * @return the build line.
                                     */
                                    build(): Line3D;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                class Surface$Builder extends java.lang.Object {
                                    static readonly class: JavaClass<Surface$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D);

                                    /**
                                     * @param pos the position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param pos the position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                                    /**
                                     * @param x the x position of the surface
                                     * @param y the y position of the surface
                                     * @param z the z position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: double, y: double, z: double): this;

                                    /**
                                     * @return the position of the surface.
                                     * @since 1.8.4
                                     */
                                    getPos(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * The surface will move with the entity at the offset location.
                                     * @param boundEntity the entity to bind the surface to
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    bindToEntity(boundEntity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null): this;

                                    /**
                                     * @return the entity the surface is bound to, or `null` if it is not bound to an
                                     *  entity.
                                     * @since 1.8.4
                                     */
                                    getBoundEntity(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

                                    /**
                                     * @param entityOffset the offset from the entity's position to render the surface at
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    boundOffset(entityOffset: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param x the x offset from the entity's position to render the surface at
                                     * @param y the y offset from the entity's position to render the surface at
                                     * @param z the z offset from the entity's position to render the surface at
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    boundOffset(x: double, y: double, z: double): this;

                                    /**
                                     * @return the offset from the entity's position to render the surface at.
                                     * @since 1.8.4
                                     */
                                    getBoundOffset(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param xRot the x rotation of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    xRotation(xRot: double): this;

                                    /**
                                     * @return the x rotation of the surface.
                                     * @since 1.8.4
                                     */
                                    getXRotation(): number;

                                    /**
                                     * @param yRot the y rotation of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    yRotation(yRot: double): this;

                                    /**
                                     * @return the y rotation of the surface.
                                     * @since 1.8.4
                                     */
                                    getYRotation(): number;

                                    /**
                                     * @param zRot the z rotation of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zRotation(zRot: double): this;

                                    /**
                                     * @return the z rotation of the surface.
                                     * @since 1.8.4
                                     */
                                    getZRotation(): number;

                                    /**
                                     * @param xRot the x rotation of the surface
                                     * @param yRot the y rotation of the surface
                                     * @param zRot the z rotation of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(xRot: double, yRot: double, zRot: double): this;

                                    /**
                                     * @param rotateCenter whether to rotate around the center of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): this;

                                    /**
                                     * @return `true` if this surface should be rotated around its center,
                                     *  `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param rotateToPlayer whether to rotate the surface to face the player or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateToPlayer(rotateToPlayer: boolean): this;

                                    /**
                                     * @return `true` if the surface should be rotated to face the player,
                                     *  `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    doesRotateToPlayer(): boolean;

                                    /**
                                     * @param width the width of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: double): this;

                                    /**
                                     * @return the width of the surface.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the height of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    height(height: double): this;

                                    /**
                                     * @return the height of the surface.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width of the surface
                                     * @param height the height of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    size(width: double, height: double): this;

                                    /**
                                     * @param minSubdivisions the minimum number of subdivisions
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    minSubdivisions(minSubdivisions: int): this;

                                    /**
                                     * @return the minimum number of subdivisions.
                                     * @since 1.8.4
                                     */
                                    getMinSubdivisions(): number;

                                    /**
                                     * @param renderBack whether the back of the surface should be rendered or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    renderBack(renderBack: boolean): this;

                                    /**
                                     * @return `true` if the back of the surface should be rendered, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    shouldRenderBack(): boolean;

                                    /**
                                     * @param cull whether to enable culling or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    cull(cull: boolean): this;

                                    /**
                                     * @return `true` if culling is enabled for this box, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isCulled(): boolean;

                                    /**
                                     * @param zIndexScale the scale of the z-index
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndexScale: double): this;

                                    /**
                                     * @return the scale of the z-index.
                                     * @since 1.8.4
                                     */
                                    getZIndexScale(): number;

                                    /**
                                     * Creates the surface for the given values and adds it to the draw3D.
                                     * @return the build surface.
                                     * @since 1.8.4
                                     */
                                    buildAndAdd(): Surface;

                                    /**
                                     * Builds the surface from the given values.
                                     * @return the build surface.
                                     */
                                    build(): Surface;

                                }


                                /**
                                 * @author aMelonRind
                                 * @since 1.9.0
                                 */
                                class EntityTraceLine extends TraceLine {
                                    static readonly class: JavaClass<EntityTraceLine>;
                                    /** @deprecated */ static prototype: undefined;

                                    static dirty: boolean;

                                    constructor (entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null, color: int, yOffset: double);
                                    constructor (entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null, color: int, alpha: int, yOffset: double);

                                    entity: /* net.minecraft.entity.Entity */ any | null;
                                    yOffset: number;
                                    shouldRemove: boolean;

                                    /**
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    setEntity(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null): this;

                                    /**
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    setYOffset(yOffset: double): this;
                                    render(drawContext: /* net.minecraft.client.gui.DrawContext */ any, builder: /* net.minecraft.client.render.BufferBuilder */ any, tickDelta: float): void;

                                }


                                /**
                                 * @author aMelonRind
                                 * @since 1.9.0
                                 */
                                interface TraceLine extends RenderElement3D {}
                                class TraceLine extends java.lang.Object {
                                    static readonly class: JavaClass<TraceLine>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (x: double, y: double, z: double, color: int);
                                    constructor (x: double, y: double, z: double, color: int, alpha: int);
                                    constructor (pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, color: int);
                                    constructor (pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, color: int, alpha: int);

                                    /**
                                     * this is not meant to be exposed because it works in a poor way<br>  
                                     *  it needs fov and aspect ratio info to render normally when not on center<br>  
                                     *  but for customize availability I just put it here as a field
                                     */
                                    screenPos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;
                                    pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
                                    color: number;

                                    /**
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    setPos(x: double, y: double, z: double): this;

                                    /**
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    setPos(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    setColor(color: int): this;

                                    /**
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    setColor(color: int, alpha: int): this;

                                    /**
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    setAlpha(alpha: int): this;
                                    render(drawContext: /* net.minecraft.client.gui.DrawContext */ any, builder: /* net.minecraft.client.render.BufferBuilder */ any, tickDelta: float): void;

                                }

                                class TraceLine$Builder extends java.lang.Object {
                                    static readonly class: JavaClass<TraceLine$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D);

                                    screenPos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;

                                    /**
                                     * @param pos the position of the target
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    pos(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param pos the position of the target
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    pos(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                                    /**
                                     * @param x the x coordinate of the target
                                     * @param y the y coordinate of the target
                                     * @param z the z coordinate of the target
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    pos(x: int, y: int, z: int): this;

                                    /**
                                     * @return the position of the target
                                     * @since 1.9.0
                                     */
                                    getPos(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param color the color of the line
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    color(color: int): this;

                                    /**
                                     * @param color the color of the line
                                     * @param alpha the alpha value of the line's color
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    color(color: int, alpha: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    color(r: int, g: int, b: int): this;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha value of the color
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    color(r: int, g: int, b: int, a: int): this;

                                    /**
                                     * @return the color of the line
                                     * @since 1.9.0
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value for the line's color
                                     * @return self for chaining
                                     * @since 1.9.0
                                     */
                                    alpha(alpha: int): this;

                                    /**
                                     * @return the alpha value of the line's color
                                     * @since 1.9.0
                                     */
                                    getAlpha(): number;

                                    /**
                                     * Creates the trace line for the given values and adds it to the draw3D
                                     * @return the build line
                                     * @since 1.9.0
                                     */
                                    buildAndAdd(): TraceLine;

                                    /**
                                     * Builds the line from the given values
                                     * @return the build line
                                     * @since 1.9.0
                                     */
                                    build(): TraceLine;

                                }


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                class Box$Builder extends java.lang.Object {
                                    static readonly class: JavaClass<Box$Builder>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D);

                                    /**
                                     * @param pos1 the first position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(pos1: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param pos1 the first position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                                    /**
                                     * @param x1 the x coordinate of the first position of the box
                                     * @param y1 the y coordinate of the first position of the box
                                     * @param z1 the z coordinate of the first position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(x1: double, y1: double, z1: double): this;

                                    /**
                                     * @return the first position of the box.
                                     * @since 1.8.4
                                     */
                                    getPos1(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param pos2 the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(pos2: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * @param pos2 the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                                    /**
                                     * @param x2 the x coordinate of the second position of the box
                                     * @param y2 the y coordinate of the second position of the box
                                     * @param z2 the z coordinate of the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(x2: double, y2: double, z2: double): this;

                                    /**
                                     * @return the second position of the box.
                                     * @since 1.8.4
                                     */
                                    getPos2(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param x1 the x coordinate of the first position of the box
                                     * @param y1 the y coordinate of the first position of the box
                                     * @param z1 the z coordinate of the first position of the box
                                     * @param x2 the x coordinate of the second position of the box
                                     * @param y2 the y coordinate of the second position of the box
                                     * @param z2 the z coordinate of the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): this;

                                    /**
                                     * @param pos1 the first position of the box
                                     * @param pos2 the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                                    /**
                                     * @param pos1 the first position of the box
                                     * @param pos2 the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos1: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, pos2: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): this;

                                    /**
                                     * Highlights the given block position.
                                     * @param x the x coordinate of the block
                                     * @param y the y coordinate of the block
                                     * @param z the z coordinate of the block
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    forBlock(x: int, y: int, z: int): this;

                                    /**
                                     * Highlights the given block position.
                                     * @param pos the block position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    forBlock(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                                    /**
                                     * @param color the color of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): this;

                                    /**
                                     * @param color the fill color of the box
                                     * @param alpha the alpha value for the box's fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): this;

                                    /**
                                     * @param r the red component of the fill color
                                     * @param g the green component of the fill color
                                     * @param b the blue component of the fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): this;

                                    /**
                                     * @param r the red component of the fill color
                                     * @param g the green component of the fill color
                                     * @param b the blue component of the fill color
                                     * @param a the alpha component of the fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): this;

                                    /**
                                     * @return the color of the box.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value for the box's color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): this;

                                    /**
                                     * @return the alpha value of the box's color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param fillColor the fill color of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillColor(fillColor: int): this;

                                    /**
                                     * @param fillColor the fill color of the box
                                     * @param alpha the alpha value for the box's fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillColor(fillColor: int, alpha: int): this;

                                    /**
                                     * @param r the red component of the fill color
                                     * @param g the green component of the fill color
                                     * @param b the blue component of the fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillColor(r: int, g: int, b: int): this;

                                    /**
                                     * @param r the red component of the fill color
                                     * @param g the green component of the fill color
                                     * @param b the blue component of the fill color
                                     * @param a the alpha component of the fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillColor(r: int, g: int, b: int, a: int): this;

                                    /**
                                     * @return the fill color of the box.
                                     * @since 1.8.4
                                     */
                                    getFillColor(): number;

                                    /**
                                     * @param fillAlpha the alpha value for the box's fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillAlpha(fillAlpha: int): this;

                                    /**
                                     * @return the alpha value of the box's fill color.
                                     * @since 1.8.4
                                     */
                                    getFillAlpha(): number;

                                    /**
                                     * @param fill `true` if the box should be filled, `false` otherwise
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fill(fill: boolean): this;

                                    /**
                                     * @return `true` if the box should be filled, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isFilled(): boolean;

                                    /**
                                     * @param cull whether to enable culling or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    cull(cull: boolean): this;

                                    /**
                                     * @return `true` if culling is enabled for this box, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isCulled(): boolean;

                                    /**
                                     * Creates the box for the given values and adds it to the draw3D.
                                     * @return the build box.
                                     * @since 1.8.4
                                     */
                                    buildAndAdd(): Box;

                                    /**
                                     * Builds the box from the given values.
                                     * @return the build box.
                                     */
                                    build(): Box;

                                }

                                export {
                                    EntityTraceLine$Builder,
                                    Line3D,
                                    RenderElement3D,
                                    Surface,
                                    Box,
                                    Line3D$Builder,
                                    Surface$Builder,
                                    EntityTraceLine,
                                    TraceLine,
                                    TraceLine$Builder,
                                    Box$Builder
                                }

                            }

                        }

                        namespace worldscanner {


                            /**
                             * A class to scan the world for certain blocks. The results of the filters are cached,  
                             *  so it's a good idea to reuse an instance of this if possible.  
                             *  The scanner can either return a list of all block positions or
                             *  a list of blocks and their respective count for every block / state matching the filters criteria.
                             * @author Etheradon
                             * @since 1.6.5
                             */
                            class WorldScanner extends java.lang.Object {
                                static readonly class: JavaClass<WorldScanner>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * Creates a new World scanner with for the given world. It accepts two boolean functions,  
                                 *  one for {@link BlockHelper} and the other for {@link BlockStateHelper}.
                                 * @param world the world to scan
                                 * @param blockFilter a filter method for the blocks
                                 * @param stateFilter a filter method for the block states
                                 */
                                constructor (world: /* net.minecraft.world.World */ any, blockFilter: MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper, any, boolean> | null, stateFilter: MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper, any, boolean> | null);

                                /**
                                 * Gets a list of all chunks in the given range around the center chunk.
                                 * @param centerX the x coordinate of the center chunk to scan around
                                 * @param centerZ the z coordinate of the center chunk to scan around
                                 * @param chunkrange the range to scan around the center chunk
                                 * @return a list of all matching block positions.
                                 */
                                getChunkRange(centerX: int, centerZ: int, chunkrange: int): JavaList</* net.minecraft.util.math.ChunkPos */ any>;

                                /**
                                 * Scans all chunks in the given range around the player and returns a list of all block positions, for blocks matching the filter.  
                                 *  This will scan in a square with length 2*range + 1. So range = 0 for example will only scan the chunk the player
                                 *  is standing in, while range = 1 will scan in a 3x3 area.
                                 * @param chunkRange the range to scan around the center chunk
                                 * @return a list of all matching block positions.
                                 */
                                scanAroundPlayer(chunkRange: int): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * Scans all chunks in the given range around the center chunk and returns a list of all block positions, for blocks matching the filter.  
                                 *  This will scan in a square with length 2*range + 1. So range = 0 for example will only scan the specified chunk,  
                                 *  while range = 1 will scan in a 3x3 area.
                                 * @param centerX the x coordinate of the center chunk to scan around
                                 * @param centerZ the z coordinate of the center chunk to scan around
                                 * @param chunkrange the range to scan around the center chunk
                                 * @return a list of all matching block positions.
                                 */
                                scanChunkRange(centerX: int, centerZ: int, chunkrange: int): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan area in blocks
                                 * @since 1.9.0
                                 */
                                scanCubeArea(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, range: int): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan area in blocks
                                 * @since 1.9.0
                                 */
                                scanCubeArea(x: int, y: int, z: int, range: int): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan area in blocks
                                 * @param pos1 first pos, inclusive
                                 * @param pos2 second pos, exclusive
                                 * @since 1.9.0
                                 */
                                scanCubeArea(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan area in blocks
                                 * @param x1 first x coordinate, inclusive
                                 * @param y1 first y coordinate, inclusive
                                 * @param z1 first z coordinate, inclusive
                                 * @param x2 second x coordinate, exclusive
                                 * @param y2 second y coordinate, exclusive
                                 * @param z2 second z coordinate, exclusive
                                 * @since 1.9.0
                                 */
                                scanCubeArea(x1: int, y1: int, z1: int, x2: int, y2: int, z2: int): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan area in blocks
                                 * @since 1.9.0
                                 */
                                scanSphereArea(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, radius: double): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan area in blocks
                                 * @since 1.9.0
                                 */
                                scanSphereArea(x: double, y: double, z: double, radius: double): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan area in blocks
                                 * @param pos1 first pos, inclusive
                                 * @param pos2 second pos, inclusive
                                 * @since 1.9.0
                                 */
                                scanCubeAreaInclusive(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan area in blocks
                                 * @param x1 first x coordinate, inclusive
                                 * @param y1 first y coordinate, inclusive
                                 * @param z1 first z coordinate, inclusive
                                 * @param x2 second x coordinate, inclusive
                                 * @param y2 second y coordinate, inclusive
                                 * @param z2 second z coordinate, inclusive
                                 * @since 1.9.0
                                 */
                                scanCubeAreaInclusive(x1: int, y1: int, z1: int, x2: int, y2: int, z2: int): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan around with player pos and player reach.<br>  
                                 *  this doesn't filter out positions that has obstacle.
                                 * @since 1.9.0
                                 */
                                scanReachable(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan around with player pos and player reach.<br>  
                                 *  this doesn't filter out positions that has obstacle.
                                 * @param strict if it should check for block outline instead of full cube, default is true
                                 * @since 1.9.0
                                 */
                                scanReachable(strict: boolean): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan around with the given pos and player reach.<br>  
                                 *  this doesn't filter out positions that has obstacle.
                                 * @since 1.9.0
                                 */
                                scanReachable(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan around with the given pos and the given reach.<br>  
                                 *  this doesn't filter out positions that has obstacle.
                                 * @since 1.9.0
                                 */
                                scanReachable(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, reach: double): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan around with the given pos and the given reach.<br>  
                                 *  this doesn't filter out positions that has obstacle.
                                 * @param pos `Player.getPlayer().getEyePos()`
                                 * @param reach `Player.getInteractionManager().getReach()`
                                 * @param strict if it should check for block outline instead of full cube, default is true
                                 * @since 1.9.0
                                 */
                                scanReachable(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, reach: double, strict: boolean): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * scan around with player pos and player reach, and return the closest one.<br>  
                                 *  this doesn't filter out positions that has obstacle.
                                 * @since 1.9.0
                                 */
                                scanClosestReachable(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D | null;

                                /**
                                 * scan around with player pos and player reach, and return the closest one.<br>  
                                 *  this doesn't filter out positions that has obstacle.
                                 * @since 1.9.0
                                 */
                                scanClosestReachable(strict: boolean): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D | null;

                                /**
                                 * scan around with player pos and player reach, and return the closest one.<br>  
                                 *  this doesn't filter out positions that has obstacle.
                                 * @since 1.9.0
                                 */
                                scanClosestReachable(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, reach: double, strict: boolean): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D | null;

                                /**
                                 * Gets the amount of all blocks matching the criteria inside the chunk.
                                 * @param chunkX the x coordinate of the chunk to scan
                                 * @param chunkZ the z coordinate of the chunk to scan
                                 * @param ignoreState whether multiple states should be combined to a single block
                                 * @return a map of all blocks inside the specified chunk and their respective count.
                                 */
                                getBlocksInChunk(chunkX: int, chunkZ: int, ignoreState: boolean): JavaMap<string, number>;

                                /**
                                 * Gets the amount of all blocks matching the criteria inside a square around the player.
                                 * @param centerX the x coordinate of the center chunk to scan around
                                 * @param centerZ the z coordinate of the center chunk to scan around
                                 * @param chunkRange the range to scan around the center chunk
                                 * @param ignoreState whether multiple states should be combined to a single block
                                 * @return a map of all blocks inside the specified chunks and their respective count.
                                 */
                                getBlocksInChunks(centerX: int, centerZ: int, chunkRange: int, ignoreState: boolean): JavaMap<string, number>;

                                /**
                                 * Get the amount of cached block states. This will normally be around 200 - 400.
                                 * @return the amount of cached block states.
                                 */
                                getCachedAmount(): number;

                            }


                            /**
                             * The builder can be used to create a world scanner with native java functions. This is especially useful for languages like javascript that
                             *  don't support multithreading, which causes streams to run sequential instead of parallel.  
                             *  The builder has two filters for the block and the block state, which need to be configured separately.  
                             *  If one function is not defined, it will just be ignored when building the scanner.<br>  
                             *  The block and block state filters have to start with a 'with' command like {@link withStateFilter}(String) or {@link withStringBlockFilter}().  
                             *  This will overwrite all previous filters of the same type. To add more commands, it's possible to use commands with the prefix 'and', 'or', 'xor'.  
                             *  The 'not' command will just negate the whole block or block state filter and doesn't need any arguments.<br>  
                             *
                             *  All other commands need some arguments to work. For String functions, it's one of these functions: 'equals', 'contains', 'startsWith', 'endsWith' or 'matches'.  
                             *  The strings to match are passed as vararg parameters (as many as needed, separated by a comma `is("chest", "barrel", "ore"`) and the filter acts
                             *  like a logical or, so only one of the arguments needs to match the criteria. It should be noted, that string functions call the toString method, so
                             *  comparing a block with something like "minecraft:stone" will always return false, because the toString method gives "{minecraft:stone}". For doing this
                             *  use either contains or the equals method with 'getId', as shown later.<br>  
                             *  This will match any block that includes 'stone' or 'diorit' in its name:  
                             *  ```  
                             *  withStringBlockFilter().contains("stone") //create new block filter, check if it contains stone
                             *  .orStringBlockFilter().contains("diorit") //append new block filter with or and check if it contains diorit
                             *  ```  
                             *
                             *  For non String functions, the method name must be passed when creating the filter. The names can be any method in {@link BlockStateHelper} or {@link BlockHelper}.  
                             *  For more complex filters, use the MethodWrapper function {@link World.getWorldScanner}(MethodWrapper, MethodWrapper).  
                             *  Depending on the return type of the method, the following parameters must be passed to 'is' or 'test'. There are two methods, because 'is' is a keyword in some languages.<br>  
                             *  ```  
                             *  For any number:  
                             *    - is(operation, number) with operation = '>', '>=', '<', '<=', '==', '!=' and the number that should be compared to,  
                             *      i.e. is(">=", 8) returns true if the returned number is greater or equal to 8.  
                             *  For any String:  
                             *    - is(method, string) with method = 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH', 'MATCHES' and the string is the one to compare the returned value to,  
                             *      i.e. is("ENDS_WITH", "ore") checks if the returned string ends with ore (can be used with withBlockFilter("getId")).  
                             *  For any Boolean:  
                             *    - is(val) with val either `true` or `false`
                             *      i.e. is(false) returns true if the returned boolean value is false
                             *  ```
                             * @author Etheradon
                             * @since 1.6.5
                             */
                            class WorldScannerBuilder extends java.lang.Object {
                                static readonly class: JavaClass<WorldScannerBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor ();

                                withStateFilter(method: string): WorldScannerBuilder;
                                andStateFilter(method: string): WorldScannerBuilder;
                                orStateFilter(method: string): WorldScannerBuilder;
                                notStateFilter(): WorldScannerBuilder;
                                withBlockFilter(method: string): WorldScannerBuilder;
                                andBlockFilter(method: string): WorldScannerBuilder;
                                orBlockFilter(method: string): WorldScannerBuilder;
                                notBlockFilter(): WorldScannerBuilder;
                                withStringBlockFilter(): WorldScannerBuilder;
                                andStringBlockFilter(): WorldScannerBuilder;
                                orStringBlockFilter(): WorldScannerBuilder;
                                withStringStateFilter(): WorldScannerBuilder;
                                andStringStateFilter(): WorldScannerBuilder;
                                orStringStateFilter(): WorldScannerBuilder;
                                is(...args: JavaVarArgs<any>): WorldScannerBuilder;
                                is(methodArgs: any[], filterArgs: any[]): WorldScannerBuilder;
                                test(...args: JavaVarArgs<any>): WorldScannerBuilder;
                                test(methodArgs: any[], filterArgs: any[]): WorldScannerBuilder;
                                equals(...args: JavaVarArgs<string>): WorldScannerBuilder;
                                equals(arg0: any): boolean;
                                contains(...args: JavaVarArgs<string>): WorldScannerBuilder;
                                startsWith(...args: JavaVarArgs<string>): WorldScannerBuilder;
                                endsWith(...args: JavaVarArgs<string>): WorldScannerBuilder;
                                matches(...args: JavaVarArgs<string>): WorldScannerBuilder;
                                build(): WorldScanner;

                            }

                            export { WorldScanner, WorldScannerBuilder }

                        }

                    }

                    namespace helpers {


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        class DyeColorHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.util.DyeColor */ any> {
                            static readonly class: JavaClass<DyeColorHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (base: /* net.minecraft.util.DyeColor */ any);

                            /**
                             * @return the name of the color.
                             * @since 1.8.4
                             */
                            getName(): DyeColorName;

                            /**
                             * @return the color's identifier.
                             * @since 1.8.4
                             */
                            getId(): number;

                            /**
                             * @return the color's rgb value.
                             * @since 1.8.4
                             */
                            getColorValue(): number;

                            /**
                             * @return the color's variation when used in fireworks.
                             * @since 1.8.4
                             */
                            getFireworkColor(): number;

                            /**
                             * @return the color's variation when used on signs.
                             * @since 1.8.4
                             */
                            getSignColor(): number;

                        }


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        class AdvancementProgressHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.advancement.AdvancementProgress */ any> {
                            static readonly class: JavaClass<AdvancementProgressHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (base: /* net.minecraft.advancement.AdvancementProgress */ any);

                            /**
                             * @return `true` if the advancement is finished, `false` otherwise.
                             * @since 1.8.4
                             */
                            isDone(): boolean;

                            /**
                             * @return `true` if any criteria has already been met, `false` otherwise.
                             * @since 1.8.4
                             */
                            isAnyObtained(): boolean;

                            /**
                             * @return a map of all criteria and their completion date.
                             * @since 1.8.4
                             */
                            getCriteria(): JavaMap<string, number>;

                            /**
                             * @return all requirements of this advancement.
                             * @since 1.8.4
                             */
                            getRequirements(): JavaArray<JavaArray<string>>;

                            /**
                             * @return the percentage of finished requirements.
                             * @since 1.8.4
                             */
                            getPercentage(): number;

                            /**
                             * @return the fraction of finished requirements to total requirements.
                             * @since 1.8.4
                             */
                            getFraction(): TextHelper;

                            /**
                             * @return the amount of requirements criteria.
                             * @since 1.8.4
                             */
                            countObtainedRequirements(): number;

                            /**
                             * @return the amount/values of missing criteria.
                             * @since 1.8.4
                             */
                            getUnobtainedCriteria(): JavaArray<string>;

                            /**
                             * @return the ids of the finished requirements.
                             * @since 1.8.4
                             */
                            getObtainedCriteria(): JavaArray<string>;

                            /**
                             * @return the earliest completion date of all criteria.
                             * @since 1.8.4
                             */
                            getEarliestProgressObtainDate(): number;

                            /**
                             * @param criteria the criteria
                             * @return the completion date of the given criteria or `-1` if the criteria is not met
                             *  yet.
                             * @since 1.8.4
                             */
                            getCriterionProgress(criteria: string): number;

                            /**
                             * @param criteria the criteria
                             * @return `true` if the given criteria is met, `false` otherwise.
                             * @since 1.8.4
                             */
                            isCriteriaObtained(criteria: string): boolean;

                        }

                        /** @since 1.5.1 */
                        abstract class NBTElementHelper$NBTListHelper extends NBTElementHelper</* net.minecraft.nbt.AbstractNbtList<any> */ any> {
                            static readonly class: JavaClass<NBTElementHelper$NBTListHelper>;
                            /** @deprecated */ static prototype: undefined;

                            /** @since 1.8.3 */
                            isPossiblyUUID(): boolean;
                            /** @since 1.8.3 */
                            asUUID(): java.util.UUID | null;
                            /** @since 1.5.1 */
                            length(): number;
                            /** @since 1.5.1 */
                            get(index: int): NBTElementHelper<any> | null;
                            /** @since 1.5.1 */
                            getHeldType(): number;

                        }

                        /** @since 1.5.1 */
                        abstract class NBTElementHelper$NBTNumberHelper extends NBTElementHelper</* net.minecraft.nbt.AbstractNbtNumber */ any> {
                            static readonly class: JavaClass<NBTElementHelper$NBTNumberHelper>;
                            /** @deprecated */ static prototype: undefined;

                            /** @since 1.5.1 */
                            asLong(): number;
                            /** @since 1.5.1 */
                            asInt(): number;
                            /** @since 1.5.1 */
                            asShort(): number;
                            /** @since 1.5.1 */
                            asByte(): number;
                            /** @since 1.5.1 */
                            asFloat(): number;
                            /** @since 1.5.1 */
                            asDouble(): number;
                            /** @since 1.5.1 */
                            asNumber(): number;

                        }


                        /**
                         * @author Wagyourtail
                         * @since 1.0.8
                         */
                        abstract class TextHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.text.Text */ any> {
                            static readonly class: JavaClass<TextHelper>;
                            /** @deprecated */ static prototype: undefined;

                            static readonly STRIP_FORMATTING_PATTERN: java.util.regex.Pattern;

                            static wrap(t: /* net.minecraft.text.Text */ any): TextHelper;

                            /**
                             * replace the text in this class with JSON data.
                             * @since 1.0.8
                             * @deprecated use {@link Chat.createTextHelperFromJSON}(String) instead.
                             */
                            replaceFromJson(json: string): TextHelper;

                            /**
                             * replace the text in this class with string data.
                             * @since 1.0.8
                             * @deprecated use {@link Chat.createTextHelperFromString}(String) instead.
                             */
                            replaceFromString(content: string): TextHelper;

                            /**
                             * @return JSON data representation.
                             * @since 1.2.7
                             */
                            getJson(): string;

                            /**
                             * @return the text content.
                             * @since 1.2.7
                             */
                            getString(): string;

                            /**
                             * @return the text content. stripped formatting when servers send it the (super) old way due to shitty coders.
                             * @since 1.6.5
                             */
                            getStringStripFormatting(): string;

                            /**
                             * @return the text helper without the formatting applied.
                             * @since 1.8.4
                             */
                            withoutFormatting(): TextHelper;

                            /**
                             * @param visitor function with 2 args, no return.
                             * @since 1.6.5
                             */
                            visit(visitor: xyz.wagyourtail.jsmacros.core.MethodWrapper<StyleHelper, string, any, any>): TextHelper;

                            /**
                             * @return the width of this text.
                             * @since 1.8.4
                             */
                            getWidth(): number;

                            /**
                             * @since 1.0.8
                             * @deprecated confusing name, use {@link getJson}() instead.
                             */
                            toJson(): string;

                            /**
                             * @return String representation of text helper.
                             * @since 1.0.8, this used to do the same as {@link getString}
                             */
                            toString(): string;

                        }


                        /**
                         * @author Wagyourtail
                         * @since 1.6.5
                         */
                        class StyleHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.text.Style */ any> {
                            static readonly class: JavaClass<StyleHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (base: /* net.minecraft.text.Style */ any);

                            hasColor(): boolean;

                            /**
                             * @return the color index of this style or `-1` if no color is set.
                             * @deprecated use {@link getColorIndex}() instead.
                             */
                            getColor(): number;

                            /**
                             * @return the formatting of this style, or `null` if no formatting was found.
                             * @since 1.8.4
                             */
                            getFormatting(): FormattingHelper | null;

                            /**
                             * @return the color index of this style or `-1` if no color is set.
                             * @since 1.8.4
                             */
                            getColorIndex(): number;

                            /**
                             * @return the color value of this style or `-1` if it doesn't have one.
                             * @since 1.8.4
                             */
                            getColorValue(): number;

                            /**
                             * @return the color name of this style or `null` if it has no color.
                             * @since 1.8.4
                             */
                            getColorName(): string | null;
                            hasCustomColor(): boolean;
                            getCustomColor(): number;
                            bold(): boolean;
                            italic(): boolean;
                            underlined(): boolean;
                            strikethrough(): boolean;
                            obfuscated(): boolean;
                            getClickAction(): TextClickAction | 'custom' | null;
                            getClickValue(): string | null;
                            getCustomClickValue(): MethodWrapper | null;
                            getHoverAction(): TextHoverAction | null;
                            getHoverValue(): any | null;
                            getInsertion(): string;

                        }


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        class AdvancementHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.advancement.PlacedAdvancement */ any> {
                            static readonly class: JavaClass<AdvancementHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (base: /* net.minecraft.advancement.PlacedAdvancement */ any);

                            /**
                             * @return the parent advancement or `null` if there is none.
                             * @since 1.8.4
                             */
                            getParent(): AdvancementHelper | null;

                            /**
                             * @return a list of all child advancements.
                             * @since 1.8.4
                             */
                            getChildren(): JavaList<AdvancementHelper>;

                            /**
                             * @return the requirements of this advancement.
                             * @since 1.8.4
                             */
                            getRequirements(): JavaArray<JavaArray<string>>;

                            /**
                             * @return the amount of requirements.
                             * @since 1.8.4
                             */
                            getRequirementCount(): number;

                            /**
                             * @return the identifier of this advancement.
                             * @since 1.8.4
                             */
                            getId(): AdvancementId;

                            /**
                             * @return the experience awarded by this advancement.
                             * @since 1.8.4
                             */
                            getExperience(): number;

                            /**
                             * @return the loot table ids for this advancement's rewards.
                             * @since 1.8.4
                             */
                            getLoot(): JavaArray<string>;

                            /**
                             * @return the recipes unlocked through this advancement.
                             * @since 1.8.4
                             */
                            getRecipes(): JavaArray<RecipeId>;

                            /**
                             * @return the progress.
                             * @since 1.8.4
                             */
                            getProgress(): AdvancementProgressHelper;

                            /**
                             * @since 1.9.0
                             * @return the json string of this advancement.
                             */
                            toJson(): string;

                        }

                        /** @since 1.5.1 */
                        abstract class NBTElementHelper<T = /* net.minecraft.nbt.NbtElement */ any> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T> {
                            static readonly class: JavaClass<NBTElementHelper<any>>;
                            /** @deprecated */ static prototype: undefined;

                            /** @since 1.9.0 */
                            static wrapCompound(compound: /* net.minecraft.nbt.NbtCompound */ any | null): NBTElementHelper$NBTCompoundHelper | null;
                            /** @since 1.5.1 */
                            static resolve(element: /* net.minecraft.nbt.NbtElement */ any | null): NBTElementHelper<any> | null;

                            /** @since 1.5.1 */
                            getType(): number;

                            /**
                             * resolves the nbt path to elements, or null if not found.<br>  
                             *  [NBT path format wiki](https://minecraft.wiki/w/NBT_path_format)
                             * @throws CommandSyntaxException if the path format is incorrect
                             * @since 1.9.0
                             */
                            resolve(nbtPath: string): JavaList<NBTElementHelper<any>> | null;
                            /** @since 1.5.1 */
                            isNull(): boolean;
                            /** @since 1.5.1 */
                            isNumber(): this is NBTElementHelper$NBTNumberHelper;
                            /** @since 1.5.1 */
                            isString(): boolean;
                            /** @since 1.5.1 */
                            isList(): this is NBTElementHelper$NBTListHelper;
                            /** @since 1.5.1 */
                            isCompound(): this is NBTElementHelper$NBTCompoundHelper;

                            /**
                             * if element is a string, returns value.  
                             *  otherwise returns toString representation.
                             * @since 1.5.1
                             */
                            asString(): string;

                            /**
                             * check with {@link isNumber}() first
                             * @since 1.5.1
                             */
                            asNumberHelper(): NBTElementHelper$NBTNumberHelper;

                            /**
                             * check with {@link isList}() first
                             * @since 1.5.1
                             */
                            asListHelper(): NBTElementHelper$NBTListHelper;

                            /**
                             * check with {@link isCompound}() first
                             * @since 1.5.1
                             */
                            asCompoundHelper(): NBTElementHelper$NBTCompoundHelper;

                        }


                        /**
                         * @author Wagyourtail
                         * @since 1.2.4
                         */
                        class StatusEffectHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.entity.effect.StatusEffectInstance */ any> {
                            static readonly class: JavaClass<StatusEffectHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (s: /* net.minecraft.entity.effect.StatusEffectInstance */ any);
                            /** @since 1.8.4 */
                            constructor (s: /* net.minecraft.entity.effect.StatusEffect */ any);
                            /** @since 1.8.4 */
                            constructor (s: /* net.minecraft.entity.effect.StatusEffect */ any, t: int);

                            /** @since 1.2.4 */
                            getId(): StatusEffectId;
                            /** @since 1.2.4 */
                            getStrength(): number;

                            /**
                             * @return the string name of the category of the status effect, "HARMFUL", "NEUTRAL", or "BENEFICIAL".
                             * @since 1.8.4
                             */
                            getCategory(): StatusEffectCategory;
                            /** @since 1.2.4 */
                            getTime(): number;

                            /**
                             * @return `true` if this effect is applied permanently, `false` otherwise.
                             * @since 1.8.4
                             */
                            isPermanent(): boolean;

                            /**
                             * Ambient effects are usually applied through beacons and they make the particles more
                             *  translucent.
                             * @return `true` if this effect is an ambient one, `false` otherwise.
                             * @since 1.8.4
                             */
                            isAmbient(): boolean;

                            /**
                             * @return `true` if this effect has an icon it should render, `false` otherwise.
                             * @since 1.8.4
                             */
                            hasIcon(): boolean;

                            /**
                             * @return `true` if this effect affects the particle color and gets rendered in game,
                             *  `false` otherwise.
                             * @since 1.8.4
                             */
                            isVisible(): boolean;

                            /**
                             * An effect which is instant can still have a duration, but only if it's set through a
                             *  command.
                             * @return `true` if this effect should be applied instantly, `false` otherwise.
                             * @since 1.8.4
                             */
                            isInstant(): boolean;

                            /**
                             * @return `true` if this effect is considered beneficial, `false` otherwise.
                             * @since 1.8.4
                             */
                            isBeneficial(): boolean;

                            /**
                             * @return `true` if this effect is considered neutral, `false` otherwise.
                             * @since 1.8.4
                             */
                            isNeutral(): boolean;

                            /**
                             * @return `true` if this effect is considered harmful, `false` otherwise.
                             * @since 1.8.4
                             */
                            isHarmful(): boolean;

                        }

                        class OptionsHelper$MusicOptionsHelper extends java.lang.Object {
                            static readonly class: JavaClass<OptionsHelper$MusicOptionsHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (OptionsHelper: OptionsHelper);

                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the current master volume.
                             * @since 1.8.4
                             */
                            getMasterVolume(): number;

                            /**
                             * @param volume the new master volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMasterVolume(volume: double): this;

                            /**
                             * @return the current music volume.
                             * @since 1.8.4
                             */
                            getMusicVolume(): number;

                            /**
                             * @param volume the new music volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMusicVolume(volume: double): this;

                            /**
                             * @return the current value of played recods.
                             * @since 1.8.4
                             */
                            getRecordsVolume(): number;

                            /**
                             * @param volume the new volume for playing records
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setRecordsVolume(volume: double): this;

                            /**
                             * @return the current volume of the weather.
                             * @since 1.8.4
                             */
                            getWeatherVolume(): number;

                            /**
                             * @param volume the new volume for the weather
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setWeatherVolume(volume: double): this;

                            /**
                             * @return the current volume of block related sounds.
                             * @since 1.8.4
                             */
                            getBlocksVolume(): number;

                            /**
                             * @param volume the new volume for block sounds
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBlocksVolume(volume: double): this;

                            /**
                             * @return the current volume of hostile mobs.
                             * @since 1.8.4
                             */
                            getHostileVolume(): number;

                            /**
                             * @param volume the new volume for hostile mobs
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setHostileVolume(volume: double): this;

                            /**
                             * @return the current volume of neutral mobs.
                             * @since 1.8.4
                             */
                            getNeutralVolume(): number;

                            /**
                             * @param volume the new volume for neutral mobs
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setNeutralVolume(volume: double): this;

                            /**
                             * @return the current player volume.
                             * @since 1.8.4
                             */
                            getPlayerVolume(): number;

                            /**
                             * @param volume the new player volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setPlayerVolume(volume: double): this;

                            /**
                             * @return the current ambient volume.
                             * @since 1.8.4
                             */
                            getAmbientVolume(): number;

                            /**
                             * @param volume the new ambient volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setAmbientVolume(volume: double): this;

                            /**
                             * @return the current voice volume.
                             * @since 1.8.4
                             */
                            getVoiceVolume(): number;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setVoiceVolume(volume: double): this;

                            /**
                             * @param category the category to get the volume of
                             * @return the volume of the given sound category.
                             * @since 1.8.4
                             */
                            getVolume(category: SoundCategory): number;

                            /**
                             * @return a map of all sound categories and their volumes.
                             * @since 1.8.4
                             */
                            getVolumes(): JavaMap<string, number>;

                            /**
                             * @param category the category to set the volume for
                             * @param volume the new volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setVolume(category: SoundCategory, volume: double): this;

                            /**
                             * @return the currently selected sound device.
                             * @since 1.8.4
                             */
                            getSoundDevice(): string;

                            /**
                             * @param audioDevice the audio device to use
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setSoundDevice(audioDevice: string): this;

                            /**
                             * @return a list of all connected audio devices.
                             * @since 1.8.4
                             */
                            getAudioDevices(): JavaList<string>;

                            /**
                             * @return `true` if subtitles should be shown, `false` otherwise.
                             * @since 1.8.4
                             */
                            areSubtitlesShown(): boolean;

                            /**
                             * @param val whether subtitles should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            showSubtitles(val: boolean): this;

                        }


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        abstract class ModContainerHelper<T> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T> {
                            static readonly class: JavaClass<ModContainerHelper<any>>;
                            /** @deprecated */ static prototype: undefined;

                            /**
                             * @return the mod's id.
                             * @since 1.8.4
                             */
                            getId(): string;

                            /**
                             * @return the mod's name.
                             * @since 1.8.4
                             */
                            getName(): string;

                            /**
                             * @return the mod's description.
                             * @since 1.8.4
                             */
                            getDescription(): string;

                            /**
                             * @return the mod's version.
                             * @since 1.8.4
                             */
                            getVersion(): string;

                            /**
                             * @return the environment this mod is intended for.
                             * @since 1.8.4
                             */
                            getEnv(): string;

                            /**
                             * @return a list of all authors.
                             * @since 1.8.4
                             */
                            getAuthors(): JavaList<string>;

                            /**
                             * @return a list of all dependencies.
                             * @since 1.8.4
                             */
                            getDependencies(): JavaList<string>;

                        }

                        class OptionsHelper$AccessibilityOptionsHelper extends java.lang.Object {
                            static readonly class: JavaClass<OptionsHelper$AccessibilityOptionsHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (OptionsHelper: OptionsHelper);

                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the current narrator mode.
                             * @since 1.8.4
                             */
                            getNarratorMode(): string;

                            /**
                             * @param mode the mode to set the narrator to. Must be either "OFF", "ALL", "CHAT", or
                             *              "SYSTEM"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setNarratorMode(mode: string): this;

                            /**
                             * @return `true` if subtitles are enabled.
                             * @since 1.8.4
                             */
                            areSubtitlesShown(): boolean;

                            /**
                             * @param val whether to show subtitles or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            showSubtitles(val: boolean): this;

                            /**
                             * @param val the new opacity for the text background
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setTextBackgroundOpacity(val: double): this;

                            /**
                             * @return the opacity of the text background.
                             * @since 1.8.4
                             */
                            getTextBackgroundOpacity(): number;
                            /** @since 1.8.4 */
                            isBackgroundForChatOnly(): boolean;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableBackgroundForChatOnly(val: boolean): this;

                            /**
                             * @return the current chat opacity.
                             * @since 1.8.4
                             */
                            getChatOpacity(): number;

                            /**
                             * @param val the new chat opacity
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatOpacity(val: double): this;

                            /**
                             * @return the current chat line spacing.
                             * @since 1.8.4
                             */
                            getChatLineSpacing(): number;

                            /**
                             * @param val the new chat line spacing
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatLineSpacing(val: double): this;

                            /**
                             * @return the current chat delay in seconds.
                             * @since 1.8.4
                             */
                            getChatDelay(): number;

                            /**
                             * @param val the new chat delay in seconds
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatDelay(val: double): this;

                            /**
                             * @return `true` if auto jump is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isAutoJumpEnabled(): boolean;

                            /**
                             * @param val whether to enable auto jump or not or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableAutoJump(val: boolean): this;

                            /**
                             * @return `true` if the toggle functionality for sneaking is enabled, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            isSneakTogglingEnabled(): boolean;

                            /**
                             * @param val whether to enable or disable the toggle functionality for sneaking
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleSneak(val: boolean): this;

                            /**
                             * @return `true` if the toggle functionality for sprinting is enabled, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            isSprintTogglingEnabled(): boolean;

                            /**
                             * @param val whether to enable or disable the toggle functionality for sprinting
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleSprint(val: boolean): this;

                            /**
                             * @return the current distortion effect scale.
                             * @since 1.8.4
                             */
                            getDistortionEffect(): number;

                            /**
                             * @param val the new distortion effect scale
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setDistortionEffect(val: double): this;

                            /**
                             * @return the current fov effect scale.
                             * @since 1.8.4
                             */
                            getFovEffect(): number;

                            /**
                             * @param val the new fov effect scale
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFovEffect(val: double): this;

                            /**
                             * @return `true` if the monochrome logo is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isMonochromeLogoEnabled(): boolean;

                            /**
                             * @param val whether to enable the monochrome logo or not
                             * @return the current helper instance for chaining.
                             * @since 1.8.4
                             */
                            enableMonochromeLogo(val: boolean): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return `true` if lighting flashes are hidden, `false` otherwise.
                             * @since 1.8.4
                             */
                            areLightningFlashesHidden(): boolean;

                            /**
                             * @param val the new fov value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFovEffect(val: boolean): this;

                        }

                        class OptionsHelper$ControlOptionsHelper extends java.lang.Object {
                            static readonly class: JavaClass<OptionsHelper$ControlOptionsHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (OptionsHelper: OptionsHelper);

                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the current mouse sensitivity.
                             * @since 1.8.4
                             */
                            getMouseSensitivity(): number;

                            /**
                             * @param val the new mouse sensitivity
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMouseSensitivity(val: double): this;

                            /**
                             * @return `true` if the mouse direction should be inverted.
                             * @since 1.8.4
                             */
                            isMouseInverted(): boolean;

                            /**
                             * @param val whether to invert the mouse direction or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            invertMouse(val: boolean): this;

                            /**
                             * @return the current mouse wheel sensitivity.
                             * @since 1.8.4
                             */
                            getMouseWheelSensitivity(): number;

                            /**
                             * @param val the new mouse wheel sensitivity
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMouseWheelSensitivity(val: double): this;

                            /**
                             * This option was introduced due to a bug on some systems where the mouse wheel would
                             *  scroll too fast.
                             * @return `true` if discrete scrolling is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isDiscreteScrollingEnabled(): boolean;

                            /**
                             * @param val whether to enable discrete scrolling or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableDiscreteScrolling(val: boolean): this;

                            /**
                             * @return `true` if touchscreen mode is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isTouchscreenEnabled(): boolean;

                            /**
                             * @param val whether to enable touchscreen mode or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableTouchscreen(val: boolean): this;

                            /**
                             * Raw input is directly reading the mouse data, without any adjustments due to other
                             *  programs or the operating system.
                             * @return `true` if raw mouse input is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isRawMouseInputEnabled(): boolean;

                            /**
                             * @param val whether to enable raw mouse input or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableRawMouseInput(val: boolean): this;

                            /**
                             * @return `true` if auto jump is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isAutoJumpEnabled(): boolean;

                            /**
                             * @param val whether to enable auto jump or not or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableAutoJump(val: boolean): this;

                            /**
                             * @return `true` if the toggle functionality for sneaking is enabled, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            isSneakTogglingEnabled(): boolean;

                            /**
                             * @param val whether to enable or disable the toggle functionality for sneaking
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleSneak(val: boolean): this;

                            /**
                             * @return `true` if the toggle functionality for sprinting is enabled, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            isSprintTogglingEnabled(): boolean;

                            /**
                             * @param val whether to enable or disable the toggle functionality for sprinting
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleSprint(val: boolean): this;

                            /**
                             * @return an array of all raw minecraft keybindings.
                             * @since 1.8.4
                             */
                            getRawKeys(): JavaArray</* net.minecraft.client.option.KeyBinding */ any>;

                            /**
                             * @return a list of all keybinding catehories.
                             * @since 1.8.4
                             */
                            getCategories(): JavaList<KeyCategory>;

                            /**
                             * @return a list of all key names.
                             * @since 1.8.4
                             */
                            getKeys(): JavaList<Key>;

                            /**
                             * @return a map of all keybindings and their bound key.
                             * @since 1.8.4
                             */
                            getKeyBinds(): JavaMap<Bind, Key>;

                            /**
                             * @param category the category to get keybindings from
                             * @return a map of all keybindings and their bound key in the specified category.
                             * @since 1.8.4
                             */
                            getKeyBindsByCategory(category: KeyCategory): JavaMap<string, string>;

                            /**
                             * @return a map of all keybinding categories, containing a map of all keybindings in that
                             *  category and their bound key.
                             * @since 1.8.4
                             */
                            getKeyBindsByCategory(): JavaMap<string, JavaMap<string, string>>;

                        }


                        /**
                         * Helper for ClientPlayerInteractionManager
                         *  it accesses interaction manager from `mc` instead of `base`, to avoid issues
                         * @author aMelonRind
                         * @since 1.9.0
                         */
                        class InteractionManagerHelper extends java.lang.Object {
                            static readonly class: JavaClass<InteractionManagerHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor ();

                            getRaw(): /* net.minecraft.client.network.ClientPlayerInteractionManager */ any;

                            /**
                             * @return the player's current gamemode.
                             * @since 1.9.0
                             */
                            getGameMode(): Gamemode;

                            /**
                             * @param gameMode possible values are survival, creative, adventure, spectator (case insensitive)
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setGameMode(gameMode: Gamemode): this;

                            /**
                             * @return the current reach distance of the player.
                             * @since 1.8.4
                             */
                            getReach(): number;

                            /**
                             * sets crosshair target to a block
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTarget(x: int, y: int, z: int): this;

                            /**
                             * sets crosshair target to a block
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTarget(x: int, y: int, z: int, direction: Direction): this;

                            /**
                             * sets crosshair target to a block
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTarget(x: int, y: int, z: int, direction: Hexit): this;

                            /**
                             * sets crosshair target to a block
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTarget(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                            /**
                             * sets crosshair target to a block
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTarget(bpos: BlockPosHelper, direction: Direction): this;

                            /**
                             * sets crosshair target to a block
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTarget(bpos: BlockPosHelper, direction: Hexit): this;

                            /**
                             * sets crosshair target to an entity
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTarget(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>): this;

                            /**
                             * @return targeted block pos, null if not targeting block
                             * @since 1.9.0
                             */
                            getTargetedBlock(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper | null;

                            /**
                             * @return targeted entity, null if not targeting entity
                             * @since 1.9.0
                             */
                            getTargetedEntity(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

                            /**
                             * sets crosshair target to missed (doesn't target anything)
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTargetMissed(): this;

                            /**
                             * @return `true` if target have been set by `ClientPlayerEntityHelper#setTarget()` or
                             *   `ClientPlayerEntityHelper#setTargetMissed()`
                             * @since 1.9.0
                             */
                            hasTargetOverride(): boolean;

                            /**
                             * clears target override
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            clearTargetOverride(): this;

                            /**
                             * @param enabled if target overriding should check range. default is `true`
                             * @param autoClear if override should clear when out of range.
                             *                   if `false`, target will set to missed if out of range. default is `true`
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTargetRangeCheck(enabled: boolean, autoClear: boolean): this;

                            /**
                             * @param enabled if target overriding should check air. default is `false`
                             * @param autoClear if override should clear when is air.
                             *                   if `false`, target will set to missed if is air. default is `false`
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTargetAirCheck(enabled: boolean, autoClear: boolean): this;

                            /**
                             * this check ignores air. use `ClientPlayerEntityHelper#setTargetAirCheck()` to check air.
                             * @param enabled if target overriding should check block shape. default is `true`
                             * @param autoClear if override should clear when shape is empty.
                             *                   if `false`, target will set to missed if is empty. default is `false`
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            setTargetShapeCheck(enabled: boolean, autoClear: boolean): this;

                            /**
                             * resets all range, air and shape check settings to default.
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            resetTargetChecks(): this;
                            /** @since 1.5.0 */
                            attack(): InteractionManagerHelper;
                            /** @since 1.6.0 */
                            attack(await: boolean): InteractionManagerHelper;
                            /** @since 1.5.0 */
                            attack(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>): InteractionManagerHelper;
                            /** @since 1.6.0 */
                            attack(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>, await: boolean): InteractionManagerHelper;

                            /**
                             * @param x the x coordinate to attack
                             * @param y the y coordinate to attack
                             * @param z the z coordinate to attack
                             * @param direction possible values are "up", "down", "north", "south", "east", "west"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            attack(x: int, y: int, z: int, direction: Direction): this;

                            /**
                             * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                             * @since 1.5.0
                             */
                            attack(x: int, y: int, z: int, direction: Hexit): InteractionManagerHelper;

                            /**
                             * @param x the x coordinate to attack
                             * @param y the y coordinate to attack
                             * @param z the z coordinate to attack
                             * @param direction possible values are "up", "down", "north", "south", "east", "west"
                             * @param await whether to wait for the attack to finish
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            attack(x: int, y: int, z: int, direction: Direction, await: boolean): this;

                            /**
                             * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                             * @throws InterruptedException
                             * @since 1.6.0
                             */
                            attack(x: int, y: int, z: int, direction: Hexit, await: boolean): InteractionManagerHelper;

                            /**
                             * breaks a block, will wait till it's done<br>  
                             *  you can use `ClientPlayerEntityHelper#setTarget()` to specify which block to break
                             * @return result
                             * @see InteractionManagerHelper.setTarget(int, int, int, String)
                             * @throws InterruptedException
                             * @since 1.9.0
                             */
                            breakBlock(): xyz.wagyourtail.jsmacros.client.api.classes.InteractionProxy$Break$BreakBlockResult;

                            /**
                             * breaks a block, will wait till it's done<br>  
                             *  this is the same as:  
                             *  ```  
                             *  setTarget(x, y, z);  
                             *  let res = null;  
                             *  if (getTargetedBlock()?.getRaw().equals(new BlockPos(x, y, z))) res = breakBlock();  
                             *  clearTargetOverride();  
                             *  return res;  
                             *  ```
                             * @return result
                             * @throws InterruptedException
                             * @since 1.9.0
                             */
                            breakBlock(x: int, y: int, z: int): xyz.wagyourtail.jsmacros.client.api.classes.InteractionProxy$Break$BreakBlockResult | null;

                            /**
                             * breaks a block, will wait till it's done<br>  
                             *  this is the same as:  
                             *  ```  
                             *  setTarget(pos);  
                             *  let res = null;  
                             *  if (getTargetedBlock()?.equals(pos)) res = breakBlock();  
                             *  clearTargetOverride();  
                             *  return res;  
                             *  ```
                             * @return result
                             * @throws InterruptedException
                             * @since 1.9.0
                             */
                            breakBlock(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): xyz.wagyourtail.jsmacros.client.api.classes.InteractionProxy$Break$BreakBlockResult | null;

                            /**
                             * starts breaking a block<br>  
                             *  you can use `ClientPlayerEntityHelper#setTarget()` to specify which block to break
                             * @param callback this will mostly be called on main thread!
                             *                  Use `methodToJavaAsync()` instead of `methodToJava()` to avoid errors.
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            breakBlockAsync(callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.InteractionProxy$Break$BreakBlockResult, any, any, any> | null): this;
                            /** @since 1.8.0 */
                            isBreakingBlock(): boolean;

                            /**
                             * @return `true` if there's not finished block breaking from `ClientPlayerEntityHelper#breakBlock()`
                             * @since 1.9.0
                             */
                            hasBreakBlockOverride(): boolean;

                            /**
                             * cancels breaking block that previously started by `ClientPlayerEntityHelper#breakBlock()` or
                             *   `ClientPlayerEntityHelper#breakBlockAsync()`
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            cancelBreakBlock(): this;
                            /** @since 1.5.0 */
                            interact(): InteractionManagerHelper;
                            /** @since 1.6.0 */
                            interact(await: boolean): InteractionManagerHelper;
                            /** @since 1.5.0, renamed from `interact` in 1.6.0 */
                            interactEntity(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>, offHand: boolean): InteractionManagerHelper;

                            /**
                             * @throws InterruptedException
                             * @since 1.6.0
                             */
                            interactEntity(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>, offHand: boolean, await: boolean): InteractionManagerHelper;
                            /** @since 1.5.0, renamed from `interact` in 1.6.0 */
                            interactItem(offHand: boolean): InteractionManagerHelper;
                            /** @since 1.6.0 */
                            interactItem(offHand: boolean, await: boolean): InteractionManagerHelper;

                            /**
                             * @param x the x coordinate to interact
                             * @param y the y coordinate to interact
                             * @param z the z coordinate to interact
                             * @param direction possible values are "up", "down", "north", "south", "east", "west"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            interactBlock(x: int, y: int, z: int, direction: Direction, offHand: boolean): this;

                            /**
                             * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                             * @since 1.5.0, renamed from `interact` in 1.6.0
                             */
                            interactBlock(x: int, y: int, z: int, direction: Hexit, offHand: boolean): InteractionManagerHelper;

                            /**
                             * @param x the x coordinate to interact
                             * @param y the y coordinate to interact
                             * @param z the z coordinate to interact
                             * @param direction possible values are "up", "down", "north", "south", "east", "west"
                             * @param await whether to wait for the interaction to complete
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            interactBlock(x: int, y: int, z: int, direction: Direction, offHand: boolean, await: boolean): this;

                            /**
                             * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                             * @param await whether to wait for the interaction to complete
                             * @since 1.5.0, renamed from `interact` in 1.6.0
                             */
                            interactBlock(x: int, y: int, z: int, direction: Hexit, offHand: boolean, await: boolean): InteractionManagerHelper;

                            /**
                             * starts/stops long interact
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            holdInteract(holding: boolean): this;

                            /**
                             * starts/stops long interact
                             * @return self for chaining
                             * @since 1.9.0
                             */
                            holdInteract(holding: boolean, awaitFirstClick: boolean): this;

                            /**
                             * interacts for specified number of ticks
                             * @return remaining ticks if the interaction was interrupted
                             * @throws InterruptedException
                             * @since 1.9.0
                             */
                            holdInteract(ticks: int): number;

                            /**
                             * interacts for specified number of ticks
                             * @param stopOnPause if `false`, this interaction will not return when interrupted by pause.
                             *                     the timer will not decrease, meaning it'll continue right after unpause and interact exact amount of ticks.
                             * @return remaining ticks if the interaction was interrupted
                             * @throws InterruptedException
                             * @since 1.9.0
                             */
                            holdInteract(ticks: int, stopOnPause: boolean): number;

                            /**
                             * @return `true` if interaction from `ClientPlayerEntityHelper#holdInteract()` is active
                             * @since 1.9.0
                             */
                            hasInteractOverride(): boolean;

                        }

                        class OptionsHelper$VideoOptionsHelper extends java.lang.Object {
                            static readonly class: JavaClass<OptionsHelper$VideoOptionsHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (OptionsHelper: OptionsHelper);

                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the full screen resolution as a string.
                             * @since 1.8.4
                             */
                            getFullscreenResolution(): string;

                            /**
                             * @return the current biome blend radius.
                             * @since 1.8.4
                             */
                            getBiomeBlendRadius(): number;

                            /**
                             * @param radius the new biome blend radius
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBiomeBlendRadius(radius: int): this;

                            /**
                             * @return the selected graphics mode.
                             * @since 1.8.4
                             */
                            getGraphicsMode(): GraphicsMode;

                            /**
                             * @param mode the graphics mode to select. Must be either "fast", "fancy" or "fabulous"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setGraphicsMode(mode: GraphicsMode): this;

                            /**
                             * @return the selected chunk builder mode.
                             * @since 1.8.4
                             */
                            getChunkBuilderMode(): ChunkBuilderMode;

                            /**
                             * @param mode the chunk builder mode to select. Must be either "none", "nearby" or
                             *              "player_affected"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChunkBuilderMode(mode: ChunkBuilderMode): this;

                            /**
                             * @return the selected smooth lightning mode.
                             * @since 1.8.4
                             */
                            getSmoothLightningMode(): boolean;

                            /**
                             * @param mode the smooth lightning mode to select. boolean value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setSmoothLightningMode(mode: boolean): this;

                            /**
                             * @return the current render distance in chunks.
                             * @since 1.8.4
                             */
                            getRenderDistance(): number;

                            /**
                             * @param radius the new render distance in chunks
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setRenderDistance(radius: int): this;

                            /**
                             * @return the current simulation distance in chunks.
                             * @since 1.8.4
                             */
                            getSimulationDistance(): number;

                            /**
                             * @param radius the new simulation distance in chunks
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setSimulationDistance(radius: int): this;

                            /**
                             * @return the current upper fps limit.
                             * @since 1.8.4
                             */
                            getMaxFps(): number;

                            /**
                             * @param maxFps the new maximum fps limit
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMaxFps(maxFps: int): this;

                            /**
                             * @return `true` if vsync is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isVsyncEnabled(): boolean;

                            /**
                             * @param val whether to enable vsync or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableVsync(val: boolean): this;

                            /**
                             * @return `true` if view bobbing is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isViewBobbingEnabled(): boolean;

                            /**
                             * @param val whether to enable view bobbing or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableViewBobbing(val: boolean): this;

                            /**
                             * @return the current gui scale.
                             * @since 1.8.4
                             */
                            getGuiScale(): number;

                            /**
                             * @param scale the gui scale to set. Must be 1, 2, 3 or 4
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setGuiScale(scale: int): this;

                            /**
                             * @return the current attack indicator type.
                             * @since 1.8.4
                             */
                            getAttackIndicatorType(): AttackIndicatorType;

                            /**
                             * @param type the attack indicator type. Must be either "off", "crosshair", or "hotbar"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setAttackIndicatorType(type: AttackIndicatorType): this;

                            /**
                             * @return the current gamma value.
                             * @since 1.8.4
                             */
                            getGamma(): number;

                            /**
                             * @param gamma the new gamma value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setGamma(gamma: double): this;

                            /**
                             * @return the current brightness value.
                             * @since 1.8.4
                             */
                            getBrightness(): number;

                            /**
                             * @param gamma the new brightness value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBrightness(gamma: double): this;

                            /**
                             * @return the current cloud rendering mode.
                             * @since 1.8.4
                             */
                            getCloudsMode(): CloudsMode;

                            /**
                             * @param mode the cloud rendering mode to select. Must be either "off", "fast" or "fancy"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setCloudsMode(mode: CloudsMode): this;

                            /**
                             * @return `true` if the game is running in fullscreen mode, `false` otherwise.
                             * @since 1.8.4
                             */
                            isFullscreen(): boolean;

                            /**
                             * @param fullscreen whether to enable fullscreen mode or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFullScreen(fullscreen: boolean): this;

                            /**
                             * @return the current particle rendering mode.
                             * @since 1.8.4
                             */
                            getParticleMode(): ParticleMode;

                            /**
                             * @param mode the particle rendering mode to select. Must be either "minimal", "decreased"
                             *              or "all"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setParticleMode(mode: ParticleMode): this;

                            /**
                             * @return the current mip map level.
                             * @since 1.8.4
                             */
                            getMipMapLevels(): number;

                            /**
                             * @param val the new mip map level
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMipMapLevels(val: int): this;

                            /**
                             * @return `true` if entity shadows should be rendered, `false` otherwise.
                             * @since 1.8.4
                             */
                            areEntityShadowsEnabled(): boolean;

                            /**
                             * @param val whether to enable entity shadows or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableEntityShadows(val: boolean): this;

                            /**
                             * @return the current distortion effect scale.
                             * @since 1.8.4
                             */
                            getDistortionEffect(): number;

                            /**
                             * @param val the new distortion effect scale
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setDistortionEffects(val: double): this;

                            /**
                             * @return the current entity render distance.
                             * @since 1.8.4
                             */
                            getEntityDistance(): number;

                            /**
                             * @param val the new entity render distance
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setEntityDistance(val: double): this;

                            /**
                             * @return the current fov value.
                             * @since 1.8.4
                             */
                            getFovEffects(): number;

                            /**
                             * @param val the new fov value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFovEffects(val: double): this;

                            /**
                             * @return `true` if the autosave indicator is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isAutosaveIndicatorEnabled(): boolean;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableAutosaveIndicator(val: boolean): this;

                        }

                        class CommandNodeHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<com.mojang.brigadier.tree.CommandNode<any>> {
                            static readonly class: JavaClass<CommandNodeHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (base: com.mojang.brigadier.tree.CommandNode, fabric: com.mojang.brigadier.tree.CommandNode);

                            readonly fabric: com.mojang.brigadier.tree.CommandNode;
                        }

                        /** @since 1.6.5 */
                        class SuggestionsBuilderHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<com.mojang.brigadier.suggestion.SuggestionsBuilder> {
                            static readonly class: JavaClass<SuggestionsBuilderHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (base: com.mojang.brigadier.suggestion.SuggestionsBuilder);

                            getInput(): string;
                            getStart(): number;
                            getRemaining(): string;
                            getRemainingLowerCase(): string;
                            suggest(suggestion: string): SuggestionsBuilderHelper;
                            suggest(value: int): SuggestionsBuilderHelper;
                            suggestWithTooltip(suggestion: string, tooltip: TextHelper): SuggestionsBuilderHelper;
                            suggestWithTooltip(value: int, tooltip: TextHelper): SuggestionsBuilderHelper;

                            /**
                             * @param suggestions the strings to match
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestMatching(...suggestions: JavaVarArgs<string>): this;

                            /**
                             * @param suggestions the strings to match
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestMatching(suggestions: JavaCollection<string>): this;

                            /**
                             * @param identifiers the identifiers to match
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestIdentifier(...identifiers: JavaVarArgs<string>): this;

                            /**
                             * @param identifiers the identifiers to match
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestIdentifier(identifiers: JavaCollection<string>): this;

                            /**
                             * @param positions the positions to suggest
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestBlockPositions(...positions: JavaVarArgs<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper>): this;

                            /**
                             * @param positions the positions to suggest
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestBlockPositions(positions: JavaCollection<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper>): this;

                            /**
                             * Positions are strings of the form "x y z" where x, y, and z are numbers or the default
                             *  minecraft selectors "~" and "^" followed by a number.
                             * @param positions the positions to suggest
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestPositions(...positions: JavaVarArgs<string>): this;

                            /**
                             * Positions are strings of the form "x y z" where x, y, and z are numbers or the default
                             *  minecraft selectors "~" and "^" followed by a number.
                             * @param positions the relative positions to suggest
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestPositions(positions: JavaCollection<string>): this;

                        }


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        class OptionsHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.client.option.GameOptions */ any> {
                            static readonly class: JavaClass<OptionsHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (options: /* net.minecraft.client.option.GameOptions */ any);

                            readonly skin: OptionsHelper$SkinOptionsHelper;
                            readonly video: OptionsHelper$VideoOptionsHelper;
                            readonly music: OptionsHelper$MusicOptionsHelper;
                            readonly control: OptionsHelper$ControlOptionsHelper;
                            readonly chat: OptionsHelper$ChatOptionsHelper;
                            readonly accessibility: OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return a helper for the skin options.
                             * @since 1.8.4
                             */
                            getSkinOptions(): OptionsHelper$SkinOptionsHelper;

                            /**
                             * @return a helper for the video options.
                             * @since 1.8.4
                             */
                            getVideoOptions(): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return a helper for the music options.
                             * @since 1.8.4
                             */
                            getMusicOptions(): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return a helper for the control options.
                             * @since 1.8.4
                             */
                            getControlOptions(): OptionsHelper$ControlOptionsHelper;

                            /**
                             * @return a helper for the chat options.
                             * @since 1.8.4
                             */
                            getChatOptions(): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return a helper for the accessibility options.
                             * @since 1.8.4
                             */
                            getAccessibilityOptions(): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            saveOptions(): this;

                            /**
                             * @return list of names of resource packs.
                             * @since 1.1.7
                             */
                            getResourcePacks(): JavaList<string>;

                            /**
                             * @return list of names of enabled resource packs.
                             * @since 1.2.0
                             */
                            getEnabledResourcePacks(): JavaList<string>;

                            /**
                             * Set the enabled resource packs to the provided list.
                             * @return self for chaining.
                             * @since 1.2.0
                             */
                            setEnabledResourcePacks(enabled: string[]): this;

                            /**
                             * @param state false to put it back
                             * @since 1.8.3
                             */
                            removeServerResourcePack(state: boolean): OptionsHelper;

                            /**
                             * @return the active language.
                             * @since 1.8.4
                             */
                            getLanguage(): Locale;

                            /**
                             * @param languageCode the language to change to
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setLanguage(languageCode: Locale): this;

                            /**
                             * @return the active difficulty.
                             * @since 1.8.4
                             */
                            getDifficulty(): Difficulty;

                            /**
                             * The name be either "peaceful", "easy", "normal", or "hard".
                             * @param name the name of the difficulty to change to
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setDifficulty(name: Difficulty): this;

                            /**
                             * @return `true` if the difficulty is locked, `false` otherwise.
                             * @since 1.8.4
                             */
                            isDifficultyLocked(): boolean;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            lockDifficulty(): this;

                            /**
                             * Unlocks the difficulty of the world. This can't be done in an unmodified client.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            unlockDifficulty(): this;

                            /**
                             * @return the current fov value.
                             * @since 1.1.7
                             */
                            getFov(): number;

                            /**
                             * @param fov the new fov value
                             * @return self for chaining.
                             * @since 1.1.7
                             */
                            setFov(fov: int): this;

                            /**
                             * @return 0 for 1st person, 2 for in front.
                             * @since 1.5.0
                             */
                            getCameraMode(): Trit;

                            /**
                             * @param mode 0: first, 2: front
                             * @since 1.5.0
                             */
                            setCameraMode(mode: Trit): OptionsHelper;
                            /** @since 1.5.0 */
                            getSmoothCamera(): boolean;
                            /** @since 1.5.0 */
                            setSmoothCamera(val: boolean): OptionsHelper;
                            /** @since 1.2.6 */
                            getWidth(): number;
                            /** @since 1.2.6 */
                            getHeight(): number;
                            /** @since 1.2.6 */
                            setWidth(w: int): OptionsHelper;
                            /** @since 1.2.6 */
                            setHeight(h: int): OptionsHelper;
                            /** @since 1.2.6 */
                            setSize(w: int, h: int): OptionsHelper;

                            /**
                             * @return 0: off, 2: fancy
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper.getCloudsMode}() instead.
                             */
                            getCloudMode(): Trit;

                            /**
                             * @param mode 0: off, 2: fancy
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper.setCloudsMode}(String) instead.
                             */
                            setCloudMode(mode: Trit): OptionsHelper;

                            /**
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper.getGraphicsMode}() instead.
                             */
                            getGraphicsMode(): number;

                            /**
                             * @param mode 0: fast, 2: fabulous
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper.setGraphicsMode}(String) instead.
                             */
                            setGraphicsMode(mode: int): OptionsHelper;

                            /**
                             * @since 1.1.7
                             * @deprecated use {@link SkinOptionsHelper.isRightHanded}() instead.
                             */
                            isRightHanded(): boolean;

                            /**
                             * @since 1.1.7
                             * @deprecated use {@link SkinOptionsHelper.toggleMainHand}(String) instead.
                             */
                            setRightHanded(val: boolean): OptionsHelper;

                            /**
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper.getRenderDistance}() instead.
                             */
                            getRenderDistance(): number;

                            /**
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper.setRenderDistance}(int) instead.
                             */
                            setRenderDistance(d: int): OptionsHelper;

                            /**
                             * @since 1.3.0 normal values for gamma are between `0` and `1`
                             * @deprecated use {@link VideoOptionsHelper.getGamma}() instead.
                             */
                            getGamma(): number;

                            /**
                             * @since 1.3.0 normal values for gamma are between `0` and `1`
                             * @deprecated use {@link VideoOptionsHelper.setGamma}(double) instead.
                             */
                            setGamma(gamma: double): OptionsHelper;

                            /**
                             * @since 1.3.1
                             * @deprecated use {@link MusicOptionsHelper.setMasterVolume}(double) instead.
                             */
                            setVolume(vol: double): OptionsHelper;

                            /**
                             * set volume by category.
                             * @since 1.3.1
                             * @deprecated use {@link MusicOptionsHelper.setVolume}(String, double) instead.
                             */
                            setVolume(category: SoundCategory, volume: double): OptionsHelper;

                            /**
                             * @since 1.3.1
                             * @deprecated use {@link MusicOptionsHelper.getVolumes}() instead.
                             */
                            getVolumes(): JavaMap<SoundCategory, float>;

                            /**
                             * sets gui scale, `0` for auto.
                             * @since 1.3.1
                             * @deprecated use {@link VideoOptionsHelper.setGuiScale}(int) instead.
                             */
                            setGuiScale(scale: int): OptionsHelper;

                            /**
                             * @return gui scale, `0` for auto.
                             * @since 1.3.1
                             * @deprecated use {@link VideoOptionsHelper.getGuiScale}() instead.
                             */
                            getGuiScale(): number;

                            /**
                             * @since 1.3.1
                             * @deprecated use {@link MusicOptionsHelper.getVolume}(String) instead.
                             */
                            getVolume(category: SoundCategory): number;

                        }


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        class AdvancementManagerHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.advancement.AdvancementManager */ any> {
                            static readonly class: JavaClass<AdvancementManagerHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (advancementManager: /* net.minecraft.advancement.AdvancementManager */ any);

                            /**
                             * @return a map of all advancement ids and their advancement.
                             * @since 1.8.4
                             */
                            getAdvancementsForIdentifiers(): JavaMap<AdvancementId, AdvancementHelper>;

                            /**
                             * @return a list of all advancements.
                             * @since 1.8.4
                             */
                            getAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * Started advancements are advancements that have been started, so at least one task has been
                             *  completed so far, but not fully completed.
                             * @return a list of all started advancements.
                             * @since 1.8.4
                             */
                            getStartedAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @return a list of all missing advancements.
                             * @since 1.8.4
                             */
                            getMissingAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @return a list of all completed advancements.
                             * @since 1.8.4
                             */
                            getCompletedAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @return a list of all the root advancements.
                             * @since 1.8.4
                             */
                            getRootAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @return a list of all advancements that are not a root.
                             * @since 1.8.4
                             */
                            getSubAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @param identifier the identifier of the advancement
                             * @return the advancement for the given identifier.
                             * @since 1.8.4
                             */
                            getAdvancement(identifier: CanOmitNamespace<AdvancementId>): AdvancementHelper;

                            /**
                             * @return a map of all advancements and their progress.
                             * @since 1.8.4
                             */
                            getAdvancementsProgress(): JavaMap<AdvancementHelper, AdvancementProgressHelper>;

                            /**
                             * @return the progress of the given advancement.
                             * @since 1.8.4
                             */
                            getAdvancementProgress(identifier: CanOmitNamespace<AdvancementId>): AdvancementProgressHelper;

                        }

                        /** @since 1.5.1 */
                        abstract class NBTElementHelper$NBTCompoundHelper extends NBTElementHelper</* net.minecraft.nbt.NbtCompound */ any> {
                            static readonly class: JavaClass<NBTElementHelper$NBTCompoundHelper>;
                            /** @deprecated */ static prototype: undefined;

                            /** @since 1.6.0 */
                            getKeys(): JavaSet<string>;
                            /** @since 1.5.1 */
                            getType(key: string): number;
                            /** @since 1.5.1 */
                            getType(): number;
                            /** @since 1.5.1 */
                            has(key: string): boolean;
                            /** @since 1.5.1 */
                            get(key: string): NBTElementHelper<any> | null;
                            /** @since 1.5.1 */
                            asString(key: string): string;

                            /**
                             * if element is a string, returns value.  
                             *  otherwise returns toString representation.
                             * @since 1.5.1
                             */
                            asString(): string;

                        }

                        class OptionsHelper$ChatOptionsHelper extends java.lang.Object {
                            static readonly class: JavaClass<OptionsHelper$ChatOptionsHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (OptionsHelper: OptionsHelper);

                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the current chat visibility mode.
                             * @since 1.8.4
                             */
                            getChatVisibility(): ChatVisibility;

                            /**
                             * @param mode the new chat visibility mode. Must be "FULL", "SYSTEM" or "HIDDEN
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatVisibility(mode: ChatVisibility): this;

                            /**
                             * @return `true` if messages can use color codes, `false` otherwise.
                             * @since 1.8.4
                             */
                            areColorsShown(): boolean;

                            /**
                             * @param val whether to allow color codes in messages or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setShowColors(val: boolean): this;

                            /**
                             * @return `true` if it's allowed to open web links from chat, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            areWebLinksEnabled(): boolean;

                            /**
                             * @param val whether to allow opening web links from chat or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableWebLinks(val: boolean): this;

                            /**
                             * @return `true` if a warning prompt before opening links should be shown,
                             *  `false` otherwise.
                             * @since 1.8.4
                             */
                            isWebLinkPromptEnabled(): boolean;

                            /**
                             * @param val whether to show warning prompts before opening links or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableWebLinkPrompt(val: boolean): this;

                            /**
                             * @return the current chat opacity.
                             * @since 1.8.4
                             */
                            getChatOpacity(): number;

                            /**
                             * @param val the new chat opacity
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatOpacity(val: double): this;

                            /**
                             * @param val the new background opacity for text
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setTextBackgroundOpacity(val: double): this;

                            /**
                             * @return the current background opacity of text.
                             * @since 1.8.4
                             */
                            getTextBackgroundOpacity(): number;

                            /**
                             * @return the current text size.
                             * @since 1.8.4
                             */
                            getTextSize(): number;

                            /**
                             * @param val the new text size
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setTextSize(val: double): this;

                            /**
                             * @return the current chat line spacing.
                             * @since 1.8.4
                             */
                            getChatLineSpacing(): number;

                            /**
                             * @param val the new chat line spacing
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatLineSpacing(val: double): this;

                            /**
                             * @return the current chat delay in seconds.
                             * @since 1.8.4
                             */
                            getChatDelay(): number;

                            /**
                             * @param val the new chat delay in seconds
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatDelay(val: double): this;

                            /**
                             * @return the current chat width.
                             * @since 1.8.4
                             */
                            getChatWidth(): number;

                            /**
                             * @param val the new chat width
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatWidth(val: double): this;

                            /**
                             * @return the focused chat height.
                             * @since 1.8.4
                             */
                            getChatFocusedHeight(): number;

                            /**
                             * @param val the new focused chat height
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatFocusedHeight(val: double): this;

                            /**
                             * @return the unfocused chat height.
                             * @since 1.8.4
                             */
                            getChatUnfocusedHeight(): number;

                            /**
                             * @param val the new unfocused chat height
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatUnfocusedHeight(val: double): this;

                            /**
                             * @return the current narrator mode.
                             * @since 1.8.4
                             */
                            getNarratorMode(): NarratorMode;

                            /**
                             * @param mode the mode to set the narrator to. Must be either "OFF", "ALL", "CHAT", or
                             *              "SYSTEM"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setNarratorMode(mode: NarratorMode): this;

                            /**
                             * @return `true` if command suggestions are enabled
                             * @since 1.8.4
                             */
                            areCommandSuggestionsEnabled(): boolean;

                            /**
                             * @param val whether to enable command suggestions or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableCommandSuggestions(val: boolean): this;

                            /**
                             * @return `true` if messages from blocked users are hidden.
                             * @since 1.8.4
                             */
                            areMatchedNamesHidden(): boolean;

                            /**
                             * @param val whether to hide messages of blocked users or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableHideMatchedNames(val: boolean): this;

                            /**
                             * @return `true` if reduced debug info is enabled, `false` otherwise.
                             * @since 1.8.4
                             */
                            isDebugInfoReduced(): boolean;

                            /**
                             * @param val whether to enable reduced debug info or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            reduceDebugInfo(val: boolean): this;

                        }


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        class PacketByteBufferHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.network.PacketByteBuf */ any> {
                            static readonly class: JavaClass<PacketByteBufferHelper>;
                            /** @deprecated */ static prototype: undefined;

                            /**
                             * Don't touch this here!
                             */
                            static readonly BUFFER_TO_PACKET: JavaMap<JavaClass</* net.minecraft.network.packet.Packet<any> */ any>, MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, /* net.minecraft.network.packet.Packet<any> */ any>>;

                            static getPacketName(packet: /* net.minecraft.network.packet.Packet<any> */ any): string;
                            static init(): void;
                            static main(args: string[]): void;

                            constructor ();
                            constructor (base: /* net.minecraft.network.PacketByteBuf */ any);
                            constructor (packet: /* net.minecraft.network.packet.Packet<any> */ any);

                            /**
                             * @return the packet for this buffer or `null` if no packet was used to create this
                             *  helper.
                             * @since 1.8.4
                             */
                            toPacket(): /* net.minecraft.network.packet.Packet<any> */ any | null;

                            /**
                             * @param packetName the name of the packet's class that should be returned
                             * @return the packet for this buffer.
                             * @see getPacketNames()
                             * @since 1.8.4
                             */
                            toPacket(packetName: PacketName): /* net.minecraft.network.packet.Packet<any> */ any;

                            /**
                             * @param clazz the class of the packet to return
                             * @return the packet for this buffer.
                             * @since 1.8.4
                             */
                            toPacket(clazz: JavaClassArg</* net.minecraft.network.packet.Packet */ any>): /* net.minecraft.network.packet.Packet<any> */ any;

                            /**
                             * @param clientbound whether the packet is clientbound or serverbound
                             * @param packetId the id of the packet
                             * @return the packet for this buffer.
                             * @see getPacketId(Class)
                             * @see getNetworkStateId(Class)
                             * @see isClientbound(Class)
                             * @see isServerbound(Class)
                             * @since 1.8.4
                             */
                            toPacket(clientbound: boolean, packetId: int): /* net.minecraft.network.packet.Packet<any> */ any;

                            /**
                             * @param packetClass the class of the packet to get the id for
                             * @return the id of the packet.
                             * @since 1.8.4
                             */
                            getPacketId(packetClass: JavaClassArg</* net.minecraft.network.packet.Packet<any> */ any>): number;

                            /**
                             * @param packetClass the class of the packet to get the id for
                             * @return the id of the network state the packet belongs to.
                             * @since 1.8.4
                             */
                            getNetworkStateId(packetClass: JavaClassArg</* net.minecraft.network.packet.Packet<any> */ any>): number;

                            /**
                             * @param packetClass the class to get the side for
                             * @return `true` if the packet is clientbound, `false` if it is serverbound.
                             * @since 1.8.4
                             */
                            isClientbound(packetClass: JavaClassArg</* net.minecraft.network.packet.Packet<any> */ any>): boolean;

                            /**
                             * @param packetClass the class to get the id for
                             * @return `true` if the packet is serverbound, `false` if it is clientbound.
                             * @since 1.8.4
                             */
                            isServerbound(packetClass: JavaClassArg</* net.minecraft.network.packet.Packet<any> */ any>): boolean;

                            /**
                             * Send a packet of the given type, created from this buffer, to the server.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            sendPacket(): this;

                            /**
                             * @param packetName the name of the packet's class that should be sent
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            sendPacket(packetName: string): this;

                            /**
                             * Send a packet of the given type, created from this buffer, to the server.
                             * @param clazz the class of the packet to send
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            sendPacket(clazz: JavaClassArg</* net.minecraft.network.packet.Packet<any> */ any>): this;

                            /**
                             * @param channel the channel to send the packet on
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            sendCustomPacket(channel: string): this;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            receivePacket(): this;

                            /**
                             * @param packetName the name of the packet's class that should be received
                             * @return self for chaining.
                             * @see getPacketNames()
                             * @since 1.8.4
                             */
                            receivePacket(packetName: PacketName): this;

                            /**
                             * @param clazz the class of the packet to receive
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            receivePacket(clazz: JavaClassArg</* net.minecraft.network.packet.Packet */ any>): this;

                            /**
                             * @param channel the channel to receive the packet on
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            receiveCustomPacket(channel: string): this;

                            /**
                             * These names are subject to change and are only for an easier access. They will probably not
                             *  change in the future, but it is not guaranteed.
                             * @return a list of all packet names.
                             * @since 1.8.4
                             */
                            getPacketNames(): JavaList<PacketName>;

                            /**
                             * Resets the buffer to the state it was in when this helper was created.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            reset(): this;

                            /**
                             * @param registry the registry the value is from
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeRegistryValue<T>(registry: /* net.minecraft.util.collection.IndexedIterable<T> */ any, value: T): this;

                            /**
                             * @param registry the registry the read value is from
                             * @return the registry value.
                             * @since 1.8.4
                             */
                            readRegistryValue<T>(registry: /* net.minecraft.util.collection.IndexedIterable<T> */ any): T;

                            /**
                             * @param key the registry key to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeRegistryKey(key: /* net.minecraft.registry.RegistryKey<any> */ any): this;

                            /**
                             * @param registry the registry the read key is from
                             * @return the registry key.
                             * @since 1.8.4
                             */
                            readRegistryKey<T>(registry: /* net.minecraft.registry.RegistryKey<net.minecraft.registry.Registry<T>> */ any): /* net.minecraft.registry.RegistryKey<T> */ any;

                            /**
                             * @param collection the collection to store
                             * @param writer the function that writes the collection's elements to the buffer
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeCollection<T>(collection: JavaCollection<T>, writer: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, T, any, any>): this;

                            /**
                             * @param reader the function that reads the collection's elements from the buffer
                             * @return the read list.
                             * @since 1.8.4
                             */
                            readList<T>(reader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, T, any>): JavaList<T>;

                            /**
                             * @param list the integer list to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeIntList(list: JavaCollection<int>): this;

                            /**
                             * @return the read integer list.
                             * @since 1.8.4
                             */
                            readIntList(): it.unimi.dsi.fastutil.ints.IntList;

                            /**
                             * @param map the map to store
                             * @param keyWriter the function to write the map's keys to the buffer
                             * @param valueWriter the function to write the map's values to the buffer
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeMap<K, V>(map: JavaMap<K, V>, keyWriter: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, K, any, any>, valueWriter: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, V, any, any>): this;

                            /**
                             * @param keyReader the function to read the map's keys from the buffer
                             * @param valueReader the function to read the map's values from the buffer
                             * @return the read map.
                             * @since 1.8.4
                             */
                            readMap<K, V>(keyReader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, K, any>, valueReader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, V, any>): JavaMap<K, V>;

                            /**
                             * @param reader the function to read the collection's elements from the buffer
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            forEachInCollection(reader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, any, any>): this;

                            /**
                             * @param value the optional value to store
                             * @param writer the function to write the optional value if present to the buffer
                             * @return self for chaining.
                             * @see writeNullable(Object, MethodWrapper)
                             * @since 1.8.4
                             */
                            writeOptional<T>(value: T, writer: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, T, any, any>): this;

                            /**
                             * @param reader the function to read the optional value from the buffer if present
                             * @return the optional value.
                             * @see readNullable(MethodWrapper)
                             * @since 1.8.4
                             */
                            readOptional<T>(reader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, T, any>): java.util.Optional<T>;

                            /**
                             * @param value the optional value to store
                             * @param writer the function to write the optional value if it's not null to the buffer
                             * @return self for chaining.
                             * @see writeOptional(Object, MethodWrapper)
                             * @since 1.8.4
                             */
                            writeNullable(value: any, writer: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, any, any>): this;

                            /**
                             * @param reader the function to read the value from the buffer if it's not null
                             * @return the read value or `null` if it was null.
                             * @see readOptional(MethodWrapper)
                             * @since 1.8.4
                             */
                            readNullable<T>(reader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, T, any>): T;

                            /**
                             * This method chooses the left value if it's not null, otherwise it chooses the right value.
                             * @param left the left value to store
                             * @param right the right value to store
                             * @param leftWriter the function to write the left value to the buffer
                             * @param rightWriter the function to write the right value to the buffer
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeEither<L, R>(left: L, right: R, leftWriter: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, L, any, any>, rightWriter: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, R, any, any>): this;

                            /**
                             * @param leftReader the function to read the left value from the buffer
                             * @param rightReader the function to read the right value from the buffer
                             * @return the read object.
                             * @since 1.8.4
                             */
                            readEither(leftReader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, any, any>, rightReader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* net.minecraft.network.PacketByteBuf */ any, any, any, any>): any;

                            /**
                             * @param bytes the bytes to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeByteArray(bytes: byte[]): this;

                            /**
                             * @return the read byte array.
                             * @since 1.8.4
                             */
                            readByteArray(): JavaArray<number>;

                            /**
                             * Will throw an exception if the byte array is bigger than the given maximum size.
                             * @param maxSize the maximum size of the byte array to read
                             * @return the read byte array.
                             * @since 1.8.4
                             */
                            readByteArray(maxSize: int): JavaArray<number>;

                            /**
                             * @param ints the int array to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeIntArray(ints: int[]): this;

                            /**
                             * @return the read int array.
                             * @since 1.8.4
                             */
                            readIntArray(): JavaArray<number>;

                            /**
                             * Will throw an exception if the int array is bigger than the given maximum size.
                             * @param maxSize the maximum size of the int array to read
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            readIntArray(maxSize: int): this;

                            /**
                             * @param longs the long array to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeLongArray(longs: long[]): this;

                            /**
                             * @return the read long array.
                             * @since 1.8.4
                             */
                            readLongArray(): JavaArray<number>;

                            /**
                             * Will throw an exception if the long array is bigger than the given maximum size.
                             * @param maxSize the maximum size of the long array to read
                             * @return the read long array.
                             * @since 1.8.4
                             */
                            readLongArray(maxSize: int): JavaArray<number>;

                            /**
                             * @param pos the block position to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBlockPos(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): this;

                            /**
                             * @param x the x coordinate of the block position to store
                             * @param y the y coordinate of the block position to store
                             * @param z the z coordinate of the block position to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBlockPos(x: int, y: int, z: int): this;

                            /**
                             * @return the read block position.
                             * @since 1.8.4
                             */
                            readBlockPos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

                            /**
                             * @param x the x coordinate of the chunk to store
                             * @param z the z coordinate of the chunk to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChunkPos(x: int, z: int): this;

                            /**
                             * @param chunk the chunk to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChunkPos(chunk: xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper): this;

                            /**
                             * @return the position of the read chunk, x at index 0, z at index 1.
                             * @since 1.8.4
                             */
                            readChunkPos(): JavaArray<number>;

                            /**
                             * @return a {@link ChunkHelper} for the read chunk position.
                             * @since 1.8.4
                             */
                            readChunkHelper(): xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper | null;

                            /**
                             * @param chunkX the x coordinate of the chunk to store
                             * @param y the y coordinate to store
                             * @param chunkZ the z coordinate of the chunk to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChunkSectionPos(chunkX: int, y: int, chunkZ: int): this;

                            /**
                             * @param chunk the chunk whose position should be stored
                             * @param y the y to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChunkSectionPos(chunk: xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper, y: int): this;

                            /**
                             * @return the read chunk section pos, as a {@link BlockPosHelper}.
                             * @since 1.8.4
                             */
                            readChunkSectionPos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

                            /**
                             * @param dimension the dimension, vanilla default are `overworld`, `the_nether`,
                             *                   `the_end`
                             * @param pos the position to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeGlobalPos(dimension: CanOmitNamespace<Dimension>, pos: BlockPosHelper): this;

                            /**
                             * @param dimension the dimension, vanilla default are `overworld`, `the_nether`,
                             *                   `the_end`
                             * @param x the x coordinate of the position to store
                             * @param y the y coordinate of the position to store
                             * @param z the z coordinate of the position to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeGlobalPos(dimension: CanOmitNamespace<Dimension>, x: int, y: int, z: int): this;

                            /**
                             * @return the read global pos, the first element is the dimension, the second is the position.
                             * @since 1.8.4
                             */
                            readGlobalPos(): xyz.wagyourtail.Pair<string, xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper>;

                            /**
                             * @param text the string to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeText(text: string): this;

                            /**
                             * @param builder the text builder whose text should be stored
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeText(builder: xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder): this;

                            /**
                             * @param text the text to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeText(text: TextHelper): this;

                            /**
                             * @return the read text.
                             * @since 1.8.4
                             */
                            readText(): TextHelper;

                            /**
                             * @param constant the enum constant to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeEnumConstant(constant: java.lang.Enum<any>): this;

                            /**
                             * @param enumClass the class of the enum to read from
                             * @return the read enum constant.
                             * @since 1.8.4
                             */
                            readEnumConstant<T extends java.lang.Enum<T>>(enumClass: JavaClassArg<T>): T;

                            /**
                             * @param i the int to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeVarInt(i: int): this;

                            /**
                             * @return the read int.
                             * @since 1.8.4
                             */
                            readVarInt(): number;

                            /**
                             * @param l the long to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeVarLong(l: long): this;

                            /**
                             * @return the read long.
                             * @since 1.8.4
                             */
                            readVarLong(): number;

                            /**
                             * @param uuid the UUID to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeUuid(uuid: string): this;

                            /**
                             * @return the read UUID.
                             * @since 1.8.4
                             */
                            readUuid(): java.util.UUID;

                            /**
                             * @param nbt the nbt
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeNbt(nbt: NBTElementHelper$NBTCompoundHelper): this;

                            /**
                             * @return the read nbt data.
                             * @since 1.8.4
                             */
                            readNbt(): NBTElementHelper<any>;

                            /**
                             * @param stack the item stack to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeItemStack(stack: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): this;

                            /**
                             * @return the read item stack.
                             * @since 1.8.4
                             */
                            readItemStack(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            /**
                             * @param string the string to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeString(string: string): this;

                            /**
                             * Throws an exception if the string is longer than the given length.
                             * @param string the string to store
                             * @param maxLength the maximum length of the string
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeString(string: string, maxLength: int): this;

                            /**
                             * @return the read string.
                             * @since 1.8.4
                             */
                            readString(): string;

                            /**
                             * Throws an exception if the read string is longer than the given length.
                             * @param maxLength the maximum length of the string to read
                             * @return the read string.
                             * @since 1.8.4
                             */
                            readString(maxLength: int): string;

                            /**
                             * @param id the identifier to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeIdentifier(id: string): this;

                            /**
                             * @return the read identifier.
                             * @since 1.8.4
                             */
                            readIdentifier(): string;

                            /**
                             * @param date the date to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeDate(date: java.util.Date): this;

                            /**
                             * @return the read date.
                             * @since 1.8.4
                             */
                            readDate(): java.util.Date;

                            /**
                             * @param instant the instant to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeInstant(instant: java.time.Instant): this;

                            /**
                             * @return the read instant.
                             * @since 1.8.4
                             */
                            readInstant(): java.time.Instant;

                            /**
                             * @param key the public key to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writePublicKey(key: java.security.PublicKey): this;

                            /**
                             * @return the read public key.
                             * @since 1.8.4
                             */
                            readPublicKey(): java.security.PublicKey;

                            /**
                             * @param hitResult the hit result to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBlockHitResult(hitResult: /* net.minecraft.util.hit.BlockHitResult */ any): this;

                            /**
                             * @param pos the position of the BlockHitResult
                             * @param direction the direction of the BlockHitResult
                             * @param blockPos the block pos of the BlockHitResult
                             * @param missed whether the BlockHitResult missed
                             * @param insideBlock whether the BlockHitResult is inside a block
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBlockHitResult(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, direction: string, blockPos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, missed: boolean, insideBlock: boolean): this;

                            /**
                             * @return the read block hit result.
                             * @since 1.8.4
                             */
                            readBlockHitResult(): /* net.minecraft.util.hit.BlockHitResult */ any;

                            /**
                             * @return a map of the block hit result's data and their values.
                             * @since 1.8.4
                             */
                            readBlockHitResultMap(): JavaMap<string, any>;

                            /**
                             * @param bitSet the bit set to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBitSet(bitSet: java.util.BitSet): this;

                            /**
                             * @return the read bit set.
                             * @since 1.8.4
                             */
                            readBitSet(): java.util.BitSet;

                            /**
                             * @param profile the profile to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeGameProfile(profile: com.mojang.authlib.GameProfile): this;

                            /**
                             * @return the read game profile.
                             * @since 1.8.4
                             */
                            readGameProfile(): com.mojang.authlib.GameProfile;

                            /**
                             * @return the read profile's name.
                             * @since 1.8.4
                             */
                            readGameProfileName(): string;

                            /**
                             * @return the read profile's UUID.
                             * @since 1.8.4
                             */
                            readGameProfileUuid(): java.util.UUID;

                            /**
                             * @return the readers current position.
                             * @since 1.8.4
                             */
                            readerIndex(): number;

                            /**
                             * @param index the readers new index
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setReaderIndex(index: int): this;

                            /**
                             * @return the writers current position.
                             * @since 1.8.4
                             */
                            writerIndex(): number;

                            /**
                             * @param index the writers new index
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setWriterIndex(index: int): this;

                            /**
                             * @param readerIndex the readers new index
                             * @param writerIndex the writers new index
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setIndices(readerIndex: int, writerIndex: int): this;

                            /**
                             * Resets the readers and writers index to their respective last marked indices.
                             * @return self for chaining.
                             * @see markReaderIndex()
                             * @see markWriterIndex()
                             * @since 1.8.4
                             */
                            resetIndices(): this;

                            /**
                             * Marks the readers current index for later use.
                             * @return self for chaining.
                             * @see resetReaderIndex()
                             * @since 1.8.4
                             */
                            markReaderIndex(): this;

                            /**
                             * Resets the readers index to the last marked index.
                             * @return self for chaining.
                             * @see markReaderIndex()
                             * @since 1.8.4
                             */
                            resetReaderIndex(): this;

                            /**
                             * Marks the writers current index for later use.
                             * @return self for chaining.
                             * @see resetWriterIndex()
                             * @see ()
                             * @since 1.8.4
                             */
                            markWriterIndex(): this;

                            /**
                             * Resets the writers index to the last marked index.
                             * @return self for chaining.
                             * @see markWriterIndex()
                             * @since 1.8.4
                             */
                            resetWriterIndex(): this;

                            /**
                             * Resets the writers and readers index to 0. This technically doesn't clear the buffer, but
                             *  rather makes it so that new operations will overwrite the old data.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            clear(): this;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBoolean(value: boolean): this;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBoolean(index: int, value: boolean): this;

                            /**
                             * @return the read boolean value.
                             * @since 1.8.4
                             */
                            readBoolean(): boolean;

                            /**
                             * @param index the index to read from
                             * @return the boolean value at the given index.
                             * @since 1.8.4
                             */
                            getBoolean(index: int): boolean;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChar(value: int): this;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChar(index: int, value: char): this;

                            /**
                             * @return the read char value.
                             * @since 1.8.4
                             */
                            readChar(): number;

                            /**
                             * @param index the index to read from
                             * @return the char at the given index.
                             * @since 1.8.4
                             */
                            getChar(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeByte(value: int): this;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setByte(index: int, value: int): this;

                            /**
                             * @return the read byte value.
                             * @since 1.8.4
                             */
                            readByte(): number;

                            /**
                             * @return the read unsigned byte value, represented as a short.
                             * @since 1.8.4
                             */
                            readUnsignedByte(): number;

                            /**
                             * @param index the index to read from
                             * @return the byte at the given index.
                             * @since 1.8.4
                             */
                            getByte(index: int): number;

                            /**
                             * @param index the index to read from
                             * @return the unsigned byte at the given index, represented as a short.
                             * @since 1.8.4
                             */
                            getUnsignedByte(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeShort(value: int): this;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setShort(index: int, value: int): this;

                            /**
                             * @return the read short value.
                             * @since 1.8.4
                             */
                            readShort(): number;

                            /**
                             * @return the read unsigned short value, represented as an int.
                             * @since 1.8.4
                             */
                            readUnsignedShort(): number;

                            /**
                             * @param index the index to read from
                             * @return the short at the given index.
                             * @since 1.8.4
                             */
                            getShort(index: int): number;

                            /**
                             * @param index the index to read from
                             * @return the unsigned short at the given index, represented as an int.
                             * @since 1.8.4
                             */
                            getUnsignedShort(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeMedium(value: int): this;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMedium(index: int, value: int): this;

                            /**
                             * @return the read medium value.
                             * @since 1.8.4
                             */
                            readMedium(): number;

                            /**
                             * @return the read unsigned medium value.
                             * @since 1.8.4
                             */
                            readUnsignedMedium(): number;

                            /**
                             * @param index the index to read from
                             * @return the medium at the given index.
                             * @since 1.8.4
                             */
                            getMedium(index: int): number;

                            /**
                             * @param index the index to read from
                             * @return the unsigned medium at the given index.
                             * @since 1.8.4
                             */
                            getUnsignedMedium(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeInt(value: int): this;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setInt(index: int, value: int): this;

                            /**
                             * @return the read int value.
                             * @since 1.8.4
                             */
                            readInt(): number;

                            /**
                             * @return the read unsigned int value, represented as a long.
                             * @since 1.8.4
                             */
                            readUnsignedInt(): number;

                            /**
                             * @param index the index to read from
                             * @return the int at the given index.
                             * @since 1.8.4
                             */
                            getInt(index: int): number;

                            /**
                             * @param index the index to read from
                             * @return the unsigned int at the given index, represented as a long.
                             * @since 1.8.4
                             */
                            getUnsignedInt(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeLong(value: long): this;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setLong(index: int, value: long): this;

                            /**
                             * @return the read long value.
                             * @since 1.8.4
                             */
                            readLong(): number;

                            /**
                             * @param index the index to read from
                             * @return the long at the given index.
                             * @since 1.8.4
                             */
                            getLong(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeFloat(value: double): this;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFloat(index: int, value: double): this;

                            /**
                             * @return the read float value.
                             * @since 1.8.4
                             */
                            readFloat(): number;

                            /**
                             * @param index the index to read from
                             * @return the float at the given index.
                             * @since 1.8.4
                             */
                            getFloat(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeDouble(value: double): this;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setDouble(index: int, value: double): this;

                            /**
                             * @return the read double value.
                             * @since 1.8.4
                             */
                            readDouble(): number;

                            /**
                             * @param index the index to read from
                             * @return the double at the given index.
                             * @since 1.8.4
                             */
                            getDouble(index: int): number;

                            /**
                             * @param length the amount of zeros to write
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeZero(length: int): this;

                            /**
                             * @param index the index to write to
                             * @param length the amount of zeros to write
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setZero(index: int, length: int): this;

                            /**
                             * @param bytes the bytes to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBytes(bytes: byte[]): this;

                            /**
                             * @param index the index to write to
                             * @param bytes the bytes to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBytes(index: int, bytes: byte[]): this;

                            /**
                             * Starts reading from this buffer's readerIndex.
                             * @param length the length of the array to read
                             * @return the read byte array.
                             * @since 1.8.4
                             */
                            readBytes(length: int): JavaArray<number>;

                            /**
                             * @param index the index to start reading from
                             * @param length the length of the array to read
                             * @return the read byte array .
                             * @since 1.8.4
                             */
                            getBytes(index: int, length: int): JavaArray<number>;

                            /**
                             * Moves the readerIndex of this buffer by the specified amount.
                             * @param length the amount of bytes to skip
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            skipBytes(length: int): this;

                        }

                        /** @since 1.4.2 */
                        class CommandContextHelper extends Events.BaseEvent {
                            static readonly class: JavaClass<CommandContextHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (base: com.mojang.brigadier.context.CommandContext<any>);

                            getRaw(): com.mojang.brigadier.context.CommandContext<any>;

                            /**
                             * @throws CommandSyntaxException
                             * @since 1.4.2
                             */
                            getArg(name: string): any;
                            getChild(): CommandContextHelper;
                            getRange(): com.mojang.brigadier.context.StringRange;
                            getInput(): string;

                        }

                        class OptionsHelper$SkinOptionsHelper extends java.lang.Object {
                            static readonly class: JavaClass<OptionsHelper$SkinOptionsHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (OptionsHelper: OptionsHelper);

                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return `true` if the player's cape should be shown, `false` otherwise.
                             * @since 1.8.4
                             */
                            isCapeActivated(): boolean;

                            /**
                             * @return `true` if the player's jacket should be shown, `false` otherwise.
                             * @since 1.8.4
                             */
                            isJacketActivated(): boolean;

                            /**
                             * @return `true` if the player's left sleeve should be shown, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            isLeftSleeveActivated(): boolean;

                            /**
                             * @return `true` if the player's right sleeve should be shown, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            isRightSleeveActivated(): boolean;

                            /**
                             * @return `true` if the player's left pants should be shown, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            isLeftPantsActivated(): boolean;

                            /**
                             * @return `true` if the player's right pants should be shown, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            isRightPantsActivated(): boolean;

                            /**
                             * @return `true` if the player's hat should be shown, `false` otherwise.
                             * @since 1.8.4
                             */
                            isHatActivated(): boolean;

                            /**
                             * @return `true` if the player's main hand is the right one, `false`
                             *  otherwise.
                             * @since 1.8.4
                             */
                            isRightHanded(): boolean;

                            /**
                             * @return `true` if the player's main hand is the left one, `false` otherwise.
                             * @since 1.8.4
                             */
                            isLeftHanded(): boolean;

                            /**
                             * @param val whether the cape should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleCape(val: boolean): this;

                            /**
                             * @param val whether the jacket should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleJacket(val: boolean): this;

                            /**
                             * @param val whether the left sleeve should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleLeftSleeve(val: boolean): this;

                            /**
                             * @param val whether the right sleeve should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleRightSleeve(val: boolean): this;

                            /**
                             * @param val whether the left pants should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleLeftPants(val: boolean): this;

                            /**
                             * @param val whether the right pants should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleRightPants(val: boolean): this;

                            /**
                             * @param val whether the hat should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleHat(val: boolean): this;

                            /**
                             * The hand must be either `"left"` or `"right"`.
                             * @param hand the hand to set as main hand
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleMainHand(hand: string): this;

                        }


                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        class FormattingHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.util.Formatting */ any> {
                            static readonly class: JavaClass<FormattingHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (base: /* net.minecraft.util.Formatting */ any);

                            /**
                             * @return the color value of this formatting.
                             * @since 1.8.4
                             */
                            getColorValue(): number;

                            /**
                             * @return the index of this formatting or `-1` if this formatting is a modifier.
                             * @since 1.8.4
                             */
                            getColorIndex(): number;

                            /**
                             * @return the name of this formatting.
                             * @since 1.8.4
                             */
                            getName(): string;

                            /**
                             * The color code can be used with the paragraph to color text.
                             * @return the color code of this formatting.
                             * @since 1.8.4
                             */
                            getCode(): number;

                            /**
                             * @return `true` if this formatting is a color, `false` otherwise.
                             * @since 1.8.4
                             */
                            isColor(): boolean;

                            /**
                             * @return `true` if this formatting is a modifier, `false` otherwise.
                             * @since 1.8.4
                             */
                            isModifier(): boolean;

                        }

                        class StatsHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.stat.StatHandler */ any> {
                            static readonly class: JavaClass<StatsHelper>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (base: /* net.minecraft.stat.StatHandler */ any);

                            getStatList(): JavaList<string>;
                            getStatText(statKey: string): /* net.minecraft.text.Text */ any;
                            getRawStatValue(statKey: string): number;
                            getFormattedStatValue(statKey: string): string;
                            getFormattedStatMap(): JavaMap<string, string>;
                            getRawStatMap(): JavaMap<string, number>;

                            /**
                             * @param id the identifier of the entity
                             * @return how many times the player has killed the entity.
                             * @since 1.8.4
                             */
                            getEntityKilled(id: EntityId): number;

                            /**
                             * @param id the identifier of the entity
                             * @return how many times the player has killed the specified entity.
                             * @since 1.8.4
                             */
                            getKilledByEntity(id: EntityId): number;

                            /**
                             * @param id the identifier of the block
                             * @return how many times the player has mined the block.
                             * @since 1.8.4
                             */
                            getBlockMined(id: BlockId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has broken the item.
                             * @since 1.8.4
                             */
                            getItemBroken(id: ItemId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has crafted the item.
                             * @since 1.8.4
                             */
                            getItemCrafted(id: ItemId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has used the item.
                             * @since 1.8.4
                             */
                            getItemUsed(id: ItemId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has picked up the item.
                             * @since 1.8.4
                             */
                            getItemPickedUp(id: ItemId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has dropped the item.
                             * @since 1.8.4
                             */
                            getItemDropped(id: ItemId): number;

                            /**
                             * @param id the identifier of the custom stat
                             * @return the value of the custom stat.
                             * @since 1.8.4
                             */
                            getCustomStat(id: string): number;

                            /**
                             * @param id the identifier of the custom stat
                             * @return the formatted value of the custom stat.
                             * @since 1.8.4
                             */
                            getCustomFormattedStat(id: string): string;

                            /**
                             * Used to request an update of the statistics from the server.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            updateStatistics(): this;

                        }

                        export {
                            DyeColorHelper,
                            AdvancementProgressHelper,
                            NBTElementHelper$NBTListHelper,
                            NBTElementHelper$NBTNumberHelper,
                            TextHelper,
                            StyleHelper,
                            AdvancementHelper,
                            NBTElementHelper,
                            StatusEffectHelper,
                            OptionsHelper$MusicOptionsHelper,
                            ModContainerHelper,
                            OptionsHelper$AccessibilityOptionsHelper,
                            OptionsHelper$ControlOptionsHelper,
                            InteractionManagerHelper,
                            OptionsHelper$VideoOptionsHelper,
                            CommandNodeHelper,
                            SuggestionsBuilderHelper,
                            OptionsHelper,
                            AdvancementManagerHelper,
                            NBTElementHelper$NBTCompoundHelper,
                            OptionsHelper$ChatOptionsHelper,
                            PacketByteBufferHelper,
                            CommandContextHelper,
                            OptionsHelper$SkinOptionsHelper,
                            FormattingHelper,
                            StatsHelper
                        }

                    }
                    namespace helpers {

                        namespace inventory {


                            /**
                             * @author Wagyourtail
                             * @since 1.3.1
                             */
                            class RecipeHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.recipe.RecipeEntry<any> */ any> {
                                static readonly class: JavaClass<RecipeHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.recipe.RecipeEntry<any> */ any, syncId: int);

                                /** @since 1.3.1 */
                                getId(): string;

                                /**
                                 * get ingredients list
                                 * @since 1.8.3
                                 */
                                getIngredients(): JavaList<JavaList<ItemStackHelper>>;
                                /** @since 1.3.1 */
                                getOutput(): ItemStackHelper;
                                /** @since 1.3.1 */
                                craft(craftAll: boolean): RecipeHelper;

                                /**
                                 * @return the type of this recipe.
                                 * @since 1.8.4
                                 */
                                getGroup(): string;

                                /**
                                 * This will not account for the actual items used in the recipe, but only the default recipe
                                 *  itself. Items with durability or with a lot of tags will probably not work correctly.
                                 * @return will return `true` if any of the default ingredients have a recipe remainder.
                                 * @since 1.8.4
                                 */
                                hasRecipeRemainders(): boolean;

                                /**
                                 * @return a list of all possible recipe remainders.
                                 * @since 1.8.4
                                 */
                                getRecipeRemainders(): JavaList<JavaList<ItemStackHelper>>;

                                /**
                                 * @return the type of this recipe.
                                 * @since 1.8.4
                                 */
                                getType(): string;

                                /**
                                 * @return `true` if the recipe can be crafted with the current inventory, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                canCraft(): boolean;

                                /**
                                 * @param amount the amount of items to craft
                                 * @return `true` if the given amount of items can be crafted with the current inventory,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                canCraft(amount: int): boolean;

                                /**
                                 * @return how often the recipe can be crafted with the current player inventory.
                                 * @since 1.8.4
                                 */
                                getCraftableAmount(): number;

                            }


                            /**
                             * @author Wagyourtail
                             */
                            class ItemStackHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.item.ItemStack */ any> {
                                static readonly class: JavaClass<ItemStackHelper>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * The old implementation use used in {@link ItemStack} before 1.20. This only checks for the nbt data, the
                                 *  items themselves are not compared.
                                 * @param left the first item stack
                                 * @param right the second item stack
                                 * @return `true` if the two item stacks have equal nbt data, `false` otherwise.
                                 */
                                static areNbtEqual(left: /* net.minecraft.item.ItemStack */ any, right: /* net.minecraft.item.ItemStack */ any): boolean;

                                constructor (id: CanOmitNamespace<ItemId>, count: int);
                                constructor (i: /* net.minecraft.item.ItemStack */ any);

                                /**
                                 * Sets the item damage value.  
                                 *  You should use {@link CreativeItemStackHelper.setDamage}(int) instead.  
                                 *  You may want to use {@link ItemStackHelper.copy}() first.
                                 * @return self
                                 * @since 1.2.0
                                 * @deprecated
                                 */
                                setDamage(damage: int): this;
                                /** @since 1.2.0 */
                                isDamageable(): boolean;

                                /**
                                 * @return `true` if this item is unbreakable, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isUnbreakable(): boolean;
                                /** @since 1.2.0 */
                                isEnchantable(): boolean;

                                /**
                                 * @return `true` if the item is enchanted, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isEnchanted(): boolean;

                                /**
                                 * @return a list of all enchantments on this item.
                                 * @since 1.8.4
                                 */
                                getEnchantments(): JavaList<EnchantmentHelper>;

                                /**
                                 * @param id the id of the enchantment to check for
                                 * @return the enchantment instance, containing the level, or `null` if the item is not
                                 *  enchanted with the specified enchantment.
                                 * @since 1.8.4
                                 */
                                getEnchantment(id: EnchantmentId): EnchantmentHelper | null;

                                /**
                                 * @param enchantment the enchantment to check for
                                 * @return `true` if the specified enchantment can be applied to this item, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                canBeApplied(enchantment: EnchantmentHelper): boolean;

                                /**
                                 * @param enchantment the enchantment to check for
                                 * @return `true` if the item is enchanted with the specified enchantment of the same
                                 *  level, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                hasEnchantment(enchantment: EnchantmentHelper): boolean;

                                /**
                                 * @param enchantment the id of the enchantment to check for
                                 * @return `true` if the item is enchanted with the specified enchantment, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                hasEnchantment(id: CanOmitNamespace<EnchantmentId>): boolean;

                                /**
                                 * @return a list of all enchantments that can be applied to this item.
                                 * @since 1.8.4
                                 */
                                getPossibleEnchantments(): JavaList<EnchantmentHelper>;

                                /**
                                 * @return a list of all enchantments that can be applied to this item through an enchanting table.
                                 * @since 1.8.4
                                 */
                                getPossibleEnchantmentsFromTable(): JavaList<EnchantmentHelper>;

                                /**
                                 * The returned list is a copy of the original list and can be modified without affecting the
                                 *  original item. For editing the actual lore see
                                 *  {@link CreativeItemStackHelper.addLore}(Object...).
                                 * @return a list of all lines of lore on this item.
                                 * @since 1.8.4
                                 */
                                getLore(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

                                /**
                                 * @return the maximum durability of this item.
                                 * @since 1.8.4
                                 */
                                getMaxDurability(): number;

                                /**
                                 * @return the current durability of this item.
                                 * @since 1.8.4
                                 */
                                getDurability(): number;

                                /**
                                 * @return the current repair cost of this item.
                                 * @since 1.8.4
                                 */
                                getRepairCost(): number;

                                /**
                                 * @return the damage taken by this item.
                                 * @see getDurability()
                                 */
                                getDamage(): number;

                                /**
                                 * @return the maximum damage this item can take.
                                 * @see getMaxDurability()
                                 */
                                getMaxDamage(): number;

                                /**
                                 * @return the default attack damage of this item.
                                 * @since 1.8.4
                                 */
                                getAttackDamage(): number;

                                /**
                                 * @return was string before 1.6.5
                                 * @since 1.2.0
                                 */
                                getDefaultName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @return was string before 1.6.5
                                 */
                                getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @return the item count this stack is holding.
                                 */
                                getCount(): number;

                                /**
                                 * @return the maximum amount of items this stack can hold.
                                 */
                                getMaxCount(): number;
                                /** @since 1.1.6, was a {@link String} until 1.5.1 */
                                getNBT(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTCompoundHelper | null;
                                /** @since 1.1.3 */
                                getCreativeTab(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;
                                // /** @deprecated */
                                // getItemID(): ItemId;
                                /** @since 1.6.4 */
                                getItemId(): ItemId;
                                /** @since 1.8.2 */
                                getTags(): JavaList<ItemTag>;
                                /** @since 1.8.2 */
                                isFood(): boolean;
                                /** @since 1.8.2 */
                                isTool(): boolean;
                                /** @since 1.8.2 */
                                isWearable(): boolean;
                                /** @since 1.8.2 */
                                getMiningLevel(): number;
                                isEmpty(): boolean;
                                /** @since 1.1.3 [citation needed] */
                                equals(ish: ItemStackHelper): boolean;
                                /** @since 1.1.3 [citation needed] */
                                equals(is: /* net.minecraft.item.ItemStack */ any): boolean;
                                equals(obj: any): boolean;
                                /** @since 1.1.3 [citation needed] */
                                isItemEqual(ish: ItemStackHelper): boolean;
                                /** @since 1.1.3 [citation needed] */
                                isItemEqual(is: /* net.minecraft.item.ItemStack */ any): boolean;
                                /** @since 1.1.3 [citation needed] */
                                isItemEqualIgnoreDamage(ish: ItemStackHelper): boolean;
                                /** @since 1.1.3 [citation needed] */
                                isItemEqualIgnoreDamage(is: /* net.minecraft.item.ItemStack */ any): boolean;
                                /** @since 1.1.3 [citation needed] */
                                isNBTEqual(ish: ItemStackHelper): boolean;
                                /** @since 1.1.3 [citation needed] */
                                isNBTEqual(is: /* net.minecraft.item.ItemStack */ any): boolean;
                                /** @since 1.6.5 */
                                isOnCooldown(): boolean;
                                /** @since 1.6.5 */
                                getCooldownProgress(): number;

                                /**
                                 * @param block the block to check
                                 * @return `true` if the given block can be mined and drops when broken with this item,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isSuitableFor(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper): boolean;

                                /**
                                 * @param block the block to check
                                 * @return `true` if the given block can be mined and drops when broken with this item,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isSuitableFor(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): boolean;

                                /**
                                 * {@link CreativeItemStackHelper} adds methods for manipulating the item's nbt data.
                                 * @return a {@link CreativeItemStackHelper} instance for this item.
                                 * @since 1.8.4
                                 */
                                getCreative(): CreativeItemStackHelper;

                                /**
                                 * @return the item this stack is made of.
                                 * @since 1.8.4
                                 */
                                getItem(): ItemHelper;
                                /** @since 1.2.0 */
                                copy(): ItemStackHelper;

                                /**
                                 * This flag only affects players in adventure mode and makes sure only specified blocks can be
                                 *  destroyed by this item.
                                 * @return `true` if the can destroy flag is set, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                hasDestroyRestrictions(): boolean;

                                /**
                                 * This flag only affects players in adventure mode and makes sure this item can only be placed
                                 *  on specified blocks.
                                 * @return `true` if the can place on flag is set, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                hasPlaceRestrictions(): boolean;

                                /**
                                 * @return a list of all filters set for the can destroy flag.
                                 * @since 1.8.4
                                 */
                                getDestroyRestrictions(): JavaList<string>;

                                /**
                                 * @return a list of all filters set for the can place on flag.
                                 * @since 1.8.4
                                 */
                                getPlaceRestrictions(): JavaList<string>;

                                /**
                                 * @return `true` if enchantments are hidden, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                areEnchantmentsHidden(): boolean;

                                /**
                                 * @return `true` if modifiers are hidden, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                areModifiersHidden(): boolean;

                                /**
                                 * @return `true` if the unbreakable flag is hidden, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isUnbreakableHidden(): boolean;

                                /**
                                 * @return `true` if the can destroy flag is hidden, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isCanDestroyHidden(): boolean;

                                /**
                                 * @return `true` if the can place flag is hidden, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isCanPlaceHidden(): boolean;

                                /**
                                 * @return `true` if additional attributes are hidden, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                areAdditionalsHidden(): boolean;

                                /**
                                 * @return `true` if dye of colored leather armor is hidden, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isDyeHidden(): boolean;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class EnchantmentHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.enchantment.Enchantment */ any> {
                                static readonly class: JavaClass<EnchantmentHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.enchantment.Enchantment */ any);
                                constructor (base: /* net.minecraft.enchantment.Enchantment */ any, level: int);
                                constructor (enchantment: CanOmitNamespace<EnchantmentId>);

                                /**
                                 * @return the level of this enchantment.
                                 * @since 1.8.4
                                 */
                                getLevel(): number;

                                /**
                                 * @return the minimum possible level of this enchantment that one can get in vanilla.
                                 * @since 1.8.4
                                 */
                                getMinLevel(): number;

                                /**
                                 * @return the maximum possible level of this enchantment that one can get in vanilla.
                                 * @since 1.8.4
                                 */
                                getMaxLevel(): number;

                                /**
                                 * @param level the level for the name
                                 * @return the translated name of this enchantment for the given level.
                                 * @since 1.8.4
                                 */
                                getLevelName(level: int): string;

                                /**
                                 * Because roman numerals only support positive integers in the range of 1 to 3999, this method
                                 *  will return the arabic numeral for any given level outside that range.
                                 * @return the translated name of this enchantment for the given level in roman numerals.
                                 * @since 1.8.4
                                 */
                                getRomanLevelName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * Because roman numerals only support positive integers in the range of 1 to 3999, this method
                                 *  will return the arabic numeral for any given level outside that range.
                                 * @param level the level for the name
                                 * @return the translated name of this enchantment for the given level in roman numerals.
                                 * @since 1.8.4
                                 */
                                getRomanLevelName(level: int): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @return the name of this enchantment.
                                 * @since 1.8.4
                                 */
                                getName(): string;

                                /**
                                 * @return the id of this enchantment.
                                 * @since 1.8.4
                                 */
                                getId(): EnchantmentId;

                                /**
                                 * @return the rarity of this enchantment.
                                 * @since 1.8.4
                                 */
                                getRarity(): EnchantmentRarity;

                                /**
                                 * Only accounts for enchantments of the same target type.
                                 * @return a list of all enchantments that conflict with this one.
                                 * @since 1.8.4
                                 */
                                getConflictingEnchantments(): JavaList<EnchantmentHelper>;

                                /**
                                 * @param ignoreType whether to check only enchantments that can be applied to the same target
                                 *                    type.
                                 * @return a list of all enchantments that conflict with this one.
                                 * @since 1.8.4
                                 */
                                getConflictingEnchantments(ignoreType: boolean): JavaList<EnchantmentHelper>;

                                /**
                                 * Only accounts for enchantments of the same target type.
                                 * @return a list of all enchantments that can be combined with this one.
                                 * @since 1.8.4
                                 */
                                getCompatibleEnchantments(): JavaList<EnchantmentHelper>;

                                /**
                                 * @param ignoreType whether to check only enchantments that can be applied to the same target
                                 *                    type.
                                 * @return a list of all enchantments that can be combined with this one.
                                 * @since 1.8.4
                                 */
                                getCompatibleEnchantments(ignoreType: boolean): JavaList<EnchantmentHelper>;

                                /**
                                 * @return the type of item this enchantment is compatible with.
                                 * @since 1.8.4
                                 */
                                getTargetType(): EnchantmentTargetType;

                                /**
                                 * The weight of an enchantment is bound to its rarity. The higher the weight, the more likely
                                 *  it is to be chosen.
                                 * @return the relative probability of this enchantment being applied to an enchanted item
                                 *  through the enchanting table or a loot table.
                                 * @since 1.8.4
                                 */
                                getWeight(): number;

                                /**
                                 * Curses are enchantments that can't be removed from the item they were applied to. They
                                 *  usually only have one possible level and can't be upgraded. When combining items with curses
                                 *  on them, they are transferred like any other enchantment. They can't be obtained through
                                 *  enchantment tables, but rather from loot chests, fishing or trading with villagers.
                                 * @return `true` if this enchantment is a curse, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isCursed(): boolean;

                                /**
                                 * Treasures are enchantments that can't be obtained through enchantment tables, but rather from
                                 *  loot chests, fishing or trading with villagers.
                                 * @return `true` if this enchantment is a treasure, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isTreasure(): boolean;

                                /**
                                 * @param item the item to check
                                 * @return `true` if this enchantment can be applied to the given item type, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                canBeApplied(item: ItemHelper): boolean;

                                /**
                                 * @param item the item to check
                                 * @return `true` if this enchantment can be applied to the given item, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                canBeApplied(item: ItemStackHelper): boolean;

                                /**
                                 * @return a list of all acceptable item ids for this enchantment.
                                 * @since 1.8.4
                                 */
                                getAcceptableItems(): JavaList<ItemHelper>;

                                /**
                                 * @param enchantment the enchantment to check
                                 * @return `true` if this enchantment is compatible with the given enchantment,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isCompatible(enchantment: CanOmitNamespace<EnchantmentId>): boolean;

                                /**
                                 * @param enchantment the enchantment to check
                                 * @return `true` if this enchantment is compatible with the given enchantment,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isCompatible(enchantment: EnchantmentHelper): boolean;

                                /**
                                 * @param enchantment the enchantment to check
                                 * @return `true` if this enchantment conflicts with the given enchantment, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                conflictsWith(enchantment: EnchantmentId): boolean;

                                /**
                                 * @param enchantment the enchantment to check
                                 * @return `true` if this enchantment conflicts with the given enchantment, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                conflictsWith(enchantment: EnchantmentHelper): boolean;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class ItemHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.item.Item */ any> {
                                static readonly class: JavaClass<ItemHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.item.Item */ any);

                                /**
                                 * @return the name of this item's group or `"UNKNOWN"` if this item is not in a group.
                                 * @since 1.8.4
                                 */
                                getCreativeTab(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

                                /**
                                 * @return the item stack representing the group of this item or `null` if this item is
                                 *  not in a group.
                                 * @since 1.8.4
                                 */
                                getGroupIcon(): JavaList<ItemStackHelper> | null;

                                /**
                                 * @param stack the possible repair material
                                 * @return `true` if the given item stack can be used to repair item stacks of this item,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                canBeRepairedWith(stack: ItemStackHelper): boolean;

                                /**
                                 * @param block the block to check
                                 * @return `true` if the given block can be mined and drops when broken with this item,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isSuitableFor(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper): boolean;

                                /**
                                 * @param block the block to check
                                 * @return `true` if the given block can be mined and drops when broken with this item,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isSuitableFor(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): boolean;

                                /**
                                 * @return `true` if the item has a block representation, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isBlockItem(): boolean;

                                /**
                                 * @return the block representation of this item or `null` if this item has no
                                 *  corresponding block.
                                 * @since 1.8.4
                                 */
                                getBlock(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper | null;

                                /**
                                 * @param state the block state to check
                                 * @return the mining speed of this item against the given block state, returns `1` by
                                 *  default.
                                 * @since 1.8.4
                                 */
                                getMiningSpeedMultiplier(state: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): number;

                                /**
                                 * @return `true` if the item has durability, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isDamageable(): boolean;

                                /**
                                 * @return `true` if when crafter the item stack has a remainder, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                hasRecipeRemainder(): boolean;

                                /**
                                 * @return the recipe remainder if it exists and `null` otherwise.
                                 * @since 1.8.4
                                 */
                                getRecipeRemainder(): ItemHelper | null;

                                /**
                                 * With increased enchantability the change to get more and better enchantments increases.
                                 * @return the enchantability of this item, returns `0` by default.
                                 * @since 1.8.4
                                 */
                                getEnchantability(): number;

                                /**
                                 * @return the name of this item, translated to the current language.
                                 * @since 1.8.4
                                 */
                                getName(): string;

                                /**
                                 * @return the identifier of this item.
                                 * @since 1.8.4
                                 */
                                getId(): ItemId;

                                /**
                                 * @return the maximum amount of items in a stack of this item.
                                 * @since 1.8.4
                                 */
                                getMaxCount(): number;

                                /**
                                 * The damage an item has taken is the opposite of the durability still left.
                                 * @return the maximum amount of damage this item can take.
                                 * @since 1.8.4
                                 */
                                getMaxDurability(): number;

                                /**
                                 * @return `true` if this item is fireproof, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isFireproof(): boolean;

                                /**
                                 * @return `true` if this item is a tool, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isTool(): boolean;

                                /**
                                 * @return `true` if this item can be worn in the armor slot, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isWearable(): boolean;

                                /**
                                 * @return `true` if this item is food, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isFood(): boolean;

                                /**
                                 * @return the food component of this item or `null` if this item is not food.
                                 * @since 1.8.4
                                 */
                                getFood(): FoodComponentHelper | null;

                                /**
                                 * @return `true` if this item can be nested, i.e. put into a bundle or shulker box,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                canBeNested(): boolean;

                                /**
                                 * @return the default item stack of this item with a stack size of `1`.
                                 * @since 1.8.4
                                 */
                                getDefaultStack(): ItemStackHelper;

                                /**
                                 * @param nbt the nbt data of the item stack
                                 * @return the item stack of this item with a stack size of `1` and the given nbt.
                                 * @throws CommandSyntaxException if the nbt data is invalid.
                                 * @since 1.8.4
                                 */
                                getStackWithNbt(nbt: string): ItemStackHelper;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class FoodComponentHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.item.FoodComponent */ any> {
                                static readonly class: JavaClass<FoodComponentHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.item.FoodComponent */ any);

                                /**
                                 * @return the amount of hunger this food restores.
                                 * @since 1.8.4
                                 */
                                getHunger(): number;

                                /**
                                 * @return the amount of saturation this food restores.
                                 * @since 1.8.4
                                 */
                                getSaturation(): number;

                                /**
                                 * @return `true` if this food can be eaten by wolves, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isMeat(): boolean;

                                /**
                                 * @return `true` if this food can be eaten even when the player is not hungry,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isAlwaysEdible(): boolean;

                                /**
                                 * @return `true` if the food can be eaten faster than usual, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isFastFood(): boolean;

                                /**
                                 * @return a map of status effects and their respective probabilities.
                                 * @since 1.8.4
                                 */
                                getStatusEffects(): JavaMap<xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper, number>;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class CreativeItemStackHelper extends ItemStackHelper {
                                static readonly class: JavaClass<CreativeItemStackHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (itemStack: /* net.minecraft.item.ItemStack */ any);

                                /**
                                 * @param damage the damage the item should take
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setDamage(damage: int): this;

                                /**
                                 * @param durability the new durability of this item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setDurability(durability: int): this;

                                /**
                                 * @param count the new count of the item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setCount(count: int): this;

                                /**
                                 * @param name the new name of the item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setName(name: string): this;

                                /**
                                 * @param name the new name of the item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setName(name: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): this;

                                /**
                                 * @param id the id of the enchantment
                                 * @param level the level of the enchantment
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                addEnchantment(id: CanOmitNamespace<EnchantmentId>, level: int): this;

                                /**
                                 * @param enchantment the enchantment to add
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                addEnchantment(enchantment: EnchantmentHelper): this;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                clearEnchantments(): this;

                                /**
                                 * @param enchantment the enchantment to remove
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                removeEnchantment(enchantment: EnchantmentHelper): this;

                                /**
                                 * @param id the id of the enchantment to remove
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                removeEnchantment(id: EnchantmentId): this;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                clearLore(): this;

                                /**
                                 * @param lore the new lore
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setLore(...lore: JavaVarArgs<any>): this;

                                /**
                                 * @param lore the lore to add
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                addLore(...lore: JavaVarArgs<any>): this;

                                /**
                                 * @param unbreakable whether the item should be unbreakable or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setUnbreakable(unbreakable: boolean): this;

                                /**
                                 * @param hide whether to hide the enchantments or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideEnchantments(hide: boolean): this;

                                /**
                                 * @param hide whether to hide attributes and modifiers or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideModifiers(hide: boolean): this;

                                /**
                                 * @param hide whether to hide the unbreakable flag or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideUnbreakable(hide: boolean): this;

                                /**
                                 * @param hide whether to hide the blocks this item can destroy or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideCanDestroy(hide: boolean): this;

                                /**
                                 * @param hide whether to hide the blocks this item can be placed on or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideCanPlace(hide: boolean): this;

                                /**
                                 * These flags are for banner patterns, potion effects, book information and other special
                                 *  flags.
                                 * @param hide whether to hide additional flags or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideAdditional(hide: boolean): this;

                                /**
                                 * @param hide whether to hide the color of colored leather armor or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideDye(hide: boolean): this;

                            }

                            export {
                                RecipeHelper,
                                ItemStackHelper,
                                EnchantmentHelper,
                                ItemHelper,
                                FoodComponentHelper,
                                CreativeItemStackHelper
                            }

                        }

                        namespace screen {


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class CyclingButtonWidgetHelper$CyclicButtonBuilder<T> extends AbstractWidgetBuilder<CyclingButtonWidgetHelper$CyclicButtonBuilder<T>, /* net.minecraft.client.gui.widget.CyclingButtonWidget<T> */ any, CyclingButtonWidgetHelper<T>> {
                                static readonly class: JavaClass<CyclingButtonWidgetHelper$CyclicButtonBuilder<any>>;
                                /** @deprecated */ static prototype: undefined;

                                constructor <T>(screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, valueToText: xyz.wagyourtail.jsmacros.core.MethodWrapper<T, any, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any>);

                                /**
                                 * @return the initial value of the slider.
                                 * @since 1.8.4
                                 */
                                getInitialValue(): T;

                                /**
                                 * @param value the initial value of the slider
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                initially(value: T): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * The option text is a prefix of all values, seperated by a colon.
                                 * @return the option text of the button or an empty text if it is omitted.
                                 * @since 1.8.4
                                 */
                                getOption(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @param option the option text of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                option(option: string): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @param option the option text of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                option(option: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<CyclingButtonWidgetHelper<T>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<CyclingButtonWidgetHelper<T>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @return the function to convert a value to a text.
                                 * @since 1.8.4
                                 */
                                getValueToText(): xyz.wagyourtail.jsmacros.core.MethodWrapper<T, any, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any>;

                                /**
                                 * @param valueToText the function to convert a value to a text
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                valueToText(valueToText: xyz.wagyourtail.jsmacros.core.MethodWrapper<T, any, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any>): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * The button will normally cycle through the default values, but if the alternate toggle is
                                 *  true, it will cycle through the alternate values.
                                 * @return the list of all default values.
                                 * @since 1.8.4
                                 */
                                getDefaultValues(): JavaList<T>;

                                /**
                                 * The button will normally cycle through the default values, but if the alternate toggle is
                                 *  true, it will cycle through the alternate values.
                                 * @return the list of all alternate values.
                                 * @since 1.8.4
                                 */
                                getAlternateValues(): JavaList<T>;

                                /**
                                 * @param values the default values of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                values(...values: JavaVarArgs<T>): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @param values the alternate values of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                alternatives(...values: JavaVarArgs<T>): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @param defaults the default values of the button
                                 * @param alternatives the alternate values of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                values(defaults: T[], alternatives: T[]): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @param defaults the default values of the button
                                 * @param alternatives the alternate values of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                values(defaults: JavaList<T>, alternatives: JavaList<T>): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @return the toggle function to determine if the button should cycle through the default
                                 *  or the alternate values.
                                 * @since 1.8.4
                                 */
                                getAlternateToggle(): xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, boolean, any> | null;

                                /**
                                 * @param alternateToggle the toggle function to determine if the button should cycle
                                 *                         through the default or the alternate values
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                alternateToggle(alternateToggle: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, boolean, any> | null): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @return `true` if the prefix option text should be omitted, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                isOptionTextOmitted(): boolean;

                                /**
                                 * @param optionTextOmitted whether the prefix option text should be omitted or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                omitTextOption(optionTextOmitted: boolean): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;
                                createWidget(): CyclingButtonWidgetHelper<T>;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class ButtonWidgetHelper<T = /* net.minecraft.client.gui.widget.ButtonWidget */ any> extends ClickableWidgetHelper<ButtonWidgetHelper<T>, T> {
                                static readonly class: JavaClass<ButtonWidgetHelper<any>>;
                                /** @deprecated */ static prototype: undefined;

                                constructor <T extends /* net.minecraft.client.gui.widget.ButtonWidget */ any>(btn: T);
                                constructor <T extends /* net.minecraft.client.gui.widget.ButtonWidget */ any>(btn: T, zIndex: int);

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class LockButtonWidgetHelper$LockButtonBuilder extends AbstractWidgetBuilder<LockButtonWidgetHelper$LockButtonBuilder, /* net.minecraft.client.gui.widget.LockButtonWidget */ any, LockButtonWidgetHelper> {
                                static readonly class: JavaClass<LockButtonWidgetHelper$LockButtonBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen);

                                /**
                                 * @return the initial state of the lock button.
                                 * @since 1.8.4
                                 */
                                isLocked(): boolean;

                                /**
                                 * @param locked whether to initially lock the button or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                locked(locked: boolean): this;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<LockButtonWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<LockButtonWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null): this;
                                createWidget(): LockButtonWidgetHelper;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.0.5
                             */
                            interface ClickableWidgetHelper<B extends ClickableWidgetHelper<B, T>, T = /* net.minecraft.client.gui.widget.ClickableWidget */ any> extends xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement, xyz.wagyourtail.jsmacros.client.api.classes.render.components.Alignable<B> {}
                            class ClickableWidgetHelper<B extends ClickableWidgetHelper<B, T>, T = /* net.minecraft.client.gui.widget.ClickableWidget */ any> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T> {
                                static readonly class: JavaClass<ClickableWidgetHelper<any, any>>;
                                /** @deprecated */ static prototype: undefined;

                                constructor <B extends ClickableWidgetHelper<B, T>, T extends /* net.minecraft.client.gui.widget.ClickableWidget */ any>(btn: T);
                                constructor <B extends ClickableWidgetHelper<B, T>, T extends /* net.minecraft.client.gui.widget.ClickableWidget */ any>(btn: T, zIndex: int);

                                zIndex: number;
                                tooltips: JavaList</* net.minecraft.text.Text */ any>;

                                /**
                                 * @return the `x` coordinate of the button.
                                 * @since 1.0.5
                                 */
                                getX(): number;

                                /**
                                 * @return the `y` coordinate of the button.
                                 * @since 1.0.5
                                 */
                                getY(): number;

                                /**
                                 * Set the button position.
                                 * @since 1.0.5
                                 */
                                setPos(x: int, y: int): B;
                                /** @since 1.0.5 */
                                getWidth(): number;

                                /**
                                 * @return the height of the button.
                                 * @since 1.8.4
                                 */
                                getHeight(): number;

                                /**
                                 * change the text.
                                 * @since 1.0.5, renamed from `setText` in 1.3.1
                                 * @deprecated only deprecated in buttonWidgetHelper for confusing name.
                                 */
                                setLabel(label: string): B;

                                /**
                                 * change the text.
                                 * @since 1.3.1
                                 */
                                setLabel(helper: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): B;

                                /**
                                 * @return current button text.
                                 * @since 1.2.3, renamed fro `getText` in 1.3.1
                                 */
                                getLabel(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @return button clickable state.
                                 * @since 1.0.5
                                 */
                                getActive(): boolean;

                                /**
                                 * set the button clickable state.
                                 * @since 1.0.5
                                 */
                                setActive(t: boolean): B;

                                /**
                                 * set the button width.
                                 * @since 1.0.5
                                 */
                                setWidth(width: int): B;

                                /**
                                 * clicks button
                                 * @since 1.3.1
                                 */
                                click(): B;

                                /**
                                 * clicks button
                                 * @param await should wait for button to finish clicking.
                                 * @since 1.3.1
                                 */
                                click(await: boolean): B;

                                /**
                                 * @param tooltips the tooltips to set
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setTooltip(...tooltips: JavaVarArgs<any>): B;

                                /**
                                 * @param tooltip the tooltips to add
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                addTooltip(tooltip: any): B;

                                /**
                                 * @param index the index of the tooltip to remove
                                 * @return `true` if the tooltip was removed successfully, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                removeTooltip(index: int): boolean;

                                /**
                                 * @param tooltip the tooltip to remove
                                 * @return `true` if the tooltip was removed successfully, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                removeTooltip(tooltip: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): boolean;

                                /**
                                 * @return a copy of the tooltips.
                                 * @since 1.8.4
                                 */
                                getTooltips(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;
                                getZIndex(): number;
                                getScaledWidth(): number;
                                getParentWidth(): number;
                                getScaledHeight(): number;
                                getParentHeight(): number;
                                getScaledLeft(): number;
                                getScaledTop(): number;
                                moveTo(x: int, y: int): B;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class CheckBoxWidgetHelper extends ClickableWidgetHelper<CheckBoxWidgetHelper, xyz.wagyourtail.wagyourgui.elements.CheckBox> {
                                static readonly class: JavaClass<CheckBoxWidgetHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (btn: xyz.wagyourtail.wagyourgui.elements.CheckBox);
                                constructor (btn: xyz.wagyourtail.wagyourgui.elements.CheckBox, zIndex: int);

                                /**
                                 * @return `true` if this button is checked, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isChecked(): boolean;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                toggle(): this;

                                /**
                                 * @param checked whether to check or uncheck this button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setChecked(checked: boolean): this;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class ButtonWidgetHelper$TexturedButtonBuilder extends AbstractWidgetBuilder<ButtonWidgetHelper$TexturedButtonBuilder, /* net.minecraft.client.gui.widget.TexturedButtonWidget */ any, ButtonWidgetHelper</* net.minecraft.client.gui.widget.TexturedButtonWidget */ any>> {
                                static readonly class: JavaClass<ButtonWidgetHelper$TexturedButtonBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen);

                                /**
                                 * @param height this argument is ignored and will always be set to 20
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                height(height: int): this;

                                /**
                                 * @param width the width of the button
                                 * @param height this argument is ignored and will always be set to 20
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                size(width: int, height: int): this;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<ButtonWidgetHelper</* net.minecraft.client.gui.widget.TexturedButtonWidget */ any>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<ButtonWidgetHelper</* net.minecraft.client.gui.widget.TexturedButtonWidget */ any>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null): this;

                                /**
                                 * @since 1.9.0
                                 * @return self for chaining.
                                 */
                                enabledTexture(enabled: /* net.minecraft.util.Identifier */ any): this;

                                /**
                                 * @since 1.9.0
                                 * @return self for chaining.
                                 */
                                disabledTexture(disabled: /* net.minecraft.util.Identifier */ any): this;

                                /**
                                 * @since 1.9.0
                                 * @return self for chaining.
                                 */
                                enabledFocusedTexture(enabledFocused: /* net.minecraft.util.Identifier */ any): this;

                                /**
                                 * @since 1.9.0
                                 * @return self for chaining.
                                 */
                                disabledFocusedTexture(disabledFocused: /* net.minecraft.util.Identifier */ any): this;
                                createWidget(): ButtonWidgetHelper</* net.minecraft.client.gui.widget.TexturedButtonWidget */ any>;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.2.9
                             */
                            class ScoreboardObjectiveHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.scoreboard.ScoreboardObjective */ any> {
                                static readonly class: JavaClass<ScoreboardObjectiveHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (o: /* net.minecraft.scoreboard.ScoreboardObjective */ any);

                                /**
                                 * @return player name to score map
                                 */
                                getPlayerScores(): JavaMap<string, number>;
                                /** @since 1.8.0 */
                                scoreToDisplayName(): JavaMap<number, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;
                                /** @since 1.7.0 */
                                getKnownPlayers(): JavaList<string>;
                                /** @since 1.8.0 */
                                getKnownPlayersDisplayNames(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

                                /**
                                 * @return name of scoreboard
                                 * @since 1.2.9
                                 */
                                getName(): string;

                                /**
                                 * @return name of scoreboard
                                 * @since 1.2.9
                                 */
                                getDisplayName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class CyclingButtonWidgetHelper<T> extends ClickableWidgetHelper<CyclingButtonWidgetHelper<T>, /* net.minecraft.client.gui.widget.CyclingButtonWidget<T> */ any> {
                                static readonly class: JavaClass<CyclingButtonWidgetHelper<any>>;
                                /** @deprecated */ static prototype: undefined;

                                constructor <T>(btn: /* net.minecraft.client.gui.widget.CyclingButtonWidget<T> */ any);
                                constructor <T>(btn: /* net.minecraft.client.gui.widget.CyclingButtonWidget<T> */ any, zIndex: int);

                                /**
                                 * @return the current value.
                                 * @since 1.8.4
                                 */
                                getValue(): T;

                                /**
                                 * @return the current value in their string representation.
                                 * @since 1.8.4
                                 */
                                getStringValue(): string;

                                /**
                                 * @param val the new value
                                 * @return `true` if the value has changed, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                setValue(val: T): boolean;

                                /**
                                 * @param amount the amount to cycle by
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                cycle(amount: int): CyclingButtonWidgetHelper<T>;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                forward(): CyclingButtonWidgetHelper<T>;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                backward(): CyclingButtonWidgetHelper<T>;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class TextFieldWidgetHelper$TextFieldBuilder extends AbstractWidgetBuilder<TextFieldWidgetHelper$TextFieldBuilder, /* net.minecraft.client.gui.widget.TextFieldWidget */ any, TextFieldWidgetHelper> {
                                static readonly class: JavaClass<TextFieldWidgetHelper$TextFieldBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, textRenderer: /* net.minecraft.client.font.TextRenderer */ any);

                                /**
                                 * @return the callback for when the text is changed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<string, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null;

                                /**
                                 * @param action the callback for when the text is changed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null): this;

                                /**
                                 * @return the current suggestion.
                                 * @since 1.8.4
                                 */
                                getSuggestion(): string;

                                /**
                                 * @param suggestion the suggestion to use
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestion(suggestion: string): this;
                                createWidget(): TextFieldWidgetHelper;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.0.5
                             */
                            class TextFieldWidgetHelper extends ClickableWidgetHelper<TextFieldWidgetHelper, /* net.minecraft.client.gui.widget.TextFieldWidget */ any> {
                                static readonly class: JavaClass<TextFieldWidgetHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (t: /* net.minecraft.client.gui.widget.TextFieldWidget */ any);
                                constructor (t: /* net.minecraft.client.gui.widget.TextFieldWidget */ any, zIndex: int);

                                /**
                                 * @return the currently entered string.
                                 * @since 1.0.5
                                 */
                                getText(): string;

                                /**
                                 * @return self for chaining.
                                 * @since 1.0.5
                                 */
                                setText(text: string): this;

                                /**
                                 * set the currently entered string.
                                 * @return self for chaining.
                                 * @throws InterruptedException
                                 * @since 1.3.1
                                 */
                                setText(text: string, await: boolean): this;

                                /**
                                 * @return self for chaining.
                                 * @since 1.0.5
                                 */
                                setEditableColor(color: int): this;

                                /**
                                 * @return self for chaining.
                                 * @since 1.0.5
                                 */
                                setEditable(edit: boolean): this;

                                /**
                                 * @return `true` if the text field is editable, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isEditable(): boolean;

                                /**
                                 * @return self for chaining.
                                 * @since 1.0.5
                                 */
                                setUneditableColor(color: int): this;

                                /**
                                 * @return the selected text.
                                 * @since 1.8.4
                                 */
                                getSelectedText(): string;

                                /**
                                 * @param suggestion the suggestion to set
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setSuggestion(suggestion: string): this;

                                /**
                                 * @return the maximum length of this text field.
                                 * @since 1.8.4
                                 */
                                getMaxLength(): number;

                                /**
                                 * @param length the new maximum length
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setMaxLength(length: int): this;
                                setSelection(start: int, end: int): TextFieldWidgetHelper;

                                /**
                                 * @param predicate the text filter
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setTextPredicate(predicate: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, any, any, any>): this;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                resetTextPredicate(): this;

                                /**
                                 * @param position the cursor position
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setCursorPosition(position: int): this;

                                /**
                                 * @return the cursor position.
                                 * @since 1.9.0
                                 */
                                setCursorPosition(position: int, shift: boolean): TextFieldWidgetHelper;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setCursorToStart(): this;

                                /**
                                 * @return self for chaining.
                                 * @since 1.9.0
                                 */
                                setCursorToStart(shift: boolean): this;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setCursorToEnd(): this;

                                /**
                                 * @return self for chaining.
                                 * @since 1.9.0
                                 */
                                setCursorToEnd(shift: boolean): this;

                            }

                            class ChatHudLineHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.client.gui.hud.ChatHudLine */ any> {
                                static readonly class: JavaClass<ChatHudLineHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.client.gui.hud.ChatHudLine */ any, hud: /* net.minecraft.client.gui.hud.ChatHud */ any);

                                getText(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                getCreationTick(): number;
                                deleteById(): ChatHudLineHelper;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            interface AbstractWidgetBuilder<B extends AbstractWidgetBuilder<B, T, U>, T = /* net.minecraft.client.gui.widget.ClickableWidget */ any, U extends ClickableWidgetHelper<U, T>> extends xyz.wagyourtail.jsmacros.client.api.classes.render.components.Alignable<B> {}
                            abstract class AbstractWidgetBuilder<B extends AbstractWidgetBuilder<B, T, U>, T = /* net.minecraft.client.gui.widget.ClickableWidget */ any, U extends ClickableWidgetHelper<U, T>> extends java.lang.Object {
                                static readonly class: JavaClass<AbstractWidgetBuilder<any, any, any>>;
                                /** @deprecated */ static prototype: undefined;

                                /**
                                 * @return the width of the widget.
                                 * @since 1.8.4
                                 */
                                getWidth(): number;

                                /**
                                 * @param width the width of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                width(width: int): B;

                                /**
                                 * @return the height of the widget.
                                 * @since 1.8.4
                                 */
                                getHeight(): number;

                                /**
                                 * @param height the height of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                height(height: int): B;

                                /**
                                 * @param width the width of the widget
                                 * @param height the height of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                size(width: int, height: int): B;

                                /**
                                 * @return the z-index of the widget.
                                 * @since 1.8.4
                                 */
                                getZIndex(): number;

                                /**
                                 * @param zIndex the z-index of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                zIndex(zIndex: int): B;

                                /**
                                 * @return the x position of the widget.
                                 * @since 1.8.4
                                 */
                                getX(): number;

                                /**
                                 * @param x the x position of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                x(x: int): B;

                                /**
                                 * @return the y position of the widget.
                                 * @since 1.8.4
                                 */
                                getY(): number;

                                /**
                                 * @param y the y position of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                y(y: int): B;

                                /**
                                 * @param x the x position of the widget
                                 * @param y the y position of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                pos(x: int, y: int): B;

                                /**
                                 * @return the message of the widget or an empty text if none is set.
                                 * @since 1.8.4
                                 */
                                getMessage(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @param message the message of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                message(message: string | null): B;

                                /**
                                 * @param message the message of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                message(message: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper | null): B;

                                /**
                                 * An inactive widget can not be interacted with and may have a different appearance.
                                 * @return `true` if the widget is active, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isActive(): boolean;

                                /**
                                 * An inactive widget can not be interacted with and may have a different appearance.
                                 * @param active whether the widget should be active or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                active(active: boolean): B;

                                /**
                                 * @return `true` if the widget is visible, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isVisible(): boolean;

                                /**
                                 * @param visible whether the widget should be visible or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                visible(visible: boolean): B;

                                /**
                                 * @return the alpha value of the widget.
                                 * @since 1.8.4
                                 */
                                getAlpha(): number;

                                /**
                                 * @param alpha the alpha value of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                alpha(alpha: double): B;

                                /**
                                 * @return the build widget for the set properties.
                                 * @since 1.8.4
                                 */
                                build(): U;
                                getScaledWidth(): number;
                                getParentWidth(): number;
                                getScaledHeight(): number;
                                getParentHeight(): number;
                                getScaledLeft(): number;
                                getScaledTop(): number;
                                moveTo(x: int, y: int): B;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class ButtonWidgetHelper$ButtonBuilder extends AbstractWidgetBuilder<ButtonWidgetHelper$ButtonBuilder, /* net.minecraft.client.gui.widget.ButtonWidget */ any, ButtonWidgetHelper</* net.minecraft.client.gui.widget.ButtonWidget */ any>> {
                                static readonly class: JavaClass<ButtonWidgetHelper$ButtonBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen);

                                /**
                                 * @param height this argument is ignored and will always be set to 20
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                height(height: int): this;

                                /**
                                 * @param width the width of the button
                                 * @param height this argument is ignored and will always be set to 20
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                size(width: int, height: int): this;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<ButtonWidgetHelper</* net.minecraft.client.gui.widget.ButtonWidget */ any>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<ButtonWidgetHelper</* net.minecraft.client.gui.widget.ButtonWidget */ any>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null): this;
                                createWidget(): ButtonWidgetHelper</* net.minecraft.client.gui.widget.ButtonWidget */ any>;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class CheckBoxWidgetHelper$CheckBoxBuilder extends AbstractWidgetBuilder<CheckBoxWidgetHelper$CheckBoxBuilder, xyz.wagyourtail.wagyourgui.elements.CheckBox, CheckBoxWidgetHelper> {
                                static readonly class: JavaClass<CheckBoxWidgetHelper$CheckBoxBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen);

                                /**
                                 * @return `true` if the checkbox is initially checked, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isChecked(): boolean;

                                /**
                                 * @param checked whether the checkbox is initially checked or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                checked(checked: boolean): this;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<CheckBoxWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<CheckBoxWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null): this;
                                createWidget(): CheckBoxWidgetHelper;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class LockButtonWidgetHelper extends ClickableWidgetHelper<LockButtonWidgetHelper, /* net.minecraft.client.gui.widget.LockButtonWidget */ any> {
                                static readonly class: JavaClass<LockButtonWidgetHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (btn: /* net.minecraft.client.gui.widget.LockButtonWidget */ any);
                                constructor (btn: /* net.minecraft.client.gui.widget.LockButtonWidget */ any, zIndex: int);

                                /**
                                 * @return `true` if the button is locked, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isLocked(): boolean;

                                /**
                                 * @param locked whether to lock the button or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setLocked(locked: boolean): this;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class SliderWidgetHelper extends ClickableWidgetHelper<SliderWidgetHelper, xyz.wagyourtail.wagyourgui.elements.Slider> {
                                static readonly class: JavaClass<SliderWidgetHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (btn: xyz.wagyourtail.wagyourgui.elements.Slider);
                                constructor (btn: xyz.wagyourtail.wagyourgui.elements.Slider, zIndex: int);

                                /**
                                 * @return the current value of this slider.
                                 * @since 1.8.4
                                 */
                                getValue(): number;

                                /**
                                 * @param value the new value
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setValue(value: double): this;

                                /**
                                 * @return the set amount of steps of this slider.
                                 * @since 1.8.4
                                 */
                                getSteps(): number;

                                /**
                                 * @param steps the amount of steps
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setSteps(steps: int): this;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class SliderWidgetHelper$SliderBuilder extends AbstractWidgetBuilder<SliderWidgetHelper$SliderBuilder, xyz.wagyourtail.wagyourgui.elements.Slider, SliderWidgetHelper> {
                                static readonly class: JavaClass<SliderWidgetHelper$SliderBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen);

                                /**
                                 * @return the amount of steps of this slider.
                                 * @since 1.8.4
                                 */
                                getSteps(): number;

                                /**
                                 * @param steps the amount of steps for the slider. Must be greater or equal to 2
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                steps(steps: int): this;

                                /**
                                 * @return the initial value of the slider.
                                 * @since 1.8.4
                                 */
                                getValue(): number;

                                /**
                                 * @param value the initial value of the slider. Must be between 0 and steps - 1
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                initially(value: int): this;

                                /**
                                 * @return the change listener of the slider.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<SliderWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null;

                                /**
                                 * @param action the change listener for the slider
                                 * @return self for chaining.
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<SliderWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any> | null): this;
                                createWidget(): SliderWidgetHelper;

                            }

                            export {
                                CyclingButtonWidgetHelper$CyclicButtonBuilder,
                                ButtonWidgetHelper,
                                LockButtonWidgetHelper$LockButtonBuilder,
                                ClickableWidgetHelper,
                                CheckBoxWidgetHelper,
                                ButtonWidgetHelper$TexturedButtonBuilder,
                                ScoreboardObjectiveHelper,
                                CyclingButtonWidgetHelper,
                                TextFieldWidgetHelper$TextFieldBuilder,
                                TextFieldWidgetHelper,
                                ChatHudLineHelper,
                                AbstractWidgetBuilder,
                                ButtonWidgetHelper$ButtonBuilder,
                                CheckBoxWidgetHelper$CheckBoxBuilder,
                                LockButtonWidgetHelper,
                                SliderWidgetHelper,
                                SliderWidgetHelper$SliderBuilder
                            }

                        }

                        namespace world {

                            /** @since 1.6.5 */
                            class ServerInfoHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.client.network.ServerInfo */ any> {
                                static readonly class: JavaClass<ServerInfoHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.client.network.ServerInfo */ any);

                                getName(): string;
                                getAddress(): string;
                                getPlayerCountLabel(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                getLabel(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                getPing(): number;
                                getProtocolVersion(): number;
                                getVersion(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                getPlayerListSummary(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;
                                resourcePackPolicy(): string;
                                getIcon(): string;
                                isOnline(): boolean;
                                isLocal(): boolean;
                                getNbt(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTCompoundHelper;

                                /**
                                 * @return `true` if the server enforces secure chat, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isSecureChatEnforced(): boolean;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class DirectionHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.util.math.Direction */ any> {
                                static readonly class: JavaClass<DirectionHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.util.math.Direction */ any);

                                /**
                                 * @return the name of this direction.
                                 * @since 1.8.4
                                 */
                                getName(): string;

                                /**
                                 * @return the name of the axis this direction is aligned to.
                                 * @since 1.8.4
                                 */
                                getAxis(): string;

                                /**
                                 * @return `true` if this direction is vertical, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isVertical(): boolean;

                                /**
                                 * @return `true` if this direction is horizontal, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isHorizontal(): boolean;

                                /**
                                 * @return `true` if this direction is pointing in a positive direction, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                isTowardsPositive(): boolean;

                                /**
                                 * @return the yaw of this direction.
                                 * @since 1.8.4
                                 */
                                getYaw(): number;

                                /**
                                 * @return the pitch of this direction.
                                 * @since 1.8.4
                                 */
                                getPitch(): number;

                                /**
                                 * @return the opposite direction.
                                 * @since 1.8.4
                                 */
                                getOpposite(): DirectionHelper;

                                /**
                                 * @return the direction to the left.
                                 * @since 1.8.4
                                 */
                                getLeft(): DirectionHelper;

                                /**
                                 * @return the direction to the right.
                                 * @since 1.8.4
                                 */
                                getRight(): DirectionHelper;

                                /**
                                 * @return the direction as a directional vector.
                                 * @since 1.8.4
                                 */
                                getVector(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                /**
                                 * @param yaw the yaw to check
                                 * @return `true` if the yaw is facing this direction more than any other one,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                pointsTo(yaw: double): boolean;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.6.5
                             */
                            class BlockHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.block.Block */ any> {
                                static readonly class: JavaClass<BlockHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.block.Block */ any);

                                /**
                                 * @return the default state of the block.
                                 * @since 1.6.5
                                 */
                                getDefaultState(): BlockStateHelper;

                                /**
                                 * @return the default item stack of the block.
                                 * @since 1.6.5
                                 */
                                getDefaultItemStack(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                canMobSpawnInside(): boolean;

                                /**
                                 * @return `true` if the block has dynamic bounds.
                                 * @since 1.6.5
                                 */
                                hasDynamicBounds(): boolean;

                                /**
                                 * @return the blast resistance.
                                 * @since 1.6.5
                                 */
                                getBlastResistance(): number;

                                /**
                                 * @return the jump velocity multiplier.
                                 * @since 1.6.5
                                 */
                                getJumpVelocityMultiplier(): number;

                                /**
                                 * @return the slipperiness.
                                 * @since 1.6.5
                                 */
                                getSlipperiness(): number;

                                /**
                                 * @return the hardness.
                                 * @since 1.6.5
                                 */
                                getHardness(): number;

                                /**
                                 * @return the velocity multiplier.
                                 * @since 1.6.5
                                 */
                                getVelocityMultiplier(): number;

                                /**
                                 * @return all tags of the block as an {@link java.util.ArrayList}.
                                 * @since 1.6.5
                                 */
                                getTags(): JavaList<BlockTag>;

                                /**
                                 * @return all possible block states of the block.
                                 * @since 1.6.5
                                 */
                                getStates(): JavaList<BlockStateHelper>;

                                /**
                                 * @return the identifier of the block.
                                 * @since 1.6.5
                                 */
                                getId(): BlockId;

                                /**
                                 * @return the name of the block.
                                 * @since 1.8.4
                                 */
                                getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.3.0
                             */
                            class TeamHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.scoreboard.Team */ any> {
                                static readonly class: JavaClass<TeamHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (t: /* net.minecraft.scoreboard.Team */ any);

                                /** @since 1.3.0 */
                                getName(): string;
                                /** @since 1.3.0 */
                                getDisplayName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                /** @since 1.3.0 */
                                getPlayerList(): JavaList<string>;

                                /**
                                 * @return the formatting of this team's color.
                                 * @since 1.8.4
                                 */
                                getColorFormat(): xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper;

                                /**
                                 * @since 1.3.0
                                 * @deprecated use {@link getColorIndex}() instead.
                                 */
                                getColor(): number;

                                /**
                                 * @return the color index of this team.
                                 * @since 1.8.4
                                 */
                                getColorIndex(): number;

                                /**
                                 * @return the color value for this team or `-1` if it has no color.
                                 * @since 1.8.4
                                 */
                                getColorValue(): number;

                                /**
                                 * @return the name of this team's color.
                                 * @since 1.8.4
                                 */
                                getColorName(): FormattingColorName;

                                /**
                                 * @return the scoreboard including this team.
                                 * @since 1.8.4
                                 */
                                getScoreboard(): ScoreboardsHelper;
                                /** @since 1.3.0 */
                                getPrefix(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                /** @since 1.3.0 */
                                getSuffix(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                /** @since 1.3.0 */
                                getCollisionRule(): TeamCollisionRule;
                                /** @since 1.3.0 */
                                isFriendlyFire(): boolean;
                                /** @since 1.3.0 */
                                showFriendlyInvisibles(): boolean;
                                /** @since 1.3.0 */
                                nametagVisibility(): TeamVisibilityRule;
                                /** @since 1.3.0 */
                                deathMessageVisibility(): TeamVisibilityRule;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.0.2
                             */
                            class PlayerListEntryHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.client.network.PlayerListEntry */ any> {
                                static readonly class: JavaClass<PlayerListEntryHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (p: /* net.minecraft.client.network.PlayerListEntry */ any);

                                /** @since 1.1.9 */
                                getUUID(): string | null;
                                /** @since 1.0.2 */
                                getName(): string | null;
                                /** @since 1.6.5 */
                                getPing(): number;

                                /**
                                 * @return null if unknown
                                 * @since 1.6.5
                                 */
                                getGamemode(): Gamemode;
                                /** @since 1.1.9 */
                                getDisplayText(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                /** @since 1.8.2 */
                                getPublicKey(): JavaArray<number>;

                                /**
                                 * @return `true` if the player has a cape enabled, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                hasCape(): boolean;

                                /**
                                 * A slim skin is an Alex skin, while the default one is Steve.
                                 * @return `true` if the player has a slim skin, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                hasSlimModel(): boolean;

                                /**
                                 * @return the identifier of the player's skin texture or `null` if it's unknown.
                                 * @since 1.8.4
                                 */
                                getSkinTexture(): string;
                                /** @since 1.9.0 */
                                getSkinUrl(): string | null;

                                /**
                                 * @return the identifier of the player's cape texture or `null` if it's unknown.
                                 * @since 1.8.4
                                 */
                                getCapeTexture(): string | null;

                                /**
                                 * @return the identifier of the player's elytra texture or `null` if it's unknown.
                                 * @since 1.8.4
                                 */
                                getElytraTexture(): string | null;

                                /**
                                 * @return the team of the player or `null` if the player is not in a team.
                                 * @since 1.8.4
                                 */
                                getTeam(): TeamHelper | null;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.2.9
                             */
                            class ScoreboardsHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.scoreboard.Scoreboard */ any> {
                                static readonly class: JavaClass<ScoreboardsHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (board: /* net.minecraft.scoreboard.Scoreboard */ any);

                                /** @since 1.2.9 */
                                getObjectiveForTeamColorIndex(index: int): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ScoreboardObjectiveHelper | null;

                                /**
                                 * `0` is tab list, `1` or `3 + getPlayerTeamColorIndex()` is sidebar, `2` should be below name.  
                                 *  therefore max slot number is 18.
                                 * @since 1.2.9
                                 */
                                getObjectiveSlot(slot: int): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ScoreboardObjectiveHelper | null;
                                /** @since 1.2.9 */
                                getPlayerTeamColorIndex(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* net.minecraft.entity.player.PlayerEntity */ any>): number;

                                /**
                                 * @return team index for client player
                                 * @since 1.6.5
                                 */
                                getPlayerTeamColorIndex(): number;

                                /**
                                 * @return the formatting for the client player's team, `null` if the player is not in a
                                 *  team.
                                 * @since 1.8.4
                                 */
                                getTeamColorFormatting(): xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper | null;

                                /**
                                 * @param player the player to get the team color's formatting for.
                                 * @return the formatting for the client player's team, `null` if the player is not in a
                                 *  team.
                                 * @since 1.8.4
                                 */
                                getTeamColorFormatting(player: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* net.minecraft.entity.player.PlayerEntity */ any>): xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper | null;

                                /**
                                 * @param player the player to get the team color for
                                 * @return the color of the speicifed player's team or `-1` if the player is not in a team.
                                 * @since 1.8.4
                                 */
                                getTeamColor(player: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* net.minecraft.entity.player.PlayerEntity */ any>): number;

                                /**
                                 * @return the color of this player's team or `-1` if this player is not in a team.
                                 * @since 1.8.4
                                 */
                                getTeamColor(): number;

                                /**
                                 * @param player the player to get the team color's name for
                                 * @return the name of the speicifed player's team color or `null` if the player is not in
                                 *  a team.
                                 * @since 1.8.4
                                 */
                                getTeamColorName(player: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* net.minecraft.entity.player.PlayerEntity */ any>): string | null;

                                /**
                                 * @return the color of this player's team or `null` if this player is not in a team.
                                 * @since 1.8.4
                                 */
                                getTeamColorName(): string | null;
                                /** @since 1.3.0 */
                                getTeams(): JavaList<TeamHelper>;
                                /** @since 1.3.0 */
                                getPlayerTeam(p: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* net.minecraft.entity.player.PlayerEntity */ any>): TeamHelper;

                                /**
                                 * @return team for client player
                                 * @since 1.6.5
                                 */
                                getPlayerTeam(): TeamHelper;

                                /**
                                 * @return the {@link ScoreboardObjectiveHelper} for the currently displayed sidebar scoreboard.
                                 * @since 1.2.9
                                 */
                                getCurrentScoreboard(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ScoreboardObjectiveHelper | null;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class ChunkHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.world.chunk.Chunk */ any> {
                                static readonly class: JavaClass<ChunkHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.world.chunk.Chunk */ any);

                                /**
                                 * @return the first block (0 0 0 coordinate) of this chunk.
                                 * @since 1.8.4
                                 */
                                getStartingBlock(): BlockPosHelper;

                                /**
                                 * The coordinates are relative to the starting chunk position, see
                                 *  {@link getStartingBlock}().
                                 * @param xOffset the xOffset offset
                                 * @param y the actual y coordinate
                                 * @param zOffset the zOffset offset
                                 * @return the block offset from the starting block of this chunk by xOffset y zOffset.
                                 * @since 1.8.4
                                 */
                                getOffsetBlock(xOffset: int, y: int, zOffset: int): BlockPosHelper;

                                /**
                                 * @return the maximum height of this chunk.
                                 * @since 1.8.4
                                 */
                                getMaxBuildHeight(): number;

                                /**
                                 * @return the minimum height of this chunk.
                                 * @since 1.8.4
                                 */
                                getMinBuildHeight(): number;

                                /**
                                 * @return the height of this chunk.
                                 * @since 1.8.4
                                 */
                                getHeight(): number;

                                /**
                                 * @param xOffset the xOffset coordinate
                                 * @param zOffset the zOffset coordinate
                                 * @param heightmap the heightmap to use
                                 * @return the maximum `y` position of all blocks inside this chunk.
                                 * @since 1.8.4
                                 */
                                getTopYAt(xOffset: int, zOffset: int, heightmap: /* net.minecraft.world.Heightmap */ any): number;

                                /**
                                 * @return the `x` coordinate (not the world coordinate) of this chunk.
                                 * @since 1.8.4
                                 */
                                getChunkX(): number;

                                /**
                                 * @return the `z` coordinate (not the world coordinate) of this chunk.
                                 * @since 1.8.4
                                 */
                                getChunkZ(): number;

                                /**
                                 * @param xOffset the x offset
                                 * @param y the y coordinate
                                 * @param zOffset the z offset
                                 * @return the biome at the given position.
                                 * @since 1.8.4
                                 */
                                getBiome(xOffset: int, y: int, zOffset: int): Biome;

                                /**
                                 * With an increasing inhabited time, the local difficulty increases and stronger mobs will
                                 *  spawn. Because the time is cumulative, the more players are in the chunk, the faster the time
                                 *  will increase.
                                 * @return the cumulative time players have spent inside this chunk.
                                 * @since 1.8.4
                                 */
                                getInhabitedTime(): number;

                                /**
                                 * @return all entities inside this chunk.
                                 * @since 1.8.4
                                 */
                                getEntities(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

                                /**
                                 * @return all tile entity positions inside this chunk.
                                 * @since 1.8.4
                                 */
                                getTileEntities(): JavaList<BlockPosHelper>;

                                /**
                                 * @param includeAir whether to include air blocks or not
                                 * @param callback the callback function
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                forEach(includeAir: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<BlockDataHelper, any, any, any>): this;

                                /**
                                 * @param blocks the blocks to search for
                                 * @return `true` if this chunk contains at least one of the specified blocks,
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                containsAny(...blocks: CanOmitNamespace<BlockId>[]): boolean;

                                /**
                                 * @param blocks the blocks to search for
                                 * @return `true` if the chunk contains all the specified blocks, `false`
                                 *  otherwise.
                                 * @since 1.8.4
                                 */
                                containsAll(...blocks: CanOmitNamespace<BlockId>[]): boolean;

                                /**
                                 * @return a map of the raw heightmap data.
                                 * @since 1.8.4
                                 */
                                getHeightmaps(): JavaCollection<java.util.Map$Entry</* net.minecraft.world.Heightmap$Type */ any, /* net.minecraft.world.Heightmap */ any>>;

                                /**
                                 * @return the raw surface heightmap.
                                 * @since 1.8.4
                                 */
                                getSurfaceHeightmap(): /* net.minecraft.world.Heightmap */ any;

                                /**
                                 * @return the raw ocean floor heightmap.
                                 * @since 1.8.4
                                 */
                                getOceanFloorHeightmap(): /* net.minecraft.world.Heightmap */ any;

                                /**
                                 * @return the raw motion blocking heightmap.
                                 * @since 1.8.4
                                 */
                                getMotionBlockingHeightmap(): /* net.minecraft.world.Heightmap */ any;

                                /**
                                 * @return the raw motion blocking heightmap without leaves.
                                 * @since 1.8.4
                                 */
                                getMotionBlockingNoLeavesHeightmap(): /* net.minecraft.world.Heightmap */ any;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.6.5
                             */
                            class BlockStateHelper extends StateHelper</* net.minecraft.block.BlockState */ any> {
                                static readonly class: JavaClass<BlockStateHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.block.BlockState */ any);

                                /**
                                 * @return the block the state belongs to.
                                 * @since 1.6.5
                                 */
                                getBlock(): BlockHelper;

                                /**
                                 * @return the block's id.
                                 * @since 1.8.4
                                 */
                                getId(): BlockId;

                                /**
                                 * @return the fluid state of this block state.
                                 * @since 1.8.4
                                 */
                                getFluidState(): FluidStateHelper;

                                /**
                                 * @return the hardness.
                                 * @since 1.6.5
                                 */
                                getHardness(): number;

                                /**
                                 * @return the luminance.
                                 * @since 1.6.5
                                 */
                                getLuminance(): number;

                                /**
                                 * @return `true` if the state emits redstone power.
                                 * @since 1.6.5
                                 */
                                emitsRedstonePower(): boolean;

                                /**
                                 * @return `true` if the shape of the state is a cube.
                                 * @since 1.6.5
                                 */
                                exceedsCube(): boolean;

                                /**
                                 * @return `true` if the state is air.
                                 * @since 1.6.5
                                 */
                                isAir(): boolean;

                                /**
                                 * @return `true` if the state is opaque.
                                 * @since 1.6.5
                                 */
                                isOpaque(): boolean;

                                /**
                                 * @return `true` if a tool is required to mine the block.
                                 * @since 1.6.5
                                 */
                                isToolRequired(): boolean;

                                /**
                                 * @return `true` if the state has a block entity.
                                 * @since 1.6.5
                                 */
                                hasBlockEntity(): boolean;

                                /**
                                 * @return `true` if the state can be random ticked.
                                 * @since 1.6.5
                                 */
                                hasRandomTicks(): boolean;

                                /**
                                 * @return `true` if the state has a comparator output.
                                 * @since 1.6.5
                                 */
                                hasComparatorOutput(): boolean;

                                /**
                                 * @return the piston behaviour of the state.
                                 * @since 1.6.5
                                 */
                                getPistonBehaviour(): PistonBehaviour;

                                /**
                                 * @return `true` if the state blocks the movement of entities.
                                 * @since 1.6.5
                                 */
                                blocksMovement(): boolean;

                                /**
                                 * @return `true` if the state is burnable.
                                 * @since 1.6.5
                                 */
                                isBurnable(): boolean;

                                /**
                                 * @return `true` if the state is a liquid.
                                 * @since 1.6.5
                                 */
                                isLiquid(): boolean;

                                /**
                                 * @return `true` if the state is solid.
                                 * @since 1.6.5
                                 */
                                isSolid(): boolean;

                                /**
                                 * This will return true for blocks like air and grass, that can be replaced without breaking
                                 *  them first.
                                 * @return `true` if the state can be replaced.
                                 * @since 1.6.5
                                 */
                                isReplaceable(): boolean;

                                /**
                                 * @param pos the position of the block to check
                                 * @param entity the entity type to check
                                 * @return `true` if the entity can spawn on this block state at the given position in the
                                 *  current world.
                                 * @since 1.6.5
                                 */
                                allowsSpawning(pos: BlockPosHelper, entity: CanOmitNamespace<EntityId>): boolean;

                                /**
                                 * @param pos the position of the block to check
                                 * @return `true` if an entity can suffocate in this block state at the given position in
                                 *  the current world.
                                 * @since 1.6.5
                                 */
                                shouldSuffocate(pos: BlockPosHelper): boolean;

                                /**
                                 * @return an {@link UniversalBlockStateHelper} to access all properties of this block state.
                                 * @since 1.8.4
                                 */
                                getUniversal(): UniversalBlockStateHelper;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class StateHelper<U = /* net.minecraft.state.State<any, any> */ any> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<U> {
                                static readonly class: JavaClass<StateHelper<any>>;
                                /** @deprecated */ static prototype: undefined;

                                constructor <U extends /* net.minecraft.state.State<any, any> */ any>(base: U);

                                /**
                                 * @return a map of the state properties with its identifier and value.
                                 * @since 1.8.4
                                 */
                                toMap(): JavaMap<string, string>;
                                with<T extends java.lang.Comparable<any>>(property: string, value: string): StateHelper<U>;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class UniversalBlockStateHelper extends BlockStateHelper {
                                static readonly class: JavaClass<UniversalBlockStateHelper>;
                                /** @deprecated */ static prototype: undefined;

                                static main(args: string[]): void;

                                constructor (base: /* net.minecraft.block.BlockState */ any);

                                /** @since 1.8.4 */
                                getAttachment(): string;
                                /** @since 1.8.4 */
                                getEastWallShape(): string;
                                /** @since 1.8.4 */
                                getNorthWallShape(): string;
                                /** @since 1.8.4 */
                                getSouthWallShape(): string;
                                /** @since 1.8.4 */
                                getWestWallShape(): string;
                                /** @since 1.8.4 */
                                getEastWireConnection(): string;
                                /** @since 1.8.4 */
                                getNorthWireConnection(): string;
                                /** @since 1.8.4 */
                                getSouthWireConnection(): string;
                                /** @since 1.8.4 */
                                getWestWireConnection(): string;
                                /** @since 1.8.4 */
                                getBlockHalf(): string;
                                /** @since 1.8.4 */
                                getDoubleBlockHalf(): string;
                                /** @since 1.8.4 */
                                getRailShape(): string;
                                /** @since 1.8.4 */
                                getStraightRailShape(): string;
                                /** @since 1.8.4 */
                                getOrientation(): string;
                                /** @since 1.8.4 */
                                getHorizontalAxis(): string;
                                /** @since 1.8.4 */
                                getAxis(): string;
                                /** @since 1.8.4 */
                                getHorizontalFacing(): DirectionHelper;
                                /** @since 1.8.4 */
                                getHopperFacing(): DirectionHelper;
                                /** @since 1.8.4 */
                                getFacing(): DirectionHelper;
                                /** @since 1.8.4 */
                                isUp(): boolean;
                                /** @since 1.8.4 */
                                isDown(): boolean;
                                /** @since 1.8.4 */
                                isNorth(): boolean;
                                /** @since 1.8.4 */
                                isSouth(): boolean;
                                /** @since 1.8.4 */
                                isEast(): boolean;
                                /** @since 1.8.4 */
                                isWest(): boolean;

                                /**
                                 * Used on beehives.
                                 * @since 1.8.4
                                 */
                                getHoneyLevel(): number;

                                /**
                                 * Used on scaffolding.
                                 * @since 1.8.4
                                 */
                                isBottom(): boolean;

                                /**
                                 * Used on bubble columns.
                                 * @since 1.8.4
                                 */
                                isBubbleColumnDown(): boolean;

                                /**
                                 * Used on bubble columns.
                                 * @since 1.8.4
                                 */
                                isBubbleColumnUp(): boolean;

                                /**
                                 * Used on trip wire hooks.
                                 * @since 1.8.4
                                 */
                                isAttached(): boolean;

                                /**
                                 * Used on trip wires.
                                 * @since 1.8.4
                                 */
                                isDisarmed(): boolean;

                                /**
                                 * Used on command blocks.
                                 * @since 1.8.4
                                 */
                                isConditional(): boolean;

                                /**
                                 * Used on hoppers.
                                 * @since 1.8.4
                                 */
                                isEnabled(): boolean;

                                /**
                                 * Used on pistons.
                                 * @since 1.8.4
                                 */
                                isExtended(): boolean;

                                /**
                                 * Used on piston heads.
                                 * @since 1.8.4
                                 */
                                isShort(): boolean;

                                /**
                                 * Used on end portal frames.
                                 * @since 1.8.4
                                 */
                                hasEye(): boolean;

                                /**
                                 * Used on fluids.
                                 * @since 1.8.4
                                 */
                                isFalling(): boolean;

                                /**
                                 * Used on fluids and stuff
                                 * @since 1.8.4
                                 */
                                getLevel(): number;
                                /** @since 1.8.4 */
                                getMaxLevel(): number;
                                /** @since 1.8.4 */
                                getMinLevel(): number;

                                /**
                                 * Used on lanterns.
                                 * @since 1.8.4
                                 */
                                isHanging(): boolean;

                                /**
                                 * Used on brewing stands.
                                 * @since 1.8.4
                                 */
                                hasBottle0(): boolean;

                                /**
                                 * Used on brewing stands.
                                 * @since 1.8.4
                                 */
                                hasBottle1(): boolean;

                                /**
                                 * Used on brewing stands.
                                 * @since 1.8.4
                                 */
                                hasBottle2(): boolean;

                                /**
                                 * Used on jukeboxes.
                                 * @since 1.8.4
                                 */
                                hasRecord(): boolean;

                                /**
                                 * Used on lecterns.
                                 * @since 1.8.4
                                 */
                                hasBook(): boolean;

                                /**
                                 * Used on daylight sensors.
                                 * @since 1.8.4
                                 */
                                isInverted(): boolean;

                                /**
                                 * Used on fence gates.
                                 * @since 1.8.4
                                 */
                                isInWall(): boolean;

                                /**
                                 * Used on fence gates, barrels, trap doors and doors.
                                 * @since 1.8.4
                                 */
                                isOpen(): boolean;

                                /**
                                 * Used on candles, all types of furnaces, campfires and redstone torches.
                                 * @since 1.8.4
                                 */
                                isLit(): boolean;

                                /**
                                 * Used on repeaters.
                                 * @since 1.8.4
                                 */
                                isLocked(): boolean;

                                /**
                                 * Used on repeaters.
                                 * @since 1.8.4
                                 */
                                getDelay(): number;

                                /**
                                 * Used on beds.
                                 * @since 1.8.4
                                 */
                                isOccupied(): boolean;

                                /**
                                 * Used on leaves.
                                 * @since 1.8.4
                                 */
                                isPersistent(): boolean;

                                /**
                                 * Used on leaves and scaffold.
                                 * @since 1.8.4
                                 */
                                getDistance(): number;

                                /**
                                 * Used on leaves and scaffold.
                                 * @since 1.8.4
                                 */
                                getMaxDistance(): number;

                                /**
                                 * Used on leaves and scaffold.
                                 * @since 1.8.4
                                 */
                                getMinDistance(): number;

                                /**
                                 * Used on bells, buttons, detector rails, diodes, doors, fence gates, lecterns, levers,  
                                 *  lightning rods, note blocks, observers, powered rails, pressure plates, trap doors, trip wire
                                 *  hooks and trip wires.
                                 * @since 1.8.4
                                 */
                                isPowered(): boolean;

                                /**
                                 * Used on campfires.
                                 * @since 1.8.4
                                 */
                                isSignalFire(): boolean;

                                /**
                                 * Used on snowy dirt blocks.
                                 * @since 1.8.4
                                 */
                                isSnowy(): boolean;

                                /**
                                 * Used on dispensers.
                                 * @since 1.8.4
                                 */
                                isTriggered(): boolean;

                                /**
                                 * Used on tnt.
                                 * @since 1.8.4
                                 */
                                isUnstable(): boolean;

                                /**
                                 * Used on amethysts, corals, rails, dripleaves, dripleaf stems, campfires, candles, chains,  
                                 *  chests, conduits, fences, double plants, ender chests, iron bars, glass panes, glow lichen,  
                                 *  hanging roots, ladders, lanterns, light blocks, lightning rods, pointed dripstone,  
                                 *  scaffolding , sculk sensors, sea pickles, signs, stairs, slabs, trap doors and walls
                                 * @since 1.8.4
                                 */
                                isWaterlogged(): boolean;
                                /** @since 1.8.4 */
                                getBedPart(): string;
                                /** @since 1.8.4 */
                                getDoorHinge(): string;
                                /** @since 1.8.4 */
                                getInstrument(): string;
                                /** @since 1.8.4 */
                                getPistonType(): string;
                                /** @since 1.8.4 */
                                getSlabType(): string;
                                /** @since 1.8.4 */
                                getStairShape(): string;
                                /** @since 1.8.4 */
                                getStructureBlockMode(): string;
                                /** @since 1.8.4 */
                                getBambooLeaves(): string;
                                /** @since 1.8.4 */
                                getTilt(): string;
                                /** @since 1.8.4 */
                                getVerticalDirection(): string;
                                /** @since 1.8.4 */
                                getThickness(): string;
                                /** @since 1.8.4 */
                                getChestType(): string;
                                /** @since 1.8.4 */
                                getComparatorMode(): string;

                                /**
                                 * Used on cave vine roots.
                                 * @since 1.8.4
                                 */
                                hasBerries(): boolean;

                                /**
                                 * crop age and such
                                 * @author Wagyourtail
                                 * @since 1.8.4
                                 */
                                getAge(): number;
                                getMaxAge(): number;

                                /**
                                 * Used on cakes.
                                 * @since 1.8.4
                                 */
                                getBites(): number;

                                /**
                                 * Used on candles.
                                 * @since 1.8.4
                                 */
                                getCandles(): number;

                                /**
                                 * Used on turtle eggs.
                                 * @since 1.8.4
                                 */
                                getEggs(): number;

                                /**
                                 * Used on turtle eggs.
                                 * @since 1.8.4
                                 */
                                getHatched(): number;

                                /**
                                 * Used on snow layers.
                                 * @since 1.8.4
                                 */
                                getLayers(): number;

                                /**
                                 * Used on farmland.
                                 * @since 1.8.4
                                 */
                                getMoisture(): number;

                                /**
                                 * Used on note blocks.
                                 * @since 1.8.4
                                 */
                                getNote(): number;

                                /**
                                 * Used on sea pickles.
                                 * @since 1.8.4
                                 */
                                getPickles(): number;

                                /**
                                 * Used on daylight sensors, redstone wires, sculk sensors, target blocks, weighted pressure
                                 *  plates.
                                 * @since 1.8.4
                                 */
                                getPower(): number;

                                /**
                                 * Used on bamboo, saplings.
                                 * @since 1.8.4
                                 */
                                getStage(): number;

                                /**
                                 * Used on respawn anchors.
                                 * @since 1.8.4
                                 */
                                getCharges(): number;

                                /**
                                 * Used on sculk sensors.
                                 * @since 1.8.4
                                 */
                                isShrieking(): boolean;

                                /**
                                 * Used on sculk sensors.
                                 * @since 1.8.4
                                 */
                                canSummon(): boolean;

                                /**
                                 * Used on sculk sensors.
                                 * @since 1.8.4
                                 */
                                getSculkSensorPhase(): string;
                                /** @since 1.8.4 */
                                isBloom(): boolean;
                                /** @since 1.8.4 */
                                getRotation(): number;
                                /** @since 1.8.4 */
                                isSlot0Occupied(): boolean;
                                /** @since 1.8.4 */
                                isSlot1Occupied(): boolean;
                                /** @since 1.8.4 */
                                isSlot2Occupied(): boolean;
                                /** @since 1.8.4 */
                                isSlot3Occupied(): boolean;
                                /** @since 1.8.4 */
                                isSlot4Occupied(): boolean;
                                /** @since 1.8.4 */
                                isSlot5Occupied(): boolean;
                                /** @since 1.9.0 */
                                getFlowerAmount(): number;
                                /** @since 1.9.0 */
                                getBlockFace(): string;
                                /** @since 1.9.0 */
                                getDusted(): number;
                                /** @since 1.9.0 */
                                isCracked(): boolean;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.2.6
                             */
                            class BlockPosHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.util.math.BlockPos */ any> {
                                static readonly class: JavaClass<BlockPosHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (b: /* net.minecraft.util.math.BlockPos */ any);
                                constructor (x: int, y: int, z: int);

                                /**
                                 * @return the `x` value of the block.
                                 * @since 1.2.6
                                 */
                                getX(): number;

                                /**
                                 * @return the `y` value of the block.
                                 * @since 1.2.6
                                 */
                                getY(): number;

                                /**
                                 * @return the `z` value of the block.
                                 * @since 1.2.6
                                 */
                                getZ(): number;

                                /**
                                 * @return the block above.
                                 * @since 1.6.5
                                 */
                                up(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move up
                                 * @return the block n-th block above.
                                 * @since 1.6.5
                                 */
                                up(distance: int): BlockPosHelper;

                                /**
                                 * @return the block below.
                                 * @since 1.6.5
                                 */
                                down(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move down
                                 * @return the block n-th block below.
                                 * @since 1.6.5
                                 */
                                down(distance: int): BlockPosHelper;

                                /**
                                 * @return the block to the north.
                                 * @since 1.6.5
                                 */
                                north(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move north
                                 * @return the n-th block to the north.
                                 * @since 1.6.5
                                 */
                                north(distance: int): BlockPosHelper;

                                /**
                                 * @return the block to the south.
                                 * @since 1.6.5
                                 */
                                south(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move south
                                 * @return the n-th block to the south.
                                 * @since 1.6.5
                                 */
                                south(distance: int): BlockPosHelper;

                                /**
                                 * @return the block to the east.
                                 * @since 1.6.5
                                 */
                                east(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move east
                                 * @return the n-th block to the east.
                                 * @since 1.6.5
                                 */
                                east(distance: int): BlockPosHelper;

                                /**
                                 * @return the block to the west.
                                 * @since 1.6.5
                                 */
                                west(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move west
                                 * @return the n-th block to the west.
                                 * @since 1.6.5
                                 */
                                west(distance: int): BlockPosHelper;

                                /**
                                 * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                 * @return the block offset by the given direction.
                                 * @since 1.6.5
                                 */
                                offset(direction: string): BlockPosHelper;

                                /**
                                 * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                 * @param distance the distance to move in the given direction
                                 * @return the n-th block offset by the given direction.
                                 * @since 1.6.5
                                 */
                                offset(direction: string, distance: int): BlockPosHelper;

                                /**
                                 * @param x the x offset
                                 * @param y the y offset
                                 * @param z the y offset
                                 * @return the block offset by the given values.
                                 * @since 1.8.4
                                 */
                                offset(x: int, y: int, z: int): BlockPosHelper;

                                /**
                                 * @return the block position converted to the respective nether coordinates.
                                 * @since 1.8.4
                                 */
                                toNetherCoords(): BlockPosHelper;

                                /**
                                 * @return the block position converted to the respective overworld coordinates.
                                 * @since 1.8.4
                                 */
                                toOverworldCoords(): BlockPosHelper;

                                /**
                                 * @param entity the entity to get the distance to
                                 * @return the distance of this position to the given entity.
                                 * @since 1.8.4
                                 */
                                distanceTo(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>): number;

                                /**
                                 * @param pos the position to get the distance to
                                 * @return the distance of this position to the given position.
                                 * @since 1.8.4
                                 */
                                distanceTo(pos: BlockPosHelper): number;

                                /**
                                 * @param pos the position to get the distance to
                                 * @return the distance of this position to the given position.
                                 * @since 1.8.4
                                 */
                                distanceTo(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): number;

                                /**
                                 * @param x the x coordinate to get the distance to
                                 * @param y the y coordinate to get the distance to
                                 * @param z the z coordinate to get the distance to
                                 * @return the distance of this position to the given position.
                                 * @since 1.8.4
                                 */
                                distanceTo(x: double, y: double, z: double): number;

                                /**
                                 * @return the {@link Pos3D} representation of this position.
                                 * @since 1.8.4
                                 */
                                toPos3D(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                            }


                            /**
                             * @author Wagyourtail
                             */
                            class BlockDataHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.block.BlockState */ any> {
                                static readonly class: JavaClass<BlockDataHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (b: /* net.minecraft.block.BlockState */ any, e: /* net.minecraft.block.entity.BlockEntity */ any, bp: /* net.minecraft.util.math.BlockPos */ any);

                                /**
                                 * @return the `x` value of the block.
                                 * @since 1.1.7
                                 */
                                getX(): number;

                                /**
                                 * @return the `y` value of the block.
                                 * @since 1.1.7
                                 */
                                getY(): number;

                                /**
                                 * @return the `z` value of the block.
                                 * @since 1.1.7
                                 */
                                getZ(): number;

                                /**
                                 * @return the item ID of the block.
                                 */
                                getId(): BlockId;

                                /**
                                 * @return the translated name of the block. (was string before 1.6.5)
                                 */
                                getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                /** @since 1.5.1, used to be a {@link Map}<{@link String}, {@link String}> */
                                getNBT(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTCompoundHelper | null;
                                /** @since 1.6.5 */
                                getBlockStateHelper(): BlockStateHelper;

                                /**
                                 * @since 1.6.5
                                 * @deprecated use {@link getBlock}() instead.
                                 */
                                getBlockHelper(): BlockHelper;

                                /**
                                 * @return the block
                                 * @since 1.6.5
                                 */
                                getBlock(): BlockHelper;

                                /**
                                 * @return block state data as a {@link Map}.
                                 * @since 1.1.7
                                 */
                                getBlockState(): JavaMap<string, string>;

                                /**
                                 * @return the block pos.
                                 * @since 1.2.7
                                 */
                                getBlockPos(): BlockPosHelper;
                                getRawBlock(): /* net.minecraft.block.Block */ any;
                                getRawBlockState(): /* net.minecraft.block.BlockState */ any;
                                getRawBlockEntity(): /* net.minecraft.block.entity.BlockEntity */ any;

                            }


                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            class FluidStateHelper extends StateHelper</* net.minecraft.fluid.FluidState */ any> {
                                static readonly class: JavaClass<FluidStateHelper>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (base: /* net.minecraft.fluid.FluidState */ any);

                                /**
                                 * @return the fluid's id.
                                 * @since 1.8.4
                                 */
                                getId(): string;

                                /**
                                 * @return `true` if this fluid is still, `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isStill(): boolean;

                                /**
                                 * @return `true` if this fluid is empty (the default fluid state for non fluid blocks),
                                 *  `false` otherwise.
                                 * @since 1.8.4
                                 */
                                isEmpty(): boolean;

                                /**
                                 * @return the height of this state.
                                 * @since 1.8.4
                                 */
                                getHeight(): number;

                                /**
                                 * @return the level of this state.
                                 * @since 1.8.4
                                 */
                                getLevel(): number;

                                /**
                                 * @return `true` if the fluid has some random tick logic (only used by lava to do the
                                 *  fire spread), `false` otherwise.
                                 * @since 1.8.4
                                 */
                                hasRandomTicks(): boolean;

                                /**
                                 * @param pos the position in the world
                                 * @return the velocity that will be applied to entities at the given position.
                                 * @since 1.8.4
                                 */
                                getVelocity(pos: BlockPosHelper): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                /**
                                 * @return the block state of this fluid.
                                 * @since 1.8.4
                                 */
                                getBlockState(): BlockStateHelper;

                                /**
                                 * @return the blast resistance of this fluid.
                                 * @since 1.8.4
                                 */
                                getBlastResistance(): number;

                            }

                            export {
                                ServerInfoHelper,
                                DirectionHelper,
                                BlockHelper,
                                TeamHelper,
                                PlayerListEntryHelper,
                                ScoreboardsHelper,
                                ChunkHelper,
                                BlockStateHelper,
                                StateHelper,
                                UniversalBlockStateHelper,
                                BlockPosHelper,
                                BlockDataHelper,
                                FluidStateHelper
                            }

                        }
                        namespace world {

                            namespace entity {


                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                class MobEntityHelper<T = /* net.minecraft.entity.mob.MobEntity */ any> extends LivingEntityHelper<T> {
                                    static readonly class: JavaClass<MobEntityHelper<any>>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor <T extends /* net.minecraft.entity.mob.MobEntity */ any>(base: T);

                                    /**
                                     * @return `true` if the entity is currently attacking something, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    isAttacking(): boolean;

                                    /**
                                     * Mobs which have there AI disabled don't move, attack, or interact with the world by
                                     *  themselves.
                                     * @return `true` if the entity's AI is disabled, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isAiDisabled(): boolean;

                                }

                                class LivingEntityHelper<T = /* net.minecraft.entity.LivingEntity */ any> extends EntityHelper<T> {
                                    static readonly class: JavaClass<LivingEntityHelper<any>>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor <T extends /* net.minecraft.entity.LivingEntity */ any>(e: T);

                                    /**
                                     * @return entity status effects.
                                     * @since 1.2.7
                                     */
                                    getStatusEffects(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper>;

                                    /**
                                     * @param effect the status effect
                                     * @return if the entity can have a certain status effect
                                     * @since 1.8.4
                                     */
                                    canHaveStatusEffect(effect: xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper): boolean;

                                    /**
                                     * For client side entities, excluding the player, this will most likely return `false`
                                     *  even if the entity has the effect, as effects are not synced to the client.
                                     * @return `true` if the entity has the specified status effect, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    hasStatusEffect(id: CanOmitNamespace<StatusEffectId>): boolean;

                                    /**
                                     * @return `true` if the entity is holding the specified item
                                     * @since 1.9.0
                                     */
                                    isHolding(item: ItemId): boolean;

                                    /**
                                     * @return the item in the entity's main hand.
                                     * @see ItemStackHelper
                                     * @since 1.2.7
                                     */
                                    getMainHand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return the item in the entity's off hand.
                                     * @since 1.2.7
                                     */
                                    getOffHand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return the item in the entity's head armor slot.
                                     * @since 1.2.7
                                     */
                                    getHeadArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return the item in the entity's chest armor slot.
                                     * @since 1.2.7
                                     */
                                    getChestArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return the item in the entity's leg armor slot.
                                     * @since 1.2.7
                                     */
                                    getLegArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return the item in the entity's foot armor slot.
                                     * @since 1.2.7
                                     */
                                    getFootArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return entity's health
                                     * @since 1.3.1
                                     */
                                    getHealth(): number;

                                    /**
                                     * @return entity's max health
                                     * @since 1.6.5
                                     */
                                    getMaxHealth(): number;

                                    /**
                                     * @return the entity's absorption amount.
                                     * @since 1.8.4
                                     */
                                    getAbsorptionHealth(): number;

                                    /**
                                     * @return the entity's armor value.
                                     * @since 1.8.4
                                     */
                                    getArmor(): number;

                                    /**
                                     * @return the entity's default health.
                                     * @since 1.8.4
                                     */
                                    getDefaultHealth(): number;

                                    /**
                                     * @return the entity's mob category, `UNDEAD`, `DEFAULT`, `ARTHROPOD`, or
                                     *  `ILLAGER`, `AQUATIC` or `UNKNOWN`.
                                     * @since 1.8.4
                                     */
                                    getMobCategory(): MobCategory;

                                    /**
                                     * @return if the entity is in a bed.
                                     * @since 1.2.7
                                     */
                                    isSleeping(): boolean;

                                    /**
                                     * @return if the entity has elytra deployed
                                     * @since 1.5.0
                                     */
                                    isFallFlying(): boolean;

                                    /**
                                     * @return if the entity is on the ground
                                     * @since 1.8.4
                                     */
                                    isOnGround(): boolean;

                                    /**
                                     * @return if the entity can breathe in water
                                     * @since 1.8.4
                                     */
                                    canBreatheInWater(): boolean;

                                    /**
                                     * @return if the entity has no drag
                                     * @since 1.8.4
                                     */
                                    hasNoDrag(): boolean;

                                    /**
                                     * @return if the entity has no gravity
                                     * @since 1.8.4
                                     */
                                    hasNoGravity(): boolean;

                                    /**
                                     * @param target the target entity
                                     * @return if the entity can target a target entity
                                     * @since 1.8.4
                                     */
                                    canTarget(target: LivingEntityHelper<any>): boolean;

                                    /**
                                     * @return if the entity can take damage
                                     * @since 1.8.4
                                     */
                                    canTakeDamage(): boolean;

                                    /**
                                     * @return if the entity is part of the game (is alive and not spectator)
                                     * @since 1.8.4
                                     */
                                    isPartOfGame(): boolean;

                                    /**
                                     * @return if the entity is in spectator
                                     * @since 1.8.4
                                     */
                                    isSpectator(): boolean;

                                    /**
                                     * @return if the entity is undead
                                     * @since 1.8.4
                                     */
                                    isUndead(): boolean;

                                    /**
                                     * @return the bow pull progress of the entity, `0` by default.
                                     * @since 1.8.4
                                     */
                                    getBowPullProgress(): number;
                                    /** @since 1.9.0 */
                                    getItemUseTimeLeft(): number;

                                    /**
                                     * @return `true` if the entity is a baby, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isBaby(): boolean;

                                    /**
                                     * @param entity the entity to check line of sight to
                                     * @return `true` if the player has line of sight to the specified entity, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    canSeeEntity(entity: EntityHelper<any>): boolean;

                                    /**
                                     * @param entity the entity to check line of sight to
                                     * @param simpleCast whether to use a simple raycast or a more complex one
                                     * @return `true` if the entity has line of sight to the specified entity, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    canSeeEntity(entity: EntityHelper<any>, simpleCast: boolean): boolean;

                                }


                                /**
                                 * @author Wagyourtail
                                 * @since 1.2.1
                                 */
                                class BossBarHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.entity.boss.BossBar */ any> {
                                    static readonly class: JavaClass<BossBarHelper>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (b: /* net.minecraft.entity.boss.BossBar */ any);

                                    /**
                                     * @return boss bar uuid.
                                     * @since 1.2.1
                                     */
                                    getUUID(): string;

                                    /**
                                     * @return percent of boss bar remaining.
                                     * @since 1.2.1
                                     */
                                    getPercent(): number;

                                    /**
                                     * @return boss bar color.
                                     * @since 1.2.1
                                     */
                                    getColor(): BossBarColor;

                                    /**
                                     * @return boss bar notch style.
                                     * @since 1.2.1
                                     */
                                    getStyle(): BossBarStyle;

                                    /**
                                     * @return the color of this boss bar.
                                     * @since 1.8.4
                                     */
                                    getColorValue(): number;

                                    /**
                                     * @return the format of the boss bar's color.
                                     * @since 1.8.4
                                     */
                                    getColorFormat(): xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper;

                                    /**
                                     * @return name of boss bar
                                     * @since 1.2.1
                                     */
                                    getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                }

                                class MerchantEntityHelper<T = /* net.minecraft.entity.passive.MerchantEntity */ any> extends LivingEntityHelper<T> {
                                    static readonly class: JavaClass<MerchantEntityHelper<any>>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor <T extends /* net.minecraft.entity.passive.MerchantEntity */ any>(e: T);

                                    /**
                                     * these might not work... depends on the data the server sends, maybe just singleplayer.
                                     */
                                    getTrades(): JavaList<TradeOfferHelper>;
                                    refreshTrades(): JavaList<TradeOfferHelper>;
                                    getExperience(): number;
                                    hasCustomer(): boolean;

                                }


                                /**
                                 * @author Wagyourtail
                                 * @since 1.0.3
                                 */
                                class PlayerAbilitiesHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.entity.player.PlayerAbilities */ any> {
                                    static readonly class: JavaClass<PlayerAbilitiesHelper>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (a: /* net.minecraft.entity.player.PlayerAbilities */ any);

                                    /**
                                     * @return whether the player can be damaged.
                                     * @since 1.0.3
                                     */
                                    getInvulnerable(): boolean;

                                    /**
                                     * @return if the player is currently flying.
                                     * @since 1.0.3
                                     */
                                    getFlying(): boolean;

                                    /**
                                     * @return if the player is allowed to fly.
                                     * @since 1.0.3
                                     */
                                    getAllowFlying(): boolean;

                                    /**
                                     * @return if the player is in creative.
                                     * @since 1.0.3
                                     */
                                    getCreativeMode(): boolean;

                                    /**
                                     * Even if this method returns true, the player may not be able to modify the world due to other
                                     *  restrictions such as plugins and mods. Modifying the world includes, placing, breaking or
                                     *  interacting with blocks.
                                     * @return `true` if the player is allowed to modify the world, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    canModifyWorld(): boolean;

                                    /**
                                     * set the player flying state.
                                     * @since 1.0.3
                                     */
                                    setFlying(b: boolean): PlayerAbilitiesHelper;

                                    /**
                                     * set the player allow flying state.
                                     * @since 1.0.3
                                     */
                                    setAllowFlying(b: boolean): PlayerAbilitiesHelper;

                                    /**
                                     * @return the player fly speed multiplier.
                                     * @since 1.0.3
                                     */
                                    getFlySpeed(): number;

                                    /**
                                     * set the player fly speed multiplier.
                                     * @since 1.0.3
                                     */
                                    setFlySpeed(flySpeed: double): PlayerAbilitiesHelper;

                                    /**
                                     * @return the player's walk speed.
                                     * @since 1.8.4
                                     */
                                    getWalkSpeed(): number;

                                    /**
                                     * @param speed the new walk speed
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWalkSpeed(speed: double): this;

                                }


                                /**
                                 * @author Wagyourtail
                                 */
                                class PlayerEntityHelper<T = /* net.minecraft.entity.player.PlayerEntity */ any> extends LivingEntityHelper<T> {
                                    static readonly class: JavaClass<PlayerEntityHelper<any>>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor <T extends /* net.minecraft.entity.player.PlayerEntity */ any>(e: T);

                                    /**
                                     * get player's actual name. (not display name)
                                     * @since 1.8.4
                                     */
                                    getPlayerName(): string;

                                    /**
                                     * @see PlayerAbilitiesHelper
                                     * @since 1.0.3
                                     */
                                    getAbilities(): PlayerAbilitiesHelper;
                                    /** @since 1.2.0 */
                                    getMainHand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getOffHand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getHeadArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getChestArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getLegArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getFootArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.5 [citation needed] */
                                    getXP(): number;
                                    /** @since 1.6.5 */
                                    getXPLevel(): number;
                                    /** @since 1.6.5 */
                                    getXPProgress(): number;
                                    /** @since 1.6.5 */
                                    getXPToLevelUp(): number;
                                    /** @since 1.2.5 [citation needed] */
                                    isSleeping(): boolean;

                                    /**
                                     * @return if the player has slept the minimum ammount of time to pass the night.
                                     * @since 1.2.5 [citation needed]
                                     */
                                    isSleepingLongEnough(): boolean;

                                    /**
                                     * @return the fishing bobber of the player, or `null` if the player is not fishing.
                                     * @since 1.8.4
                                     */
                                    getFishingBobber(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.projectile.FishingBobberEntityHelper | null;
                                    /** @since 1.8.4 */
                                    getAttackCooldownProgress(): number;
                                    /** @since 1.8.4 */
                                    getAttackCooldownProgressPerTick(): number;

                                    /**
                                     * @return the player's score.
                                     * @since 1.8.4
                                     */
                                    getScore(): number;

                                }


                                /**
                                 * @author Wagyourtail
                                 */
                                abstract class EntityHelper<T = /* net.minecraft.entity.Entity */ any> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T> {
                                    static readonly class: JavaClass<EntityHelper<any>>;
                                    /** @deprecated */ static prototype: undefined;

                                    /**
                                     * mostly for internal use.
                                     * @param e mc entity.
                                     * @return correct subclass of this.
                                     */
                                    static create(e: /* net.minecraft.entity.Entity */ any): EntityHelper<any>;

                                    /**
                                     * @return entity position.
                                     */
                                    getPos(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @return entity block position.
                                     * @since 1.6.5
                                     */
                                    getBlockPos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

                                    /**
                                     * @return the entity's eye position.
                                     * @since 1.8.4
                                     */
                                    getEyePos(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @return entity chunk coordinates. Since Pos2D only has x and y fields, z coord is y.
                                     * @since 1.6.5
                                     */
                                    getChunkPos(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;

                                    /**
                                     * @return the `x` value of the entity.
                                     * @since 1.0.8
                                     */
                                    getX(): number;

                                    /**
                                     * @return the `y` value of the entity.
                                     * @since 1.0.8
                                     */
                                    getY(): number;

                                    /**
                                     * @return the `z` value of the entity.
                                     * @since 1.0.8
                                     */
                                    getZ(): number;

                                    /**
                                     * @return the current eye height offset for the entitye.
                                     * @since 1.2.8
                                     */
                                    getEyeHeight(): number;

                                    /**
                                     * @return the `pitch` value of the entity.
                                     * @since 1.0.8
                                     */
                                    getPitch(): number;

                                    /**
                                     * @return the `yaw` value of the entity.
                                     * @since 1.0.8
                                     */
                                    getYaw(): number;

                                    /**
                                     * @return the name of the entity.
                                     * @since 1.0.8 [citation needed], returned string until 1.6.4
                                     */
                                    getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                    /**
                                     * @return the type of the entity.
                                     */
                                    getType(): EntityId;

                                    /**
                                     * checks if this entity type equals to any of the specified types<br>
                                     * @since 1.9.0
                                     */
                                    is<E extends CanOmitNamespace<EntityId>>(...types: E[]): this is EntityTypeFromId<E>;

                                    /**
                                     * @return if the entity has the glowing effect.
                                     * @since 1.1.9
                                     */
                                    isGlowing(): boolean;

                                    /**
                                     * @return if the entity is in lava.
                                     * @since 1.1.9
                                     */
                                    isInLava(): boolean;

                                    /**
                                     * @return if the entity is on fire.
                                     * @since 1.1.9
                                     */
                                    isOnFire(): boolean;

                                    /**
                                     * @return `true` if the entity is sneaking, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isSneaking(): boolean;

                                    /**
                                     * @return `true` if the entity is sprinting, `false` otherwise.
                                     * @since 1.8.4
                                     */
                                    isSprinting(): boolean;

                                    /**
                                     * @return the vehicle of the entity.
                                     * @since 1.1.8 [citation needed]
                                     */
                                    getVehicle(): EntityHelper<any> | null;

                                    /**
                                     * @return the entity passengers.
                                     * @since 1.1.8 [citation needed]
                                     */
                                    getPassengers(): JavaList<EntityHelper<any>> | null;
                                    /** @since 1.2.8, was a {@link String} until 1.5.0 */
                                    getNBT(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTCompoundHelper;
                                    /** @since 1.6.4 */
                                    setCustomName(name: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper | null): EntityHelper<T>;

                                    /**
                                     * sets the name to always display
                                     * @since 1.8.0
                                     */
                                    setCustomNameVisible(b: boolean): EntityHelper<T>;
                                    setGlowingColor(color: int): EntityHelper<T>;
                                    resetGlowingColor(): EntityHelper<T>;

                                    /**
                                     * warning: affected by setGlowingColor
                                     * @return glow color
                                     * @since 1.8.2
                                     */
                                    getGlowingColor(): number;

                                    /**
                                     * Sets whether the entity is glowing.
                                     * @since 1.1.9
                                     */
                                    setGlowing(val: boolean): EntityHelper<T>;

                                    /**
                                     * reset the glowing effect to proper value.
                                     * @since 1.6.3
                                     */
                                    resetGlowing(): EntityHelper<T>;

                                    /**
                                     * Checks if the entity is still alive.
                                     * @since 1.2.8
                                     */
                                    isAlive(): boolean;

                                    /**
                                     * @return UUID of the entity, random* if not a player, otherwise the player's uuid.
                                     * @since 1.6.5
                                     */
                                    getUUID(): string;

                                    /**
                                     * @return the maximum amount of air this entity can have.
                                     * @since 1.8.4
                                     */
                                    getMaxAir(): number;

                                    /**
                                     * @return the amount of air this entity has.
                                     * @since 1.8.4
                                     */
                                    getAir(): number;

                                    /**
                                     * @return this entity's current speed in blocks per second.
                                     * @since 1.8.4
                                     */
                                    getSpeed(): number;

                                    /**
                                     * @return the direction the entity is facing, rounded to the nearest 45 degrees.
                                     * @since 1.8.4
                                     */
                                    getFacingDirection(): xyz.wagyourtail.jsmacros.client.api.helpers.world.DirectionHelper;

                                    /**
                                     * @return the distance between this entity and the specified one.
                                     * @since 1.8.4
                                     */
                                    distanceTo(entity: EntityHelper<any>): number;

                                    /**
                                     * @return the distance between this entity and the specified position.
                                     * @since 1.8.4
                                     */
                                    distanceTo(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): number;

                                    /**
                                     * @return the distance between this entity and the specified position.
                                     * @since 1.8.4
                                     */
                                    distanceTo(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): number;

                                    /**
                                     * @return the distance between this entity and the specified position.
                                     * @since 1.8.4
                                     */
                                    distanceTo(x: double, y: double, z: double): number;

                                    /**
                                     * @return the velocity vector.
                                     * @since 1.8.4
                                     */
                                    getVelocity(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @return the chunk helper for the chunk this entity is in.
                                     * @since 1.8.4
                                     */
                                    getChunk(): xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper;

                                    /**
                                     * @return the name of the biome this entity is in.
                                     * @since 1.8.4
                                     */
                                    getBiome(): Biome;

                                    /**
                                     * @return cast of this entity helper (mainly for typescript)
                                     * @since 1.6.3
                                     */
                                    asClientPlayer(): ClientPlayerEntityHelper<any>;

                                    /**
                                     * @return cast of this entity helper (mainly for typescript)
                                     * @since 1.6.3
                                     */
                                    asPlayer(): PlayerEntityHelper<any>;

                                    /**
                                     * @return cast of this entity helper (mainly for typescript)
                                     * @since 1.6.3
                                     */
                                    asVillager(): VillagerEntityHelper;

                                    /**
                                     * @return cast of this entity helper (mainly for typescript)
                                     * @since 1.6.3
                                     */
                                    asMerchant(): MerchantEntityHelper<any>;

                                    /**
                                     * @return cast of this entity helper (mainly for typescript)
                                     * @since 1.6.3
                                     */
                                    asLiving(): LivingEntityHelper<any>;

                                    /**
                                     * @return this helper as an animal entity helper (mainly for typescript).
                                     * @since 1.8.4
                                     */
                                    asAnimal(): LivingEntityHelper<any>;

                                    /**
                                     * @return cast of this entity helper (mainly for typescript)
                                     * @since 1.6.3
                                     */
                                    asItem(): ItemEntityHelper;

                                    /**
                                     * @return the entity as a server entity if an integrated server is running and `null` otherwise.
                                     * @since 1.8.4
                                     */
                                    asServerEntity(): EntityHelper<any> | null;

                                }

                                class ItemEntityHelper extends EntityHelper</* net.minecraft.entity.ItemEntity */ any> {
                                    static readonly class: JavaClass<ItemEntityHelper>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (e: /* net.minecraft.entity.ItemEntity */ any);

                                    getContainedItemStack(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                }

                                class TradeOfferHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* net.minecraft.village.TradeOffer */ any> {
                                    static readonly class: JavaClass<TradeOfferHelper>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (base: /* net.minecraft.village.TradeOffer */ any, index: int, inv: xyz.wagyourtail.jsmacros.client.api.classes.inventory.VillagerInventory);

                                    /**
                                     * @return list of input items required
                                     */
                                    getInput(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                    /**
                                     * The returned item uses the adjusted price, in form of its stack size and will be empty
                                     *  {@link ItemStackHelper.isEmpty}() if the first input doesn't exist.
                                     * @return the first input item.
                                     * @since 1.8.4
                                     */
                                    getLeftInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * The returned item uses the adjusted price, in form of its stack size and will be empty
                                     *  {@link ItemStackHelper.isEmpty}() if the first input doesn't exist.
                                     * @return the second input item.
                                     * @since 1.8.4
                                     */
                                    getRightInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return output item that will be received
                                     */
                                    getOutput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return the index if this trade in the given villager inventory.
                                     * @since 1.8.4
                                     */
                                    getIndex(): number;

                                    /**
                                     * select trade offer on screen
                                     */
                                    select(): TradeOfferHelper;
                                    isAvailable(): boolean;

                                    /**
                                     * @return trade offer as nbt tag
                                     */
                                    getNBT(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTCompoundHelper;

                                    /**
                                     * @return current number of uses
                                     */
                                    getUses(): number;

                                    /**
                                     * @return max uses before it locks
                                     */
                                    getMaxUses(): number;

                                    /**
                                     * @return `true` if after a successful trade xp will be summoned, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    shouldRewardPlayerExperience(): boolean;

                                    /**
                                     * @return experience gained for trade
                                     */
                                    getExperience(): number;

                                    /**
                                     * @return current price adjustment, negative is discount.
                                     */
                                    getCurrentPriceAdjustment(): number;

                                    /**
                                     * @return the original priced item without any adjustments due to rewards or demand.
                                     * @since 1.8.4
                                     */
                                    getOriginalFirstInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return the original price of the item without any adjustments due to rewards or demand.
                                     * @since 1.8.4
                                     */
                                    getOriginalPrice(): number;

                                    /**
                                     * @return the adjusted price of the item.
                                     * @since 1.8.4
                                     */
                                    getAdjustedPrice(): number;

                                    /**
                                     * A negative value is a discount and means that the player has a good reputation with the
                                     *  villager, while a positive value is a premium. Hero of the village will always affect and
                                     *  reduce this value.
                                     * @return the special price multiplier, which affects the price of the item depending on the
                                     *  player's reputation with the villager.
                                     * @since 1.8.4
                                     */
                                    getSpecialPrice(): number;

                                    /**
                                     * A higher price multiplier means that the price of these trades can vary much more than normal
                                     *  ones. The default value is 0.05 and 0.2 for armor and tools.
                                     * @return the price multiplier, which is only depended on the type of trade.
                                     * @since 1.8.4
                                     */
                                    getPriceMultiplier(): number;

                                    /**
                                     * The demand bonus is globally applied to all trades of this type for all villagers and
                                     *  players. It is used to increase the price of trades that are in high demand. The demand is
                                     *  only calculated and updated on restock. Note that a villager can always restock, even if no
                                     *  items were traded with him. Updating the demand is done with the following formula:  
                                     *  ``` `demand = demand + 2 * uses - maxUses` ```  
                                     *  Thus trading only half of the max uses will not increase the demand.  
                                     *  The demand is also capped at 0, so it can not decrease the price.
                                     * @return the demand bonus for this trade.
                                     * @since 1.8.4
                                     */
                                    getDemandBonus(): number;

                                }


                                /**
                                 * @author Wagyourtail
                                 * @see PlayerEntityHelper
                                 * @since 1.0.3
                                 */
                                class ClientPlayerEntityHelper<T = /* net.minecraft.client.network.ClientPlayerEntity */ any> extends PlayerEntityHelper<T> {
                                    static readonly class: JavaClass<ClientPlayerEntityHelper<any>>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor <T extends /* net.minecraft.client.network.ClientPlayerEntity */ any>(e: T);

                                    /** @since 1.8.4 */
                                    setVelocity(velocity: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): ClientPlayerEntityHelper<T>;
                                    /** @since 1.8.4 */
                                    setVelocity(x: double, y: double, z: double): ClientPlayerEntityHelper<T>;
                                    /** @since 1.8.4 */
                                    addVelocity(velocity: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): ClientPlayerEntityHelper<T>;
                                    /** @since 1.8.4 */
                                    addVelocity(x: double, y: double, z: double): ClientPlayerEntityHelper<T>;
                                    /** @since 1.8.4 */
                                    setPos(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): ClientPlayerEntityHelper<T>;
                                    /** @since 1.8.4 */
                                    setPos(x: double, y: double, z: double): ClientPlayerEntityHelper<T>;
                                    /** @since 1.8.4 */
                                    addPos(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): ClientPlayerEntityHelper<T>;
                                    /** @since 1.8.4 */
                                    addPos(x: double, y: double, z: double): ClientPlayerEntityHelper<T>;

                                    /**
                                     * Sets the player rotation along the given axis and keeps the other axis the same.
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    lookAt(direction: string): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param yaw (was pitch prior to 1.2.6)
                                     * @param pitch (was yaw prior to 1.2.6)
                                     * @since 1.0.3
                                     */
                                    lookAt(yaw: double, pitch: double): ClientPlayerEntityHelper<T>;

                                    /**
                                     * look at the specified coordinates.
                                     * @since 1.2.8
                                     */
                                    lookAt(x: double, y: double, z: double): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate of the block to look at
                                     * @param y the y coordinate of the block to look at
                                     * @param z the z coordinate of the block to look at
                                     * @return `true` if the player is targeting the specified block, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    tryLookAt(x: int, y: int, z: int): boolean;

                                    /**
                                     * Will try many rotations to find one that will make the player target the specified block. If
                                     *  successful, the player will be turned towards the block and `true` will be returned. If
                                     *  `false` is returned, the player will keep its current rotation.
                                     * @param pos the position of the block to look at
                                     * @return `true` if the player is targeting the specified block, `false`
                                     *  otherwise.
                                     * @since 1.8.4
                                     */
                                    tryLookAt(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): boolean;

                                    /**
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    turnLeft(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    turnRight(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    turnBack(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.5.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    attack(entity: EntityHelper<any>): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    attack(entity: EntityHelper<any>, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate to attack
                                     * @param y the y coordinate to attack
                                     * @param z the z coordinate to attack
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    attack(x: int, y: int, z: int, direction: Direction): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                     * @since 1.5.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    attack(x: int, y: int, z: int, direction: Hexit): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate to attack
                                     * @param y the y coordinate to attack
                                     * @param z the z coordinate to attack
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @param await whether to wait for the attack to finish
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    attack(x: int, y: int, z: int, direction: Direction, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                     * @throws InterruptedException
                                     * @since 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    attack(x: int, y: int, z: int, direction: Hexit, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.5.0, renamed from `interact` in 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interactEntity(entity: EntityHelper<any>, offHand: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @throws InterruptedException
                                     * @since 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interactEntity(entity: EntityHelper<any>, offHand: boolean, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.5.0, renamed from `interact` in 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interactItem(offHand: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interactItem(offHand: boolean, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate to interact
                                     * @param y the y coordinate to interact
                                     * @param z the z coordinate to interact
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interactBlock(x: int, y: int, z: int, direction: Direction, offHand: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                     * @since 1.5.0, renamed from `interact` in 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interactBlock(x: int, y: int, z: int, direction: Hexit, offHand: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate to interact
                                     * @param y the y coordinate to interact
                                     * @param z the z coordinate to interact
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @param await whether to wait for the interaction to complete
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interactBlock(x: int, y: int, z: int, direction: Direction, offHand: boolean, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                     * @param await whether to wait for the interaction to complete
                                     * @since 1.5.0, renamed from `interact` in 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interactBlock(x: int, y: int, z: int, direction: Hexit, offHand: boolean, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.5.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interact(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    interact(await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.5.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    attack(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.0
                                     * @deprecated moved to `Player.getInteractionManager()`
                                     */
                                    attack(await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.3
                                     * @deprecated use `Player.getInteractionManager().breakBlock()` instead
                                     */
                                    setLongAttack(stop: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.3
                                     * @deprecated use `Player.getInteractionManager().holdInteract()` instead
                                     */
                                    setLongInteract(stop: boolean): ClientPlayerEntityHelper<T>;
                                    /** @since 1.6.5 */
                                    getItemCooldownsRemainingTicks(): JavaMap<ItemId, int>;
                                    /** @since 1.6.5 */
                                    getItemCooldownRemainingTicks(item: CanOmitNamespace<ItemId>): number;
                                    /** @since 1.6.5 */
                                    getTicksSinceCooldownsStart(): JavaMap<ItemId, int>;
                                    /** @since 1.6.5 */
                                    getTicksSinceCooldownStart(item: CanOmitNamespace<ItemId>): number;
                                    /** @since 1.1.2 */
                                    getFoodLevel(): number;

                                    /**
                                     * This will return the invisible hunger decade that you may have seen in mods as a yellow overlay.
                                     * @return the saturation level.
                                     * @since 1.8.4
                                     */
                                    getSaturation(): number;

                                    /**
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    dropHeldItem(dropStack: boolean): ClientPlayerEntityHelper<any>;

                                    /**
                                     * @return an advancement manager to work with advancements.
                                     * @since 1.8.4
                                     */
                                    getAdvancementManager(): xyz.wagyourtail.jsmacros.client.api.helpers.AdvancementManagerHelper;

                                    /**
                                     * The returned time is an approximation and will likely be off by a few ticks, although it
                                     *  should always be less than the actual time.
                                     * @param block the block to mine
                                     * @return the time in ticks that it will approximately take the player with the currently held
                                     *  item to mine said block.
                                     */
                                    calculateMiningSpeed(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): number;

                                    /**
                                     * Calculate mining speed for a given block mined with a specified item in ticks. Use air to
                                     *  calculate the mining speed for the hand. The returned time is an approximation and will
                                     *  likely be off by a few ticks, although it should always be less than the actual time.
                                     * @param usedItem the item to mine with
                                     * @param blockState the block to mine
                                     * @return the time in ticks that it will approximately take the player with the specified item
                                     *  to mine said block.
                                     * @since 1.8.4
                                     */
                                    calculateMiningSpeed(usedItem: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, blockState: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): number;

                                }

                                /** @since 1.6.3 */
                                class VillagerEntityHelper extends MerchantEntityHelper</* net.minecraft.entity.passive.VillagerEntity */ any> {
                                    static readonly class: JavaClass<VillagerEntityHelper>;
                                    /** @deprecated */ static prototype: undefined;

                                    constructor (e: /* net.minecraft.entity.passive.VillagerEntity */ any);

                                    /** @since 1.6.3 */
                                    getProfession(): VillagerProfession;
                                    /** @since 1.6.3 */
                                    getStyle(): VillagerStyle;
                                    /** @since 1.6.3 */
                                    getLevel(): number;

                                }

                                export {
                                    MobEntityHelper,
                                    LivingEntityHelper,
                                    BossBarHelper,
                                    MerchantEntityHelper,
                                    PlayerAbilitiesHelper,
                                    PlayerEntityHelper,
                                    EntityHelper,
                                    ItemEntityHelper,
                                    TradeOfferHelper,
                                    ClientPlayerEntityHelper,
                                    VillagerEntityHelper
                                }

                            }
                            namespace entity {

                                namespace specialized {

                                    namespace boss {


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class WitherEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.boss.WitherEntity */ any> {
                                            static readonly class: JavaClass<WitherEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.boss.WitherEntity */ any);

                                            /**
                                             * @return the time in ticks the wither will be invulnerable for.
                                             * @since 1.8.4
                                             */
                                            getRemainingInvulnerableTime(): number;

                                            /**
                                             * The wither will only be invulnerable, by default for 220 ticks, when summoned.
                                             * @return `true` if the wither is invulnerable, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isInvulnerable(): boolean;

                                            /**
                                             * @return `true` if the wither is in its first phase, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isFirstPhase(): boolean;

                                            /**
                                             * In the second phase the wither will be invulnerable to projectiles and starts going down
                                             *  towards the player.
                                             * @return `true` if the wither is in its second phase, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSecondPhase(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class EnderDragonEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.boss.dragon.EnderDragonEntity */ any> {
                                            static readonly class: JavaClass<EnderDragonEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.boss.dragon.EnderDragonEntity */ any);

                                            /**
                                             * The phases are as follows:  
                                             *
                                             *  `HoldingPattern`, `StrafePlayer`, `LandingApproach`, `Landing`,  
                                             *  `Takeoff`, `SittingFlaming`, `SittingScanning`, `SittingAttacking`,  
                                             *  `ChargingPlayer`, `Dying`, `Hover`
                                             * @return the current phase of the dragon.
                                             * @since 1.8.4
                                             */
                                            getPhase(): DragonPhase;

                                            /**
                                             * @param index the index of the dragon's body part to get
                                             * @return the specified body part of the dragon.
                                             * @since 1.8.4
                                             */
                                            getBodyPart(index: int): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;

                                            /**
                                             * @return a list of all body parts of the dragon.
                                             * @since 1.8.4
                                             */
                                            getBodyParts(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

                                            /**
                                             * The name can be either `head`, `neck`, `body`, `tail` or
                                             *  `wing`.
                                             * @param name the name of the body part to get
                                             * @return a list of all body parts of the dragon with the specified name.
                                             * @since 1.8.4
                                             */
                                            getBodyParts(name: DragonBodyPart): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

                                        }

                                        export { WitherEntityHelper, EnderDragonEntityHelper }

                                    }

                                    namespace decoration {


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class ArmorStandEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.LivingEntityHelper</* net.minecraft.entity.decoration.ArmorStandEntity */ any> {
                                            static readonly class: JavaClass<ArmorStandEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.decoration.ArmorStandEntity */ any);

                                            /**
                                             * @return `true` if the armor stand is visible, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isVisible(): boolean;

                                            /**
                                             * @return `true` if the armor is small, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSmall(): boolean;

                                            /**
                                             * @return `true` if the armor stand has arms, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasArms(): boolean;

                                            /**
                                             * @return `true` if the armor stand has a base plate, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasBasePlate(): boolean;

                                            /**
                                             * @return `true` if the armor stand is a marker, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isMarker(): boolean;

                                            /**
                                             * The rotation is in the format of `[yaw, pitch, roll]`.
                                             * @return the head rotation of the armor stand.
                                             * @since 1.8.4
                                             */
                                            getHeadRotation(): JavaArray<number>;

                                            /**
                                             * The rotation is in the format of `[yaw, pitch, roll]`.
                                             * @return the body rotation of the armor stand.
                                             * @since 1.8.4
                                             */
                                            getBodyRotation(): JavaArray<number>;

                                            /**
                                             * The rotation is in the format of `[yaw, pitch, roll]`.
                                             * @return the left arm rotation of the armor stand.
                                             * @since 1.8.4
                                             */
                                            getLeftArmRotation(): JavaArray<number>;

                                            /**
                                             * The rotation is in the format of `[yaw, pitch, roll]`.
                                             * @return the right arm rotation of the armor stand.
                                             * @since 1.8.4
                                             */
                                            getRightArmRotation(): JavaArray<number>;

                                            /**
                                             * The rotation is in the format of `[yaw, pitch, roll]`.
                                             * @return the left leg rotation of the armor stand.
                                             * @since 1.8.4
                                             */
                                            getLeftLegRotation(): JavaArray<number>;

                                            /**
                                             * The rotation is in the format of `[yaw, pitch, roll]`.
                                             * @return the right leg rotation of the armor stand.
                                             * @since 1.8.4
                                             */
                                            getRightLegRotation(): JavaArray<number>;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class ItemFrameEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.decoration.ItemFrameEntity */ any> {
                                            static readonly class: JavaClass<ItemFrameEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.decoration.ItemFrameEntity */ any);

                                            /**
                                             * @return `true` if the item frame is glowing, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isGlowingFrame(): boolean;

                                            /**
                                             * @return the rotation of the item inside this frame.
                                             * @since 1.8.4
                                             */
                                            getRotation(): number;

                                            /**
                                             * @return the item inside this item frame.
                                             * @since 1.8.4
                                             */
                                            getItem(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class PaintingEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.decoration.painting.PaintingEntity */ any> {
                                            static readonly class: JavaClass<PaintingEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.decoration.painting.PaintingEntity */ any);

                                            /**
                                             * @return the width of this painting.
                                             * @since 1.8.4
                                             */
                                            getWidth(): number;

                                            /**
                                             * @return the height of this painting.
                                             * @since 1.8.4
                                             */
                                            getHeight(): number;

                                            /**
                                             * @return the identifier of this painting's art.
                                             * @since 1.8.4
                                             */
                                            getIdentifier(): PaintingId;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class EndCrystalEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.decoration.EndCrystalEntity */ any> {
                                            static readonly class: JavaClass<EndCrystalEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.decoration.EndCrystalEntity */ any);

                                            /**
                                             * Naturally generated end crystals will have a bedrock base, while player placed ones will
                                             *  not.
                                             * @return `true` if the end crystal was not placed by a player, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isNatural(): boolean;

                                            /**
                                             * @return the target of the crystal's beam, or `null` if there is none.
                                             * @since 1.8.4
                                             */
                                            getBeamTarget(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper | null;

                                        }

                                        export {
                                            ArmorStandEntityHelper,
                                            ItemFrameEntityHelper,
                                            PaintingEntityHelper,
                                            EndCrystalEntityHelper
                                        }

                                    }

                                    namespace mob {


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class ShulkerEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.ShulkerEntity */ any> {
                                            static readonly class: JavaClass<ShulkerEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.ShulkerEntity */ any);

                                            isClosed(): boolean;
                                            getAttachedSide(): xyz.wagyourtail.jsmacros.client.api.helpers.world.DirectionHelper;
                                            getColor(): xyz.wagyourtail.jsmacros.client.api.helpers.DyeColorHelper | null;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class PhantomEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.PhantomEntity */ any> {
                                            static readonly class: JavaClass<PhantomEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.PhantomEntity */ any);

                                            /**
                                             * @return the size of this phantom.
                                             * @since 1.8.4
                                             */
                                            getSize(): number;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class ZombieVillagerEntityHelper extends ZombieEntityHelper</* net.minecraft.entity.mob.ZombieVillagerEntity */ any> {
                                            static readonly class: JavaClass<ZombieVillagerEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.ZombieVillagerEntity */ any);

                                            /**
                                             * @return `true` if this zombie villager is currently being converted back to a villager,
                                             *  `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isConvertingToVillager(): boolean;

                                            /**
                                             * @return the type of biome the villager belonged to it was converted to a zombie.
                                             * @since 1.8.4
                                             */
                                            getVillagerBiomeType(): string;

                                            /**
                                             * @return the profession of the villager before it was converted to a zombie.
                                             * @since 1.8.4
                                             */
                                            getProfession(): string;

                                            /**
                                             * @return the level of the villager before it was converted to a zombie.
                                             * @since 1.8.4
                                             */
                                            getLevel(): number;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class CreeperEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.CreeperEntity */ any> {
                                            static readonly class: JavaClass<CreeperEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.CreeperEntity */ any);

                                            /**
                                             * @return `true` if the creeper is charged, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isCharged(): boolean;

                                            /**
                                             * @return `true` if the creeper has been ignited, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isIgnited(): boolean;

                                            /**
                                             * A negative value means the creeper is currently defusing, while a positive value means the
                                             *  creeper is currently charging up.
                                             * @return the change in fuse every tick.
                                             * @since 1.8.4
                                             */
                                            getFuseChange(): number;

                                            /**
                                             * @return the time the creeper has been charging up.
                                             * @since 1.8.4
                                             */
                                            getFuseTime(): number;

                                            /**
                                             * @return the maximum time the creeper can be charged for before exploding.
                                             * @since 1.8.4
                                             */
                                            getMaxFuseTime(): number;

                                            /**
                                             * @return the remaining time until the creeper explodes with the current fuse time, or
                                             *  `-1` if the creeper is not about to explode.
                                             * @since 1.8.4
                                             */
                                            getRemainingFuseTime(): number;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class GuardianEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.GuardianEntity */ any> {
                                            static readonly class: JavaClass<GuardianEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.GuardianEntity */ any);

                                            /**
                                             * @return `true` if this guardian is an elder guardian, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isElder(): boolean;

                                            /**
                                             * @return `true` if this guardian is targeting a mob, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasTarget(): boolean;

                                            /**
                                             * @return the target of this guardian's beam, or `null` if it has no target.
                                             * @since 1.8.4
                                             */
                                            getTarget(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

                                            /**
                                             * @return `true` if this guardian has its spikes extended, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasSpikesRetracted(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class IllagerEntityHelper<T = /* net.minecraft.entity.mob.IllagerEntity */ any> extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper<T> {
                                            static readonly class: JavaClass<IllagerEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.mob.IllagerEntity */ any>(base: T);

                                            isCelebrating(): boolean;
                                            getState(): string;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class EndermanEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.EndermanEntity */ any> {
                                            static readonly class: JavaClass<EndermanEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.EndermanEntity */ any);

                                            /**
                                             * @return `true` if this enderman is screaming, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isScreaming(): boolean;

                                            /**
                                             * @return `true` if this enderman was provoked by a player, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isProvoked(): boolean;

                                            /**
                                             * @return `true` if this enderman is holding a block, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isHoldingBlock(): boolean;

                                            /**
                                             * @return the held block of this enderman, or `null` if it is not holding a block.
                                             * @since 1.8.4
                                             */
                                            getHeldBlock(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper | null;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class PillagerEntityHelper extends IllagerEntityHelper</* net.minecraft.entity.mob.PillagerEntity */ any> {
                                            static readonly class: JavaClass<PillagerEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.PillagerEntity */ any);

                                            /**
                                             * @return `true` if this pillager is a captain, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isCaptain(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class AbstractPiglinEntityHelper<T = /* net.minecraft.entity.mob.AbstractPiglinEntity */ any> extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper<T> {
                                            static readonly class: JavaClass<AbstractPiglinEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.mob.AbstractPiglinEntity */ any>(base: T);

                                            /**
                                             * @return `true` if this piglin can be zombified in the current dimension, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            canBeZombified(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class WardenEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.WardenEntity */ any> {
                                            static readonly class: JavaClass<WardenEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.WardenEntity */ any);

                                            /**
                                             * @return this warden's anger towards its active target.
                                             * @since 1.8.4
                                             */
                                            getAnger(): number;

                                            /**
                                             * @return `true` if this warden is digging into the ground, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isDigging(): boolean;

                                            /**
                                             * @return `true` if this warden is emerging from the ground, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isEmerging(): boolean;

                                            /**
                                             * @return `true` if this warden is roaring, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isRoaring(): boolean;

                                            /**
                                             * @return `true` if this warden is sniffing, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSniffing(): boolean;

                                            /**
                                             * @return `true` if this warden is charging its sonic boom attack, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isChargingSonicBoom(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class DrownedEntityHelper extends ZombieEntityHelper</* net.minecraft.entity.mob.DrownedEntity */ any> {
                                            static readonly class: JavaClass<DrownedEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.DrownedEntity */ any);

                                            /**
                                             * @return `true` if this drowned is holding a trident, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasTrident(): boolean;

                                            /**
                                             * @return `true` if this drowned is holding a nautilus shell, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasNautilusShell(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class BlazeEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.BlazeEntity */ any> {
                                            static readonly class: JavaClass<BlazeEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.BlazeEntity */ any);

                                            /**
                                             * A blaze can only shoot fireballs when it's on fire.
                                             * @return `true` if the blaze is on fire, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isOnFire(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class VexEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.VexEntity */ any> {
                                            static readonly class: JavaClass<VexEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.VexEntity */ any);

                                            /**
                                             * @return `true` if this vex is currently charging at its target, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isCharging(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class VindicatorEntityHelper extends IllagerEntityHelper</* net.minecraft.entity.mob.VindicatorEntity */ any> {
                                            static readonly class: JavaClass<VindicatorEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.VindicatorEntity */ any);

                                            /**
                                             * @return `true` if this vindicator is johnny, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isJohnny(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class SpellcastingIllagerEntityHelper<T = /* net.minecraft.entity.mob.SpellcastingIllagerEntity */ any> extends IllagerEntityHelper<T> {
                                            static readonly class: JavaClass<SpellcastingIllagerEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.mob.SpellcastingIllagerEntity */ any>(base: T);

                                            /**
                                             * @return `true` if this spell caster is currently casting a spell, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isCastingSpell(): boolean;

                                            /**
                                             * @return the spell this spell caster is currently casting.
                                             * @since 1.8.4
                                             */
                                            getCastedSpell(): IllagerSpell;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class SlimeEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.SlimeEntity */ any> {
                                            static readonly class: JavaClass<SlimeEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.SlimeEntity */ any);

                                            /**
                                             * @return the size of this slime.
                                             * @since 1.8.4
                                             */
                                            getSize(): number;

                                            /**
                                             * Small slimes, with a size less than 1, don't attack the player.
                                             * @return `true` if this slime is small, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSmall(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class PiglinEntityHelper extends AbstractPiglinEntityHelper</* net.minecraft.entity.mob.PiglinEntity */ any> {
                                            static readonly class: JavaClass<PiglinEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.PiglinEntity */ any);

                                            /**
                                             * @return `true` if this piglin is doing nothing special, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isWandering(): boolean;

                                            /**
                                             * @return `true` if this piglin is dancing to music, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isDancing(): boolean;

                                            /**
                                             * @return `true` if this piglin is admiring an item, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isAdmiring(): boolean;

                                            /**
                                             * @return `true` if this piglin is attacking another entity, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isMeleeAttacking(): boolean;

                                            /**
                                             * @return `true` if this piglin is currently charging its crossbow, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isChargingCrossbow(): boolean;

                                            /**
                                             * @return `true` if this piglin has its crossbow fully charged, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasCrossbowReady(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class ZombieEntityHelper<T = /* net.minecraft.entity.mob.ZombieEntity */ any> extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper<T> {
                                            static readonly class: JavaClass<ZombieEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.mob.ZombieEntity */ any>(base: T);

                                            /**
                                             * @return `true` if this zombie is converting to a drowned, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isConvertingToDrowned(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class SpiderEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.SpiderEntity */ any> {
                                            static readonly class: JavaClass<SpiderEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.SpiderEntity */ any);

                                            /**
                                             * @return `true` if this spider is currently climbing a wall, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isClimbing(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class GhastEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.GhastEntity */ any> {
                                            static readonly class: JavaClass<GhastEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.GhastEntity */ any);

                                            /**
                                             * @return `true` if this ghast is currently about to shoot a fireball, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isShooting(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class WitchEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.mob.WitchEntity */ any> {
                                            static readonly class: JavaClass<WitchEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.mob.WitchEntity */ any);

                                            /**
                                             * @return `true` if this witch is drinking a potion, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isDrinkingPotion(): boolean;

                                            /**
                                             * @return the held potion item.
                                             * @since 1.8.4
                                             */
                                            getPotion(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                        }

                                        export {
                                            ShulkerEntityHelper,
                                            PhantomEntityHelper,
                                            ZombieVillagerEntityHelper,
                                            CreeperEntityHelper,
                                            GuardianEntityHelper,
                                            IllagerEntityHelper,
                                            EndermanEntityHelper,
                                            PillagerEntityHelper,
                                            AbstractPiglinEntityHelper,
                                            WardenEntityHelper,
                                            DrownedEntityHelper,
                                            BlazeEntityHelper,
                                            VexEntityHelper,
                                            VindicatorEntityHelper,
                                            SpellcastingIllagerEntityHelper,
                                            SlimeEntityHelper,
                                            PiglinEntityHelper,
                                            ZombieEntityHelper,
                                            SpiderEntityHelper,
                                            GhastEntityHelper,
                                            WitchEntityHelper
                                        }

                                    }

                                    namespace other {


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class TntEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.TntEntity */ any> {
                                            static readonly class: JavaClass<TntEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.TntEntity */ any);

                                            /**
                                             * @return the remaining time until this TNT explodes.
                                             * @since 1.8.4
                                             */
                                            getRemainingTime(): number;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class AreaEffectCloudEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.AreaEffectCloudEntity */ any> {
                                            static readonly class: JavaClass<AreaEffectCloudEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (e: /* net.minecraft.entity.AreaEffectCloudEntity */ any);

                                            /**
                                             * @return the radius of this cloud.
                                             * @since 1.8.4
                                             */
                                            getRadius(): number;

                                            /**
                                             * @return the color of this cloud.
                                             * @since 1.8.4
                                             */
                                            getColor(): number;

                                            /**
                                             * @return the id of this cloud's particles.
                                             * @since 1.8.4
                                             */
                                            getParticleType(): ParticleId;
                                            /** @since 1.8.4 */
                                            isWaiting(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class FallingBlockEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.FallingBlockEntity */ any> {
                                            static readonly class: JavaClass<FallingBlockEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.FallingBlockEntity */ any);

                                            /**
                                             * @return the block position this block is falling from.
                                             * @since 1.8.4
                                             */
                                            getOriginBlockPos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

                                            /**
                                             * @return the block state of this falling block.
                                             * @since 1.8.4
                                             */
                                            getBlockState(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper;

                                        }

                                        export {
                                            TntEntityHelper,
                                            AreaEffectCloudEntityHelper,
                                            FallingBlockEntityHelper
                                        }

                                    }

                                    namespace passive {


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class RabbitEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.RabbitEntity */ any> {
                                            static readonly class: JavaClass<RabbitEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.RabbitEntity */ any);

                                            /**
                                             * @return the variant of this rabbit.
                                             * @since 1.8.4
                                             */
                                            getVariant(): RabbitVariant;

                                            /**
                                             * @return `true` if this rabbit is a killer bunny, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isKillerBunny(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class SheepEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.SheepEntity */ any> {
                                            static readonly class: JavaClass<SheepEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.SheepEntity */ any);

                                            /**
                                             * @return `true` if this sheep is sheared, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSheared(): boolean;

                                            /**
                                             * @return `true` if this sheep can be sheared, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isShearable(): boolean;

                                            /**
                                             * @return the color of this sheep.
                                             * @since 1.8.4
                                             */
                                            getColor(): xyz.wagyourtail.jsmacros.client.api.helpers.DyeColorHelper;

                                            /**
                                             * Sheep named `jeb_` will cycle through all colors when rendered. If sheared, they will
                                             *  drop their original colored wool.
                                             * @return `true` if the sheep has a rainbow overlay, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isJeb(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class StriderEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.StriderEntity */ any> {
                                            static readonly class: JavaClass<StriderEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.StriderEntity */ any);

                                            /**
                                             * @return `true` if this strider is saddled, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSaddled(): boolean;

                                            /**
                                             * @return `true` if this strider is shivering in the cold, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isShivering(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class PigEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.PigEntity */ any> {
                                            static readonly class: JavaClass<PigEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.PigEntity */ any);

                                            /**
                                             * @return `true` if this pig is saddled, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSaddled(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class LlamaEntityHelper<T = /* net.minecraft.entity.passive.LlamaEntity */ any> extends DonkeyEntityHelper<T> {
                                            static readonly class: JavaClass<LlamaEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.passive.LlamaEntity */ any>(base: T);

                                            /**
                                             * @return the variant of this llama.
                                             * @since 1.8.4
                                             */
                                            getVariant(): LlamaVariant;

                                            /**
                                             * @return the color of this llama's carpet.
                                             * @since 1.8.4
                                             */
                                            getCarpetColor(): xyz.wagyourtail.jsmacros.client.api.helpers.DyeColorHelper;

                                            /**
                                             * @return the strength of this llama.
                                             * @since 1.8.4
                                             */
                                            getStrength(): number;

                                            /**
                                             * @return `true` if this llama belongs to a wandering trader, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isTraderLlama(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class HorseEntityHelper extends AbstractHorseEntityHelper</* net.minecraft.entity.passive.HorseEntity */ any> {
                                            static readonly class: JavaClass<HorseEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.HorseEntity */ any);

                                            /**
                                             * @return the variant of this horse.
                                             * @since 1.8.4
                                             */
                                            getVariant(): number;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class WolfEntityHelper extends TameableEntityHelper</* net.minecraft.entity.passive.WolfEntity */ any> {
                                            static readonly class: JavaClass<WolfEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.WolfEntity */ any);

                                            /**
                                             * @return `true` if this wolf is tamed and the player has either a bone or meat in one of
                                             *  their hands, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isBegging(): boolean;

                                            /**
                                             * @return the color of this wolf's collar.
                                             * @since 1.8.4
                                             */
                                            getCollarColor(): xyz.wagyourtail.jsmacros.client.api.helpers.DyeColorHelper;

                                            /**
                                             * @return `true` if this wolf is angry, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isAngry(): boolean;

                                            /**
                                             * @return `true` if this wolf is wet, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isWet(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class TameableEntityHelper<T = /* net.minecraft.entity.passive.TameableEntity */ any> extends AnimalEntityHelper<T> {
                                            static readonly class: JavaClass<TameableEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.passive.TameableEntity */ any>(base: T);

                                            /**
                                             * @return `true` if the entity is tamed, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isTamed(): boolean;

                                            /**
                                             * @return `true` if the entity is sitting, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSitting(): boolean;

                                            /**
                                             * @return the owner's uuid, or `null` if the entity is not tamed.
                                             * @since 1.8.4
                                             */
                                            getOwner(): string | null;

                                            /**
                                             * @param owner the possible owner
                                             * @return `true` if the entity is tamed by the given owner, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isOwner(owner: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.LivingEntityHelper<any>): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class BeeEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.BeeEntity */ any> {
                                            static readonly class: JavaClass<BeeEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.BeeEntity */ any);

                                            /**
                                             * @return `true` if the bee has nectar, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasNectar(): boolean;

                                            /**
                                             * @return `true` if the bee is angry at a player, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isAngry(): boolean;

                                            /**
                                             * @return `true` if the bee has already stung a player, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasStung(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class FrogEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.FrogEntity */ any> {
                                            static readonly class: JavaClass<FrogEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.FrogEntity */ any);

                                            /**
                                             * @return the variant of this frog.
                                             * @since 1.8.4
                                             */
                                            getVariant(): FrogVariant;

                                            /**
                                             * @return the target of this frog, or `null` if it has none.
                                             * @since 1.8.4
                                             */
                                            getTarget(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

                                            /**
                                             * @return `true` if this frog is croaking, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isCroaking(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class TropicalFishEntityHelper extends FishEntityHelper</* net.minecraft.entity.passive.TropicalFishEntity */ any> {
                                            static readonly class: JavaClass<TropicalFishEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.TropicalFishEntity */ any);

                                            /**
                                             * @return the variant of this tropical fish.
                                             * @since 1.8.4
                                             */
                                            getVariant(): TropicalVariant;

                                            /**
                                             * @return the size of this tropical fish's variant.
                                             * @since 1.8.4
                                             */
                                            getSize(): TropicalSize;

                                            /**
                                             * @return the base color of this tropical fish's pattern.
                                             * @since 1.8.4
                                             */
                                            getBaseColor(): number;

                                            /**
                                             * @return the pattern color of this tropical fish's pattern.
                                             * @since 1.8.4
                                             */
                                            getPatternColor(): number;

                                            /**
                                             * @return the id of this tropical fish's variant.
                                             * @since 1.8.4
                                             */
                                            getVarietyId(): number;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class AllayEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.passive.AllayEntity */ any> {
                                            static readonly class: JavaClass<AllayEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.AllayEntity */ any);

                                            /**
                                             * @return `true` if this allay is dancing, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isDancing(): boolean;

                                            /**
                                             * @return `true` if this allay can be duplicated, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            canDuplicate(): boolean;

                                            /**
                                             * @return `true` if this allay is holding a item, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isHoldingItem(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class PufferfishEntityHelper extends FishEntityHelper</* net.minecraft.entity.passive.PufferfishEntity */ any> {
                                            static readonly class: JavaClass<PufferfishEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.PufferfishEntity */ any);

                                            /**
                                             * A state of 0 means the fish is deflated, a state of 1 means the fish is inflated and a state
                                             *  of 2 means the fish is fully inflated.
                                             * @return the puff state of this pufferfish.
                                             * @since 1.8.4
                                             */
                                            getSize(): number;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class AnimalEntityHelper<T = /* net.minecraft.entity.passive.AnimalEntity */ any> extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper<T> {
                                            static readonly class: JavaClass<AnimalEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.passive.AnimalEntity */ any>(base: T);

                                            /**
                                             * @param item the item to check
                                             * @return `true` if the item can be used to feed and breed this animal, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isFood(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemHelper): boolean;

                                            /**
                                             * @param item the item to check
                                             * @return `true` if the item can be used to feed and breed this animal, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isFood(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): boolean;

                                            /**
                                             * @param other the other animal to check
                                             * @return `true` if this animal can be bred with the other animal, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            canBreedWith(other: AnimalEntityHelper<any>): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class FishEntityHelper<T = /* net.minecraft.entity.passive.FishEntity */ any> extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper<T> {
                                            static readonly class: JavaClass<FishEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.passive.FishEntity */ any>(base: T);

                                            /**
                                             * @return `true` if this fish came from a bucket, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isFromBucket(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class FoxEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.FoxEntity */ any> {
                                            static readonly class: JavaClass<FoxEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.FoxEntity */ any);

                                            /**
                                             * @return the item in this fox's mouth.
                                             * @since 1.8.4
                                             */
                                            getItemInMouth(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                            /**
                                             * @return `true` if this fox is a snow fox, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSnowFox(): boolean;

                                            /**
                                             * @return `true` if this fox is a red fox, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isRedFox(): boolean;

                                            /**
                                             * @return the owner's UUID, or `null` if this fox has no owner.
                                             * @since 1.8.4
                                             */
                                            getOwner(): string | null;

                                            /**
                                             * @return the second owner's name, or `null` if this fox has no owner.
                                             * @since 1.8.4
                                             */
                                            getSecondOwner(): string | null;

                                            /**
                                             * @param entity the entity to check
                                             * @return `true` if this fox trusts the given entity, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            canTrust(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>): boolean;

                                            /**
                                             * @return `true` if this fox is preparing its jump, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasFoundTarget(): boolean;

                                            /**
                                             * @return `true` if this fox is sitting, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSitting(): boolean;

                                            /**
                                             * @return `true` if this fox is wandering around, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isWandering(): boolean;

                                            /**
                                             * @return `true` if this fox is sleeping, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSleeping(): boolean;

                                            /**
                                             * @return `true` if this fox is defending another fox, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isDefending(): boolean;

                                            /**
                                             * @return `true` if this fox is just before its leap, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isPouncing(): boolean;

                                            /**
                                             * @return `true` if this fox is jumping, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isJumping(): boolean;

                                            /**
                                             * @return `true` if this fox is sneaking in preparation of an attack, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isSneaking(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class DolphinEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.passive.DolphinEntity */ any> {
                                            static readonly class: JavaClass<DolphinEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.DolphinEntity */ any);

                                            /**
                                             * @return `true` if the dolphin has a fish in its mouth, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasFish(): boolean;

                                            /**
                                             * The position will be 0 0 0 by default.
                                             * @return the position of the treasure the dolphin is looking for.
                                             * @since 1.8.4
                                             */
                                            getTreasurePos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

                                            /**
                                             * @return the moisture level of the dolphin.
                                             * @since 1.8.4
                                             */
                                            getMoistness(): number;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class DonkeyEntityHelper<T = /* net.minecraft.entity.passive.AbstractDonkeyEntity */ any> extends AbstractHorseEntityHelper<T> {
                                            static readonly class: JavaClass<DonkeyEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.passive.AbstractDonkeyEntity */ any>(base: T);

                                            /**
                                             * @return `true` if the donkey is carrying a chest, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasChest(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class ParrotEntityHelper extends TameableEntityHelper</* net.minecraft.entity.passive.ParrotEntity */ any> {
                                            static readonly class: JavaClass<ParrotEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.ParrotEntity */ any);

                                            /**
                                             * @return the variant of this parrot.
                                             * @since 1.8.4
                                             */
                                            getVariant(): ParrotVariant;

                                            /**
                                             * @return `true` if this parrot is sitting, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSitting(): boolean;

                                            /**
                                             * @return `true` if this parrot is flying, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isFlying(): boolean;

                                            /**
                                             * @return `true` if this parrot is dancing to music, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isPartying(): boolean;

                                            /**
                                             * @return `true` if this parrot is just standing around, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isStanding(): boolean;

                                            /**
                                             * @return `true` if this parrot is sitting on any player's shoulder, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isSittingOnShoulder(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class GoatEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.GoatEntity */ any> {
                                            static readonly class: JavaClass<GoatEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.GoatEntity */ any);

                                            /**
                                             * @return `true` if this goat is currently screaming, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isScreaming(): boolean;

                                            /**
                                             * @return `true` if this goat has its left horn still left, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasLeftHorn(): boolean;

                                            /**
                                             * @return `true` if this goat has its right horn still left, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasRightHorn(): boolean;

                                            /**
                                             * @return `true` if this goat still has a horn, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasHorns(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class AxolotlEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.AxolotlEntity */ any> {
                                            static readonly class: JavaClass<AxolotlEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.AxolotlEntity */ any);

                                            /**
                                             * @return the id of this axolotl's variant.
                                             * @since 1.8.4
                                             */
                                            getVariantId(): number;

                                            /**
                                             * @return the name of this axolotl's variant.
                                             * @since 1.8.4
                                             */
                                            getVariantName(): AxolotlVariant;

                                            /**
                                             * @return `true` if the axolotl is playing dead, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isPlayingDead(): boolean;

                                            /**
                                             * @return `true` if the axolotl came from a bucket, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isFromBucket(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class IronGolemEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.passive.IronGolemEntity */ any> {
                                            static readonly class: JavaClass<IronGolemEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.IronGolemEntity */ any);

                                            /**
                                             * @return `true` if this iron golem was created by a player, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isPlayerCreated(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class PolarBearEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.PolarBearEntity */ any> {
                                            static readonly class: JavaClass<PolarBearEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.PolarBearEntity */ any);

                                            /**
                                             * @return `true` if the polar bear is standing up to attack, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isAttacking(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class PandaEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.PandaEntity */ any> {
                                            static readonly class: JavaClass<PandaEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.PandaEntity */ any);

                                            /**
                                             * @return the id of this panda's main gene.
                                             * @since 1.8.4
                                             */
                                            getMainGene(): number;

                                            /**
                                             * @return the name of this panda's main gene.
                                             * @since 1.8.4
                                             */
                                            getMainGeneName(): PandaGene;

                                            /**
                                             * @return `true` if this panda's main gene is recessive, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isMainGeneRecessive(): boolean;

                                            /**
                                             * @return the id of this panda's hidden gene.
                                             * @since 1.8.4
                                             */
                                            getHiddenGene(): number;

                                            /**
                                             * @return the name of this panda's hidden gene.
                                             * @since 1.8.4
                                             */
                                            getHiddenGeneName(): PandaGene;

                                            /**
                                             * @return `true` if this panda's hidden gene is recessive, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isHiddenGeneRecessive(): boolean;

                                            /**
                                             * @return `true` if this panda is idling, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isIdle(): boolean;

                                            /**
                                             * @return `true` if this panda is currently sneezing, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSneezing(): boolean;

                                            /**
                                             * @return `true` if this panda is playing, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isPlaying(): boolean;

                                            /**
                                             * @return `true` if this panda is sitting, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSitting(): boolean;

                                            /**
                                             * @return `true` if this panda is lying on its back, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isLyingOnBack(): boolean;

                                            /**
                                             * @return `true` if this panda's genes make him lazy, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isLazy(): boolean;

                                            /**
                                             * @return `true` if this panda's genes make him worried, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isWorried(): boolean;

                                            /**
                                             * @return `true` if this panda is scared by an active thunderstorm, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isScaredByThunderstorm(): boolean;

                                            /**
                                             * @return `true` if this panda's genes make him playful, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isPlayful(): boolean;

                                            /**
                                             * @return `true` if this panda's genes make him brown, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isBrown(): boolean;

                                            /**
                                             * @return `true` if this panda's genes make him weak, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isWeak(): boolean;

                                            /**
                                             * @return `true` if this panda's genes make him aggressive, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isAttacking(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class AbstractHorseEntityHelper<T = /* net.minecraft.entity.passive.AbstractHorseEntity */ any> extends AnimalEntityHelper<T> {
                                            static readonly class: JavaClass<AbstractHorseEntityHelper<any>>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor <T extends /* net.minecraft.entity.passive.AbstractHorseEntity */ any>(base: T);

                                            /**
                                             * @return the UUID of this horse's owner, or `null` if it has no owner.
                                             * @since 1.8.4
                                             */
                                            getOwner(): string | null;

                                            /**
                                             * @return `true` if this horse is already tamed, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isTame(): boolean;

                                            /**
                                             * @return `true` if this horse is saddled, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSaddled(): boolean;

                                            /**
                                             * @return `true` if this horse is angry, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isAngry(): boolean;

                                            /**
                                             * @return `true` if this horse was bred and not naturally spawned, `false`
                                             *  otherwise.
                                             * @since 1.8.4
                                             */
                                            isBred(): boolean;

                                            /**
                                             * @return `true` if this horse is currently eating, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isEating(): boolean;

                                            /**
                                             * @return `true` if this horse can wear armor, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            canWearArmor(): boolean;

                                            /**
                                             * @return `true` if this horse can be saddled, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            canBeSaddled(): boolean;

                                            /**
                                             * @return this horse's inventory size.
                                             * @since 1.8.4
                                             */
                                            getInventorySize(): number;

                                            /**
                                             * @return this horse's jump strength.
                                             * @since 1.8.4
                                             */
                                            getJumpStrengthStat(): number;

                                            /**
                                             * The result of this method is only an approximation, but it's really close.
                                             * @return this horse's maximum jump height for its current jump strength.
                                             * @since 1.8.4
                                             */
                                            getHorseJumpHeight(): number;

                                            /**
                                             * @return the maximum possible value of a horse's jump strength.
                                             * @since 1.8.4
                                             */
                                            getMaxJumpStrengthStat(): number;

                                            /**
                                             * @return the minimum possible value of a horse's jump strength.
                                             * @since 1.8.4
                                             */
                                            getMinJumpStrengthStat(): number;

                                            /**
                                             * @return this horse's speed stat.
                                             * @since 1.8.4
                                             */
                                            getSpeedStat(): number;

                                            /**
                                             * @return this horse's speed in blocks per second.
                                             * @since 1.8.4
                                             */
                                            getHorseSpeed(): number;

                                            /**
                                             * @return the maximum possible value of a horse's speed stat.
                                             * @since 1.8.4
                                             */
                                            getMaxSpeedStat(): number;

                                            /**
                                             * @return the minimum possible value of a horse's speed stat.
                                             * @since 1.8.4
                                             */
                                            getMinSpeedStat(): number;

                                            /**
                                             * The returned value is equal to {@link getMaxHealth}().
                                             * @return this horse's health stat.
                                             * @since 1.8.4
                                             */
                                            getHealthStat(): number;

                                            /**
                                             * @return the maximum possible value of a horse's health stat.
                                             * @since 1.8.4
                                             */
                                            getMaxHealthStat(): number;

                                            /**
                                             * @return the minimum possible value of a horse's health stat.
                                             * @since 1.8.4
                                             */
                                            getMinHealthStat(): number;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class OcelotEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.OcelotEntity */ any> {
                                            static readonly class: JavaClass<OcelotEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.OcelotEntity */ any);

                                            /**
                                             * Ocelots trust players after being fed with cod or salmon.
                                             * @return `true` if this ocelot is trusting player and not running away form them,
                                             *  `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isTrusting(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class MooshroomEntityHelper extends AnimalEntityHelper</* net.minecraft.entity.passive.MooshroomEntity */ any> {
                                            static readonly class: JavaClass<MooshroomEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.MooshroomEntity */ any);

                                            /**
                                             * @return `true` if this mooshroom can be sheared, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isShearable(): boolean;

                                            /**
                                             * @return `true` if this mooshroom is a red mooshroom, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isRed(): boolean;

                                            /**
                                             * @return `true` if this mooshroom is a brown mooshroom, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isBrown(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class SnowGolemEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.passive.SnowGolemEntity */ any> {
                                            static readonly class: JavaClass<SnowGolemEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.SnowGolemEntity */ any);

                                            /**
                                             * @return `true` if the snow golem has a pumpkin on its head, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasPumpkin(): boolean;

                                            /**
                                             * @return `true` if this snow golem can be sheared, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isShearable(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class BatEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper</* net.minecraft.entity.passive.BatEntity */ any> {
                                            static readonly class: JavaClass<BatEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.BatEntity */ any);

                                            /**
                                             * @return `true` if the bat is hanging upside down, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isResting(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class CatEntityHelper extends TameableEntityHelper</* net.minecraft.entity.passive.CatEntity */ any> {
                                            static readonly class: JavaClass<CatEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.passive.CatEntity */ any);

                                            /**
                                             * @return `true` if this cat is sleeping, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isSleeping(): boolean;

                                            /**
                                             * @return the color of this cat's collar.
                                             * @since 1.8.4
                                             */
                                            getCollarColor(): xyz.wagyourtail.jsmacros.client.api.helpers.DyeColorHelper;

                                            /**
                                             * @return the variant of this cat.
                                             * @since 1.8.4
                                             */
                                            getVariant(): string;

                                        }

                                        export {
                                            RabbitEntityHelper,
                                            SheepEntityHelper,
                                            StriderEntityHelper,
                                            PigEntityHelper,
                                            LlamaEntityHelper,
                                            HorseEntityHelper,
                                            WolfEntityHelper,
                                            TameableEntityHelper,
                                            BeeEntityHelper,
                                            FrogEntityHelper,
                                            TropicalFishEntityHelper,
                                            AllayEntityHelper,
                                            PufferfishEntityHelper,
                                            AnimalEntityHelper,
                                            FishEntityHelper,
                                            FoxEntityHelper,
                                            DolphinEntityHelper,
                                            DonkeyEntityHelper,
                                            ParrotEntityHelper,
                                            GoatEntityHelper,
                                            AxolotlEntityHelper,
                                            IronGolemEntityHelper,
                                            PolarBearEntityHelper,
                                            PandaEntityHelper,
                                            AbstractHorseEntityHelper,
                                            OcelotEntityHelper,
                                            MooshroomEntityHelper,
                                            SnowGolemEntityHelper,
                                            BatEntityHelper,
                                            CatEntityHelper
                                        }

                                    }

                                    namespace projectile {


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class FishingBobberEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.projectile.FishingBobberEntity */ any> {
                                            static readonly class: JavaClass<FishingBobberEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.projectile.FishingBobberEntity */ any);

                                            /**
                                             * @return `true` if a fish has been caught, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasCaughtFish(): boolean;

                                            /**
                                             * When in open water the player can get treasures from fishing.
                                             * @return `true` if the bobber is in open water, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isInOpenWater(): boolean;

                                            /**
                                             * @return `true` if the bobber has an entity hooked, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasEntityHooked(): boolean;

                                            /**
                                             * @return the hooked entity, or `null` if there is no entity hooked.
                                             * @since 1.8.4
                                             */
                                            getHookedEntity(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any> | null;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class TridentEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.projectile.TridentEntity */ any> {
                                            static readonly class: JavaClass<TridentEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.projectile.TridentEntity */ any);

                                            /**
                                             * @return `true` if the trident is enchanted with loyalty, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            hasLoyalty(): boolean;

                                            /**
                                             * @return `true` if the trident is enchanted, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isEnchanted(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class ArrowEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.projectile.PersistentProjectileEntity */ any> {
                                            static readonly class: JavaClass<ArrowEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.projectile.PersistentProjectileEntity */ any);

                                            /**
                                             * @return the particle's color of the arrow, or `-1` if the arrow has no particles.
                                             * @since 1.8.4
                                             */
                                            getColor(): number;

                                            /**
                                             * @return `true` if the arrow will deal critical damage, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isCritical(): boolean;

                                            /**
                                             * The piercing level will only be set if the arrow was fired from a crossbow with the piercing
                                             *  enchantment.
                                             * @return the piercing level of the arrow.
                                             * @since 1.8.4
                                             */
                                            getPiercingLevel(): number;

                                            /**
                                             * @return `true` if the arrow is shot from a crossbow, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isShotFromCrossbow(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class WitherSkullEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.projectile.WitherSkullEntity */ any> {
                                            static readonly class: JavaClass<WitherSkullEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.projectile.WitherSkullEntity */ any);

                                            /**
                                             * @return `true` if the wither skull is charged, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isCharged(): boolean;

                                        }

                                        export {
                                            FishingBobberEntityHelper,
                                            TridentEntityHelper,
                                            ArrowEntityHelper,
                                            WitherSkullEntityHelper
                                        }

                                    }

                                    namespace vehicle {


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class FurnaceMinecartEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.vehicle.FurnaceMinecartEntity */ any> {
                                            static readonly class: JavaClass<FurnaceMinecartEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.vehicle.FurnaceMinecartEntity */ any);

                                            /**
                                             * @return `` true if the furnace minecart is powered, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isPowered(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class BoatEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.vehicle.BoatEntity */ any> {
                                            static readonly class: JavaClass<BoatEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.vehicle.BoatEntity */ any);

                                            /**
                                             * @return `true` if the boat is a chest boat, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isChestBoat(): boolean;

                                            /**
                                             * @return the boat's plank type.
                                             * @since 1.8.4
                                             */
                                            getBoatBlockType(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper;

                                            /**
                                             * @return the name of the boat's material.
                                             * @since 1.8.4
                                             */
                                            getBoatType(): BoatType;

                                            /**
                                             * @return `true` if the boat is on top of water, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isInWater(): boolean;

                                            /**
                                             * @return `true` if the boat is on land, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isOnLand(): boolean;

                                            /**
                                             * @return `true` if the boat is underwater, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isUnderwater(): boolean;

                                            /**
                                             * @return `true` if the boat is in the air, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isInAir(): boolean;

                                        }


                                        /**
                                         * @author Etheradon
                                         * @since 1.8.4
                                         */
                                        class TntMinecartEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* net.minecraft.entity.vehicle.TntMinecartEntity */ any> {
                                            static readonly class: JavaClass<TntMinecartEntityHelper>;
                                            /** @deprecated */ static prototype: undefined;

                                            constructor (base: /* net.minecraft.entity.vehicle.TntMinecartEntity */ any);

                                            /**
                                             * @return the remaining time in ticks before the tnt explodes, or `-1` if the tnt is not
                                             *  primed.
                                             * @since 1.8.4
                                             */
                                            getRemainingTime(): number;

                                            /**
                                             * @return `true` if the tnt is primed, `false` otherwise.
                                             * @since 1.8.4
                                             */
                                            isPrimed(): boolean;

                                        }

                                        export {
                                            FurnaceMinecartEntityHelper,
                                            BoatEntityHelper,
                                            TntMinecartEntityHelper
                                        }

                                    }

                                }

                            }

                        }

                    }

                }

                namespace gui {

                    namespace editor {

                        class SelectCursor extends java.lang.Object {
                            static readonly class: JavaClass<SelectCursor>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (defaultStyle: /* net.minecraft.text.Style */ any);

                            onChange: MethodWrapper<SelectCursor>;
                            defaultStyle: /* net.minecraft.text.Style */ any;
                            startLine: number;
                            endLine: number;
                            startIndex: number;
                            endIndex: number;
                            startLineIndex: number;
                            endLineIndex: number;
                            dragStartIndex: number;
                            arrowLineIndex: number;
                            arrowEnd: boolean;
                            startCol: number;
                            endCol: number;

                            updateStartIndex(startIndex: int, current: string): void;
                            updateEndIndex(endIndex: int, current: string): void;

                        }

                        class History extends java.lang.Object {
                            static readonly class: JavaClass<History>;
                            /** @deprecated */ static prototype: undefined;

                            constructor (start: string, cursor: SelectCursor);

                            onChange: MethodWrapper<string>;
                            current: string;

                            /**
                             * @return is new step.
                             */
                            addChar(position: int, content: char): boolean;
                            add(position: int, content: string): boolean;

                            /**
                             * @return is new step.
                             */
                            deletePos(position: int, length: int): boolean;

                            /**
                             * @return is new step
                             */
                            bkspacePos(position: int, length: int): boolean;
                            shiftLine(startLine: int, lines: int, shiftDown: boolean): boolean;
                            replace(position: int, length: int, content: string): void;
                            tabLines(startLine: int, lineCount: int, reverse: boolean): void;
                            tabLinesKeepCursor(startLine: int, startLineIndex: int, endLineIndex: int, lineCount: int, reverse: boolean): void;

                            /**
                             * @return position of step. -1 if nothing to undo.
                             */
                            undo(): number;

                            /**
                             * @return position of step. -1 if nothing to redo.
                             */
                            redo(): number;

                        }

                        export { SelectCursor, History }

                    }
                    namespace editor {

                        namespace highlighting {

                            class AbstractRenderCodeCompiler extends java.lang.Object {
                                static readonly class: JavaClass<AbstractRenderCodeCompiler>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (language: string, screen: xyz.wagyourtail.jsmacros.client.gui.screens.EditorScreen);

                                recompileRenderedText(text: string): void;
                                getRightClickOptions(index: int): JavaMap<string, MethodWrapper>;
                                getRenderedText(): JavaArray</* net.minecraft.text.Text */ any>;
                                getSuggestions(): JavaList<AutoCompleteSuggestion>;

                            }

                            class AutoCompleteSuggestion extends java.lang.Object {
                                static readonly class: JavaClass<AutoCompleteSuggestion>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (startIndex: int, suggestion: string);
                                constructor (startIndex: int, suggestion: string, displayText: /* net.minecraft.text.Text */ any);

                                readonly startIndex: number;
                                readonly suggestion: string;
                                readonly displayText: /* net.minecraft.text.Text */ any;
                            }

                            export { AbstractRenderCodeCompiler, AutoCompleteSuggestion }

                        }

                    }

                    namespace screens {

                        class EditorScreen extends xyz.wagyourtail.wagyourgui.BaseScreen {
                            static readonly class: JavaClass<EditorScreen>;
                            /** @deprecated */ static prototype: undefined;

                            static readonly langs: JavaList<string>;
                            static defaultStyle: /* net.minecraft.text.Style */ any;

                            static openAndScrollToIndex(file: java.io.File, startIndex: int, endIndex: int): void;
                            static openAndScrollToLine(file: java.io.File, line: int, col: int, endCol: int): void;

                            constructor (parent: /* net.minecraft.client.gui.screen.Screen */ any, file: java.io.File);

                            readonly history: xyz.wagyourtail.jsmacros.client.gui.editor.History;
                            readonly cursor: xyz.wagyourtail.jsmacros.client.gui.editor.SelectCursor;
                            blockFirst: boolean;
                            textRenderTime: number;
                            prevChar: number;
                            language: string;
                            codeCompiler: xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AbstractRenderCodeCompiler;

                            getDefaultLanguage(): string;
                            setScroll(pages: double): void;
                            setLanguage(language: string): void;
                            copyToClipboard(): void;
                            pasteFromClipboard(): void;
                            cutToClipboard(): void;
                            scrollToCursor(): void;
                            save(): void;
                            needSave(): boolean;
                            openParent(): void;
                            selectWordAtCursor(): void;
                            updateSettings(): void;

                        }

                        export { EditorScreen }

                    }

                }

            }

            namespace core {


                /**
                 * Wraps most of the important functional interfaces.
                 * @author Wagyourtail
                 * @see IFWrapper
                 */
                interface MethodWrapper<T, U, R, C extends xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>> extends java.util.function.Function<T, R>, java.util.function.Supplier<R>, java.util.function.Consumer<T>, java.util.function.Predicate<T>, java.util.function.BiPredicate<T, U>, java.util.function.BiFunction<T, U, R>, java.util.function.BiConsumer<T, U>, java.lang.Runnable, java.util.Comparator<T> {}
                class MethodWrapper<T, U, R, C extends xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>> extends java.lang.Object {
                    static readonly class: JavaClass<MethodWrapper<any, any, any, any>>;
                    /** @deprecated */ static prototype: undefined;

                    constructor <T, U, R, C extends xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>>(containingContext: C);

                    getCtx(): C;
                    accept(t: T): void;
                    accept(t: T, u: U): void;
                    apply(t: T): R;
                    apply(t: T, u: U): R;
                    test(t: T): boolean;
                    test(t: T, u: U): boolean;

                    /**
                     * override to return true if the method can't join to the context it was wrapped/created in, ie for languages that don't allow multithreading.
                     */
                    preventSameScriptJoin(): boolean;

                    /**
                     * make return something to override the thread set in {@link JsMacros.on}(String, MethodWrapper)
                     *  (hi jep)
                     */
                    overrideThread(): java.lang.Thread;

                    /**
                     * Makes {@link Function} and {@link BiFunction} work together.  
                     *  Extended so it's called on every type not just those 2.
                     * @param after put a {@link MethodWrapper} here when using in scripts.
                     */
                    andThen<V>(after: MethodWrapper<R, any, V>): MethodWrapper<T, U, V, C>;
                    andThen(arg0: MethodWrapper<T>): MethodWrapper<T>;
                    andThen(arg0: MethodWrapper<T, U>): MethodWrapper<T, U>;

                    /**
                     * Makes {@link Predicate} and {@link BiPredicate} work together
                     */
                    negate(): MethodWrapper<T, U, R, C>;

                }

                abstract class Core<T extends xyz.wagyourtail.jsmacros.core.config.BaseProfile, U extends xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry> extends java.lang.Object {
                    static readonly class: JavaClass<Core<any, any>>;
                    /** @deprecated */ static prototype: undefined;

                    /**
                     * static reference to instance created by {@link createInstance}(Function, BiFunction, File, File, Logger)
                     */
                    static getInstance(): Core<any, any>;

                    /**
                     * start by running this function, supplying implementations of {@link BaseEventRegistry} and {@link BaseProfile} and a {@link Supplier} for
                     *  creating the config manager with the folder paths it needs.
                     */
                    static createInstance<V extends xyz.wagyourtail.jsmacros.core.config.BaseProfile, R extends xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry>(eventRegistryFunction: MethodWrapper<Core<V, R>, any, R>, profileFunction: MethodWrapper<Core<V, R>, org.slf4j.Logger, V>, configFolder: java.io.File, macroFolder: java.io.File, logger: org.slf4j.Logger): Core<V, R>;

                    readonly libraryRegistry: xyz.wagyourtail.jsmacros.core.library.LibraryRegistry;
                    readonly eventRegistry: xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry;
                    readonly extensions: xyz.wagyourtail.jsmacros.core.extensions.ExtensionLoader;
                    readonly profile: T;
                    readonly config: xyz.wagyourtail.jsmacros.core.config.ConfigManager;
                    readonly services: xyz.wagyourtail.jsmacros.core.service.ServiceManager;
                    readonly threadPool: xyz.wagyourtail.jsmacros.core.threads.JsMacrosThreadPool;

                    deferredInit(): void;
                    addContext(container: xyz.wagyourtail.jsmacros.core.language.EventContainer<any>): void;
                    getContexts(): JavaSet<xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>>;

                    /**
                     * executes an {@link BaseEvent} on a ${@link ScriptTrigger}
                     */
                    exec(macro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger, event: Events.BaseEvent): xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

                    /**
                     * Executes an {@link BaseEvent} on a ${@link ScriptTrigger} with callback.
                     */
                    exec(macro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger, event: Events.BaseEvent, then: MethodWrapper, catcher: MethodWrapper<java.lang.Throwable>): xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;
                    /** @since 1.7.0 */
                    exec(lang: string, script: string, fakeFile: java.io.File, event: Events.BaseEvent, then: MethodWrapper, catcher: MethodWrapper<java.lang.Throwable>): xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

                    /**
                     * wraps an exception for more uniform parsing between languages, also extracts useful info.
                     * @param ex exception to wrap.
                     */
                    wrapException(ex: java.lang.Throwable): xyz.wagyourtail.jsmacros.core.language.BaseWrappedException<any>;

                }

                export { MethodWrapper, Core }

            }
            namespace core {

                namespace classes {


                    /**
                     * @template T the type of the wrapped class
                     * @since 1.6.5
                     */
                    class WrappedClassInstance<T> extends java.lang.Object {
                        static readonly class: JavaClass<WrappedClassInstance<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <T>(instance: T);
                        constructor <T>(instanceNullable: T, tClass: JavaClassArg<T>);

                        getFieldValue(fieldName: string): any;
                        getFieldValueAsClass(asClass: string, fieldName: string): any;
                        setFieldValue(fieldName: string, fieldValue: any): void;
                        setFieldValueAsClass(asClass: string, fieldName: string, fieldValue: any): void;
                        invokeMethod(methodNameOrSig: string, ...params: JavaVarArgs<any>): any;
                        invokeMethodAsClass(asClass: string, methodNameOrSig: string, ...params: JavaVarArgs<any>): any;
                        /** @since 1.6.5 */
                        getRawInstance(): T;
                        /** @since 1.6.5 */
                        getRawClass(): JavaClass<T>;

                    }


                    /**
                     * @author Wagyourtail
                     * @since 1.3.1
                     */
                    class Mappings extends java.lang.Object {
                        static readonly class: JavaClass<Mappings>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (mappingsource: string);

                        readonly mappingsource: string;

                        /**
                         * @return mappings from Intermediary to Named
                         * @throws IOException will throw if malformed url/path
                         * @since 1.3.1
                         */
                        getMappings(): JavaMap<string, Mappings$ClassData>;

                        /**
                         * @return mappings from Named to Intermediary
                         * @throws IOException will throw if malformed url/path
                         * @since 1.3.1
                         */
                        getReversedMappings(): JavaMap<string, Mappings$ClassData>;
                        /** @since 1.6.0 */
                        remapClass<T>(instance: T): Mappings$MappedClass<T>;

                        /**
                         * gets the class without instance, so can only access static methods/fields
                         * @throws IOException
                         * @throws ClassNotFoundException
                         */
                        getClass(className: string): Mappings$MappedClass<any>;
                        getClass(): JavaClass<any>;

                    }

                    /** @since 1.6.0 */
                    class Mappings$MappedClass<T> extends WrappedClassInstance<T> {
                        static readonly class: JavaClass<Mappings$MappedClass<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <T>(instance: T);
                        constructor <T>(instance: T, type: JavaClassArg<T>);

                    }

                    class Mappings$ClassData extends java.lang.Object {
                        static readonly class: JavaClass<Mappings$ClassData>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (name: string);

                        readonly methods: JavaMap<string, Mappings$MethodData>;
                        readonly fields: JavaMap<string, string>;
                        readonly name: string;
                    }

                    class Mappings$MethodData extends java.lang.Object {
                        static readonly class: JavaClass<Mappings$MethodData>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (name: string, sig: MethodWrapper<any, any, string>);

                        readonly name: string;
                        readonly sig: MethodWrapper<any, any, string>;
                    }

                    export {
                        WrappedClassInstance,
                        Mappings,
                        Mappings$MappedClass,
                        Mappings$ClassData,
                        Mappings$MethodData
                    }

                }

                namespace config {


                    /**
                     * @author Wagyourtail
                     * @since 1.2.7
                     */
                    class BaseProfile extends java.lang.Object {
                        static readonly class: JavaClass<BaseProfile>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (runner: xyz.wagyourtail.jsmacros.core.Core, logger: org.slf4j.Logger);

                        readonly LOGGER: org.slf4j.Logger;
                        readonly joinedThreadStack: JavaSet<java.lang.Thread>;
                        readonly events: JavaSet<string>;
                        profileName: string;

                        logError(ex: java.lang.Throwable): void;

                        /**
                         * @since 1.1.2 [citation needed]
                         * @deprecated
                         */
                        getRegistry(): xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry;
                        /** @since 1.6.0 */
                        checkJoinedThreadStack(): boolean;
                        /** @since 1.1.2 [citation needed] */
                        loadOrCreateProfile(profileName: string): void;
                        /** @since 1.0.8 [citation needed] */
                        saveProfile(): void;
                        /** @since 1.2.7 */
                        triggerEvent(event: Events.BaseEvent): void;
                        init(defaultProfile: string): void;
                        getCurrentProfileName(): string;
                        renameCurrentProfile(profile: string): void;

                    }

                    class ScriptTrigger extends java.lang.Object {
                        static readonly class: JavaClass<ScriptTrigger>;
                        /** @deprecated */ static prototype: undefined;

                        static copy(m: ScriptTrigger): ScriptTrigger;

                        constructor (triggerType: ScriptTrigger$TriggerType, event: string, scriptFile: java.io.File, enabled: boolean, joined: boolean);
                        /** @deprecated */
                        constructor (triggerType: ScriptTrigger$TriggerType, event: string, scriptFile: string, enabled: boolean, joined: boolean);

                        triggerType: ScriptTrigger$TriggerType;
                        event: string;
                        scriptFile: string;
                        enabled: boolean;
                        joined: boolean;

                        equals(macro: ScriptTrigger): boolean;
                        equals(arg0: any): boolean;
                        copy(): ScriptTrigger;
                        /** @since 1.2.7 */
                        getTriggerType(): ScriptTrigger$TriggerType;
                        /** @since 1.2.7 */
                        getEvent(): string;
                        /** @since 1.2.7 */
                        getScriptFile(): string;
                        /** @since 1.2.7 */
                        getEnabled(): boolean;

                    }

                    class ConfigManager extends java.lang.Object {
                        static readonly class: JavaClass<ConfigManager>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (configFolder: java.io.File, macroFolder: java.io.File, logger: org.slf4j.Logger);

                        readonly optionClasses: JavaMap<string, JavaClass<any>>;
                        readonly options: JavaMap<JavaClass<any>, any>;
                        readonly configFolder: java.io.File;
                        readonly macroFolder: java.io.File;
                        readonly configFile: java.io.File;
                        readonly LOGGER: org.slf4j.Logger;
                        rawOptions: com.google.gson.JsonObject;

                        reloadRawConfigFromFile(): void;
                        convertConfigFormat(): void;
                        convertConfigFormat(clazz: JavaClassArg<any>): void;
                        getOptions<T>(optionClass: JavaClassArg<T>): T;
                        addOptions(key: string, optionClass: JavaClassArg<any>): void;
                        loadConfig(): void;
                        loadDefaults(): void;
                        saveConfig(): void;

                    }


                    /**
                     * @author Wagyourtail
                     * @since 1.0.0 [citation needed]
                     */
                    abstract class ScriptTrigger$TriggerType extends java.lang.Enum<ScriptTrigger$TriggerType> {
                        static readonly class: JavaClass<ScriptTrigger$TriggerType>;
                        /** @deprecated */ static prototype: undefined;

                        static readonly KEY_FALLING: ScriptTrigger$TriggerType;
                        static readonly KEY_RISING: ScriptTrigger$TriggerType;
                        static readonly KEY_BOTH: ScriptTrigger$TriggerType;
                        static readonly EVENT: ScriptTrigger$TriggerType;

                        static values(): JavaArray<ScriptTrigger$TriggerType>;
                        static valueOf(name: string): ScriptTrigger$TriggerType;

                    }

                    export {
                        BaseProfile,
                        ScriptTrigger,
                        ConfigManager,
                        ScriptTrigger$TriggerType
                    }

                }

                namespace event {

                    abstract class IEventListener extends java.lang.Interface {
                        static readonly class: JavaClass<IEventListener>;
                        /** @deprecated */ static prototype: undefined;

                        static readonly NULL: IEventListener;
                    }
                    interface IEventListener {

                        joined(): boolean;
                        trigger(event: Events.BaseEvent): xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

                        /**
                         * Used for self unregistering events.
                         * @since 1.8.4
                         */
                        off(): void;

                    }


                    /**
                     * @author Wagyourtail
                     * @since 1.2.7
                     */
                    class BaseEventRegistry extends java.lang.Object {
                        static readonly class: JavaClass<BaseEventRegistry>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (runner: xyz.wagyourtail.jsmacros.core.Core);

                        readonly oldEvents: JavaMap<string, string>;
                        readonly events: JavaSet<string>;
                        readonly cancellableEvents: JavaSet<string>;
                        readonly joinableEvents: JavaSet<string>;

                        clearMacros(): void;
                        /** @since 1.1.2 [citation needed] */
                        addScriptTrigger(rawmacro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger): void;
                        /** @since 1.2.3 */
                        addListener(event: string, listener: IEventListener): void;
                        /** @since 1.2.3 */
                        removeListener(event: string, listener: IEventListener): boolean;

                        /**
                         * @since 1.2.3
                         * @deprecated
                         */
                        removeListener(listener: IEventListener): boolean;
                        /** @since 1.1.2 [citation needed] */
                        removeScriptTrigger(rawmacro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger): boolean;
                        /** @since 1.2.3 */
                        getListeners(): JavaMap<string, JavaSet<IEventListener>>;
                        /** @since 1.2.3 */
                        getListeners(key: string): JavaSet<IEventListener>;

                        /**
                         * @see ScriptTrigger
                         * @since 1.1.2 [citation needed]
                         */
                        getScriptTriggers(): JavaList<xyz.wagyourtail.jsmacros.core.config.ScriptTrigger>;
                        /** @since 1.1.2 [citation needed] */
                        addEvent(eventName: string): void;
                        addEvent(eventName: string, joinable: boolean): void;
                        addEvent(eventName: string, joinable: boolean, cancellable: boolean): void;
                        addEvent(clazz: JavaClassArg<Events.BaseEvent>): void;

                    }

                    export { IEventListener, BaseEventRegistry }

                }
                namespace event {

                    namespace impl {


                        /**
                         * Custom Events
                         * @author Wagyourtail
                         * @since 1.2.8
                         */
                        class EventCustom extends Events.BaseEvent {
                            static readonly class: JavaClass<EventCustom>;
                            /** @deprecated */ static prototype: undefined;

                            /**
                             * @param eventName name of the event. please don't use an existing one... your scripts might not like that.
                             */
                            constructor (eventName: string);

                            eventName: string;
                            joinable: boolean;
                            cancelable: boolean;

                            joinable(): boolean;
                            cancellable(): boolean;

                            /**
                             * Triggers the event.  
                             *  Try not to cause infinite looping by triggering the same {@link EventCustom} from its own listeners.
                             * @since 1.2.8
                             */
                            trigger(): void;

                            /**
                             * trigger the event listeners, then run `callback` when they finish.
                             * @param callback used as a {@link Runnable}, so no args, no return value.
                             * @since 1.9.0
                             */
                            triggerAsync(callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): void;

                            /**
                             * Put an Integer into the event.
                             * @since 1.2.8
                             */
                            putInt(name: string, i: int): number;

                            /**
                             * put a String into the event.
                             * @since 1.2.8
                             */
                            putString(name: string, str: string): string;

                            /**
                             * put a Double into the event.
                             * @since 1.2.8
                             */
                            putDouble(name: string, d: double): number;

                            /**
                             * put a Boolean into the event.
                             * @since 1.2.8
                             */
                            putBoolean(name: string, b: boolean): boolean;

                            /**
                             * put anything else into the event.
                             * @since 1.2.8
                             */
                            putObject(name: string, o: any): any;

                            /**
                             * Returns the type of the defined item in the event as a string.
                             * @since 1.2.8
                             */
                            getType(name: string): 'Int' | 'String' | 'Double' | 'Boolean' | 'Object' | null;

                            /**
                             * Gets an Integer from the event.
                             * @since 1.2.8
                             */
                            getInt(name: string): number | null;

                            /**
                             * Gets a String from the event
                             * @since 1.2.8
                             */
                            getString(name: string): string | null;

                            /**
                             * Gets a Double from the event.
                             * @since 1.2.8
                             */
                            getDouble(name: string): number | null;

                            /**
                             * Gets a Boolean from the event.
                             * @since 1.2.8
                             */
                            getBoolean(name: string): boolean | null;

                            /**
                             * Gets an Object from the event.
                             * @since 1.2.8
                             */
                            getObject(name: string): any | null;

                            /**
                             * @return map backing the event
                             * @since 1.6.4
                             */
                            getUnderlyingMap(): JavaMap<string, any>;

                            /**
                             * registers event so you can see it in the gui
                             * @since 1.3.0
                             */
                            registerEvent(): void;

                        }

                        export { EventCustom }

                    }

                }

                namespace extensions {

                    class ExtensionLoader extends java.lang.Object {
                        static readonly class: JavaClass<ExtensionLoader>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (core: xyz.wagyourtail.jsmacros.core.Core<any, any>);

                        isExtensionLoaded(name: string): boolean;
                        notLoaded(): boolean;
                        getHighestPriorityExtension(): Extension;
                        getAllExtensions(): JavaSet<Extension>;
                        getExtensionForFile(file: java.io.File): Extension | null;
                        getExtensionForName(lang: string): Extension;
                        loadExtensions(): void;
                        isGuestObject(obj: any): boolean;

                    }

                    abstract class Extension extends java.lang.Interface {
                        static readonly class: JavaClass<Extension>;
                        /** @deprecated */ static prototype: undefined;

                        static getDependenciesInternal(clazz: JavaClassArg<any>, fname: string): JavaSet<java.net.URL>;
                        static getTranslationsInternal(clazz: JavaClassArg<any>, fname: string): JavaMap<string, string>;

                    }
                    interface Extension {

                        /**
                         * @return the *minimum* version of the jsMacros core that this extension is compatible with.
                         * @since 1.9.0
                         */
                        minCoreVersion(): string;

                        /**
                         * @return the *maximum* version of the jsMacros core that this extension is compatible with.
                         * @since 1.9.0
                         */
                        maxCoreVersion(): string;
                        init(): void;
                        getPriority(): number;
                        getLanguageImplName(): string;
                        extensionMatch(file: java.io.File): Extension$ExtMatch;
                        defaultFileExtension(): string;

                        /**
                         * @return a single static instance of the language definition
                         */
                        getLanguage(runner: xyz.wagyourtail.jsmacros.core.Core<any, any>): xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>;
                        getLibraries(): JavaSet<JavaClass<xyz.wagyourtail.jsmacros.core.library.BaseLibrary>>;
                        getDependencies(): JavaSet<java.net.URL>;
                        wrapException(t: java.lang.Throwable): xyz.wagyourtail.jsmacros.core.language.BaseWrappedException<any>;
                        getTranslations(lang: string): JavaMap<string, string>;
                        isGuestObject(o: any): boolean;

                    }

                    abstract class Extension$ExtMatch extends java.lang.Enum<Extension$ExtMatch> {
                        static readonly class: JavaClass<Extension$ExtMatch>;
                        /** @deprecated */ static prototype: undefined;

                        static readonly NOT_MATCH: Extension$ExtMatch;
                        static readonly MATCH: Extension$ExtMatch;
                        static readonly MATCH_WITH_NAME: Extension$ExtMatch;

                        static values(): JavaArray<Extension$ExtMatch>;
                        static valueOf(name: string): Extension$ExtMatch;

                        isMatch(): boolean;

                    }

                    export { ExtensionLoader, Extension, Extension$ExtMatch }

                }

                namespace helpers {

                    class BaseHelper<T> extends java.lang.Object {
                        static readonly class: JavaClass<BaseHelper<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <T>(base: T);

                        getRaw(): T;

                    }

                    export { BaseHelper }

                }

                namespace language {

                    /** @since 1.4.0 */
                    class BaseScriptContext<T> extends java.lang.Object {
                        static readonly class: JavaClass<BaseScriptContext<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <T>(event: Events.BaseEvent, file: java.io.File);

                        readonly startTime: number;
                        readonly syncObject: java.lang.ref.WeakReference<any>;
                        readonly triggeringEvent: Events.BaseEvent;
                        hasMethodWrapperBeenInvoked: boolean;

                        /**
                         * this object should only be weak referenced unless we want to prevent the context from closing when syncObject is cleared.
                         */
                        getSyncObject(): any;
                        clearSyncObject(): void;
                        /** @since 1.6.0 */
                        getBoundEvents(): JavaMap<java.lang.Thread, EventContainer<BaseScriptContext<T>>>;
                        /** @since 1.6.0 */
                        bindEvent(th: java.lang.Thread, event: EventContainer<BaseScriptContext<T>>): void;
                        /** @since 1.6.0 */
                        releaseBoundEventIfPresent(thread: java.lang.Thread): boolean;
                        getContext(): T;
                        /** @since 1.5.0 */
                        getMainThread(): java.lang.Thread;

                        /**
                         * @return is a newly bound thread
                         * @since 1.6.0
                         */
                        bindThread(t: java.lang.Thread): boolean;
                        /** @since 1.6.0 */
                        unbindThread(t: java.lang.Thread): void;
                        /** @since 1.6.0 */
                        getBoundThreads(): JavaSet<java.lang.Thread>;
                        /** @since 1.5.0 */
                        setMainThread(t: java.lang.Thread): void;
                        /** @since 1.5.0 */
                        getTriggeringEvent(): Events.BaseEvent;
                        setContext(context: T): void;
                        isContextClosed(): boolean;
                        closeContext(): void;
                        /** @since 1.6.0 */
                        getFile(): java.io.File | null;
                        /** @since 1.6.0 */
                        getContainedFolder(): java.io.File;
                        isMultiThreaded(): boolean;
                        wrapSleep(sleep: BaseScriptContext$SleepRunnable): void;

                    }

                    /** @since 1.4.0 */
                    class EventContainer<T extends BaseScriptContext<any>> extends java.lang.Object {
                        static readonly class: JavaClass<EventContainer<any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <T extends BaseScriptContext<any>>(ctx: T);

                        isLocked(): boolean;
                        setLockThread(lockThread: java.lang.Thread): void;
                        getCtx(): T;
                        getLockThread(): java.lang.Thread;

                        /**
                         * careful with this one it can cause deadlocks if used in scripts incorrectly.
                         * @param then must be a {@link MethodWrapper} when called from a script.
                         * @throws InterruptedException
                         * @since 1.4.0
                         */
                        awaitLock(then: MethodWrapper): void;

                        /**
                         * can be released earlier in a script or language impl.
                         * @since 1.4.0
                         */
                        releaseLock(): void;

                    }

                    abstract class BaseScriptContext$SleepRunnable extends java.lang.Interface {
                        static readonly class: JavaClass<BaseScriptContext$SleepRunnable>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface BaseScriptContext$SleepRunnable {

                        run(): void;

                    }


                    /**
                     * Language class for languages to be implemented on top of.
                     * @since 1.1.3
                     */
                    class BaseLanguage<U, T extends BaseScriptContext<U>> extends java.lang.Object {
                        static readonly class: JavaClass<BaseLanguage<any, any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <U, T extends BaseScriptContext<U>>(extension: xyz.wagyourtail.jsmacros.core.extensions.Extension, runner: xyz.wagyourtail.jsmacros.core.Core<any, any>);

                        readonly extension: xyz.wagyourtail.jsmacros.core.extensions.Extension;
                        preThread: MethodWrapper;

                        trigger(macro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger, event: Events.BaseEvent, then: MethodWrapper, catcher: MethodWrapper<java.lang.Throwable>): EventContainer<T>;
                        trigger(lang: string, script: string, fakeFile: java.io.File, event: Events.BaseEvent, then: MethodWrapper, catcher: MethodWrapper<java.lang.Throwable>): EventContainer<T>;
                        retrieveLibs(context: T): JavaMap<string, xyz.wagyourtail.jsmacros.core.library.BaseLibrary>;
                        retrieveOnceLibs(): JavaMap<string, xyz.wagyourtail.jsmacros.core.library.BaseLibrary>;
                        retrievePerExecLibs(context: T): JavaMap<string, xyz.wagyourtail.jsmacros.core.library.BaseLibrary>;
                        createContext(event: Events.BaseEvent, file: java.io.File): T;

                    }

                    class BaseWrappedException<T> extends java.lang.Object {
                        static readonly class: JavaClass<BaseWrappedException<any>>;
                        /** @deprecated */ static prototype: undefined;

                        static wrapHostElement(t: java.lang.StackTraceElement, next: BaseWrappedException<any>): BaseWrappedException<java.lang.StackTraceElement>;

                        constructor <T>(exception: T, message: string, location: BaseWrappedException$SourceLocation, next: BaseWrappedException<any>);

                        readonly stackFrame: T;
                        readonly location: BaseWrappedException$SourceLocation;
                        readonly message: string;
                        readonly next: BaseWrappedException<any>;
                    }

                    class BaseWrappedException$SourceLocation extends java.lang.Object {
                        static readonly class: JavaClass<BaseWrappedException$SourceLocation>;
                        /** @deprecated */ static prototype: undefined;

                        constructor ();

                    }

                    export {
                        BaseScriptContext,
                        EventContainer,
                        BaseScriptContext$SleepRunnable,
                        BaseLanguage,
                        BaseWrappedException,
                        BaseWrappedException$SourceLocation
                    }

                }

                namespace library {

                    class BaseLibrary extends java.lang.Object {
                        static readonly class: JavaClass<BaseLibrary>;
                        /** @deprecated */ static prototype: undefined;

                        constructor ();

                    }

                    class LibraryRegistry extends java.lang.Object {
                        static readonly class: JavaClass<LibraryRegistry>;
                        /** @deprecated */ static prototype: undefined;

                        constructor ();

                        readonly libraries: JavaMap<Library, BaseLibrary>;
                        readonly perExec: JavaMap<Library, JavaClass<PerExecLibrary>>;
                        readonly perLanguage: JavaMap<JavaClass<xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>>, JavaMap<Library, PerLanguageLibrary>>;
                        readonly perExecLanguage: JavaMap<JavaClass<xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>>, JavaMap<Library, JavaClass<PerExecLanguageLibrary<any, any>>>>;

                        getLibraries(language: xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>, context: xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>): JavaMap<string, BaseLibrary>;
                        getOnceLibraries(language: xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>): JavaMap<string, BaseLibrary>;
                        getPerExecLibraries(language: xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>, context: xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>): JavaMap<string, BaseLibrary>;
                        addLibrary(clazz: JavaClassArg<BaseLibrary>): void;

                    }

                    class PerExecLanguageLibrary<U, T extends xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<U>> extends BaseLibrary {
                        static readonly class: JavaClass<PerExecLanguageLibrary<any, any>>;
                        /** @deprecated */ static prototype: undefined;

                        constructor <U, T extends xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<U>>(context: T, language: JavaClassArg<xyz.wagyourtail.jsmacros.core.language.BaseLanguage<U, T>>);

                    }

                    class PerLanguageLibrary extends BaseLibrary {
                        static readonly class: JavaClass<PerLanguageLibrary>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (language: JavaClassArg<xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>>);

                    }

                    class PerExecLibrary extends BaseLibrary {
                        static readonly class: JavaClass<PerExecLibrary>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (context: xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>);

                    }


                    /**
                     * Base Function interface.
                     * @author Wagyourtail
                     */
                    abstract class Library extends java.lang.Interface {
                        static readonly class: JavaClass<Library>;
                        /** @deprecated */ static prototype: undefined;
                    }
                    interface Library extends java.lang.annotation.Annotation {

                        value(): string;
                        languages(): JavaArray<JavaClass<xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>>>;

                    }

                    export {
                        BaseLibrary,
                        LibraryRegistry,
                        PerExecLanguageLibrary,
                        PerLanguageLibrary,
                        PerExecLibrary,
                        Library
                    }

                }
                namespace library {

                    namespace impl {

                        class FJsMacros$EventAndContext<E extends Events.BaseEvent> extends java.lang.Object {
                            static readonly class: JavaClass<FJsMacros$EventAndContext<any>>;
                            /** @deprecated */ static prototype: undefined;

                            constructor <E extends Events.BaseEvent>(event: E, context: xyz.wagyourtail.jsmacros.core.language.EventContainer<any>);

                            readonly event: E;
                            readonly context: xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;
                        }

                        export { FJsMacros$EventAndContext }

                    }
                    namespace impl {

                        namespace classes {


                            /**
                             * @author Wagyourtail, R3alCl0ud
                             */
                            class Websocket extends java.lang.Object {
                                static readonly class: JavaClass<Websocket>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (address: string);
                                constructor (address: java.net.URL);

                                /**
                                 * calls your method as a {@link java.util.function.Consumer}<{@link WebSocket}, {@link List}<{@link String}>>
                                 */
                                onConnect: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, JavaMap<string, JavaList<string>>, any, any> | null;

                                /**
                                 * calls your method as a {@link java.util.function.BiConsumer}<{@link WebSocket}, {@link String}>
                                 */
                                onTextMessage: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, string, any, any> | null;

                                /**
                                 * calls your method as a {@link java.util.function.BiConsumer}<{@link WebSocket}, {@link Disconnected}>
                                 */
                                onDisconnect: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, Websocket$Disconnected, any, any> | null;

                                /**
                                 * calls your method as a {@link java.util.function.BiConsumer}<{@link WebSocket}, {@link WebSocketException}>
                                 */
                                onError: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, com.neovisionaries.ws.client.WebSocketException, any, any> | null;

                                /**
                                 * calls your method as a {@link java.util.function.BiConsumer}<{@link WebSocket}, {@link WebSocketFrame}>
                                 */
                                onFrame: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, com.neovisionaries.ws.client.WebSocketFrame, any, any> | null;

                                /**
                                 * @return self
                                 * @throws WebSocketException
                                 * @since 1.1.9
                                 */
                                connect(): this;
                                /** @since 1.1.9 */
                                getWs(): com.neovisionaries.ws.client.WebSocket;

                                /**
                                 * @return self
                                 * @since 1.1.9
                                 */
                                sendText(text: string): this;

                                /**
                                 * @return self
                                 * @since 1.1.9
                                 */
                                close(): this;

                                /**
                                 * @return self
                                 * @since 1.1.9
                                 */
                                close(closeCode: int): this;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.6.5
                             */
                            class LibraryBuilder extends ClassBuilder<xyz.wagyourtail.jsmacros.core.library.BaseLibrary> {
                                static readonly class: JavaClass<LibraryBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (name: string, perExec: boolean, ...allowedLangs: JavaVarArgs<string>);

                                /**
                                 * constructor, if perExec run every context, if per language run once for each lang;  
                                 *  params are context and language class.  
                                 *  if not per exec, param will be skipped.  
                                 *  ie:  
                                 *  BaseLibrary: no params
                                 *  PerExecLibrary: context
                                 *  PerExecLanguageLibrary: context, language
                                 *  PerLanguageLibrary: language
                                 *
                                 *  Don't do other constructors...
                                 * @throws NotFoundException
                                 */
                                addConstructor(): ClassBuilder$ConstructorBuilder;
                                addConstructor(...params: JavaVarArgs<JavaClassArg<any>>): ClassBuilder$ConstructorBuilder;

                                /**
                                 * The code must define the full constructor, including visibility and parameters.  
                                 *  Generic types are not supported as arguments, neither can varargs be used.  
                                 *  Annotations are also not supported.  
                                 *  Just like in java, classes from the `java.lang` package don't need a fully qualified name.  
                                 *  To make sure the class can be easily instantiated, the visibility of the constructor should be public.  
                                 *  Examples are:  
                                 *  ```  
                                 *  `public MyClass() { }`
                                 *  `public MyClass(String text) { System.out.println(text); }`
                                 *  `protected MyClass(String text, int number) { super(text, number, ""); }`
                                 *  `public MyClass(String text, int number, String other) {
                                 *       this(text, number);  
                                 *       this.other = other;  
                                 *  }`
                                 *  ```
                                 * @param code the code for the constructor
                                 * @return self for chaining.
                                 * @throws CannotCompileException
                                 * @since 1.8.4
                                 */
                                addConstructor(code: string): ClassBuilder<T>;
                                finishBuildAndFreeze(): JavaClass<xyz.wagyourtail.jsmacros.core.library.BaseLibrary>;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.1.8
                             */
                            class FileHandler extends java.lang.Object {
                                static readonly class: JavaClass<FileHandler>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (path: string);
                                constructor (path: string, charset: string);
                                constructor (path: java.io.File, charset: string);
                                constructor (path: string, charset: java.nio.charset.Charset);
                                constructor (path: java.io.File);
                                constructor (path: java.io.File, charset: java.nio.charset.Charset);

                                /**
                                 * writes a string to the file. this is a destructive operation that replaces the file contents.
                                 * @return self
                                 * @throws IOException
                                 * @since 1.1.8
                                 */
                                write(s: string): this;

                                /**
                                 * writes a byte array to the file. this is a destructive operation that replaces the file contents.
                                 * @return self
                                 * @throws IOException
                                 * @since 1.1.8
                                 */
                                write(b: byte[]): this;

                                /**
                                 * @throws IOException
                                 * @since 1.1.8
                                 */
                                read(): string;

                                /**
                                 * @throws IOException
                                 * @since 1.2.6
                                 */
                                readBytes(): JavaArray<number>;

                                /**
                                 * get an iterator for the lines in the file.  
                                 *  please call {@link FileLineIterator.close}() when you are done with the iterator to not leak resources.
                                 * @since 1.8.4
                                 */
                                readLines(): FileHandler$FileLineIterator;

                                /**
                                 * get an input stream for the file.  
                                 *  please call {@link BufferedInputStream.close}() when you are done with the stream to not leak resources.
                                 * @since 1.8.4
                                 */
                                streamBytes(): java.io.BufferedInputStream;

                                /**
                                 * @return self
                                 * @throws IOException
                                 * @since 1.1.8
                                 */
                                append(s: string): this;

                                /**
                                 * @return self
                                 * @throws IOException
                                 * @since 1.2.6
                                 */
                                append(b: byte[]): this;
                                getFile(): java.io.File;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.1.8
                             */
                            class HTTPRequest$Response extends java.lang.Object {
                                static readonly class: JavaClass<HTTPRequest$Response>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (inputStream: java.io.InputStream, responseCode: int, headers: JavaMap<string, JavaList<string>> | null);

                                headers: JavaMap<string, JavaList<string>> | null;
                                responseCode: number;

                                /** @since 1.1.8 */
                                text(): string;

                                /**
                                 * Don't use this. Parse {@link HTTPRequest.Response.text}() in the guest language
                                 * @since 1.1.8
                                 * @deprecated
                                 */
                                json(): any;

                                /**
                                 * @throws IOException
                                 * @since 1.2.2
                                 */
                                byteArray(): JavaArray<number>;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.6.0
                             */
                            class ProxyBuilder<T> extends java.lang.Object {
                                static readonly class: JavaClass<ProxyBuilder<any>>;
                                /** @deprecated */ static prototype: undefined;

                                constructor <T>(clazz: JavaClassArg<T>, interfaces: JavaClassArg<any>[]);

                                readonly factory: javassist.util.proxy.ProxyFactory;
                                readonly proxiedMethods: JavaMap<ProxyBuilder$MethodSigParts, xyz.wagyourtail.jsmacros.core.MethodWrapper<ProxyBuilder$ProxyReference<T>, JavaArray<any>, any, any>>;
                                readonly proxiedMethodDefaults: JavaMap<string, xyz.wagyourtail.jsmacros.core.MethodWrapper<ProxyBuilder$ProxyReference<T>, JavaArray<any>, any, any>>;

                                /**
                                 * @param methodNameOrSig name of method or sig (the usual format)
                                 * @return self for chaining
                                 * @since 1.6.0
                                 */
                                addMethod(methodNameOrSig: string, proxyMethod: xyz.wagyourtail.jsmacros.core.MethodWrapper<ProxyBuilder$ProxyReference<T>, any[], any, any>): ProxyBuilder<T>;

                                /**
                                 * @param constructorArgs args for the super constructor
                                 * @return new instance of the constructor
                                 * @throws InvocationTargetException
                                 * @throws NoSuchMethodException
                                 * @throws InstantiationException
                                 * @throws IllegalAccessException
                                 * @since 1.6.0
                                 */
                                buildInstance(constructorArgs: any[]): T;

                                /**
                                 * @param constructorSig string signature (you can skip the <init> part)
                                 * @param constructorArgs args for the super constructor
                                 * @return new instance of the constructor
                                 * @throws InvocationTargetException
                                 * @throws NoSuchMethodException
                                 * @throws InstantiationException
                                 * @throws IllegalAccessException
                                 * @throws ClassNotFoundException
                                 * @since 1.6.0
                                 */
                                buildInstance(constructorSig: string, constructorArgs: any[]): T;

                                /**
                                 * @param constructorSig string signature (you can skip the <init> part)
                                 * @param constructorArgs args for the super constructor
                                 * @return new instance of the constructor
                                 * @throws InvocationTargetException
                                 * @throws NoSuchMethodException
                                 * @throws InstantiationException
                                 * @throws IllegalAccessException
                                 * @throws ClassNotFoundException
                                 * @since 1.6.0
                                 */
                                buildInstance(constructorSig: JavaClassArg<any>[], constructorArgs: any[]): T;

                            }


                            /**
                             * @author Wagyourtail
                             * @since 1.1.8
                             */
                            class HTTPRequest extends java.lang.Object {
                                static readonly class: JavaClass<HTTPRequest>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (url: string);

                                headers: JavaMap<string, string>;
                                conn: java.net.URL;
                                connectTimeout: number;
                                readTimeout: number;

                                /** @since 1.1.8 */
                                addHeader(key: string, value: string): HTTPRequest;
                                /** @since 1.8.6 */
                                setConnectTimeout(timeout: int): HTTPRequest;
                                /** @since 1.8.6 */
                                setReadTimeout(timeout: int): HTTPRequest;

                                /**
                                 * @throws IOException
                                 * @since 1.1.8
                                 */
                                get(): HTTPRequest$Response;

                                /**
                                 * @throws IOException
                                 * @since 1.1.8
                                 */
                                post(data: string): HTTPRequest$Response;

                                /**
                                 * @throws IOException
                                 * @since 1.8.4
                                 */
                                post(data: byte[]): HTTPRequest$Response;

                                /**
                                 * @throws IOException
                                 * @since 1.8.4
                                 */
                                put(data: string): HTTPRequest$Response;

                                /**
                                 * @throws IOException
                                 * @since 1.8.4
                                 */
                                put(data: byte[]): HTTPRequest$Response;
                                /** @since 1.8.6 */
                                send(method: string): HTTPRequest$Response;

                                /**
                                 * @throws IOException
                                 * @since 1.8.4
                                 */
                                send(method: string, data: string): HTTPRequest$Response;

                                /**
                                 * @throws IOException
                                 * @since 1.8.4
                                 */
                                send(method: string, data: byte[]): HTTPRequest$Response;

                            }

                            /** @since 1.6.5 */
                            class ClassBuilder<T> extends java.lang.Object {
                                static readonly class: JavaClass<ClassBuilder<any>>;
                                /** @deprecated */ static prototype: undefined;

                                static readonly methodWrappers: JavaMap<string, xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>>;

                                constructor <T>(name: string, parent: JavaClassArg<T>, ...interfaces: JavaVarArgs<JavaClassArg<any>>);

                                readonly ctClass: javassist.CtClass;

                                addField(fieldType: JavaClassArg<any>, name: string): ClassBuilder$FieldBuilder;

                                /**
                                 * The code must define the full field, including visibility, type, name and an optional value.  
                                 *  Generic types are not supported and must be explicitly cast in the source code when used.  
                                 *  Annotations are also not supported.  
                                 *  Just like in java, classes from the `java.lang` package don't need a fully qualified name.  
                                 *  Examples are:  
                                 *  ```  
                                 *  `private String name;`
                                 *  `private java.lang.String name;`
                                 *  `public java.util.List list = new java.util.ArrayList();`
                                 *  `static int value = 10;`
                                 *  ```
                                 * @param code the code for the field
                                 * @return self for chaining.
                                 * @throws CannotCompileException
                                 * @since 1.8.4
                                 */
                                addField(code: string): ClassBuilder<T>;
                                addMethod(returnType: JavaClassArg<any>, name: string, ...params: JavaVarArgs<JavaClassArg<any>>): ClassBuilder$MethodBuilder;

                                /**
                                 * The code must define the full method, including visibility, return type, name and parameters.  
                                 *  Generic types are not supported as return values or arguments, neither can varargs be used.  
                                 *  Annotations are also not supported.  
                                 *  Just like in java, classes from the `java.lang` package don't need a fully qualified name.  
                                 *  Examples are:  
                                 *  ```  
                                 *  `public Object id(Object obj) { return obj; }`
                                 *  `private void print(String text) { System.out.println(text); }`
                                 *  `private static java.util.Map toMap(Object[] keys, Object[] values) {
                                 *       java.util.Map map = new java.util.HashMap();  
                                 *       for (int i = 0; i < keys.length; i++) {
                                 *           map.put(keys[i], values[i]);  
                                 *       }
                                 *       return map;  
                                 *   }`
                                 *  `public String toString() {
                                 *       System.out.println(super.toString());  
                                 *       return "Hello World!";  
                                 *   }`
                                 *  ```
                                 * @param code the code for the method
                                 * @return self for chaining.
                                 * @throws CannotCompileException
                                 * @since 1.8.4
                                 */
                                addMethod(code: string): ClassBuilder<T>;
                                addConstructor(...params: JavaVarArgs<JavaClassArg<any>>): ClassBuilder$ConstructorBuilder;

                                /**
                                 * The code must define the full constructor, including visibility and parameters.  
                                 *  Generic types are not supported as arguments, neither can varargs be used.  
                                 *  Annotations are also not supported.  
                                 *  Just like in java, classes from the `java.lang` package don't need a fully qualified name.  
                                 *  To make sure the class can be easily instantiated, the visibility of the constructor should be public.  
                                 *  Examples are:  
                                 *  ```  
                                 *  `public MyClass() { }`
                                 *  `public MyClass(String text) { System.out.println(text); }`
                                 *  `protected MyClass(String text, int number) { super(text, number, ""); }`
                                 *  `public MyClass(String text, int number, String other) {
                                 *       this(text, number);  
                                 *       this.other = other;  
                                 *  }`
                                 *  ```
                                 * @param code the code for the constructor
                                 * @return self for chaining.
                                 * @throws CannotCompileException
                                 * @since 1.8.4
                                 */
                                addConstructor(code: string): ClassBuilder<T>;
                                addClinit(): ClassBuilder$ConstructorBuilder;
                                addAnnotation(type: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder<T>>;
                                finishBuildAndFreeze(): JavaClass<T>;

                            }

                            class ClassBuilder$MethodBuilder extends java.lang.Object {
                                static readonly class: JavaClass<ClassBuilder$MethodBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (methodReturnType: javassist.CtClass, methodName: string, ...params: JavaVarArgs<javassist.CtClass>);

                                compile(code: string): ClassBuilder<T>;
                                makePrivate(): ClassBuilder$MethodBuilder;
                                makePublic(): ClassBuilder$MethodBuilder;
                                makeProtected(): ClassBuilder$MethodBuilder;
                                makePackagePrivate(): ClassBuilder$MethodBuilder;
                                toggleStatic(): ClassBuilder$MethodBuilder;
                                rename(newName: string): ClassBuilder$MethodBuilder;
                                exceptions(...exceptions: JavaVarArgs<JavaClassArg<any>>): ClassBuilder$MethodBuilder;
                                body(code_src: string): ClassBuilder<T>;
                                guestBody(methodBody: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): ClassBuilder<T>;
                                buildBody(): ClassBuilder$BodyBuilder;
                                body(buildBody: xyz.wagyourtail.jsmacros.core.MethodWrapper<javassist.CtClass, javassist.CtBehavior, any, any>): ClassBuilder<T>;
                                endAbstract(): ClassBuilder<T>;
                                addAnnotation(type: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder$MethodBuilder>;

                            }

                            class ClassBuilder$ConstructorBuilder extends ClassBuilder$MethodBuilder {
                                static readonly class: JavaClass<ClassBuilder$ConstructorBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (params: javassist.CtClass[], clInit: boolean);

                                body(code_src: string): ClassBuilder<T>;
                                guestBody(methodBody: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): ClassBuilder<T>;
                                buildBody(): ClassBuilder$BodyBuilder;
                                body(buildBody: xyz.wagyourtail.jsmacros.core.MethodWrapper<javassist.CtClass, javassist.CtBehavior, any, any>): ClassBuilder<T>;
                                endAbstract(): ClassBuilder<T>;

                            }

                            interface FileHandler$FileLineIterator extends java.util.Iterator<java.lang.String>, java.lang.AutoCloseable {}
                            class FileHandler$FileLineIterator extends java.lang.Object {
                                static readonly class: JavaClass<FileHandler$FileLineIterator>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (file: java.io.File, charset: java.nio.charset.Charset);

                                hasNext(): boolean;
                                next(): string;
                                close(): void;

                            }

                            abstract class ClassBuilder$AnnotationBuilder<T> extends java.lang.Object {
                                static readonly class: JavaClass<ClassBuilder$AnnotationBuilder<any>>;
                                /** @deprecated */ static prototype: undefined;

                                putString(key: string, value: string): ClassBuilder$AnnotationBuilder<T>;
                                putBoolean(key: string, value: boolean): ClassBuilder$AnnotationBuilder<T>;
                                putByte(key: string, value: byte): ClassBuilder$AnnotationBuilder<T>;
                                putChar(key: string, value: char): ClassBuilder$AnnotationBuilder<T>;
                                putShort(key: string, value: short): ClassBuilder$AnnotationBuilder<T>;
                                putInt(key: string, value: int): ClassBuilder$AnnotationBuilder<T>;
                                putLong(key: string, value: long): ClassBuilder$AnnotationBuilder<T>;
                                putFloat(key: string, value: double): ClassBuilder$AnnotationBuilder<T>;
                                putDouble(key: string, value: double): ClassBuilder$AnnotationBuilder<T>;
                                putClass(key: string, value: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<T>;
                                putEnum(key: string, value: java.lang.Enum<any>): ClassBuilder$AnnotationBuilder<T>;
                                putAnnotation(key: string, annotationClass: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder$AnnotationBuilder<T>>;
                                putArray(key: string): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<ClassBuilder$AnnotationBuilder<T>>;
                                finish(): T;

                            }


                            /**
                             * @author Perry "R3alCl0ud" Berman
                             */
                            class Websocket$Disconnected extends java.lang.Object {
                                static readonly class: JavaClass<Websocket$Disconnected>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (serverFrame: com.neovisionaries.ws.client.WebSocketFrame, clientFrame: com.neovisionaries.ws.client.WebSocketFrame, isServer: boolean);

                                serverFrame: com.neovisionaries.ws.client.WebSocketFrame;
                                clientFrame: com.neovisionaries.ws.client.WebSocketFrame;
                                isServer: boolean;
                            }

                            class ClassBuilder$FieldBuilder extends java.lang.Object {
                                static readonly class: JavaClass<ClassBuilder$FieldBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor (fieldType: javassist.CtClass, name: string);

                                fieldInitializer: javassist.CtField$Initializer;

                                compile(code: string): ClassBuilder<T>;
                                rename(name: string): ClassBuilder$FieldBuilder;
                                makePrivate(): ClassBuilder$FieldBuilder;
                                makePublic(): ClassBuilder$FieldBuilder;
                                makeProtected(): ClassBuilder$FieldBuilder;
                                makePackagePrivate(): ClassBuilder$FieldBuilder;
                                toggleStatic(): ClassBuilder$FieldBuilder;
                                toggleFinal(): ClassBuilder$FieldBuilder;
                                getMods(): number;
                                getModString(): string;
                                addAnnotation(type: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder$FieldBuilder>;
                                initializer(): ClassBuilder$FieldBuilder$FieldInitializerBuilder;
                                end(): ClassBuilder<T>;

                            }

                            class ProxyBuilder$ProxyReference<T> extends java.lang.Object {
                                static readonly class: JavaClass<ProxyBuilder$ProxyReference<any>>;
                                /** @deprecated */ static prototype: undefined;

                                constructor <T>(self: T, parent: MethodWrapper<any[], any, any>);

                                /**
                                 * "this" value, but like python because "this" is a keyword in java...
                                 */
                                readonly self: T;

                                /**
                                 * "super" value, but that's also a keyword so...
                                 */
                                readonly parent: MethodWrapper<JavaArray<any>, any, any>;
                            }

                            abstract class ProxyBuilder$MethodSigParts extends java.lang.Object {
                                static readonly class: JavaClass<ProxyBuilder$MethodSigParts>;
                                /** @deprecated */ static prototype: undefined;

                                readonly name: string;
                                readonly params: JavaArray<JavaClass<any>>;
                                readonly returnType: JavaClass<any>;
                            }

                            class ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U> extends java.lang.Object {
                                static readonly class: JavaClass<ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<any>>;
                                /** @deprecated */ static prototype: undefined;

                                constructor <U>(parent: U, constPool: javassist.bytecode.ConstPool);

                                putString(value: string): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putBoolean(value: boolean): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putByte(value: byte): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putChar(value: char): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putShort(value: short): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putInt(value: int): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putLong(value: long): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putFloat(value: double): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putDouble(value: double): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putClass(value: JavaClassArg<any>): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putEnum(value: java.lang.Enum<any>): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putAnnotation(annotationClass: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>>;
                                putArray(annotationClass: JavaClassArg<any>): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>>;
                                finish(): U;

                            }

                            abstract class ClassBuilder$BodyBuilder extends java.lang.Object {
                                static readonly class: JavaClass<ClassBuilder$BodyBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                appendJavaCode(code: string): ClassBuilder$BodyBuilder;

                                /**
                                 * @param tokenBefore ie, "return", "Object wasd = " etc
                                 */
                                appendGuestCode(code: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>, argsAsObjects: string, tokenBefore: string): ClassBuilder$BodyBuilder;
                                finish(): ClassBuilder<T>;

                            }

                            class ClassBuilder$FieldBuilder$FieldInitializerBuilder extends java.lang.Object {
                                static readonly class: JavaClass<ClassBuilder$FieldBuilder$FieldInitializerBuilder>;
                                /** @deprecated */ static prototype: undefined;

                                constructor ();

                                setInt(value: int): ClassBuilder$FieldBuilder;
                                setLong(value: long): ClassBuilder$FieldBuilder;
                                setFloat(value: double): ClassBuilder$FieldBuilder;
                                setDouble(value: double): ClassBuilder$FieldBuilder;
                                setChar(value: char): ClassBuilder$FieldBuilder;
                                setString(value: string): ClassBuilder$FieldBuilder;
                                setBoolean(value: boolean): ClassBuilder$FieldBuilder;
                                setByte(value: byte): ClassBuilder$FieldBuilder;
                                setShort(value: short): ClassBuilder$FieldBuilder;
                                compile(code: string): ClassBuilder$FieldBuilder;
                                initClass(clazz: JavaClassArg<any>, ...code_arg: JavaVarArgs<string>): ClassBuilder$FieldBuilder;
                                callStaticMethod(clazz: JavaClassArg<any>, methodName: string, ...code_arg: JavaVarArgs<string>): ClassBuilder$FieldBuilder;
                                callStaticMethodInThisClass(methodName: string, ...code_arg: JavaVarArgs<string>): ClassBuilder$FieldBuilder;

                            }

                            export {
                                Websocket,
                                LibraryBuilder,
                                FileHandler,
                                HTTPRequest$Response,
                                ProxyBuilder,
                                HTTPRequest,
                                ClassBuilder,
                                ClassBuilder$MethodBuilder,
                                ClassBuilder$ConstructorBuilder,
                                FileHandler$FileLineIterator,
                                ClassBuilder$AnnotationBuilder,
                                Websocket$Disconnected,
                                ClassBuilder$FieldBuilder,
                                ProxyBuilder$ProxyReference,
                                ProxyBuilder$MethodSigParts,
                                ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder,
                                ClassBuilder$BodyBuilder,
                                ClassBuilder$FieldBuilder$FieldInitializerBuilder
                            }

                        }

                    }

                }

                namespace service {


                    /**
                     * @author Wagyourtail
                     * @since 1.6.3
                     */
                    class ServiceManager extends java.lang.Object {
                        static readonly class: JavaClass<ServiceManager>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (runner: xyz.wagyourtail.jsmacros.core.Core<any, any>);

                        /**
                         * @param pathToFile relative to macro folder
                         * @return false if service with that name is already registered
                         */
                        registerService(name: string, pathToFile: string): boolean;

                        /**
                         * @param pathToFile relative to macro folder
                         * @return false if service with that name is already registered
                         */
                        registerService(name: string, pathToFile: string, enabled: boolean): boolean;

                        /**
                         * @return false if service with that name already registered
                         */
                        registerService(name: string, trigger: ServiceTrigger): boolean;
                        unregisterService(name: string): boolean;

                        /**
                         * @param serviceName the name of the service to disable the reload feature for
                         * @since 1.8.4
                         */
                        disableReload(serviceName: string): void;

                        /**
                         * @return false if service with new name already registered or old name doesn't exist
                         */
                        renameService(oldName: string, newName: string): boolean;

                        /**
                         * @return registered service names
                         */
                        getServices(): JavaSet<string>;

                        /**
                         * starts service once
                         * @param name service name
                         * @return previous state (or {@link ServiceStatus.UNKNOWN} if unknown service)
                         */
                        startService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name service name
                         * @return previous state (or {@link ServiceStatus.UNKNOWN} if unknown service)
                         */
                        stopService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name service name
                         * @return state before "restarting" (or {@link ServiceStatus.UNKNOWN} if unknown service)
                         */
                        restartService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name service name
                         * @return previous state (or {@link ServiceStatus.UNKNOWN} if unknown service)
                         */
                        enableService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name service name
                         * @return previous state (or {@link ServiceStatus.UNKNOWN} if unknown service)
                         */
                        disableService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name the name of the service to check
                         * @return `true` if the service is running, `false` otherwise.
                         * @since 1.8.4
                         */
                        isRunning(name: string): boolean;

                        /**
                         * @param name the name of the service to check
                         * @return `true` if the service is enabled, `false` otherwise.
                         * @since 1.8.4
                         */
                        isEnabled(name: string): boolean;

                        /**
                         * @param name service name
                         * @return {*} {@link ServiceStatus.UNKNOWN} if unknown service, {@link ServiceStatus.RUNNING} if disabled and running, {@link ServiceStatus.DISABLED} if disabled and stopped, {@link ServiceStatus.STOPPED} if enabled and stopped, {@link ServiceStatus.ENABLED} if enabled and running.
                         */
                        status(name: string): ServiceManager$ServiceStatus;

                        /**
                         * this might throw if the service is not running...
                         * @return the event that is current for the service
                         * @since 1.6.5
                         */
                        getServiceData(name: string): EventService;
                        /** @since 1.6.5 [named getServiceData previously] */
                        getTrigger(name: string): ServiceTrigger;

                        /**
                         * load services from config
                         */
                        load(): void;

                        /**
                         * save current registered services & enabled/disabled status to config
                         */
                        save(): void;

                        /**
                         * Stops the service manager from reloading scrips on file changes.
                         * @since 1.8.4
                         */
                        stopReloadListener(): void;

                        /**
                         * Will make the service manager reload scripts on file changes.
                         * @since 1.8.4
                         */
                        startReloadListener(): void;

                        /**
                         * Mark a service as crashed so that it can be reloaded when its file changes. Crashed services
                         *  must be marked so that file change listener knows to restart them even if they are not
                         *  running because they crashed.
                         * @param serviceName the name of the service to mark as crashed
                         * @since 1.8.4
                         */
                        markCrashed(serviceName: string): void;

                        /**
                         * @param serviceName the name of the service to check
                         * @return `true` if the service previously crashed, `false` otherwise.
                         * @since 1.8.4
                         */
                        isCrashed(serviceName: string): boolean;

                        /**
                         * Ticks the service manager. This will check if any services need to be reloaded and reloads
                         *  them if necessary.
                         * @since 1.8.4
                         */
                        tickReloadListener(): void;

                    }

                    abstract class ServiceManager$ServiceStatus extends java.lang.Enum<ServiceManager$ServiceStatus> {
                        static readonly class: JavaClass<ServiceManager$ServiceStatus>;
                        /** @deprecated */ static prototype: undefined;

                        static readonly ENABLED: ServiceManager$ServiceStatus;
                        static readonly DISABLED: ServiceManager$ServiceStatus;
                        static readonly RUNNING: ServiceManager$ServiceStatus;
                        static readonly STOPPED: ServiceManager$ServiceStatus;
                        static readonly UNKNOWN: ServiceManager$ServiceStatus;

                        static values(): JavaArray<ServiceManager$ServiceStatus>;
                        static valueOf(name: string): ServiceManager$ServiceStatus;

                    }

                    class ServiceTrigger extends java.lang.Object {
                        static readonly class: JavaClass<ServiceTrigger>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (file: java.io.File, enabled: boolean);

                        file: string;
                        enabled: boolean;

                        toScriptTrigger(): xyz.wagyourtail.jsmacros.core.config.ScriptTrigger;

                    }

                    /** @since 1.6.4 */
                    class EventService extends Events.BaseEvent {
                        static readonly class: JavaClass<EventService>;
                        /** @deprecated */ static prototype: undefined;

                        constructor (name: string);

                        readonly serviceName: string;

                        /**
                         * when this service is stopped, this is run...
                         */
                        stopListener: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any> | null;

                        /**
                         * Put an Integer into the global variable space.
                         * @since 1.6.5
                         */
                        putInt(name: string, i: int): number;

                        /**
                         * put a String into the global variable space.
                         * @since 1.6.5
                         */
                        putString(name: string, str: string): string;

                        /**
                         * put a Double into the global variable space.
                         * @since 1.6.5
                         */
                        putDouble(name: string, d: double): number;

                        /**
                         * put a Boolean into the global variable space.
                         * @since 1.6.5
                         */
                        putBoolean(name: string, b: boolean): boolean;

                        /**
                         * put anything else into the global variable space.
                         * @since 1.6.5
                         */
                        putObject(name: string, o: any): any;

                        /**
                         * Returns the type of the defined item in the global variable space as a string.
                         * @since 1.6.5
                         */
                        getType(name: string): 'Int' | 'String' | 'Double' | 'Boolean' | 'Object' | null;

                        /**
                         * Gets an Integer from the global variable space.
                         * @since 1.6.5
                         */
                        getInt(name: string): number | null;

                        /**
                         * Gets an Integer from the global variable space. and then increment it there.
                         * @since 1.6.5
                         */
                        getAndIncrementInt(name: string): number | null;

                        /**
                         * Gets an integer from the global variable pace. and then decrement it there.
                         * @since 1.6.5
                         */
                        getAndDecrementInt(name: string): number | null;

                        /**
                         * increment an Integer in the global variable space. then return it.
                         * @since 1.6.5
                         */
                        incrementAndGetInt(name: string): number | null;

                        /**
                         * decrement an Integer in the global variable space. then return it.
                         * @since 1.6.5
                         */
                        decrementAndGetInt(name: string): number | null;

                        /**
                         * Gets a String from the global variable space
                         * @since 1.6.5
                         */
                        getString(name: string): string | null;

                        /**
                         * Gets a Double from the global variable space.
                         * @since 1.6.5
                         */
                        getDouble(name: string): number | null;

                        /**
                         * Gets a Boolean from the global variable space.
                         * @since 1.6.5
                         */
                        getBoolean(name: string): boolean | null;

                        /**
                         * toggles a global boolean and returns its new value
                         * @since 1.6.5
                         */
                        toggleBoolean(name: string): boolean | null;

                        /**
                         * Gets an Object from the global variable space.
                         * @since 1.6.5
                         */
                        getObject(name: string): any | null;

                        /**
                         * removes a key from the global variable space.
                         * @since 1.6.5
                         */
                        remove(key: string): void;
                        getRaw(): JavaMap<string, any>;

                    }

                    export {
                        ServiceManager,
                        ServiceManager$ServiceStatus,
                        ServiceTrigger,
                        EventService
                    }

                }

                namespace threads {

                    class JsMacrosThreadPool extends java.lang.Object {
                        static readonly class: JavaClass<JsMacrosThreadPool>;
                        /** @deprecated */ static prototype: undefined;

                        constructor ();
                        constructor (maxFreeThreads: int);

                        readonly maxFreeThreads: number;

                        runTask(task: MethodWrapper): java.lang.Thread;
                        runTask(task: MethodWrapper, beforeRunTask: MethodWrapper<java.lang.Thread>): java.lang.Thread;

                    }

                    export { JsMacrosThreadPool }

                }

            }

        }

        namespace wagyourgui {

            interface BaseScreen extends xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, xyz.wagyourtail.wagyourgui.overlays.IOverlayParent {}
            abstract class BaseScreen extends /* net.minecraft.client.gui.screen.Screen */ java.lang.Object {
                static readonly class: JavaClass<BaseScreen>;
                /** @deprecated */ static prototype: undefined;

                static trimmed(textRenderer: /* net.minecraft.client.font.TextRenderer */ any, str: /* net.minecraft.text.StringVisitable */ any, width: int): /* net.minecraft.text.OrderedText */ any;

                setParent(parent: /* net.minecraft.client.gui.screen.Screen */ any): void;
                reload(): void;
                openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer): void;
                getFirstOverlayParent(): xyz.wagyourtail.wagyourgui.overlays.IOverlayParent;
                getChildOverlay(): xyz.wagyourtail.wagyourgui.overlays.OverlayContainer;
                openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer, disableButtons: boolean): void;
                closeOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer): void;
                updateSettings(): void;
                openParent(): void;

            }

            export { BaseScreen }

        }
        namespace wagyourgui {

            namespace containers {

                abstract class IContainerParent extends java.lang.Interface {
                    static readonly class: JavaClass<IContainerParent>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IContainerParent {

                    addDrawableChild<T extends (/* net.minecraft.client.gui.Element */ any & /* net.minecraft.client.gui.Drawable */ any & /* net.minecraft.client.gui.Selectable */ any)>(drawableElement: T): T;
                    remove(button: /* net.minecraft.client.gui.Element */ any): void;
                    openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer): void;
                    openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer, disableButtons: boolean): void;
                    getFirstOverlayParent(): xyz.wagyourtail.wagyourgui.overlays.IOverlayParent;

                }

                interface MultiElementContainer<T extends IContainerParent> extends IContainerParent {}
                class MultiElementContainer<T extends IContainerParent> extends java.lang.Object {
                    static readonly class: JavaClass<MultiElementContainer<any>>;
                    /** @deprecated */ static prototype: undefined;

                    constructor <T extends IContainerParent>(x: int, y: int, width: int, height: int, textRenderer: /* net.minecraft.client.font.TextRenderer */ any, parent: T);

                    readonly parent: T;
                    x: number;
                    y: number;
                    width: number;
                    height: number;

                    init(): void;
                    getVisible(): boolean;
                    setVisible(visible: boolean): void;
                    addDrawableChild<T extends (/* net.minecraft.client.gui.Element */ any & /* net.minecraft.client.gui.Drawable */ any & /* net.minecraft.client.gui.Selectable */ any)>(drawableElement: T): T;
                    getButtons(): JavaList</* net.minecraft.client.gui.widget.ClickableWidget */ any>;
                    setPos(x: int, y: int, width: int, height: int): void;
                    openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer): void;
                    openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer, disableButtons: boolean): void;
                    remove(button: /* net.minecraft.client.gui.Element */ any): void;
                    getFirstOverlayParent(): xyz.wagyourtail.wagyourgui.overlays.IOverlayParent;
                    render(drawContext: /* net.minecraft.client.gui.DrawContext */ any, mouseX: int, mouseY: int, delta: float): void;

                }

                export { IContainerParent, MultiElementContainer }

            }

            namespace elements {


                /**
                 * @author Etheradon
                 * @since 1.8.4
                 */
                class Slider extends /* net.minecraft.client.gui.widget.ClickableWidget */ java.lang.Object {
                    static readonly class: JavaClass<Slider>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (x: int, y: int, width: int, height: int, text: /* net.minecraft.text.Text */ any, value: double, action: MethodWrapper<Slider>, steps: int);
                    constructor (x: int, y: int, width: int, height: int, text: /* net.minecraft.text.Text */ any, value: double, action: MethodWrapper<Slider>);

                    roundValue(value: double): number;
                    getValue(): number;
                    setValue(mouseX: double): void;
                    getSteps(): number;
                    setSteps(steps: int): void;
                    setMessage(message: string): void;

                }


                /**
                 * @author Etheradon
                 * @since 1.8.4
                 */
                class CheckBox extends /* net.minecraft.client.gui.widget.CheckboxWidget */ java.lang.Object {
                    static readonly class: JavaClass<CheckBox>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (x: int, y: int, width: int, height: int, text: /* net.minecraft.text.Text */ any, checked: boolean, action: MethodWrapper<CheckBox>);
                    constructor (x: int, y: int, width: int, height: int, text: /* net.minecraft.text.Text */ any, checked: boolean, showMessage: boolean, action: MethodWrapper<CheckBox>);

                }

                class Scrollbar extends /* net.minecraft.client.gui.widget.ClickableWidget */ java.lang.Object {
                    static readonly class: JavaClass<Scrollbar>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (x: int, y: int, width: int, height: int, color: int, borderColor: int, highlightColor: int, scrollPages: double, onChange: MethodWrapper<double>);

                    setPos(x: int, y: int, width: int, height: int): Scrollbar;
                    setScrollPages(scrollPages: double): void;
                    scrollToPercent(percent: double): void;
                    onChange(): void;

                }

                export { Slider, CheckBox, Scrollbar }

            }

            namespace overlays {

                abstract class IOverlayParent extends java.lang.Interface {
                    static readonly class: JavaClass<IOverlayParent>;
                    /** @deprecated */ static prototype: undefined;
                }
                interface IOverlayParent extends xyz.wagyourtail.wagyourgui.containers.IContainerParent {

                    closeOverlay(overlay: OverlayContainer): void;
                    setFocused(focused: /* net.minecraft.client.gui.Element */ any): void;
                    getChildOverlay(): OverlayContainer;

                }

                interface OverlayContainer extends IOverlayParent {}
                class OverlayContainer extends xyz.wagyourtail.wagyourgui.containers.MultiElementContainer<IOverlayParent> {
                    static readonly class: JavaClass<OverlayContainer>;
                    /** @deprecated */ static prototype: undefined;

                    constructor (x: int, y: int, width: int, height: int, textRenderer: /* net.minecraft.client.font.TextRenderer */ any, parent: IOverlayParent);

                    savedBtnStates: JavaMap</* net.minecraft.client.gui.widget.ClickableWidget */ any, boolean>;
                    scroll: xyz.wagyourtail.wagyourgui.elements.Scrollbar;

                    remove(btn: /* net.minecraft.client.gui.Element */ any): void;
                    openOverlay(overlay: OverlayContainer): void;
                    getFirstOverlayParent(): IOverlayParent;
                    openOverlay(overlay: OverlayContainer, disableButtons: boolean): void;
                    getChildOverlay(): OverlayContainer;
                    closeOverlay(overlay: OverlayContainer): void;
                    setFocused(focused: /* net.minecraft.client.gui.Element */ any): void;
                    onClick(mouseX: double, mouseY: double, button: int): void;

                    /**
                     * @return true if should be handled by overlay
                     */
                    keyPressed(keyCode: int, scanCode: int, modifiers: int): boolean;
                    close(): void;
                    onClose(): void;
                    renderBackground(drawContext: /* net.minecraft.client.gui.DrawContext */ any): void;
                    render(drawContext: /* net.minecraft.client.gui.DrawContext */ any, mouseX: int, mouseY: int, delta: float): void;

                }

                export { IOverlayParent, OverlayContainer }

            }

        }

    }

}

type AbstractHorseEntityHelper<T = /* net.minecraft.entity.passive.AbstractHorseEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.AbstractHorseEntityHelper<T>;
type AbstractPiglinEntityHelper<T = /* net.minecraft.entity.mob.AbstractPiglinEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.AbstractPiglinEntityHelper<T>;
type AbstractRenderCodeCompiler = Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AbstractRenderCodeCompiler;
type AbstractWidgetBuilder<B extends Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.AbstractWidgetBuilder<B, T, U> = any, T = /* net.minecraft.client.gui.widget.ClickableWidget */ any, U extends Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<U, T> = any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.AbstractWidgetBuilder<B, T, U>;
type AdvancementHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.AdvancementHelper;
type AdvancementManagerHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.AdvancementManagerHelper;
type AdvancementProgressHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.AdvancementProgressHelper;
type Alignable<B extends Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Alignable<B> = any> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Alignable<B>;
type AllayEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.AllayEntityHelper;
type AnimalEntityHelper<T = /* net.minecraft.entity.passive.AnimalEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.AnimalEntityHelper<T>;
type AnvilInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.AnvilInventory;
type AreaEffectCloudEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.other.AreaEffectCloudEntityHelper;
type ArmorStandEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.decoration.ArmorStandEntityHelper;
type ArrowEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.projectile.ArrowEntityHelper;
type AutoCompleteSuggestion = Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AutoCompleteSuggestion;
type AxolotlEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.AxolotlEntityHelper;
type BaseEventRegistry = Packages.xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry;
type BaseHelper<T = any> = Packages.xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T>;
type BaseLanguage<U = any, T extends Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<U> = any> = Packages.xyz.wagyourtail.jsmacros.core.language.BaseLanguage<U, T>;
type BaseLibrary = Packages.xyz.wagyourtail.jsmacros.core.library.BaseLibrary;
type BaseProfile = Packages.xyz.wagyourtail.jsmacros.core.config.BaseProfile;
type BaseScreen = Packages.xyz.wagyourtail.wagyourgui.BaseScreen;
type BaseScriptContext$SleepRunnable = Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext$SleepRunnable;
type BaseScriptContext<T = any> = Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<T>;
type BaseWrappedException$SourceLocation = Packages.xyz.wagyourtail.jsmacros.core.language.BaseWrappedException$SourceLocation;
type BaseWrappedException<T = any> = Packages.xyz.wagyourtail.jsmacros.core.language.BaseWrappedException<T>;
type BatEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.BatEntityHelper;
type BeaconInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.BeaconInventory;
type BeeEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.BeeEntityHelper;
type BlazeEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.BlazeEntityHelper;
type BlockDataHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;
type BlockHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper;
type BlockPosHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;
type BlockStateHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper;
type BoatEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.vehicle.BoatEntityHelper;
type BossBarHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.BossBarHelper;
type Box = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;
type Box$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box$Builder;
type BrewingStandInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.BrewingStandInventory;
type ButtonWidgetHelper$ButtonBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper$ButtonBuilder;
type ButtonWidgetHelper$TexturedButtonBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper$TexturedButtonBuilder;
type ButtonWidgetHelper<T = /* net.minecraft.client.gui.widget.ButtonWidget */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper<T>;
type CartographyInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CartographyInventory;
type CatEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.CatEntityHelper;
type ChatHistoryManager = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.ChatHistoryManager;
type ChatHudLineHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper;
type CheckBox = Packages.xyz.wagyourtail.wagyourgui.elements.CheckBox;
type CheckBoxWidgetHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;
type CheckBoxWidgetHelper$CheckBoxBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper$CheckBoxBuilder;
type ChunkHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper;
type ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
type ClassBuilder$AnnotationBuilder<T = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$AnnotationBuilder<T>;
type ClassBuilder$BodyBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$BodyBuilder;
type ClassBuilder$ConstructorBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$ConstructorBuilder;
type ClassBuilder$FieldBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$FieldBuilder;
type ClassBuilder$FieldBuilder$FieldInitializerBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$FieldBuilder$FieldInitializerBuilder;
type ClassBuilder$MethodBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$MethodBuilder;
type ClassBuilder<T = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder<T>;
type ClickableWidgetHelper<B extends Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<B, T> = any, T = /* net.minecraft.client.gui.widget.ClickableWidget */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<B, T>;
type ClientPlayerEntityHelper<T = /* net.minecraft.client.network.ClientPlayerEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.ClientPlayerEntityHelper<T>;
type CommandBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CommandBuilder;
type CommandContextHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandContextHelper;
type CommandManager = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CommandManager;
type CommandNodeHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper;
type ConfigManager = Packages.xyz.wagyourtail.jsmacros.core.config.ConfigManager;
type ContainerInventory<T = /* net.minecraft.client.gui.screen.ingame.HandledScreen<any> */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.ContainerInventory<T>;
type Core<T extends Packages.xyz.wagyourtail.jsmacros.core.config.BaseProfile = any, U extends Packages.xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry = any> = Packages.xyz.wagyourtail.jsmacros.core.Core<T, U>;
type CraftingInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CraftingInventory;
type CreativeInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CreativeInventory;
type CreativeItemStackHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.CreativeItemStackHelper;
type CreeperEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.CreeperEntityHelper;
type CustomImage = Packages.xyz.wagyourtail.jsmacros.client.api.classes.CustomImage;
type CyclingButtonWidgetHelper$CyclicButtonBuilder<T = any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;
type CyclingButtonWidgetHelper<T = any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<T>;
type DirectionHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.DirectionHelper;
type DolphinEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.DolphinEntityHelper;
type DonkeyEntityHelper<T = /* net.minecraft.entity.passive.AbstractDonkeyEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.DonkeyEntityHelper<T>;
type Draw2D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D;
type Draw2DElement = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;
type Draw2DElement$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement$Builder;
type Draw3D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D;
type DrownedEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.DrownedEntityHelper;
type DyeColorHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.DyeColorHelper;
type EditorScreen = Packages.xyz.wagyourtail.jsmacros.client.gui.screens.EditorScreen;
type EnchantInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.EnchantInventory;
type EnchantmentHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.EnchantmentHelper;
type EndCrystalEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.decoration.EndCrystalEntityHelper;
type EnderDragonEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.boss.EnderDragonEntityHelper;
type EndermanEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.EndermanEntityHelper;
type EntityHelper<T = /* net.minecraft.entity.Entity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<T>;
type EntityTraceLine = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.EntityTraceLine;
type EntityTraceLine$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.EntityTraceLine$Builder;
type EventContainer<T extends Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any> = any> = Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<T>;
type EventCustom = Packages.xyz.wagyourtail.jsmacros.core.event.impl.EventCustom;
type EventService = Packages.xyz.wagyourtail.jsmacros.core.service.EventService;
type Extension = Packages.xyz.wagyourtail.jsmacros.core.extensions.Extension;
type Extension$ExtMatch = Packages.xyz.wagyourtail.jsmacros.core.extensions.Extension$ExtMatch;
type ExtensionLoader = Packages.xyz.wagyourtail.jsmacros.core.extensions.ExtensionLoader;
type FJsMacros$EventAndContext<E extends Events.BaseEvent = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.FJsMacros$EventAndContext<E>;
type FallingBlockEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.other.FallingBlockEntityHelper;
type FileHandler = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.FileHandler;
type FileHandler$FileLineIterator = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.FileHandler$FileLineIterator;
type FishEntityHelper<T = /* net.minecraft.entity.passive.FishEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.FishEntityHelper<T>;
type FishingBobberEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.projectile.FishingBobberEntityHelper;
type FluidStateHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.FluidStateHelper;
type FoodComponentHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.FoodComponentHelper;
type FormattingHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper;
type FoxEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.FoxEntityHelper;
type FrogEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.FrogEntityHelper;
type FurnaceInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.FurnaceInventory;
type FurnaceMinecartEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.vehicle.FurnaceMinecartEntityHelper;
type GhastEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.GhastEntityHelper;
type GoatEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.GoatEntityHelper;
type GrindStoneInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.GrindStoneInventory;
type GuardianEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.GuardianEntityHelper;
type HTTPRequest = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest;
type HTTPRequest$Response = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;
type History = Packages.xyz.wagyourtail.jsmacros.client.gui.editor.History;
type HorseEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.HorseEntityHelper;
type HorseInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.HorseInventory;
type IContainerParent = Packages.xyz.wagyourtail.wagyourgui.containers.IContainerParent;
type IDraw2D<T = any> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<T>;
type IEventListener = Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener;
type IOverlayParent = Packages.xyz.wagyourtail.wagyourgui.overlays.IOverlayParent;
type IScreen = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen;
type IllagerEntityHelper<T = /* net.minecraft.entity.mob.IllagerEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.IllagerEntityHelper<T>;
type Image = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;
type Image$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image$Builder;
type InteractionManagerHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.InteractionManagerHelper;
type InteractionProxy$Break$BreakBlockResult = Packages.xyz.wagyourtail.jsmacros.client.api.classes.InteractionProxy$Break$BreakBlockResult;
type Inventory<T = /* net.minecraft.client.gui.screen.ingame.HandledScreen<any> */ IScreen> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory<T>;
type IronGolemEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.IronGolemEntityHelper;
type Item = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
type Item$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item$Builder;
type ItemEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.ItemEntityHelper;
type ItemFrameEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.decoration.ItemFrameEntityHelper;
type ItemHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemHelper;
type ItemStackHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
type JsMacrosThreadPool = Packages.xyz.wagyourtail.jsmacros.core.threads.JsMacrosThreadPool;
type Library = Packages.xyz.wagyourtail.jsmacros.core.library.Library;
type LibraryBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.LibraryBuilder;
type LibraryRegistry = Packages.xyz.wagyourtail.jsmacros.core.library.LibraryRegistry;
type Line = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
type Line$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line$Builder;
type Line3D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;
type Line3D$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D$Builder;
type LivingEntityHelper<T = /* net.minecraft.entity.LivingEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.LivingEntityHelper<T>;
type LlamaEntityHelper<T = /* net.minecraft.entity.passive.LlamaEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.LlamaEntityHelper<T>;
type LockButtonWidgetHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper;
type LockButtonWidgetHelper$LockButtonBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper$LockButtonBuilder;
type LoomInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.LoomInventory;
type Mappings = Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings;
type Mappings$ClassData = Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings$ClassData;
type Mappings$MappedClass<T = any> = Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings$MappedClass<T>;
type Mappings$MethodData = Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings$MethodData;
type MerchantEntityHelper<T = /* net.minecraft.entity.passive.MerchantEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MerchantEntityHelper<T>;
type MethodWrapper<T = any, U = any, R = any, C extends Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any> = any> = Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, C>;
type MobEntityHelper<T = /* net.minecraft.entity.mob.MobEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MobEntityHelper<T>;
type ModContainerHelper<T = any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.ModContainerHelper<T>;
type MooshroomEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.MooshroomEntityHelper;
type MultiElementContainer<T extends Packages.xyz.wagyourtail.wagyourgui.containers.IContainerParent = any> = Packages.xyz.wagyourtail.wagyourgui.containers.MultiElementContainer<T>;
type NBTElementHelper$NBTCompoundHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTCompoundHelper;
type NBTElementHelper$NBTListHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTListHelper;
type NBTElementHelper$NBTNumberHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTNumberHelper;
type NBTElementHelper<T = /* net.minecraft.nbt.NbtElement */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper<T>;
type OcelotEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.OcelotEntityHelper;
type OptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper;
type OptionsHelper$AccessibilityOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$AccessibilityOptionsHelper;
type OptionsHelper$ChatOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$ChatOptionsHelper;
type OptionsHelper$ControlOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$ControlOptionsHelper;
type OptionsHelper$MusicOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$MusicOptionsHelper;
type OptionsHelper$SkinOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$SkinOptionsHelper;
type OptionsHelper$VideoOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$VideoOptionsHelper;
type OverlayContainer = Packages.xyz.wagyourtail.wagyourgui.overlays.OverlayContainer;
type PacketByteBufferHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;
type PaintingEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.decoration.PaintingEntityHelper;
type Pair<T = any, U = any> = Packages.xyz.wagyourtail.Pair<T, U>;
type PandaEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.PandaEntityHelper;
type ParrotEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.ParrotEntityHelper;
type PerExecLanguageLibrary<U = any, T extends Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<U> = any> = Packages.xyz.wagyourtail.jsmacros.core.library.PerExecLanguageLibrary<U, T>;
type PerExecLibrary = Packages.xyz.wagyourtail.jsmacros.core.library.PerExecLibrary;
type PerLanguageLibrary = Packages.xyz.wagyourtail.jsmacros.core.library.PerLanguageLibrary;
type PhantomEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.PhantomEntityHelper;
type PigEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.PigEntityHelper;
type PiglinEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.PiglinEntityHelper;
type PillagerEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.PillagerEntityHelper;
type PlayerAbilitiesHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerAbilitiesHelper;
type PlayerEntityHelper<T = /* net.minecraft.entity.player.PlayerEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper<T>;
type PlayerInput = Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;
type PlayerInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.PlayerInventory;
type PlayerListEntryHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper;
type PolarBearEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.PolarBearEntityHelper;
type Pos2D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;
type Pos3D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
type ProxyBuilder$MethodSigParts = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ProxyBuilder$MethodSigParts;
type ProxyBuilder$ProxyReference<T = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ProxyBuilder$ProxyReference<T>;
type ProxyBuilder<T = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ProxyBuilder<T>;
type PufferfishEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.PufferfishEntityHelper;
type RabbitEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.RabbitEntityHelper;
type RecipeHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.RecipeHelper;
type RecipeInventory<T = /* net.minecraft.client.gui.screen.ingame.HandledScreen<net.minecraft.screen.AbstractRecipeScreenHandler<any>> */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.RecipeInventory<T>;
type Rect = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;
type Rect$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect$Builder;
type RegistryHelper = Packages.xyz.wagyourtail.jsmacros.client.api.classes.RegistryHelper;
type RenderElement = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement;
type RenderElement3D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.RenderElement3D;
type RenderElementBuilder<T extends Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement = any> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElementBuilder<T>;
type ScoreboardObjectiveHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ScoreboardObjectiveHelper;
type ScoreboardsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ScoreboardsHelper;
type ScriptScreen = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.ScriptScreen;
type ScriptTrigger = Packages.xyz.wagyourtail.jsmacros.core.config.ScriptTrigger;
type ScriptTrigger$TriggerType = Packages.xyz.wagyourtail.jsmacros.core.config.ScriptTrigger$TriggerType;
type Scrollbar = Packages.xyz.wagyourtail.wagyourgui.elements.Scrollbar;
type SelectCursor = Packages.xyz.wagyourtail.jsmacros.client.gui.editor.SelectCursor;
type ServerInfoHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ServerInfoHelper;
type ServiceManager = Packages.xyz.wagyourtail.jsmacros.core.service.ServiceManager;
type ServiceManager$ServiceStatus = Packages.xyz.wagyourtail.jsmacros.core.service.ServiceManager$ServiceStatus;
type ServiceTrigger = Packages.xyz.wagyourtail.jsmacros.core.service.ServiceTrigger;
type SheepEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.SheepEntityHelper;
type ShulkerEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.ShulkerEntityHelper;
type Slider = Packages.xyz.wagyourtail.wagyourgui.elements.Slider;
type SliderWidgetHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;
type SliderWidgetHelper$SliderBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper$SliderBuilder;
type SlimeEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.SlimeEntityHelper;
type SmithingInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.SmithingInventory;
type SnowGolemEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.SnowGolemEntityHelper;
type SpellcastingIllagerEntityHelper<T = /* net.minecraft.entity.mob.SpellcastingIllagerEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.SpellcastingIllagerEntityHelper<T>;
type SpiderEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.SpiderEntityHelper;
type StateHelper<U = /* net.minecraft.state.State<any, any> */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.StateHelper<U>;
type StatsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatsHelper;
type StatusEffectHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper;
type StoneCutterInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.StoneCutterInventory;
type StriderEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.StriderEntityHelper;
type StringHashTrie = Packages.xyz.wagyourtail.StringHashTrie;
type StyleHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StyleHelper;
type SuggestionsBuilderHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.SuggestionsBuilderHelper;
type Surface = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;
type Surface$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface$Builder;
type TameableEntityHelper<T = /* net.minecraft.entity.passive.TameableEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.TameableEntityHelper<T>;
type TeamHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.TeamHelper;
type Text = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
type Text$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text$Builder;
type TextBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder;
type TextFieldWidgetHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper;
type TextFieldWidgetHelper$TextFieldBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper$TextFieldBuilder;
type TextHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
type TntEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.other.TntEntityHelper;
type TntMinecartEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.vehicle.TntMinecartEntityHelper;
type TraceLine = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine;
type TraceLine$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.TraceLine$Builder;
type TradeOfferHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.TradeOfferHelper;
type TridentEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.projectile.TridentEntityHelper;
type TropicalFishEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.TropicalFishEntityHelper;
type UniversalBlockStateHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.UniversalBlockStateHelper;
type Vec2D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec2D;
type Vec3D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;
type VexEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.VexEntityHelper;
type VillagerEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.VillagerEntityHelper;
type VillagerInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.VillagerInventory;
type VindicatorEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.VindicatorEntityHelper;
type WardenEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.WardenEntityHelper;
type Websocket = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.Websocket;
type Websocket$Disconnected = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.Websocket$Disconnected;
type WitchEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.WitchEntityHelper;
type WitherEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.boss.WitherEntityHelper;
type WitherSkullEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.projectile.WitherSkullEntityHelper;
type WolfEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.WolfEntityHelper;
type WorldScanner = Packages.xyz.wagyourtail.jsmacros.client.api.classes.worldscanner.WorldScanner;
type WorldScannerBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.worldscanner.WorldScannerBuilder;
type WrappedClassInstance<T = any> = Packages.xyz.wagyourtail.jsmacros.core.classes.WrappedClassInstance<T>;
type ZombieEntityHelper<T = /* net.minecraft.entity.mob.ZombieEntity */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.ZombieEntityHelper<T>;
type ZombieVillagerEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.ZombieVillagerEntityHelper;

// Enum types
type Bit    = 1 | 0;
type Trit   = 2 | Bit;
type Dit    = 3 | Trit;
type Pentit = 4 | Dit;
type Hexit  = 5 | Pentit;
type Septit = 6 | Hexit;
type Octit  = 7 | Septit;

type Side = Hexit;
type HotbarSlot = Octit | 8;
type HotbarSwapSlot = HotbarSlot | OffhandSlot;
type ClickSlotButton = HotbarSwapSlot | 9 | 10;
type OffhandSlot = 40;

type ArmorSlot = 'HEAD' | 'CHEST' | 'LEGS' | 'FEET';
type AttackIndicatorType = 'off' | 'crosshair' | 'hotbar';
type BlockUpdateType = 'STATE' | 'ENTITY';
type BossBarUpdateType = 'ADD' | 'REMOVE' | 'UPDATE_PERCENT'
| 'UPDATE_NAME' | 'UPDATE_STYLE' | 'UPDATE_PROPERTIES'
type BreakBlockResult$Reason = 'SUCCESS' | 'CANCELLED' | 'INTERRUPTED' | 'NOT_BREAKING' | 'RESET' | 'NO_OVERRIDE' | 'IS_AIR' | 'NO_SHAPE' | 'NO_TARGET' | 'TARGET_LOST' | 'TARGET_CHANGE';
type ChatVisibility = 'FULL' | 'SYSTEM' | 'HIDDEN';
type ChunkBuilderMode = 'none' | 'nearby' | 'player_affected';
type CloudsMode = 'off' | 'fast' | 'fancy';
type Difficulty = 'peaceful' | 'easy' | 'normal' | 'hard';
type Direction = 'up' | 'down' | 'north' | 'south' | 'east' | 'west';
type GraphicsMode = 'fast' | 'fancy' | 'fabulous';
type HandledScreenName = | `${ 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 } Row Chest`
| '3x3 Container'
| 'Anvil'
| 'Beacon'
| 'Blast Furnace'
| 'Brewing Stand'
| 'Crafting Table'
| 'Enchanting Table'
| 'Furnace'
| 'Grindstone'
| 'Hopper'
| 'Loom'
| 'Villager'
| 'Shulker Box'
| 'Smithing Table'
| 'Smoker'
| 'Cartography Table'
| 'Stonecutter'
| 'Survival Inventory'
| 'Horse'
| 'Creative Inventory'
| 'Chat'
| string & {}
| 'unknown'
type HealSource = DamageSource;
type IllagerSpell = 'NONE' | 'SUMMON_VEX' | 'FANGS' | 'WOLOLO' | 'DISAPPEAR' | 'BLINDNESS' | 'ERROR';
type InvMapId = InvMapType.All;
declare namespace InvMapType {
    type _inv = 'hotbar' | 'main';
    type _invio = _inv | 'input' | 'output';
    type Inventory = _inv | 'offhand' | 'boots' | 'leggings' | 'chestplate' | 'helmet'
    | 'crafting_in' | 'craft_out';
    type CreativeInvInvTab = Exclude<Inventory, 'crafting_in' | 'craft_out'> | 'delete';
    type CreativeInv = 'hotbar' | 'creative';
    type Container        = _inv | 'container';
    type Beacon           = _inv | 'slot';
    type Furnace          = _invio | 'fuel';
    type BrewingStand     = _invio | 'fuel';
    type Crafting         = _invio;
    type Enchantment      = _inv | 'lapis' | 'item';
    type Loom             = _inv | 'output' | 'pattern' | 'dye' | 'banner';
    type Stonecutter      = _invio;
    type Horse            = _inv | 'saddle' | 'armor' | 'container';
    type Anvil            = _invio;
    type Merchant         = _invio;
    type Smithing         = _invio;
    type Grindstone       = _invio;
    type CartographyTable = _invio;
    type All =
    | Inventory
    | CreativeInvInvTab
    | CreativeInv
    | Container
    | Beacon
    | Furnace
    | BrewingStand
    | Crafting
    | Enchantment
    | Loom
    | Stonecutter
    | Horse
    | Anvil
    | Merchant
    | Smithing
    | Grindstone
    | CartographyTable
}
type InvNameToTypeMap = {
    '1 Row Chest': ContainerInventory;
    '2 Row Chest': ContainerInventory;
    '3 Row Chest': ContainerInventory;
    '4 Row Chest': ContainerInventory;
    '5 Row Chest': ContainerInventory;
    '6 Row Chest': ContainerInventory;
    '7 Row Chest': ContainerInventory;
    '8 Row Chest': ContainerInventory;
    '9 Row Chest': ContainerInventory;
    '3x3 Container': ContainerInventory;
    'Anvil': AnvilInventory;
    'Beacon': BeaconInventory;
    'Blast Furnace': FurnaceInventory;
    'Brewing Stand': BrewingStandInventory;
    'Crafting Table': CraftingInventory;
    'Enchanting Table': EnchantInventory;
    'Furnace': FurnaceInventory;
    'Grindstone': GrindStoneInventory;
    'Hopper': ContainerInventory;
    'Loom': LoomInventory;
    'Villager': VillagerInventory;
    'Shulker Box': ContainerInventory;
    'Smithing Table': SmithingInventory;
    'Smoker': FurnaceInventory;
    'Cartography Table': CartographyInventory;
    'Stonecutter': StoneCutterInventory;
    'Survival Inventory': PlayerInventory;
    'Horse': HorseInventory;
    'Creative Inventory': CreativeInventory;
}
type KeyMods = KeyMod.shift | KeyMod.ctrl | KeyMod.alt
| `${KeyMod.shift}+${KeyMod.ctrl | KeyMod.alt}`
| `${KeyMod.ctrl}+${KeyMod.alt}`
| `${KeyMod.shift}+${KeyMod.ctrl}+${KeyMod.alt}`
declare namespace KeyMod {
    type shift = 'key.keyboard.left.shift';
    type ctrl = 'key.keyboard.left.control';
    type alt = 'key.keyboard.left.alt';
}
type MobCategory = 'UNDEAD' | 'DEFAULT' | 'ARTHROPOD' | 'ILLAGER' | 'AQUATIC' | 'UNKNOWN';
type NarratorMode = 'OFF' | 'ALL' | 'CHAT' | 'SYSTEM';
type ParticleMode = 'minimal' | 'decreased' | 'all';
type SlotUpdateType = 'HELD' | 'INVENTORY' | 'SCREEN';
type TitleType = 'TITLE' | 'SUBTITLE' | 'ACTIONBAR';
